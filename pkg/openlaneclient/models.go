// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package openlaneclient

import (
	"encoding/json"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/theopenlane/core/pkg/enums"
	"github.com/theopenlane/entx/history"
)

type SearchResult interface {
	IsSearchResult()
}

type APIToken struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name associated with the token
	Name  string `json:"name"`
	Token string `json:"token"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string       `json:"description,omitempty"`
	Scopes      []string      `json:"scopes,omitempty"`
	LastUsedAt  *time.Time    `json:"lastUsedAt,omitempty"`
	Owner       *Organization `json:"owner,omitempty"`
}

func (APIToken) IsNode() {}

// Return response for createBulkAPIToken mutation
type APITokenBulkCreatePayload struct {
	// Created apiTokens
	APITokens []*APIToken `json:"apiTokens,omitempty"`
}

// A connection to a list of items.
type APITokenConnection struct {
	// A list of edges.
	Edges []*APITokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createAPIToken mutation
type APITokenCreatePayload struct {
	// Created apiToken
	APIToken *APIToken `json:"apiToken"`
}

// Return response for deleteAPIToken mutation
type APITokenDeletePayload struct {
	// Deleted apiToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type APITokenEdge struct {
	// The item at the end of the edge.
	Node *APIToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type APITokenSearchResult struct {
	APITokens []*APIToken `json:"apiTokens,omitempty"`
}

func (APITokenSearchResult) IsSearchResult() {}

// Return response for updateAPIToken mutation
type APITokenUpdatePayload struct {
	// Updated apiToken
	APIToken *APIToken `json:"apiToken"`
}

// APITokenWhereInput is used for filtering APIToken objects.
// Input was generated by ent.
type APITokenWhereInput struct {
	Not *APITokenWhereInput   `json:"not,omitempty"`
	And []*APITokenWhereInput `json:"and,omitempty"`
	Or  []*APITokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type ActionPlan struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the action plan
	Name string `json:"name"`
	// description of the action plan
	Description *string `json:"description,omitempty"`
	// status of the action plan
	Status *string `json:"status,omitempty"`
	// due date of the action plan
	DueDate *time.Time `json:"dueDate,omitempty"`
	// priority of the action plan
	Priority *string `json:"priority,omitempty"`
	// source of the action plan
	Source *string `json:"source,omitempty"`
	// json data including details of the action plan
	Details  map[string]interface{} `json:"details,omitempty"`
	Standard []*Standard            `json:"standard,omitempty"`
	Risk     []*Risk                `json:"risk,omitempty"`
	Control  []*Control             `json:"control,omitempty"`
	User     []*User                `json:"user,omitempty"`
	Program  []*Program             `json:"program,omitempty"`
}

func (ActionPlan) IsNode() {}

// Return response for createBulkActionPlan mutation
type ActionPlanBulkCreatePayload struct {
	// Created actionPlans
	ActionPlans []*ActionPlan `json:"actionPlans,omitempty"`
}

// A connection to a list of items.
type ActionPlanConnection struct {
	// A list of edges.
	Edges []*ActionPlanEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createActionPlan mutation
type ActionPlanCreatePayload struct {
	// Created actionPlan
	ActionPlan *ActionPlan `json:"actionPlan"`
}

// Return response for deleteActionPlan mutation
type ActionPlanDeletePayload struct {
	// Deleted actionPlan ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ActionPlanEdge struct {
	// The item at the end of the edge.
	Node *ActionPlan `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ActionPlanHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the action plan
	Name string `json:"name"`
	// description of the action plan
	Description *string `json:"description,omitempty"`
	// status of the action plan
	Status *string `json:"status,omitempty"`
	// due date of the action plan
	DueDate *time.Time `json:"dueDate,omitempty"`
	// priority of the action plan
	Priority *string `json:"priority,omitempty"`
	// source of the action plan
	Source *string `json:"source,omitempty"`
	// json data including details of the action plan
	Details map[string]interface{} `json:"details,omitempty"`
}

func (ActionPlanHistory) IsNode() {}

// A connection to a list of items.
type ActionPlanHistoryConnection struct {
	// A list of edges.
	Edges []*ActionPlanHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ActionPlanHistoryEdge struct {
	// The item at the end of the edge.
	Node *ActionPlanHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ActionPlanHistoryWhereInput is used for filtering ActionPlanHistory objects.
// Input was generated by ent.
type ActionPlanHistoryWhereInput struct {
	Not *ActionPlanHistoryWhereInput   `json:"not,omitempty"`
	And []*ActionPlanHistoryWhereInput `json:"and,omitempty"`
	Or  []*ActionPlanHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// due_date field predicates
	DueDate       *time.Time   `json:"dueDate,omitempty"`
	DueDateNeq    *time.Time   `json:"dueDateNEQ,omitempty"`
	DueDateIn     []*time.Time `json:"dueDateIn,omitempty"`
	DueDateNotIn  []*time.Time `json:"dueDateNotIn,omitempty"`
	DueDateGt     *time.Time   `json:"dueDateGT,omitempty"`
	DueDateGte    *time.Time   `json:"dueDateGTE,omitempty"`
	DueDateLt     *time.Time   `json:"dueDateLT,omitempty"`
	DueDateLte    *time.Time   `json:"dueDateLTE,omitempty"`
	DueDateIsNil  *bool        `json:"dueDateIsNil,omitempty"`
	DueDateNotNil *bool        `json:"dueDateNotNil,omitempty"`
	// priority field predicates
	Priority             *string  `json:"priority,omitempty"`
	PriorityNeq          *string  `json:"priorityNEQ,omitempty"`
	PriorityIn           []string `json:"priorityIn,omitempty"`
	PriorityNotIn        []string `json:"priorityNotIn,omitempty"`
	PriorityGt           *string  `json:"priorityGT,omitempty"`
	PriorityGte          *string  `json:"priorityGTE,omitempty"`
	PriorityLt           *string  `json:"priorityLT,omitempty"`
	PriorityLte          *string  `json:"priorityLTE,omitempty"`
	PriorityContains     *string  `json:"priorityContains,omitempty"`
	PriorityHasPrefix    *string  `json:"priorityHasPrefix,omitempty"`
	PriorityHasSuffix    *string  `json:"priorityHasSuffix,omitempty"`
	PriorityIsNil        *bool    `json:"priorityIsNil,omitempty"`
	PriorityNotNil       *bool    `json:"priorityNotNil,omitempty"`
	PriorityEqualFold    *string  `json:"priorityEqualFold,omitempty"`
	PriorityContainsFold *string  `json:"priorityContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
}

type ActionPlanSearchResult struct {
	ActionPlans []*ActionPlan `json:"actionPlans,omitempty"`
}

func (ActionPlanSearchResult) IsSearchResult() {}

// Return response for updateActionPlan mutation
type ActionPlanUpdatePayload struct {
	// Updated actionPlan
	ActionPlan *ActionPlan `json:"actionPlan"`
}

// ActionPlanWhereInput is used for filtering ActionPlan objects.
// Input was generated by ent.
type ActionPlanWhereInput struct {
	Not *ActionPlanWhereInput   `json:"not,omitempty"`
	And []*ActionPlanWhereInput `json:"and,omitempty"`
	Or  []*ActionPlanWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// due_date field predicates
	DueDate       *time.Time   `json:"dueDate,omitempty"`
	DueDateNeq    *time.Time   `json:"dueDateNEQ,omitempty"`
	DueDateIn     []*time.Time `json:"dueDateIn,omitempty"`
	DueDateNotIn  []*time.Time `json:"dueDateNotIn,omitempty"`
	DueDateGt     *time.Time   `json:"dueDateGT,omitempty"`
	DueDateGte    *time.Time   `json:"dueDateGTE,omitempty"`
	DueDateLt     *time.Time   `json:"dueDateLT,omitempty"`
	DueDateLte    *time.Time   `json:"dueDateLTE,omitempty"`
	DueDateIsNil  *bool        `json:"dueDateIsNil,omitempty"`
	DueDateNotNil *bool        `json:"dueDateNotNil,omitempty"`
	// priority field predicates
	Priority             *string  `json:"priority,omitempty"`
	PriorityNeq          *string  `json:"priorityNEQ,omitempty"`
	PriorityIn           []string `json:"priorityIn,omitempty"`
	PriorityNotIn        []string `json:"priorityNotIn,omitempty"`
	PriorityGt           *string  `json:"priorityGT,omitempty"`
	PriorityGte          *string  `json:"priorityGTE,omitempty"`
	PriorityLt           *string  `json:"priorityLT,omitempty"`
	PriorityLte          *string  `json:"priorityLTE,omitempty"`
	PriorityContains     *string  `json:"priorityContains,omitempty"`
	PriorityHasPrefix    *string  `json:"priorityHasPrefix,omitempty"`
	PriorityHasSuffix    *string  `json:"priorityHasSuffix,omitempty"`
	PriorityIsNil        *bool    `json:"priorityIsNil,omitempty"`
	PriorityNotNil       *bool    `json:"priorityNotNil,omitempty"`
	PriorityEqualFold    *string  `json:"priorityEqualFold,omitempty"`
	PriorityContainsFold *string  `json:"priorityContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// standard edge predicates
	HasStandard     *bool                 `json:"hasStandard,omitempty"`
	HasStandardWith []*StandardWhereInput `json:"hasStandardWith,omitempty"`
	// risk edge predicates
	HasRisk     *bool             `json:"hasRisk,omitempty"`
	HasRiskWith []*RiskWhereInput `json:"hasRiskWith,omitempty"`
	// control edge predicates
	HasControl     *bool                `json:"hasControl,omitempty"`
	HasControlWith []*ControlWhereInput `json:"hasControlWith,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// program edge predicates
	HasProgram     *bool                `json:"hasProgram,omitempty"`
	HasProgramWith []*ProgramWhereInput `json:"hasProgramWith,omitempty"`
}

type AuditLog struct {
	Table     *string    `json:"table,omitempty"`
	Time      *time.Time `json:"time,omitempty"`
	ID        string     `json:"id"`
	Operation *string    `json:"operation,omitempty"`
	Changes   []string   `json:"changes,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
}

func (AuditLog) IsNode() {}

// A connection to a list of items.
type AuditLogConnection struct {
	// A list of edges.
	Edges []*AuditLogEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type AuditLogEdge struct {
	// The item at the end of the edge.
	Node *AuditLog `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type AuditLogWhereInput struct {
	RefID     *string    `json:"refID,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	Operation *string    `json:"operation,omitempty"`
	Table     *string    `json:"table,omitempty"`
	Before    *time.Time `json:"before,omitempty"`
	After     *time.Time `json:"after,omitempty"`
}

type Contact struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the full name of the contact
	FullName string `json:"fullName"`
	// the title of the contact
	Title *string `json:"title,omitempty"`
	// the company of the contact
	Company *string `json:"company,omitempty"`
	// the email of the contact
	Email *string `json:"email,omitempty"`
	// the phone number of the contact
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// the address of the contact
	Address *string `json:"address,omitempty"`
	// status of the contact
	Status   enums.UserStatus `json:"status"`
	Owner    *Organization    `json:"owner,omitempty"`
	Entities []*Entity        `json:"entities,omitempty"`
	Files    []*File          `json:"files,omitempty"`
}

func (Contact) IsNode() {}

// Return response for createBulkContact mutation
type ContactBulkCreatePayload struct {
	// Created contacts
	Contacts []*Contact `json:"contacts,omitempty"`
}

// A connection to a list of items.
type ContactConnection struct {
	// A list of edges.
	Edges []*ContactEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createContact mutation
type ContactCreatePayload struct {
	// Created contact
	Contact *Contact `json:"contact"`
}

// Return response for deleteContact mutation
type ContactDeletePayload struct {
	// Deleted contact ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ContactEdge struct {
	// The item at the end of the edge.
	Node *Contact `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ContactHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the full name of the contact
	FullName string `json:"fullName"`
	// the title of the contact
	Title *string `json:"title,omitempty"`
	// the company of the contact
	Company *string `json:"company,omitempty"`
	// the email of the contact
	Email *string `json:"email,omitempty"`
	// the phone number of the contact
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// the address of the contact
	Address *string `json:"address,omitempty"`
	// status of the contact
	Status enums.UserStatus `json:"status"`
}

func (ContactHistory) IsNode() {}

// A connection to a list of items.
type ContactHistoryConnection struct {
	// A list of edges.
	Edges []*ContactHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ContactHistoryEdge struct {
	// The item at the end of the edge.
	Node *ContactHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ContactHistoryWhereInput is used for filtering ContactHistory objects.
// Input was generated by ent.
type ContactHistoryWhereInput struct {
	Not *ContactHistoryWhereInput   `json:"not,omitempty"`
	And []*ContactHistoryWhereInput `json:"and,omitempty"`
	Or  []*ContactHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// full_name field predicates
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNeq          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGt           *string  `json:"fullNameGT,omitempty"`
	FullNameGte          *string  `json:"fullNameGTE,omitempty"`
	FullNameLt           *string  `json:"fullNameLT,omitempty"`
	FullNameLte          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// company field predicates
	Company             *string  `json:"company,omitempty"`
	CompanyNeq          *string  `json:"companyNEQ,omitempty"`
	CompanyIn           []string `json:"companyIn,omitempty"`
	CompanyNotIn        []string `json:"companyNotIn,omitempty"`
	CompanyGt           *string  `json:"companyGT,omitempty"`
	CompanyGte          *string  `json:"companyGTE,omitempty"`
	CompanyLt           *string  `json:"companyLT,omitempty"`
	CompanyLte          *string  `json:"companyLTE,omitempty"`
	CompanyContains     *string  `json:"companyContains,omitempty"`
	CompanyHasPrefix    *string  `json:"companyHasPrefix,omitempty"`
	CompanyHasSuffix    *string  `json:"companyHasSuffix,omitempty"`
	CompanyIsNil        *bool    `json:"companyIsNil,omitempty"`
	CompanyNotNil       *bool    `json:"companyNotNil,omitempty"`
	CompanyEqualFold    *string  `json:"companyEqualFold,omitempty"`
	CompanyContainsFold *string  `json:"companyContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        *bool    `json:"emailIsNil,omitempty"`
	EmailNotNil       *bool    `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// phone_number field predicates
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNeq          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGt           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGte          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLt           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLte          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        *bool    `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       *bool    `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`
	// address field predicates
	Address             *string  `json:"address,omitempty"`
	AddressNeq          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGt           *string  `json:"addressGT,omitempty"`
	AddressGte          *string  `json:"addressGTE,omitempty"`
	AddressLt           *string  `json:"addressLT,omitempty"`
	AddressLte          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        *bool    `json:"addressIsNil,omitempty"`
	AddressNotNil       *bool    `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
}

type ContactSearchResult struct {
	Contacts []*Contact `json:"contacts,omitempty"`
}

func (ContactSearchResult) IsSearchResult() {}

// Return response for updateContact mutation
type ContactUpdatePayload struct {
	// Updated contact
	Contact *Contact `json:"contact"`
}

// ContactWhereInput is used for filtering Contact objects.
// Input was generated by ent.
type ContactWhereInput struct {
	Not *ContactWhereInput   `json:"not,omitempty"`
	And []*ContactWhereInput `json:"and,omitempty"`
	Or  []*ContactWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// full_name field predicates
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNeq          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGt           *string  `json:"fullNameGT,omitempty"`
	FullNameGte          *string  `json:"fullNameGTE,omitempty"`
	FullNameLt           *string  `json:"fullNameLT,omitempty"`
	FullNameLte          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// company field predicates
	Company             *string  `json:"company,omitempty"`
	CompanyNeq          *string  `json:"companyNEQ,omitempty"`
	CompanyIn           []string `json:"companyIn,omitempty"`
	CompanyNotIn        []string `json:"companyNotIn,omitempty"`
	CompanyGt           *string  `json:"companyGT,omitempty"`
	CompanyGte          *string  `json:"companyGTE,omitempty"`
	CompanyLt           *string  `json:"companyLT,omitempty"`
	CompanyLte          *string  `json:"companyLTE,omitempty"`
	CompanyContains     *string  `json:"companyContains,omitempty"`
	CompanyHasPrefix    *string  `json:"companyHasPrefix,omitempty"`
	CompanyHasSuffix    *string  `json:"companyHasSuffix,omitempty"`
	CompanyIsNil        *bool    `json:"companyIsNil,omitempty"`
	CompanyNotNil       *bool    `json:"companyNotNil,omitempty"`
	CompanyEqualFold    *string  `json:"companyEqualFold,omitempty"`
	CompanyContainsFold *string  `json:"companyContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        *bool    `json:"emailIsNil,omitempty"`
	EmailNotNil       *bool    `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// phone_number field predicates
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNeq          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGt           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGte          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLt           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLte          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        *bool    `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       *bool    `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`
	// address field predicates
	Address             *string  `json:"address,omitempty"`
	AddressNeq          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGt           *string  `json:"addressGT,omitempty"`
	AddressGte          *string  `json:"addressGTE,omitempty"`
	AddressLt           *string  `json:"addressLT,omitempty"`
	AddressLte          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        *bool    `json:"addressIsNil,omitempty"`
	AddressNotNil       *bool    `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

type Control struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the control
	Name string `json:"name"`
	// description of the control
	Description *string `json:"description,omitempty"`
	// status of the control
	Status *string `json:"status,omitempty"`
	// type of the control
	ControlType *string `json:"controlType,omitempty"`
	// version of the control
	Version *string `json:"version,omitempty"`
	// control number or identifier
	ControlNumber *string `json:"controlNumber,omitempty"`
	// family associated with the control
	Family *string `json:"family,omitempty"`
	// class associated with the control
	Class *string `json:"class,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *string `json:"source,omitempty"`
	// which control objectives are satisfied by the control
	Satisfies *string `json:"satisfies,omitempty"`
	// mapped frameworks
	MappedFrameworks *string `json:"mappedFrameworks,omitempty"`
	// json data including details of the control
	Details           map[string]interface{} `json:"details,omitempty"`
	Procedures        []*Procedure           `json:"procedures,omitempty"`
	Subcontrols       []*Subcontrol          `json:"subcontrols,omitempty"`
	Controlobjectives []*ControlObjective    `json:"controlobjectives,omitempty"`
	Standard          []*Standard            `json:"standard,omitempty"`
	Narratives        []*Narrative           `json:"narratives,omitempty"`
	Risks             []*Risk                `json:"risks,omitempty"`
	Actionplans       []*ActionPlan          `json:"actionplans,omitempty"`
	Tasks             []*Task                `json:"tasks,omitempty"`
	Programs          []*Program             `json:"programs,omitempty"`
}

func (Control) IsNode() {}

// Return response for createBulkControl mutation
type ControlBulkCreatePayload struct {
	// Created controls
	Controls []*Control `json:"controls,omitempty"`
}

// A connection to a list of items.
type ControlConnection struct {
	// A list of edges.
	Edges []*ControlEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createControl mutation
type ControlCreatePayload struct {
	// Created control
	Control *Control `json:"control"`
}

// Return response for deleteControl mutation
type ControlDeletePayload struct {
	// Deleted control ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ControlEdge struct {
	// The item at the end of the edge.
	Node *Control `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ControlHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the control
	Name string `json:"name"`
	// description of the control
	Description *string `json:"description,omitempty"`
	// status of the control
	Status *string `json:"status,omitempty"`
	// type of the control
	ControlType *string `json:"controlType,omitempty"`
	// version of the control
	Version *string `json:"version,omitempty"`
	// control number or identifier
	ControlNumber *string `json:"controlNumber,omitempty"`
	// family associated with the control
	Family *string `json:"family,omitempty"`
	// class associated with the control
	Class *string `json:"class,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *string `json:"source,omitempty"`
	// which control objectives are satisfied by the control
	Satisfies *string `json:"satisfies,omitempty"`
	// mapped frameworks
	MappedFrameworks *string `json:"mappedFrameworks,omitempty"`
	// json data including details of the control
	Details map[string]interface{} `json:"details,omitempty"`
}

func (ControlHistory) IsNode() {}

// A connection to a list of items.
type ControlHistoryConnection struct {
	// A list of edges.
	Edges []*ControlHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ControlHistoryEdge struct {
	// The item at the end of the edge.
	Node *ControlHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ControlHistoryWhereInput is used for filtering ControlHistory objects.
// Input was generated by ent.
type ControlHistoryWhereInput struct {
	Not *ControlHistoryWhereInput   `json:"not,omitempty"`
	And []*ControlHistoryWhereInput `json:"and,omitempty"`
	Or  []*ControlHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// control_type field predicates
	ControlType             *string  `json:"controlType,omitempty"`
	ControlTypeNeq          *string  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn           []string `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn        []string `json:"controlTypeNotIn,omitempty"`
	ControlTypeGt           *string  `json:"controlTypeGT,omitempty"`
	ControlTypeGte          *string  `json:"controlTypeGTE,omitempty"`
	ControlTypeLt           *string  `json:"controlTypeLT,omitempty"`
	ControlTypeLte          *string  `json:"controlTypeLTE,omitempty"`
	ControlTypeContains     *string  `json:"controlTypeContains,omitempty"`
	ControlTypeHasPrefix    *string  `json:"controlTypeHasPrefix,omitempty"`
	ControlTypeHasSuffix    *string  `json:"controlTypeHasSuffix,omitempty"`
	ControlTypeIsNil        *bool    `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil       *bool    `json:"controlTypeNotNil,omitempty"`
	ControlTypeEqualFold    *string  `json:"controlTypeEqualFold,omitempty"`
	ControlTypeContainsFold *string  `json:"controlTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// control_number field predicates
	ControlNumber             *string  `json:"controlNumber,omitempty"`
	ControlNumberNeq          *string  `json:"controlNumberNEQ,omitempty"`
	ControlNumberIn           []string `json:"controlNumberIn,omitempty"`
	ControlNumberNotIn        []string `json:"controlNumberNotIn,omitempty"`
	ControlNumberGt           *string  `json:"controlNumberGT,omitempty"`
	ControlNumberGte          *string  `json:"controlNumberGTE,omitempty"`
	ControlNumberLt           *string  `json:"controlNumberLT,omitempty"`
	ControlNumberLte          *string  `json:"controlNumberLTE,omitempty"`
	ControlNumberContains     *string  `json:"controlNumberContains,omitempty"`
	ControlNumberHasPrefix    *string  `json:"controlNumberHasPrefix,omitempty"`
	ControlNumberHasSuffix    *string  `json:"controlNumberHasSuffix,omitempty"`
	ControlNumberIsNil        *bool    `json:"controlNumberIsNil,omitempty"`
	ControlNumberNotNil       *bool    `json:"controlNumberNotNil,omitempty"`
	ControlNumberEqualFold    *string  `json:"controlNumberEqualFold,omitempty"`
	ControlNumberContainsFold *string  `json:"controlNumberContainsFold,omitempty"`
	// family field predicates
	Family             *string  `json:"family,omitempty"`
	FamilyNeq          *string  `json:"familyNEQ,omitempty"`
	FamilyIn           []string `json:"familyIn,omitempty"`
	FamilyNotIn        []string `json:"familyNotIn,omitempty"`
	FamilyGt           *string  `json:"familyGT,omitempty"`
	FamilyGte          *string  `json:"familyGTE,omitempty"`
	FamilyLt           *string  `json:"familyLT,omitempty"`
	FamilyLte          *string  `json:"familyLTE,omitempty"`
	FamilyContains     *string  `json:"familyContains,omitempty"`
	FamilyHasPrefix    *string  `json:"familyHasPrefix,omitempty"`
	FamilyHasSuffix    *string  `json:"familyHasSuffix,omitempty"`
	FamilyIsNil        *bool    `json:"familyIsNil,omitempty"`
	FamilyNotNil       *bool    `json:"familyNotNil,omitempty"`
	FamilyEqualFold    *string  `json:"familyEqualFold,omitempty"`
	FamilyContainsFold *string  `json:"familyContainsFold,omitempty"`
	// class field predicates
	Class             *string  `json:"class,omitempty"`
	ClassNeq          *string  `json:"classNEQ,omitempty"`
	ClassIn           []string `json:"classIn,omitempty"`
	ClassNotIn        []string `json:"classNotIn,omitempty"`
	ClassGt           *string  `json:"classGT,omitempty"`
	ClassGte          *string  `json:"classGTE,omitempty"`
	ClassLt           *string  `json:"classLT,omitempty"`
	ClassLte          *string  `json:"classLTE,omitempty"`
	ClassContains     *string  `json:"classContains,omitempty"`
	ClassHasPrefix    *string  `json:"classHasPrefix,omitempty"`
	ClassHasSuffix    *string  `json:"classHasSuffix,omitempty"`
	ClassIsNil        *bool    `json:"classIsNil,omitempty"`
	ClassNotNil       *bool    `json:"classNotNil,omitempty"`
	ClassEqualFold    *string  `json:"classEqualFold,omitempty"`
	ClassContainsFold *string  `json:"classContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// satisfies field predicates
	Satisfies             *string  `json:"satisfies,omitempty"`
	SatisfiesNeq          *string  `json:"satisfiesNEQ,omitempty"`
	SatisfiesIn           []string `json:"satisfiesIn,omitempty"`
	SatisfiesNotIn        []string `json:"satisfiesNotIn,omitempty"`
	SatisfiesGt           *string  `json:"satisfiesGT,omitempty"`
	SatisfiesGte          *string  `json:"satisfiesGTE,omitempty"`
	SatisfiesLt           *string  `json:"satisfiesLT,omitempty"`
	SatisfiesLte          *string  `json:"satisfiesLTE,omitempty"`
	SatisfiesContains     *string  `json:"satisfiesContains,omitempty"`
	SatisfiesHasPrefix    *string  `json:"satisfiesHasPrefix,omitempty"`
	SatisfiesHasSuffix    *string  `json:"satisfiesHasSuffix,omitempty"`
	SatisfiesIsNil        *bool    `json:"satisfiesIsNil,omitempty"`
	SatisfiesNotNil       *bool    `json:"satisfiesNotNil,omitempty"`
	SatisfiesEqualFold    *string  `json:"satisfiesEqualFold,omitempty"`
	SatisfiesContainsFold *string  `json:"satisfiesContainsFold,omitempty"`
	// mapped_frameworks field predicates
	MappedFrameworks             *string  `json:"mappedFrameworks,omitempty"`
	MappedFrameworksNeq          *string  `json:"mappedFrameworksNEQ,omitempty"`
	MappedFrameworksIn           []string `json:"mappedFrameworksIn,omitempty"`
	MappedFrameworksNotIn        []string `json:"mappedFrameworksNotIn,omitempty"`
	MappedFrameworksGt           *string  `json:"mappedFrameworksGT,omitempty"`
	MappedFrameworksGte          *string  `json:"mappedFrameworksGTE,omitempty"`
	MappedFrameworksLt           *string  `json:"mappedFrameworksLT,omitempty"`
	MappedFrameworksLte          *string  `json:"mappedFrameworksLTE,omitempty"`
	MappedFrameworksContains     *string  `json:"mappedFrameworksContains,omitempty"`
	MappedFrameworksHasPrefix    *string  `json:"mappedFrameworksHasPrefix,omitempty"`
	MappedFrameworksHasSuffix    *string  `json:"mappedFrameworksHasSuffix,omitempty"`
	MappedFrameworksIsNil        *bool    `json:"mappedFrameworksIsNil,omitempty"`
	MappedFrameworksNotNil       *bool    `json:"mappedFrameworksNotNil,omitempty"`
	MappedFrameworksEqualFold    *string  `json:"mappedFrameworksEqualFold,omitempty"`
	MappedFrameworksContainsFold *string  `json:"mappedFrameworksContainsFold,omitempty"`
}

type ControlObjective struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the control objective
	Name string `json:"name"`
	// description of the control objective
	Description *string `json:"description,omitempty"`
	// status of the control objective
	Status *string `json:"status,omitempty"`
	// type of the control objective
	ControlObjectiveType *string `json:"controlObjectiveType,omitempty"`
	// version of the control objective
	Version *string `json:"version,omitempty"`
	// number of the control objective
	ControlNumber *string `json:"controlNumber,omitempty"`
	// family of the control objective
	Family *string `json:"family,omitempty"`
	// class associated with the control objective
	Class *string `json:"class,omitempty"`
	// source of the control objective, e.g. framework, template, user-defined, etc.
	Source *string `json:"source,omitempty"`
	// mapped frameworks
	MappedFrameworks *string `json:"mappedFrameworks,omitempty"`
	// json data including details of the control objective
	Details     map[string]interface{} `json:"details,omitempty"`
	Policy      []*InternalPolicy      `json:"policy,omitempty"`
	Controls    []*Control             `json:"controls,omitempty"`
	Procedures  []*Procedure           `json:"procedures,omitempty"`
	Risks       []*Risk                `json:"risks,omitempty"`
	Subcontrols []*Subcontrol          `json:"subcontrols,omitempty"`
	Standard    []*Standard            `json:"standard,omitempty"`
	Narratives  []*Narrative           `json:"narratives,omitempty"`
	Tasks       []*Task                `json:"tasks,omitempty"`
	Programs    []*Program             `json:"programs,omitempty"`
}

func (ControlObjective) IsNode() {}

// Return response for createBulkControlObjective mutation
type ControlObjectiveBulkCreatePayload struct {
	// Created controlObjectives
	ControlObjectives []*ControlObjective `json:"controlObjectives,omitempty"`
}

// A connection to a list of items.
type ControlObjectiveConnection struct {
	// A list of edges.
	Edges []*ControlObjectiveEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createControlObjective mutation
type ControlObjectiveCreatePayload struct {
	// Created controlObjective
	ControlObjective *ControlObjective `json:"controlObjective"`
}

// Return response for deleteControlObjective mutation
type ControlObjectiveDeletePayload struct {
	// Deleted controlObjective ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ControlObjectiveEdge struct {
	// The item at the end of the edge.
	Node *ControlObjective `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ControlObjectiveHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the control objective
	Name string `json:"name"`
	// description of the control objective
	Description *string `json:"description,omitempty"`
	// status of the control objective
	Status *string `json:"status,omitempty"`
	// type of the control objective
	ControlObjectiveType *string `json:"controlObjectiveType,omitempty"`
	// version of the control objective
	Version *string `json:"version,omitempty"`
	// number of the control objective
	ControlNumber *string `json:"controlNumber,omitempty"`
	// family of the control objective
	Family *string `json:"family,omitempty"`
	// class associated with the control objective
	Class *string `json:"class,omitempty"`
	// source of the control objective, e.g. framework, template, user-defined, etc.
	Source *string `json:"source,omitempty"`
	// mapped frameworks
	MappedFrameworks *string `json:"mappedFrameworks,omitempty"`
	// json data including details of the control objective
	Details map[string]interface{} `json:"details,omitempty"`
}

func (ControlObjectiveHistory) IsNode() {}

// A connection to a list of items.
type ControlObjectiveHistoryConnection struct {
	// A list of edges.
	Edges []*ControlObjectiveHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ControlObjectiveHistoryEdge struct {
	// The item at the end of the edge.
	Node *ControlObjectiveHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ControlObjectiveHistoryWhereInput is used for filtering ControlObjectiveHistory objects.
// Input was generated by ent.
type ControlObjectiveHistoryWhereInput struct {
	Not *ControlObjectiveHistoryWhereInput   `json:"not,omitempty"`
	And []*ControlObjectiveHistoryWhereInput `json:"and,omitempty"`
	Or  []*ControlObjectiveHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// control_objective_type field predicates
	ControlObjectiveType             *string  `json:"controlObjectiveType,omitempty"`
	ControlObjectiveTypeNeq          *string  `json:"controlObjectiveTypeNEQ,omitempty"`
	ControlObjectiveTypeIn           []string `json:"controlObjectiveTypeIn,omitempty"`
	ControlObjectiveTypeNotIn        []string `json:"controlObjectiveTypeNotIn,omitempty"`
	ControlObjectiveTypeGt           *string  `json:"controlObjectiveTypeGT,omitempty"`
	ControlObjectiveTypeGte          *string  `json:"controlObjectiveTypeGTE,omitempty"`
	ControlObjectiveTypeLt           *string  `json:"controlObjectiveTypeLT,omitempty"`
	ControlObjectiveTypeLte          *string  `json:"controlObjectiveTypeLTE,omitempty"`
	ControlObjectiveTypeContains     *string  `json:"controlObjectiveTypeContains,omitempty"`
	ControlObjectiveTypeHasPrefix    *string  `json:"controlObjectiveTypeHasPrefix,omitempty"`
	ControlObjectiveTypeHasSuffix    *string  `json:"controlObjectiveTypeHasSuffix,omitempty"`
	ControlObjectiveTypeIsNil        *bool    `json:"controlObjectiveTypeIsNil,omitempty"`
	ControlObjectiveTypeNotNil       *bool    `json:"controlObjectiveTypeNotNil,omitempty"`
	ControlObjectiveTypeEqualFold    *string  `json:"controlObjectiveTypeEqualFold,omitempty"`
	ControlObjectiveTypeContainsFold *string  `json:"controlObjectiveTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// control_number field predicates
	ControlNumber             *string  `json:"controlNumber,omitempty"`
	ControlNumberNeq          *string  `json:"controlNumberNEQ,omitempty"`
	ControlNumberIn           []string `json:"controlNumberIn,omitempty"`
	ControlNumberNotIn        []string `json:"controlNumberNotIn,omitempty"`
	ControlNumberGt           *string  `json:"controlNumberGT,omitempty"`
	ControlNumberGte          *string  `json:"controlNumberGTE,omitempty"`
	ControlNumberLt           *string  `json:"controlNumberLT,omitempty"`
	ControlNumberLte          *string  `json:"controlNumberLTE,omitempty"`
	ControlNumberContains     *string  `json:"controlNumberContains,omitempty"`
	ControlNumberHasPrefix    *string  `json:"controlNumberHasPrefix,omitempty"`
	ControlNumberHasSuffix    *string  `json:"controlNumberHasSuffix,omitempty"`
	ControlNumberIsNil        *bool    `json:"controlNumberIsNil,omitempty"`
	ControlNumberNotNil       *bool    `json:"controlNumberNotNil,omitempty"`
	ControlNumberEqualFold    *string  `json:"controlNumberEqualFold,omitempty"`
	ControlNumberContainsFold *string  `json:"controlNumberContainsFold,omitempty"`
	// family field predicates
	Family             *string  `json:"family,omitempty"`
	FamilyNeq          *string  `json:"familyNEQ,omitempty"`
	FamilyIn           []string `json:"familyIn,omitempty"`
	FamilyNotIn        []string `json:"familyNotIn,omitempty"`
	FamilyGt           *string  `json:"familyGT,omitempty"`
	FamilyGte          *string  `json:"familyGTE,omitempty"`
	FamilyLt           *string  `json:"familyLT,omitempty"`
	FamilyLte          *string  `json:"familyLTE,omitempty"`
	FamilyContains     *string  `json:"familyContains,omitempty"`
	FamilyHasPrefix    *string  `json:"familyHasPrefix,omitempty"`
	FamilyHasSuffix    *string  `json:"familyHasSuffix,omitempty"`
	FamilyIsNil        *bool    `json:"familyIsNil,omitempty"`
	FamilyNotNil       *bool    `json:"familyNotNil,omitempty"`
	FamilyEqualFold    *string  `json:"familyEqualFold,omitempty"`
	FamilyContainsFold *string  `json:"familyContainsFold,omitempty"`
	// class field predicates
	Class             *string  `json:"class,omitempty"`
	ClassNeq          *string  `json:"classNEQ,omitempty"`
	ClassIn           []string `json:"classIn,omitempty"`
	ClassNotIn        []string `json:"classNotIn,omitempty"`
	ClassGt           *string  `json:"classGT,omitempty"`
	ClassGte          *string  `json:"classGTE,omitempty"`
	ClassLt           *string  `json:"classLT,omitempty"`
	ClassLte          *string  `json:"classLTE,omitempty"`
	ClassContains     *string  `json:"classContains,omitempty"`
	ClassHasPrefix    *string  `json:"classHasPrefix,omitempty"`
	ClassHasSuffix    *string  `json:"classHasSuffix,omitempty"`
	ClassIsNil        *bool    `json:"classIsNil,omitempty"`
	ClassNotNil       *bool    `json:"classNotNil,omitempty"`
	ClassEqualFold    *string  `json:"classEqualFold,omitempty"`
	ClassContainsFold *string  `json:"classContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// mapped_frameworks field predicates
	MappedFrameworks             *string  `json:"mappedFrameworks,omitempty"`
	MappedFrameworksNeq          *string  `json:"mappedFrameworksNEQ,omitempty"`
	MappedFrameworksIn           []string `json:"mappedFrameworksIn,omitempty"`
	MappedFrameworksNotIn        []string `json:"mappedFrameworksNotIn,omitempty"`
	MappedFrameworksGt           *string  `json:"mappedFrameworksGT,omitempty"`
	MappedFrameworksGte          *string  `json:"mappedFrameworksGTE,omitempty"`
	MappedFrameworksLt           *string  `json:"mappedFrameworksLT,omitempty"`
	MappedFrameworksLte          *string  `json:"mappedFrameworksLTE,omitempty"`
	MappedFrameworksContains     *string  `json:"mappedFrameworksContains,omitempty"`
	MappedFrameworksHasPrefix    *string  `json:"mappedFrameworksHasPrefix,omitempty"`
	MappedFrameworksHasSuffix    *string  `json:"mappedFrameworksHasSuffix,omitempty"`
	MappedFrameworksIsNil        *bool    `json:"mappedFrameworksIsNil,omitempty"`
	MappedFrameworksNotNil       *bool    `json:"mappedFrameworksNotNil,omitempty"`
	MappedFrameworksEqualFold    *string  `json:"mappedFrameworksEqualFold,omitempty"`
	MappedFrameworksContainsFold *string  `json:"mappedFrameworksContainsFold,omitempty"`
}

type ControlObjectiveSearchResult struct {
	ControlObjectives []*ControlObjective `json:"controlObjectives,omitempty"`
}

func (ControlObjectiveSearchResult) IsSearchResult() {}

// Return response for updateControlObjective mutation
type ControlObjectiveUpdatePayload struct {
	// Updated controlObjective
	ControlObjective *ControlObjective `json:"controlObjective"`
}

// ControlObjectiveWhereInput is used for filtering ControlObjective objects.
// Input was generated by ent.
type ControlObjectiveWhereInput struct {
	Not *ControlObjectiveWhereInput   `json:"not,omitempty"`
	And []*ControlObjectiveWhereInput `json:"and,omitempty"`
	Or  []*ControlObjectiveWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// control_objective_type field predicates
	ControlObjectiveType             *string  `json:"controlObjectiveType,omitempty"`
	ControlObjectiveTypeNeq          *string  `json:"controlObjectiveTypeNEQ,omitempty"`
	ControlObjectiveTypeIn           []string `json:"controlObjectiveTypeIn,omitempty"`
	ControlObjectiveTypeNotIn        []string `json:"controlObjectiveTypeNotIn,omitempty"`
	ControlObjectiveTypeGt           *string  `json:"controlObjectiveTypeGT,omitempty"`
	ControlObjectiveTypeGte          *string  `json:"controlObjectiveTypeGTE,omitempty"`
	ControlObjectiveTypeLt           *string  `json:"controlObjectiveTypeLT,omitempty"`
	ControlObjectiveTypeLte          *string  `json:"controlObjectiveTypeLTE,omitempty"`
	ControlObjectiveTypeContains     *string  `json:"controlObjectiveTypeContains,omitempty"`
	ControlObjectiveTypeHasPrefix    *string  `json:"controlObjectiveTypeHasPrefix,omitempty"`
	ControlObjectiveTypeHasSuffix    *string  `json:"controlObjectiveTypeHasSuffix,omitempty"`
	ControlObjectiveTypeIsNil        *bool    `json:"controlObjectiveTypeIsNil,omitempty"`
	ControlObjectiveTypeNotNil       *bool    `json:"controlObjectiveTypeNotNil,omitempty"`
	ControlObjectiveTypeEqualFold    *string  `json:"controlObjectiveTypeEqualFold,omitempty"`
	ControlObjectiveTypeContainsFold *string  `json:"controlObjectiveTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// control_number field predicates
	ControlNumber             *string  `json:"controlNumber,omitempty"`
	ControlNumberNeq          *string  `json:"controlNumberNEQ,omitempty"`
	ControlNumberIn           []string `json:"controlNumberIn,omitempty"`
	ControlNumberNotIn        []string `json:"controlNumberNotIn,omitempty"`
	ControlNumberGt           *string  `json:"controlNumberGT,omitempty"`
	ControlNumberGte          *string  `json:"controlNumberGTE,omitempty"`
	ControlNumberLt           *string  `json:"controlNumberLT,omitempty"`
	ControlNumberLte          *string  `json:"controlNumberLTE,omitempty"`
	ControlNumberContains     *string  `json:"controlNumberContains,omitempty"`
	ControlNumberHasPrefix    *string  `json:"controlNumberHasPrefix,omitempty"`
	ControlNumberHasSuffix    *string  `json:"controlNumberHasSuffix,omitempty"`
	ControlNumberIsNil        *bool    `json:"controlNumberIsNil,omitempty"`
	ControlNumberNotNil       *bool    `json:"controlNumberNotNil,omitempty"`
	ControlNumberEqualFold    *string  `json:"controlNumberEqualFold,omitempty"`
	ControlNumberContainsFold *string  `json:"controlNumberContainsFold,omitempty"`
	// family field predicates
	Family             *string  `json:"family,omitempty"`
	FamilyNeq          *string  `json:"familyNEQ,omitempty"`
	FamilyIn           []string `json:"familyIn,omitempty"`
	FamilyNotIn        []string `json:"familyNotIn,omitempty"`
	FamilyGt           *string  `json:"familyGT,omitempty"`
	FamilyGte          *string  `json:"familyGTE,omitempty"`
	FamilyLt           *string  `json:"familyLT,omitempty"`
	FamilyLte          *string  `json:"familyLTE,omitempty"`
	FamilyContains     *string  `json:"familyContains,omitempty"`
	FamilyHasPrefix    *string  `json:"familyHasPrefix,omitempty"`
	FamilyHasSuffix    *string  `json:"familyHasSuffix,omitempty"`
	FamilyIsNil        *bool    `json:"familyIsNil,omitempty"`
	FamilyNotNil       *bool    `json:"familyNotNil,omitempty"`
	FamilyEqualFold    *string  `json:"familyEqualFold,omitempty"`
	FamilyContainsFold *string  `json:"familyContainsFold,omitempty"`
	// class field predicates
	Class             *string  `json:"class,omitempty"`
	ClassNeq          *string  `json:"classNEQ,omitempty"`
	ClassIn           []string `json:"classIn,omitempty"`
	ClassNotIn        []string `json:"classNotIn,omitempty"`
	ClassGt           *string  `json:"classGT,omitempty"`
	ClassGte          *string  `json:"classGTE,omitempty"`
	ClassLt           *string  `json:"classLT,omitempty"`
	ClassLte          *string  `json:"classLTE,omitempty"`
	ClassContains     *string  `json:"classContains,omitempty"`
	ClassHasPrefix    *string  `json:"classHasPrefix,omitempty"`
	ClassHasSuffix    *string  `json:"classHasSuffix,omitempty"`
	ClassIsNil        *bool    `json:"classIsNil,omitempty"`
	ClassNotNil       *bool    `json:"classNotNil,omitempty"`
	ClassEqualFold    *string  `json:"classEqualFold,omitempty"`
	ClassContainsFold *string  `json:"classContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// mapped_frameworks field predicates
	MappedFrameworks             *string  `json:"mappedFrameworks,omitempty"`
	MappedFrameworksNeq          *string  `json:"mappedFrameworksNEQ,omitempty"`
	MappedFrameworksIn           []string `json:"mappedFrameworksIn,omitempty"`
	MappedFrameworksNotIn        []string `json:"mappedFrameworksNotIn,omitempty"`
	MappedFrameworksGt           *string  `json:"mappedFrameworksGT,omitempty"`
	MappedFrameworksGte          *string  `json:"mappedFrameworksGTE,omitempty"`
	MappedFrameworksLt           *string  `json:"mappedFrameworksLT,omitempty"`
	MappedFrameworksLte          *string  `json:"mappedFrameworksLTE,omitempty"`
	MappedFrameworksContains     *string  `json:"mappedFrameworksContains,omitempty"`
	MappedFrameworksHasPrefix    *string  `json:"mappedFrameworksHasPrefix,omitempty"`
	MappedFrameworksHasSuffix    *string  `json:"mappedFrameworksHasSuffix,omitempty"`
	MappedFrameworksIsNil        *bool    `json:"mappedFrameworksIsNil,omitempty"`
	MappedFrameworksNotNil       *bool    `json:"mappedFrameworksNotNil,omitempty"`
	MappedFrameworksEqualFold    *string  `json:"mappedFrameworksEqualFold,omitempty"`
	MappedFrameworksContainsFold *string  `json:"mappedFrameworksContainsFold,omitempty"`
	// policy edge predicates
	HasPolicy     *bool                       `json:"hasPolicy,omitempty"`
	HasPolicyWith []*InternalPolicyWhereInput `json:"hasPolicyWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// standard edge predicates
	HasStandard     *bool                 `json:"hasStandard,omitempty"`
	HasStandardWith []*StandardWhereInput `json:"hasStandardWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

type ControlSearchResult struct {
	Controls []*Control `json:"controls,omitempty"`
}

func (ControlSearchResult) IsSearchResult() {}

// Return response for updateControl mutation
type ControlUpdatePayload struct {
	// Updated control
	Control *Control `json:"control"`
}

// ControlWhereInput is used for filtering Control objects.
// Input was generated by ent.
type ControlWhereInput struct {
	Not *ControlWhereInput   `json:"not,omitempty"`
	And []*ControlWhereInput `json:"and,omitempty"`
	Or  []*ControlWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// control_type field predicates
	ControlType             *string  `json:"controlType,omitempty"`
	ControlTypeNeq          *string  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn           []string `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn        []string `json:"controlTypeNotIn,omitempty"`
	ControlTypeGt           *string  `json:"controlTypeGT,omitempty"`
	ControlTypeGte          *string  `json:"controlTypeGTE,omitempty"`
	ControlTypeLt           *string  `json:"controlTypeLT,omitempty"`
	ControlTypeLte          *string  `json:"controlTypeLTE,omitempty"`
	ControlTypeContains     *string  `json:"controlTypeContains,omitempty"`
	ControlTypeHasPrefix    *string  `json:"controlTypeHasPrefix,omitempty"`
	ControlTypeHasSuffix    *string  `json:"controlTypeHasSuffix,omitempty"`
	ControlTypeIsNil        *bool    `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil       *bool    `json:"controlTypeNotNil,omitempty"`
	ControlTypeEqualFold    *string  `json:"controlTypeEqualFold,omitempty"`
	ControlTypeContainsFold *string  `json:"controlTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// control_number field predicates
	ControlNumber             *string  `json:"controlNumber,omitempty"`
	ControlNumberNeq          *string  `json:"controlNumberNEQ,omitempty"`
	ControlNumberIn           []string `json:"controlNumberIn,omitempty"`
	ControlNumberNotIn        []string `json:"controlNumberNotIn,omitempty"`
	ControlNumberGt           *string  `json:"controlNumberGT,omitempty"`
	ControlNumberGte          *string  `json:"controlNumberGTE,omitempty"`
	ControlNumberLt           *string  `json:"controlNumberLT,omitempty"`
	ControlNumberLte          *string  `json:"controlNumberLTE,omitempty"`
	ControlNumberContains     *string  `json:"controlNumberContains,omitempty"`
	ControlNumberHasPrefix    *string  `json:"controlNumberHasPrefix,omitempty"`
	ControlNumberHasSuffix    *string  `json:"controlNumberHasSuffix,omitempty"`
	ControlNumberIsNil        *bool    `json:"controlNumberIsNil,omitempty"`
	ControlNumberNotNil       *bool    `json:"controlNumberNotNil,omitempty"`
	ControlNumberEqualFold    *string  `json:"controlNumberEqualFold,omitempty"`
	ControlNumberContainsFold *string  `json:"controlNumberContainsFold,omitempty"`
	// family field predicates
	Family             *string  `json:"family,omitempty"`
	FamilyNeq          *string  `json:"familyNEQ,omitempty"`
	FamilyIn           []string `json:"familyIn,omitempty"`
	FamilyNotIn        []string `json:"familyNotIn,omitempty"`
	FamilyGt           *string  `json:"familyGT,omitempty"`
	FamilyGte          *string  `json:"familyGTE,omitempty"`
	FamilyLt           *string  `json:"familyLT,omitempty"`
	FamilyLte          *string  `json:"familyLTE,omitempty"`
	FamilyContains     *string  `json:"familyContains,omitempty"`
	FamilyHasPrefix    *string  `json:"familyHasPrefix,omitempty"`
	FamilyHasSuffix    *string  `json:"familyHasSuffix,omitempty"`
	FamilyIsNil        *bool    `json:"familyIsNil,omitempty"`
	FamilyNotNil       *bool    `json:"familyNotNil,omitempty"`
	FamilyEqualFold    *string  `json:"familyEqualFold,omitempty"`
	FamilyContainsFold *string  `json:"familyContainsFold,omitempty"`
	// class field predicates
	Class             *string  `json:"class,omitempty"`
	ClassNeq          *string  `json:"classNEQ,omitempty"`
	ClassIn           []string `json:"classIn,omitempty"`
	ClassNotIn        []string `json:"classNotIn,omitempty"`
	ClassGt           *string  `json:"classGT,omitempty"`
	ClassGte          *string  `json:"classGTE,omitempty"`
	ClassLt           *string  `json:"classLT,omitempty"`
	ClassLte          *string  `json:"classLTE,omitempty"`
	ClassContains     *string  `json:"classContains,omitempty"`
	ClassHasPrefix    *string  `json:"classHasPrefix,omitempty"`
	ClassHasSuffix    *string  `json:"classHasSuffix,omitempty"`
	ClassIsNil        *bool    `json:"classIsNil,omitempty"`
	ClassNotNil       *bool    `json:"classNotNil,omitempty"`
	ClassEqualFold    *string  `json:"classEqualFold,omitempty"`
	ClassContainsFold *string  `json:"classContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// satisfies field predicates
	Satisfies             *string  `json:"satisfies,omitempty"`
	SatisfiesNeq          *string  `json:"satisfiesNEQ,omitempty"`
	SatisfiesIn           []string `json:"satisfiesIn,omitempty"`
	SatisfiesNotIn        []string `json:"satisfiesNotIn,omitempty"`
	SatisfiesGt           *string  `json:"satisfiesGT,omitempty"`
	SatisfiesGte          *string  `json:"satisfiesGTE,omitempty"`
	SatisfiesLt           *string  `json:"satisfiesLT,omitempty"`
	SatisfiesLte          *string  `json:"satisfiesLTE,omitempty"`
	SatisfiesContains     *string  `json:"satisfiesContains,omitempty"`
	SatisfiesHasPrefix    *string  `json:"satisfiesHasPrefix,omitempty"`
	SatisfiesHasSuffix    *string  `json:"satisfiesHasSuffix,omitempty"`
	SatisfiesIsNil        *bool    `json:"satisfiesIsNil,omitempty"`
	SatisfiesNotNil       *bool    `json:"satisfiesNotNil,omitempty"`
	SatisfiesEqualFold    *string  `json:"satisfiesEqualFold,omitempty"`
	SatisfiesContainsFold *string  `json:"satisfiesContainsFold,omitempty"`
	// mapped_frameworks field predicates
	MappedFrameworks             *string  `json:"mappedFrameworks,omitempty"`
	MappedFrameworksNeq          *string  `json:"mappedFrameworksNEQ,omitempty"`
	MappedFrameworksIn           []string `json:"mappedFrameworksIn,omitempty"`
	MappedFrameworksNotIn        []string `json:"mappedFrameworksNotIn,omitempty"`
	MappedFrameworksGt           *string  `json:"mappedFrameworksGT,omitempty"`
	MappedFrameworksGte          *string  `json:"mappedFrameworksGTE,omitempty"`
	MappedFrameworksLt           *string  `json:"mappedFrameworksLT,omitempty"`
	MappedFrameworksLte          *string  `json:"mappedFrameworksLTE,omitempty"`
	MappedFrameworksContains     *string  `json:"mappedFrameworksContains,omitempty"`
	MappedFrameworksHasPrefix    *string  `json:"mappedFrameworksHasPrefix,omitempty"`
	MappedFrameworksHasSuffix    *string  `json:"mappedFrameworksHasSuffix,omitempty"`
	MappedFrameworksIsNil        *bool    `json:"mappedFrameworksIsNil,omitempty"`
	MappedFrameworksNotNil       *bool    `json:"mappedFrameworksNotNil,omitempty"`
	MappedFrameworksEqualFold    *string  `json:"mappedFrameworksEqualFold,omitempty"`
	MappedFrameworksContainsFold *string  `json:"mappedFrameworksContainsFold,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// controlobjectives edge predicates
	HasControlobjectives     *bool                         `json:"hasControlobjectives,omitempty"`
	HasControlobjectivesWith []*ControlObjectiveWhereInput `json:"hasControlobjectivesWith,omitempty"`
	// standard edge predicates
	HasStandard     *bool                 `json:"hasStandard,omitempty"`
	HasStandardWith []*StandardWhereInput `json:"hasStandardWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// actionplans edge predicates
	HasActionplans     *bool                   `json:"hasActionplans,omitempty"`
	HasActionplansWith []*ActionPlanWhereInput `json:"hasActionplansWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

// CreateAPITokenInput is used for create APIToken object.
// Input was generated by ent.
type CreateAPITokenInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name associated with the token
	Name string `json:"name"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string    `json:"description,omitempty"`
	Scopes      []string   `json:"scopes,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	OwnerID     *string    `json:"ownerID,omitempty"`
}

// CreateActionPlanInput is used for create ActionPlan object.
// Input was generated by ent.
type CreateActionPlanInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the action plan
	Name string `json:"name"`
	// description of the action plan
	Description *string `json:"description,omitempty"`
	// status of the action plan
	Status *string `json:"status,omitempty"`
	// due date of the action plan
	DueDate *time.Time `json:"dueDate,omitempty"`
	// priority of the action plan
	Priority *string `json:"priority,omitempty"`
	// source of the action plan
	Source *string `json:"source,omitempty"`
	// json data including details of the action plan
	Details     map[string]interface{} `json:"details,omitempty"`
	StandardIDs []string               `json:"standardIDs,omitempty"`
	RiskIDs     []string               `json:"riskIDs,omitempty"`
	ControlIDs  []string               `json:"controlIDs,omitempty"`
	UserIDs     []string               `json:"userIDs,omitempty"`
	ProgramIDs  []string               `json:"programIDs,omitempty"`
}

// CreateContactInput is used for create Contact object.
// Input was generated by ent.
type CreateContactInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the full name of the contact
	FullName string `json:"fullName"`
	// the title of the contact
	Title *string `json:"title,omitempty"`
	// the company of the contact
	Company *string `json:"company,omitempty"`
	// the email of the contact
	Email *string `json:"email,omitempty"`
	// the phone number of the contact
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// the address of the contact
	Address *string `json:"address,omitempty"`
	// status of the contact
	Status    *enums.UserStatus `json:"status,omitempty"`
	OwnerID   *string           `json:"ownerID,omitempty"`
	EntityIDs []string          `json:"entityIDs,omitempty"`
	FileIDs   []string          `json:"fileIDs,omitempty"`
}

// CreateControlInput is used for create Control object.
// Input was generated by ent.
type CreateControlInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the control
	Name string `json:"name"`
	// description of the control
	Description *string `json:"description,omitempty"`
	// status of the control
	Status *string `json:"status,omitempty"`
	// type of the control
	ControlType *string `json:"controlType,omitempty"`
	// version of the control
	Version *string `json:"version,omitempty"`
	// control number or identifier
	ControlNumber *string `json:"controlNumber,omitempty"`
	// family associated with the control
	Family *string `json:"family,omitempty"`
	// class associated with the control
	Class *string `json:"class,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *string `json:"source,omitempty"`
	// which control objectives are satisfied by the control
	Satisfies *string `json:"satisfies,omitempty"`
	// mapped frameworks
	MappedFrameworks *string `json:"mappedFrameworks,omitempty"`
	// json data including details of the control
	Details             map[string]interface{} `json:"details,omitempty"`
	ProcedureIDs        []string               `json:"procedureIDs,omitempty"`
	SubcontrolIDs       []string               `json:"subcontrolIDs,omitempty"`
	ControlobjectiveIDs []string               `json:"controlobjectiveIDs,omitempty"`
	StandardIDs         []string               `json:"standardIDs,omitempty"`
	NarrativeIDs        []string               `json:"narrativeIDs,omitempty"`
	RiskIDs             []string               `json:"riskIDs,omitempty"`
	ActionplanIDs       []string               `json:"actionplanIDs,omitempty"`
	TaskIDs             []string               `json:"taskIDs,omitempty"`
	ProgramIDs          []string               `json:"programIDs,omitempty"`
}

// CreateControlObjectiveInput is used for create ControlObjective object.
// Input was generated by ent.
type CreateControlObjectiveInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the control objective
	Name string `json:"name"`
	// description of the control objective
	Description *string `json:"description,omitempty"`
	// status of the control objective
	Status *string `json:"status,omitempty"`
	// type of the control objective
	ControlObjectiveType *string `json:"controlObjectiveType,omitempty"`
	// version of the control objective
	Version *string `json:"version,omitempty"`
	// number of the control objective
	ControlNumber *string `json:"controlNumber,omitempty"`
	// family of the control objective
	Family *string `json:"family,omitempty"`
	// class associated with the control objective
	Class *string `json:"class,omitempty"`
	// source of the control objective, e.g. framework, template, user-defined, etc.
	Source *string `json:"source,omitempty"`
	// mapped frameworks
	MappedFrameworks *string `json:"mappedFrameworks,omitempty"`
	// json data including details of the control objective
	Details       map[string]interface{} `json:"details,omitempty"`
	PolicyIDs     []string               `json:"policyIDs,omitempty"`
	ControlIDs    []string               `json:"controlIDs,omitempty"`
	ProcedureIDs  []string               `json:"procedureIDs,omitempty"`
	RiskIDs       []string               `json:"riskIDs,omitempty"`
	SubcontrolIDs []string               `json:"subcontrolIDs,omitempty"`
	StandardIDs   []string               `json:"standardIDs,omitempty"`
	NarrativeIDs  []string               `json:"narrativeIDs,omitempty"`
	TaskIDs       []string               `json:"taskIDs,omitempty"`
	ProgramIDs    []string               `json:"programIDs,omitempty"`
}

// CreateDocumentDataInput is used for create DocumentData object.
// Input was generated by ent.
type CreateDocumentDataInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the json data of the document
	Data       json.RawMessage `json:"data"`
	OwnerID    *string         `json:"ownerID,omitempty"`
	TemplateID string          `json:"templateID"`
	EntityIDs  []string        `json:"entityIDs,omitempty"`
	FileIDs    []string        `json:"fileIDs,omitempty"`
}

// CreateEntitlementInput is used for create Entitlement object.
// Input was generated by ent.
type CreateEntitlementInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalCustomerID *string `json:"externalCustomerID,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalSubscriptionID *string `json:"externalSubscriptionID,omitempty"`
	// the time at which a customer's entitlement will expire, e.g. they've cancelled but paid through the end of the month
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// whether or not the customer has cancelled their entitlement - usually used in conjunction with expires and expires at
	Cancelled      *bool    `json:"cancelled,omitempty"`
	OwnerID        *string  `json:"ownerID,omitempty"`
	PlanID         string   `json:"planID"`
	OrganizationID string   `json:"organizationID"`
	EventIDs       []string `json:"eventIDs,omitempty"`
}

// CreateEntitlementPlanFeatureInput is used for create EntitlementPlanFeature object.
// Input was generated by ent.
type CreateEntitlementPlanFeatureInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// metadata for the entitlement plan feature such as usage limits
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
	OwnerID   *string                `json:"ownerID,omitempty"`
	PlanID    string                 `json:"planID"`
	FeatureID string                 `json:"featureID"`
	EventIDs  []string               `json:"eventIDs,omitempty"`
}

// CreateEntitlementPlanInput is used for create EntitlementPlan object.
// Input was generated by ent.
type CreateEntitlementPlanInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the displayed 'friendly' name of the plan
	DisplayName *string `json:"displayName,omitempty"`
	// the unique name of the plan
	Name string `json:"name"`
	// a description of the plan
	Description *string `json:"description,omitempty"`
	// the version of the plan
	Version string `json:"version"`
	// metadata for the plan
	Metadata       map[string]interface{} `json:"metadata,omitempty"`
	OwnerID        *string                `json:"ownerID,omitempty"`
	EntitlementIDs []string               `json:"entitlementIDs,omitempty"`
	BaseFeatureIDs []string               `json:"baseFeatureIDs,omitempty"`
	EventIDs       []string               `json:"eventIDs,omitempty"`
}

// CreateEntityInput is used for create Entity object.
// Input was generated by ent.
type CreateEntityInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the entity
	Name *string `json:"name,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the entity
	Description *string `json:"description,omitempty"`
	// domains associated with the entity
	Domains []string `json:"domains,omitempty"`
	// status of the entity
	Status       *string          `json:"status,omitempty"`
	OwnerID      *string          `json:"ownerID,omitempty"`
	ContactIDs   []string         `json:"contactIDs,omitempty"`
	DocumentIDs  []string         `json:"documentIDs,omitempty"`
	NoteIDs      []string         `json:"noteIDs,omitempty"`
	FileIDs      []string         `json:"fileIDs,omitempty"`
	EntityTypeID *string          `json:"entityTypeID,omitempty"`
	Note         *CreateNoteInput `json:"note,omitempty"`
}

// CreateEntityTypeInput is used for create EntityType object.
// Input was generated by ent.
type CreateEntityTypeInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the entity
	Name      string   `json:"name"`
	OwnerID   *string  `json:"ownerID,omitempty"`
	EntityIDs []string `json:"entityIDs,omitempty"`
}

// CreateEventInput is used for create Event object.
// Input was generated by ent.
type CreateEventInput struct {
	// tags associated with the object
	Tags                   []string               `json:"tags,omitempty"`
	EventID                *string                `json:"eventID,omitempty"`
	CorrelationID          *string                `json:"correlationID,omitempty"`
	EventType              string                 `json:"eventType"`
	Metadata               map[string]interface{} `json:"metadata,omitempty"`
	UserIDs                []string               `json:"userIDs,omitempty"`
	GroupIDs               []string               `json:"groupIDs,omitempty"`
	IntegrationIDs         []string               `json:"integrationIDs,omitempty"`
	OrganizationIDs        []string               `json:"organizationIDs,omitempty"`
	InviteIDs              []string               `json:"inviteIDs,omitempty"`
	FeatureIDs             []string               `json:"featureIDs,omitempty"`
	EntitlementplanIDs     []string               `json:"entitlementplanIDs,omitempty"`
	PersonalAccessTokenIDs []string               `json:"personalAccessTokenIDs,omitempty"`
	Oauth2tokenIDs         []string               `json:"oauth2tokenIDs,omitempty"`
	HushIDs                []string               `json:"hushIDs,omitempty"`
	EntitlementIDs         []string               `json:"entitlementIDs,omitempty"`
	WebhookIDs             []string               `json:"webhookIDs,omitempty"`
	SubscriberIDs          []string               `json:"subscriberIDs,omitempty"`
	FileIDs                []string               `json:"fileIDs,omitempty"`
}

// CreateFeatureInput is used for create Feature object.
// Input was generated by ent.
type CreateFeatureInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the unique name of the feature
	Name string `json:"name"`
	// the displayed 'friendly' name of the feature
	DisplayName *string `json:"displayName,omitempty"`
	// enabled features are available for use
	Enabled *bool `json:"enabled,omitempty"`
	// a description of the feature
	Description *string `json:"description,omitempty"`
	// metadata for the feature
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	OwnerID  *string                `json:"ownerID,omitempty"`
	PlanIDs  []string               `json:"planIDs,omitempty"`
	EventIDs []string               `json:"eventIDs,omitempty"`
}

// CreateFileInput is used for create File object.
// Input was generated by ent.
type CreateFileInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName string `json:"providedFileName"`
	// the extension of the file provided
	ProvidedFileExtension string `json:"providedFileExtension"`
	// the computed size of the file in the original http request
	ProvidedFileSize  *int64 `json:"providedFileSize,omitempty"`
	PersistedFileSize *int64 `json:"persistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType *string `json:"detectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash *string `json:"md5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType string `json:"detectedContentType"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey *string `json:"storeKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType *string `json:"categoryType,omitempty"`
	// the full URI of the file
	URI *string `json:"uri,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme *string `json:"storageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume *string `json:"storageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath            *string  `json:"storagePath,omitempty"`
	UserIDs                []string `json:"userIDs,omitempty"`
	OrganizationIDs        []string `json:"organizationIDs,omitempty"`
	GroupIDs               []string `json:"groupIDs,omitempty"`
	ContactIDs             []string `json:"contactIDs,omitempty"`
	EntityIDs              []string `json:"entityIDs,omitempty"`
	UsersettingIDs         []string `json:"usersettingIDs,omitempty"`
	OrganizationsettingIDs []string `json:"organizationsettingIDs,omitempty"`
	TemplateIDs            []string `json:"templateIDs,omitempty"`
	DocumentdatumIDs       []string `json:"documentdatumIDs,omitempty"`
	EventIDs               []string `json:"eventIDs,omitempty"`
	ProgramIDs             []string `json:"programIDs,omitempty"`
}

// CreateGroupInput is used for create Group object.
// Input was generated by ent.
type CreateGroupInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the group - must be unique within the organization
	Name string `json:"name"`
	// the groups description
	Description *string `json:"description,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL *string `json:"gravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL *string `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName         *string                  `json:"displayName,omitempty"`
	OwnerID             *string                  `json:"ownerID,omitempty"`
	SettingID           string                   `json:"settingID"`
	UserIDs             []string                 `json:"userIDs,omitempty"`
	EventIDs            []string                 `json:"eventIDs,omitempty"`
	IntegrationIDs      []string                 `json:"integrationIDs,omitempty"`
	FileIDs             []string                 `json:"fileIDs,omitempty"`
	TaskIDs             []string                 `json:"taskIDs,omitempty"`
	CreateGroupSettings *CreateGroupSettingInput `json:"createGroupSettings,omitempty"`
}

// CreateGroupMembershipInput is used for create GroupMembership object.
// Input was generated by ent.
type CreateGroupMembershipInput struct {
	Role     *enums.Role `json:"role,omitempty"`
	GroupID  string      `json:"groupID"`
	UserID   string      `json:"userID"`
	EventIDs []string    `json:"eventIDs,omitempty"`
}

// CreateGroupSettingInput is used for create GroupSetting object.
// Input was generated by ent.
type CreateGroupSettingInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility *enums.Visibility `json:"visibility,omitempty"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy *enums.JoinPolicy `json:"joinPolicy,omitempty"`
	// whether to sync group members to slack groups
	SyncToSlack *bool `json:"syncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub *bool   `json:"syncToGithub,omitempty"`
	GroupID      *string `json:"groupID,omitempty"`
}

// CreateHushInput is used for create Hush object.
// Input was generated by ent.
type CreateHushInput struct {
	// the logical name of the corresponding hush secret or it's general grouping
	Name string `json:"name"`
	// a description of the hush value or purpose, such as github PAT
	Description *string `json:"description,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind *string `json:"kind,omitempty"`
	// the generic name of a secret associated with the organization
	SecretName *string `json:"secretName,omitempty"`
	// the secret value
	SecretValue     *string  `json:"secretValue,omitempty"`
	IntegrationIDs  []string `json:"integrationIDs,omitempty"`
	OrganizationIDs []string `json:"organizationIDs,omitempty"`
	EventIDs        []string `json:"eventIDs,omitempty"`
}

// CreateIntegrationInput is used for create Integration object.
// Input was generated by ent.
type CreateIntegrationInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the integration - must be unique within the organization
	Name string `json:"name"`
	// a description of the integration
	Description    *string  `json:"description,omitempty"`
	Kind           *string  `json:"kind,omitempty"`
	OwnerID        *string  `json:"ownerID,omitempty"`
	SecretIDs      []string `json:"secretIDs,omitempty"`
	Oauth2tokenIDs []string `json:"oauth2tokenIDs,omitempty"`
	EventIDs       []string `json:"eventIDs,omitempty"`
	WebhookIDs     []string `json:"webhookIDs,omitempty"`
}

// CreateInternalPolicyInput is used for create InternalPolicy object.
// Input was generated by ent.
type CreateInternalPolicyInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the policy
	Name string `json:"name"`
	// description of the policy
	Description string `json:"description"`
	// status of the policy
	Status *string `json:"status,omitempty"`
	// type of the policy
	PolicyType *string `json:"policyType,omitempty"`
	// version of the policy
	Version *string `json:"version,omitempty"`
	// purpose and scope
	PurposeAndScope *string `json:"purposeAndScope,omitempty"`
	// background of the policy
	Background *string `json:"background,omitempty"`
	// json data for the policy document
	Details             map[string]interface{} `json:"details,omitempty"`
	ControlobjectiveIDs []string               `json:"controlobjectiveIDs,omitempty"`
	ControlIDs          []string               `json:"controlIDs,omitempty"`
	ProcedureIDs        []string               `json:"procedureIDs,omitempty"`
	NarrativeIDs        []string               `json:"narrativeIDs,omitempty"`
	TaskIDs             []string               `json:"taskIDs,omitempty"`
	ProgramIDs          []string               `json:"programIDs,omitempty"`
}

// CreateInviteInput is used for create Invite object.
// Input was generated by ent.
type CreateInviteInput struct {
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires *time.Time `json:"expires,omitempty"`
	// the email used as input to generate the invitation token and is the destination person the invitation is sent to who is required to accept to join the organization
	Recipient string `json:"recipient"`
	// the status of the invitation
	Status *enums.InviteStatus `json:"status,omitempty"`
	Role   *enums.Role         `json:"role,omitempty"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts *int64 `json:"sendAttempts,omitempty"`
	// the user who initiated the invitation
	RequestorID *string  `json:"requestorID,omitempty"`
	OwnerID     *string  `json:"ownerID,omitempty"`
	EventIDs    []string `json:"eventIDs,omitempty"`
}

// CreateNarrativeInput is used for create Narrative object.
// Input was generated by ent.
type CreateNarrativeInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the narrative
	Name string `json:"name"`
	// the description of the narrative
	Description *string `json:"description,omitempty"`
	// which controls are satisfied by the narrative
	Satisfies *string `json:"satisfies,omitempty"`
	// json data for the narrative document
	Details             map[string]interface{} `json:"details,omitempty"`
	PolicyIDs           []string               `json:"policyIDs,omitempty"`
	ControlIDs          []string               `json:"controlIDs,omitempty"`
	ProcedureIDs        []string               `json:"procedureIDs,omitempty"`
	ControlobjectiveIDs []string               `json:"controlobjectiveIDs,omitempty"`
	ProgramIDs          []string               `json:"programIDs,omitempty"`
}

// CreateNoteInput is used for create Note object.
// Input was generated by ent.
type CreateNoteInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the text of the note
	Text          string   `json:"text"`
	OwnerID       *string  `json:"ownerID,omitempty"`
	EntityID      *string  `json:"entityID,omitempty"`
	SubcontrolIDs []string `json:"subcontrolIDs,omitempty"`
	ProgramIDs    []string `json:"programIDs,omitempty"`
}

// CreateOauthProviderInput is used for create OauthProvider object.
// Input was generated by ent.
type CreateOauthProviderInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the oauth provider's name
	Name string `json:"name"`
	// the client id for the oauth provider
	ClientID string `json:"clientID"`
	// the client secret
	ClientSecret string `json:"clientSecret"`
	// the redirect url
	RedirectURL string `json:"redirectURL"`
	// the scopes
	Scopes string `json:"scopes"`
	// the auth url of the provider
	AuthURL string `json:"authURL"`
	// the token url of the provider
	TokenURL string `json:"tokenURL"`
	// the auth style, 0: auto detect 1: third party log in 2: log in with username and password
	AuthStyle string `json:"authStyle"`
	// the URL to request user information by token
	InfoURL string  `json:"infoURL"`
	OwnerID *string `json:"ownerID,omitempty"`
}

// CreateOhAuthTooTokenInput is used for create OhAuthTooToken object.
// Input was generated by ent.
type CreateOhAuthTooTokenInput struct {
	// tags associated with the object
	Tags                    []string   `json:"tags,omitempty"`
	ClientID                string     `json:"clientID"`
	Scopes                  []string   `json:"scopes,omitempty"`
	Nonce                   string     `json:"nonce"`
	ClaimsUserID            string     `json:"claimsUserID"`
	ClaimsUsername          string     `json:"claimsUsername"`
	ClaimsEmail             string     `json:"claimsEmail"`
	ClaimsEmailVerified     bool       `json:"claimsEmailVerified"`
	ClaimsGroups            []string   `json:"claimsGroups,omitempty"`
	ClaimsPreferredUsername string     `json:"claimsPreferredUsername"`
	ConnectorID             string     `json:"connectorID"`
	ConnectorData           []string   `json:"connectorData,omitempty"`
	LastUsed                *time.Time `json:"lastUsed,omitempty"`
	IntegrationIDs          []string   `json:"integrationIDs,omitempty"`
	EventIDs                []string   `json:"eventIDs,omitempty"`
}

// CreateOrgMembershipInput is used for create OrgMembership object.
// Input was generated by ent.
type CreateOrgMembershipInput struct {
	Role           *enums.Role `json:"role,omitempty"`
	OrganizationID string      `json:"organizationID"`
	UserID         string      `json:"userID"`
	EventIDs       []string    `json:"eventIDs,omitempty"`
}

// CreateOrganizationInput is used for create Organization object.
// Input was generated by ent.
type CreateOrganizationInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the organization
	Name string `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the organization
	Description *string `json:"description,omitempty"`
	// orgs directly associated with a user
	PersonalOrg *bool `json:"personalOrg,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// Whether the organization has a dedicated database
	DedicatedDb                *bool                           `json:"dedicatedDb,omitempty"`
	ParentID                   *string                         `json:"parentID,omitempty"`
	GroupIDs                   []string                        `json:"groupIDs,omitempty"`
	TemplateIDs                []string                        `json:"templateIDs,omitempty"`
	IntegrationIDs             []string                        `json:"integrationIDs,omitempty"`
	SettingID                  *string                         `json:"settingID,omitempty"`
	DocumentdatumIDs           []string                        `json:"documentdatumIDs,omitempty"`
	EntitlementIDs             []string                        `json:"entitlementIDs,omitempty"`
	OrganizationEntitlementIDs []string                        `json:"organizationEntitlementIDs,omitempty"`
	PersonalAccessTokenIDs     []string                        `json:"personalAccessTokenIDs,omitempty"`
	APITokenIDs                []string                        `json:"apiTokenIDs,omitempty"`
	OauthproviderIDs           []string                        `json:"oauthproviderIDs,omitempty"`
	UserIDs                    []string                        `json:"userIDs,omitempty"`
	InviteIDs                  []string                        `json:"inviteIDs,omitempty"`
	SubscriberIDs              []string                        `json:"subscriberIDs,omitempty"`
	WebhookIDs                 []string                        `json:"webhookIDs,omitempty"`
	EventIDs                   []string                        `json:"eventIDs,omitempty"`
	SecretIDs                  []string                        `json:"secretIDs,omitempty"`
	FeatureIDs                 []string                        `json:"featureIDs,omitempty"`
	FileIDs                    []string                        `json:"fileIDs,omitempty"`
	EntitlementplanIDs         []string                        `json:"entitlementplanIDs,omitempty"`
	EntityIDs                  []string                        `json:"entityIDs,omitempty"`
	EntitytypeIDs              []string                        `json:"entitytypeIDs,omitempty"`
	ContactIDs                 []string                        `json:"contactIDs,omitempty"`
	NoteIDs                    []string                        `json:"noteIDs,omitempty"`
	TaskIDs                    []string                        `json:"taskIDs,omitempty"`
	ProgramIDs                 []string                        `json:"programIDs,omitempty"`
	CreateOrgSettings          *CreateOrganizationSettingInput `json:"createOrgSettings,omitempty"`
}

// CreateOrganizationSettingInput is used for create OrganizationSetting object.
// Input was generated by ent.
type CreateOrganizationSettingInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// domains associated with the organization
	Domains []string `json:"domains,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone *string `json:"billingPhone,omitempty"`
	// Address to send billing information to
	BillingAddress *string `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation    *enums.Region `json:"geoLocation,omitempty"`
	OrganizationID *string       `json:"organizationID,omitempty"`
	FileIDs        []string      `json:"fileIDs,omitempty"`
}

// CreatePersonalAccessTokenInput is used for create PersonalAccessToken object.
// Input was generated by ent.
type CreatePersonalAccessTokenInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name associated with the token
	Name string `json:"name"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description     *string    `json:"description,omitempty"`
	Scopes          []string   `json:"scopes,omitempty"`
	LastUsedAt      *time.Time `json:"lastUsedAt,omitempty"`
	OwnerID         string     `json:"ownerID"`
	OrganizationIDs []string   `json:"organizationIDs,omitempty"`
	EventIDs        []string   `json:"eventIDs,omitempty"`
}

// CreateProcedureInput is used for create Procedure object.
// Input was generated by ent.
type CreateProcedureInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the procedure
	Name string `json:"name"`
	// description of the procedure
	Description *string `json:"description,omitempty"`
	// status of the procedure
	Status *string `json:"status,omitempty"`
	// type of the procedure
	ProcedureType *string `json:"procedureType,omitempty"`
	// version of the procedure
	Version *string `json:"version,omitempty"`
	// purpose and scope
	PurposeAndScope *string `json:"purposeAndScope,omitempty"`
	// background of the procedure
	Background *string `json:"background,omitempty"`
	// which controls are satisfied by the procedure
	Satisfies *string `json:"satisfies,omitempty"`
	// json data for the procedure document
	Details           map[string]interface{} `json:"details,omitempty"`
	ControlIDs        []string               `json:"controlIDs,omitempty"`
	InternalpolicyIDs []string               `json:"internalpolicyIDs,omitempty"`
	NarrativeIDs      []string               `json:"narrativeIDs,omitempty"`
	RiskIDs           []string               `json:"riskIDs,omitempty"`
	TaskIDs           []string               `json:"taskIDs,omitempty"`
	ProgramIDs        []string               `json:"programIDs,omitempty"`
}

// CreateProgramInput is used for create Program object.
// Input was generated by ent.
type CreateProgramInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the program
	Name string `json:"name"`
	// the description of the program
	Description *string `json:"description,omitempty"`
	// the status of the program
	Status *enums.ProgramStatus `json:"status,omitempty"`
	// the start date of the period
	StartDate *time.Time `json:"startDate,omitempty"`
	// the end date of the period
	EndDate *time.Time `json:"endDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady *bool `json:"auditorReady,omitempty"`
	// can the auditor write comments
	AuditorWriteComments *bool `json:"auditorWriteComments,omitempty"`
	// can the auditor read comments
	AuditorReadComments *bool    `json:"auditorReadComments,omitempty"`
	OwnerID             *string  `json:"ownerID,omitempty"`
	ControlIDs          []string `json:"controlIDs,omitempty"`
	SubcontrolIDs       []string `json:"subcontrolIDs,omitempty"`
	ControlobjectiveIDs []string `json:"controlobjectiveIDs,omitempty"`
	PolicyIDs           []string `json:"policyIDs,omitempty"`
	ProcedureIDs        []string `json:"procedureIDs,omitempty"`
	RiskIDs             []string `json:"riskIDs,omitempty"`
	TaskIDs             []string `json:"taskIDs,omitempty"`
	NoteIDs             []string `json:"noteIDs,omitempty"`
	FileIDs             []string `json:"fileIDs,omitempty"`
	NarrativeIDs        []string `json:"narrativeIDs,omitempty"`
	ActionplanIDs       []string `json:"actionplanIDs,omitempty"`
	StandardIDs         []string `json:"standardIDs,omitempty"`
	UserIDs             []string `json:"userIDs,omitempty"`
}

// CreateProgramMembershipInput is used for create ProgramMembership object.
// Input was generated by ent.
type CreateProgramMembershipInput struct {
	Role      *enums.Role `json:"role,omitempty"`
	ProgramID string      `json:"programID"`
	UserID    string      `json:"userID"`
}

// CreateRiskInput is used for create Risk object.
// Input was generated by ent.
type CreateRiskInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the risk
	Name string `json:"name"`
	// description of the risk
	Description *string `json:"description,omitempty"`
	// status of the risk - mitigated or not, inflight, etc.
	Status *string `json:"status,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType *string `json:"riskType,omitempty"`
	// business costs associated with the risk
	BusinessCosts *string `json:"businessCosts,omitempty"`
	// impact of the risk - high, medium, low
	Impact *enums.RiskImpact `json:"impact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood *enums.RiskLikelihood `json:"likelihood,omitempty"`
	// mitigation for the risk
	Mitigation *string `json:"mitigation,omitempty"`
	// which controls are satisfied by the risk
	Satisfies *string `json:"satisfies,omitempty"`
	// json data for the risk document
	Details       map[string]interface{} `json:"details,omitempty"`
	ControlIDs    []string               `json:"controlIDs,omitempty"`
	ProcedureIDs  []string               `json:"procedureIDs,omitempty"`
	ActionplanIDs []string               `json:"actionplanIDs,omitempty"`
	ProgramIDs    []string               `json:"programIDs,omitempty"`
}

// CreateStandardInput is used for create Standard object.
// Input was generated by ent.
type CreateStandardInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the standard body, e.g. TSC, NIST, SOC, HITRUST, FedRamp, etc.
	Name string `json:"name"`
	// description of the standard
	Description *string `json:"description,omitempty"`
	// family of the standard, e.g. 800-53, 800-171, 27001, etc.
	Family *string `json:"family,omitempty"`
	// status of the standard - active, deprecated, etc.
	Status *string `json:"status,omitempty"`
	// type of the standard - security, privacy, etc.
	StandardType *string `json:"standardType,omitempty"`
	// version of the standard
	Version *string `json:"version,omitempty"`
	// purpose and scope
	PurposeAndScope *string `json:"purposeAndScope,omitempty"`
	// background of the standard
	Background *string `json:"background,omitempty"`
	// which controls are satisfied by the standard
	Satisfies *string `json:"satisfies,omitempty"`
	// json data with details of the standard
	Details             map[string]interface{} `json:"details,omitempty"`
	ControlobjectiveIDs []string               `json:"controlobjectiveIDs,omitempty"`
	ControlIDs          []string               `json:"controlIDs,omitempty"`
	ProcedureIDs        []string               `json:"procedureIDs,omitempty"`
	ActionplanIDs       []string               `json:"actionplanIDs,omitempty"`
	ProgramIDs          []string               `json:"programIDs,omitempty"`
}

// CreateSubcontrolInput is used for create Subcontrol object.
// Input was generated by ent.
type CreateSubcontrolInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the subcontrol
	Name string `json:"name"`
	// description of the subcontrol
	Description *string `json:"description,omitempty"`
	// status of the subcontrol
	Status *string `json:"status,omitempty"`
	// type of the subcontrol
	SubcontrolType *string `json:"subcontrolType,omitempty"`
	// version of the control
	Version *string `json:"version,omitempty"`
	// number of the subcontrol
	SubcontrolNumber *string `json:"subcontrolNumber,omitempty"`
	// subcontrol family
	Family *string `json:"family,omitempty"`
	// subcontrol class
	Class *string `json:"class,omitempty"`
	// source of the control, e.g. framework, template, user-defined, etc.
	Source *string `json:"source,omitempty"`
	// mapped frameworks that the subcontrol is part of
	MappedFrameworks *string `json:"mappedFrameworks,omitempty"`
	// implementation evidence of the subcontrol
	ImplementationEvidence *string `json:"implementationEvidence,omitempty"`
	// implementation status
	ImplementationStatus *string `json:"implementationStatus,omitempty"`
	// date the subcontrol was implemented
	ImplementationDate *time.Time `json:"implementationDate,omitempty"`
	// implementation verification
	ImplementationVerification *string `json:"implementationVerification,omitempty"`
	// date the subcontrol implementation was verified
	ImplementationVerificationDate *time.Time `json:"implementationVerificationDate,omitempty"`
	// json data details of the subcontrol
	Details    map[string]interface{} `json:"details,omitempty"`
	ControlIDs []string               `json:"controlIDs,omitempty"`
	UserIDs    []string               `json:"userIDs,omitempty"`
	TaskIDs    []string               `json:"taskIDs,omitempty"`
	NotesID    *string                `json:"notesID,omitempty"`
	ProgramIDs []string               `json:"programIDs,omitempty"`
}

// CreateSubscriberInput is used for create Subscriber object.
// Input was generated by ent.
type CreateSubscriberInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// email address of the subscriber
	Email string `json:"email"`
	// phone number of the subscriber
	PhoneNumber *string  `json:"phoneNumber,omitempty"`
	OwnerID     *string  `json:"ownerID,omitempty"`
	EventIDs    []string `json:"eventIDs,omitempty"`
}

// CreateTFASettingInput is used for create TFASetting object.
// Input was generated by ent.
type CreateTFASettingInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// specifies a user may complete authentication by verifying a TOTP code delivered through an authenticator app
	TotpAllowed *bool   `json:"totpAllowed,omitempty"`
	OwnerID     *string `json:"ownerID,omitempty"`
}

// CreateTaskInput is used for create Task object.
// Input was generated by ent.
type CreateTaskInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the title of the task
	Title string `json:"title"`
	// the description of the task
	Description *string `json:"description,omitempty"`
	// the details of the task
	Details map[string]interface{} `json:"details,omitempty"`
	// the status of the task
	Status *enums.TaskStatus `json:"status,omitempty"`
	// the due date of the task
	Due *time.Time `json:"due,omitempty"`
	// the completion date of the task
	Completed           *time.Time `json:"completed,omitempty"`
	AssignerID          string     `json:"assignerID"`
	AssigneeID          *string    `json:"assigneeID,omitempty"`
	OrganizationIDs     []string   `json:"organizationIDs,omitempty"`
	GroupIDs            []string   `json:"groupIDs,omitempty"`
	PolicyIDs           []string   `json:"policyIDs,omitempty"`
	ProcedureIDs        []string   `json:"procedureIDs,omitempty"`
	ControlIDs          []string   `json:"controlIDs,omitempty"`
	ControlObjectiveIDs []string   `json:"controlObjectiveIDs,omitempty"`
	SubcontrolIDs       []string   `json:"subcontrolIDs,omitempty"`
	ProgramIDs          []string   `json:"programIDs,omitempty"`
}

// CreateTemplateInput is used for create Template object.
// Input was generated by ent.
type CreateTemplateInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the template
	Name string `json:"name"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType *enums.DocumentType `json:"templateType,omitempty"`
	// the description of the template
	Description *string `json:"description,omitempty"`
	// the jsonschema object of the template
	Jsonconfig json.RawMessage `json:"jsonconfig"`
	// the uischema for the template to render in the UI
	Uischema    json.RawMessage `json:"uischema,omitempty"`
	OwnerID     *string         `json:"ownerID,omitempty"`
	DocumentIDs []string        `json:"documentIDs,omitempty"`
	FileIDs     []string        `json:"fileIDs,omitempty"`
}

// CreateUserInput is used for create User object.
// Input was generated by ent.
type CreateUserInput struct {
	// tags associated with the object
	Tags      []string `json:"tags,omitempty"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName,omitempty"`
	LastName  *string  `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile *string `json:"avatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// user password hash
	Password *string `json:"password,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// auth provider used to register the account
	AuthProvider *enums.AuthProvider `json:"authProvider,omitempty"`
	// the user's role
	Role                      *enums.Role `json:"role,omitempty"`
	PersonalAccessTokenIDs    []string    `json:"personalAccessTokenIDs,omitempty"`
	TfaSettingIDs             []string    `json:"tfaSettingIDs,omitempty"`
	SettingID                 string      `json:"settingID"`
	EmailVerificationTokenIDs []string    `json:"emailVerificationTokenIDs,omitempty"`
	PasswordResetTokenIDs     []string    `json:"passwordResetTokenIDs,omitempty"`
	GroupIDs                  []string    `json:"groupIDs,omitempty"`
	OrganizationIDs           []string    `json:"organizationIDs,omitempty"`
	WebauthnIDs               []string    `json:"webauthnIDs,omitempty"`
	FileIDs                   []string    `json:"fileIDs,omitempty"`
	FileID                    *string     `json:"fileID,omitempty"`
	EventIDs                  []string    `json:"eventIDs,omitempty"`
	ActionplanIDs             []string    `json:"actionplanIDs,omitempty"`
	SubcontrolIDs             []string    `json:"subcontrolIDs,omitempty"`
	AssignerTaskIDs           []string    `json:"assignerTaskIDs,omitempty"`
	AssigneeTaskIDs           []string    `json:"assigneeTaskIDs,omitempty"`
	ProgramIDs                []string    `json:"programIDs,omitempty"`
}

// CreateUserSettingInput is used for create UserSetting object.
// Input was generated by ent.
type CreateUserSettingInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// status of the user account
	Status *enums.UserStatus `json:"status,omitempty"`
	// whether the user has confirmed their email address
	EmailConfirmed *bool `json:"emailConfirmed,omitempty"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed *bool `json:"isWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled *bool    `json:"isTfaEnabled,omitempty"`
	UserID       *string  `json:"userID,omitempty"`
	DefaultOrgID *string  `json:"defaultOrgID,omitempty"`
	FileIDs      []string `json:"fileIDs,omitempty"`
}

// CreateWebhookInput is used for create Webhook object.
// Input was generated by ent.
type CreateWebhookInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the webhook
	Name string `json:"name"`
	// a description of the webhook
	Description *string `json:"description,omitempty"`
	// the url to send the webhook to
	DestinationURL string `json:"destinationURL"`
	// indicates if the webhook is active and enabled
	Enabled *bool `json:"enabled,omitempty"`
	// the number of failures
	Failures *int64 `json:"failures,omitempty"`
	// the last error message
	LastError *string `json:"lastError,omitempty"`
	// the last response
	LastResponse   *string  `json:"lastResponse,omitempty"`
	OwnerID        *string  `json:"ownerID,omitempty"`
	EventIDs       []string `json:"eventIDs,omitempty"`
	IntegrationIDs []string `json:"integrationIDs,omitempty"`
}

type DocumentData struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the template id of the document
	TemplateID string `json:"templateID"`
	// the json data of the document
	Data     json.RawMessage `json:"data"`
	Owner    *Organization   `json:"owner,omitempty"`
	Template *Template       `json:"template"`
	Entity   []*Entity       `json:"entity,omitempty"`
	Files    []*File         `json:"files,omitempty"`
}

func (DocumentData) IsNode() {}

// Return response for createBulkDocumentData mutation
type DocumentDataBulkCreatePayload struct {
	// Created documentData
	DocumentData []*DocumentData `json:"documentData,omitempty"`
}

// A connection to a list of items.
type DocumentDataConnection struct {
	// A list of edges.
	Edges []*DocumentDataEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createDocumentData mutation
type DocumentDataCreatePayload struct {
	// Created documentData
	DocumentData *DocumentData `json:"documentData"`
}

// Return response for deleteDocumentData mutation
type DocumentDataDeletePayload struct {
	// Deleted documentData ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type DocumentDataEdge struct {
	// The item at the end of the edge.
	Node *DocumentData `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type DocumentDataHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the template id of the document
	TemplateID string `json:"templateID"`
	// the json data of the document
	Data json.RawMessage `json:"data"`
}

func (DocumentDataHistory) IsNode() {}

// A connection to a list of items.
type DocumentDataHistoryConnection struct {
	// A list of edges.
	Edges []*DocumentDataHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type DocumentDataHistoryEdge struct {
	// The item at the end of the edge.
	Node *DocumentDataHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// DocumentDataHistoryWhereInput is used for filtering DocumentDataHistory objects.
// Input was generated by ent.
type DocumentDataHistoryWhereInput struct {
	Not *DocumentDataHistoryWhereInput   `json:"not,omitempty"`
	And []*DocumentDataHistoryWhereInput `json:"and,omitempty"`
	Or  []*DocumentDataHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// template_id field predicates
	TemplateID             *string  `json:"templateID,omitempty"`
	TemplateIdneq          *string  `json:"templateIDNEQ,omitempty"`
	TemplateIDIn           []string `json:"templateIDIn,omitempty"`
	TemplateIDNotIn        []string `json:"templateIDNotIn,omitempty"`
	TemplateIdgt           *string  `json:"templateIDGT,omitempty"`
	TemplateIdgte          *string  `json:"templateIDGTE,omitempty"`
	TemplateIdlt           *string  `json:"templateIDLT,omitempty"`
	TemplateIdlte          *string  `json:"templateIDLTE,omitempty"`
	TemplateIDContains     *string  `json:"templateIDContains,omitempty"`
	TemplateIDHasPrefix    *string  `json:"templateIDHasPrefix,omitempty"`
	TemplateIDHasSuffix    *string  `json:"templateIDHasSuffix,omitempty"`
	TemplateIDEqualFold    *string  `json:"templateIDEqualFold,omitempty"`
	TemplateIDContainsFold *string  `json:"templateIDContainsFold,omitempty"`
}

type DocumentDataSearchResult struct {
	DocumentData []*DocumentData `json:"documentData,omitempty"`
}

func (DocumentDataSearchResult) IsSearchResult() {}

// Return response for updateDocumentData mutation
type DocumentDataUpdatePayload struct {
	// Updated documentData
	DocumentData *DocumentData `json:"documentData"`
}

// DocumentDataWhereInput is used for filtering DocumentData objects.
// Input was generated by ent.
type DocumentDataWhereInput struct {
	Not *DocumentDataWhereInput   `json:"not,omitempty"`
	And []*DocumentDataWhereInput `json:"and,omitempty"`
	Or  []*DocumentDataWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// template_id field predicates
	TemplateID             *string  `json:"templateID,omitempty"`
	TemplateIdneq          *string  `json:"templateIDNEQ,omitempty"`
	TemplateIDIn           []string `json:"templateIDIn,omitempty"`
	TemplateIDNotIn        []string `json:"templateIDNotIn,omitempty"`
	TemplateIdgt           *string  `json:"templateIDGT,omitempty"`
	TemplateIdgte          *string  `json:"templateIDGTE,omitempty"`
	TemplateIdlt           *string  `json:"templateIDLT,omitempty"`
	TemplateIdlte          *string  `json:"templateIDLTE,omitempty"`
	TemplateIDContains     *string  `json:"templateIDContains,omitempty"`
	TemplateIDHasPrefix    *string  `json:"templateIDHasPrefix,omitempty"`
	TemplateIDHasSuffix    *string  `json:"templateIDHasSuffix,omitempty"`
	TemplateIDEqualFold    *string  `json:"templateIDEqualFold,omitempty"`
	TemplateIDContainsFold *string  `json:"templateIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// template edge predicates
	HasTemplate     *bool                 `json:"hasTemplate,omitempty"`
	HasTemplateWith []*TemplateWhereInput `json:"hasTemplateWith,omitempty"`
	// entity edge predicates
	HasEntity     *bool               `json:"hasEntity,omitempty"`
	HasEntityWith []*EntityWhereInput `json:"hasEntityWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

type Entitlement struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the plan to which the entitlement belongs
	PlanID string `json:"planID"`
	// the organization to which the entitlement belongs
	OrganizationID string `json:"organizationID"`
	// used to store references to external systems, e.g. Stripe
	ExternalCustomerID *string `json:"externalCustomerID,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalSubscriptionID *string `json:"externalSubscriptionID,omitempty"`
	// whether or not the customers entitlement expires - expires_at will show the time
	Expires bool `json:"expires"`
	// the time at which a customer's entitlement will expire, e.g. they've cancelled but paid through the end of the month
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// whether or not the customer has cancelled their entitlement - usually used in conjunction with expires and expires at
	Cancelled    bool             `json:"cancelled"`
	Owner        *Organization    `json:"owner,omitempty"`
	Plan         *EntitlementPlan `json:"plan"`
	Organization *Organization    `json:"organization"`
	Events       []*Event         `json:"events,omitempty"`
}

func (Entitlement) IsNode() {}

// Return response for createBulkEntitlement mutation
type EntitlementBulkCreatePayload struct {
	// Created entitlements
	Entitlements []*Entitlement `json:"entitlements,omitempty"`
}

// A connection to a list of items.
type EntitlementConnection struct {
	// A list of edges.
	Edges []*EntitlementEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntitlement mutation
type EntitlementCreatePayload struct {
	// Created entitlement
	Entitlement *Entitlement `json:"entitlement"`
}

// Return response for deleteEntitlement mutation
type EntitlementDeletePayload struct {
	// Deleted entitlement ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntitlementEdge struct {
	// The item at the end of the edge.
	Node *Entitlement `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntitlementHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the plan to which the entitlement belongs
	PlanID string `json:"planID"`
	// the organization to which the entitlement belongs
	OrganizationID string `json:"organizationID"`
	// used to store references to external systems, e.g. Stripe
	ExternalCustomerID *string `json:"externalCustomerID,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalSubscriptionID *string `json:"externalSubscriptionID,omitempty"`
	// whether or not the customers entitlement expires - expires_at will show the time
	Expires bool `json:"expires"`
	// the time at which a customer's entitlement will expire, e.g. they've cancelled but paid through the end of the month
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// whether or not the customer has cancelled their entitlement - usually used in conjunction with expires and expires at
	Cancelled bool `json:"cancelled"`
}

func (EntitlementHistory) IsNode() {}

// A connection to a list of items.
type EntitlementHistoryConnection struct {
	// A list of edges.
	Edges []*EntitlementHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntitlementHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntitlementHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// EntitlementHistoryWhereInput is used for filtering EntitlementHistory objects.
// Input was generated by ent.
type EntitlementHistoryWhereInput struct {
	Not *EntitlementHistoryWhereInput   `json:"not,omitempty"`
	And []*EntitlementHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntitlementHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// plan_id field predicates
	PlanID             *string  `json:"planID,omitempty"`
	PlanIdneq          *string  `json:"planIDNEQ,omitempty"`
	PlanIDIn           []string `json:"planIDIn,omitempty"`
	PlanIDNotIn        []string `json:"planIDNotIn,omitempty"`
	PlanIdgt           *string  `json:"planIDGT,omitempty"`
	PlanIdgte          *string  `json:"planIDGTE,omitempty"`
	PlanIdlt           *string  `json:"planIDLT,omitempty"`
	PlanIdlte          *string  `json:"planIDLTE,omitempty"`
	PlanIDContains     *string  `json:"planIDContains,omitempty"`
	PlanIDHasPrefix    *string  `json:"planIDHasPrefix,omitempty"`
	PlanIDHasSuffix    *string  `json:"planIDHasSuffix,omitempty"`
	PlanIDEqualFold    *string  `json:"planIDEqualFold,omitempty"`
	PlanIDContainsFold *string  `json:"planIDContainsFold,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// external_customer_id field predicates
	ExternalCustomerID             *string  `json:"externalCustomerID,omitempty"`
	ExternalCustomerIdneq          *string  `json:"externalCustomerIDNEQ,omitempty"`
	ExternalCustomerIDIn           []string `json:"externalCustomerIDIn,omitempty"`
	ExternalCustomerIDNotIn        []string `json:"externalCustomerIDNotIn,omitempty"`
	ExternalCustomerIdgt           *string  `json:"externalCustomerIDGT,omitempty"`
	ExternalCustomerIdgte          *string  `json:"externalCustomerIDGTE,omitempty"`
	ExternalCustomerIdlt           *string  `json:"externalCustomerIDLT,omitempty"`
	ExternalCustomerIdlte          *string  `json:"externalCustomerIDLTE,omitempty"`
	ExternalCustomerIDContains     *string  `json:"externalCustomerIDContains,omitempty"`
	ExternalCustomerIDHasPrefix    *string  `json:"externalCustomerIDHasPrefix,omitempty"`
	ExternalCustomerIDHasSuffix    *string  `json:"externalCustomerIDHasSuffix,omitempty"`
	ExternalCustomerIDIsNil        *bool    `json:"externalCustomerIDIsNil,omitempty"`
	ExternalCustomerIDNotNil       *bool    `json:"externalCustomerIDNotNil,omitempty"`
	ExternalCustomerIDEqualFold    *string  `json:"externalCustomerIDEqualFold,omitempty"`
	ExternalCustomerIDContainsFold *string  `json:"externalCustomerIDContainsFold,omitempty"`
	// external_subscription_id field predicates
	ExternalSubscriptionID             *string  `json:"externalSubscriptionID,omitempty"`
	ExternalSubscriptionIdneq          *string  `json:"externalSubscriptionIDNEQ,omitempty"`
	ExternalSubscriptionIDIn           []string `json:"externalSubscriptionIDIn,omitempty"`
	ExternalSubscriptionIDNotIn        []string `json:"externalSubscriptionIDNotIn,omitempty"`
	ExternalSubscriptionIdgt           *string  `json:"externalSubscriptionIDGT,omitempty"`
	ExternalSubscriptionIdgte          *string  `json:"externalSubscriptionIDGTE,omitempty"`
	ExternalSubscriptionIdlt           *string  `json:"externalSubscriptionIDLT,omitempty"`
	ExternalSubscriptionIdlte          *string  `json:"externalSubscriptionIDLTE,omitempty"`
	ExternalSubscriptionIDContains     *string  `json:"externalSubscriptionIDContains,omitempty"`
	ExternalSubscriptionIDHasPrefix    *string  `json:"externalSubscriptionIDHasPrefix,omitempty"`
	ExternalSubscriptionIDHasSuffix    *string  `json:"externalSubscriptionIDHasSuffix,omitempty"`
	ExternalSubscriptionIDIsNil        *bool    `json:"externalSubscriptionIDIsNil,omitempty"`
	ExternalSubscriptionIDNotNil       *bool    `json:"externalSubscriptionIDNotNil,omitempty"`
	ExternalSubscriptionIDEqualFold    *string  `json:"externalSubscriptionIDEqualFold,omitempty"`
	ExternalSubscriptionIDContainsFold *string  `json:"externalSubscriptionIDContainsFold,omitempty"`
	// expires field predicates
	Expires    *bool `json:"expires,omitempty"`
	ExpiresNeq *bool `json:"expiresNEQ,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// cancelled field predicates
	Cancelled    *bool `json:"cancelled,omitempty"`
	CancelledNeq *bool `json:"cancelledNEQ,omitempty"`
}

type EntitlementPlan struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the displayed 'friendly' name of the plan
	DisplayName *string `json:"displayName,omitempty"`
	// the unique name of the plan
	Name string `json:"name"`
	// a description of the plan
	Description *string `json:"description,omitempty"`
	// the version of the plan
	Version string `json:"version"`
	// metadata for the plan
	Metadata     map[string]interface{}    `json:"metadata,omitempty"`
	Owner        *Organization             `json:"owner,omitempty"`
	Entitlements []*Entitlement            `json:"entitlements,omitempty"`
	BaseFeatures []*Feature                `json:"baseFeatures,omitempty"`
	Events       []*Event                  `json:"events,omitempty"`
	Features     []*EntitlementPlanFeature `json:"features,omitempty"`
}

func (EntitlementPlan) IsNode() {}

// Return response for createBulkEntitlementPlan mutation
type EntitlementPlanBulkCreatePayload struct {
	// Created entitlementPlans
	EntitlementPlans []*EntitlementPlan `json:"entitlementPlans,omitempty"`
}

// A connection to a list of items.
type EntitlementPlanConnection struct {
	// A list of edges.
	Edges []*EntitlementPlanEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntitlementPlan mutation
type EntitlementPlanCreatePayload struct {
	// Created entitlementPlan
	EntitlementPlan *EntitlementPlan `json:"entitlementPlan"`
}

// Return response for deleteEntitlementPlan mutation
type EntitlementPlanDeletePayload struct {
	// Deleted entitlementPlan ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntitlementPlanEdge struct {
	// The item at the end of the edge.
	Node *EntitlementPlan `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntitlementPlanFeature struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// metadata for the entitlement plan feature such as usage limits
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
	PlanID    string                 `json:"planID"`
	FeatureID string                 `json:"featureID"`
	Owner     *Organization          `json:"owner,omitempty"`
	Plan      *EntitlementPlan       `json:"plan"`
	Feature   *Feature               `json:"feature"`
	Events    []*Event               `json:"events,omitempty"`
}

func (EntitlementPlanFeature) IsNode() {}

// Return response for createBulkEntitlementPlanFeature mutation
type EntitlementPlanFeatureBulkCreatePayload struct {
	// Created entitlementPlanFeatures
	EntitlementPlanFeatures []*EntitlementPlanFeature `json:"entitlementPlanFeatures,omitempty"`
}

// A connection to a list of items.
type EntitlementPlanFeatureConnection struct {
	// A list of edges.
	Edges []*EntitlementPlanFeatureEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntitlementPlanFeature mutation
type EntitlementPlanFeatureCreatePayload struct {
	// Created entitlementPlanFeature
	EntitlementPlanFeature *EntitlementPlanFeature `json:"entitlementPlanFeature"`
}

// Return response for deleteEntitlementPlanFeature mutation
type EntitlementPlanFeatureDeletePayload struct {
	// Deleted entitlementPlanFeature ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntitlementPlanFeatureEdge struct {
	// The item at the end of the edge.
	Node *EntitlementPlanFeature `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntitlementPlanFeatureHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// metadata for the entitlement plan feature such as usage limits
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
	PlanID    string                 `json:"planID"`
	FeatureID string                 `json:"featureID"`
}

func (EntitlementPlanFeatureHistory) IsNode() {}

// A connection to a list of items.
type EntitlementPlanFeatureHistoryConnection struct {
	// A list of edges.
	Edges []*EntitlementPlanFeatureHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntitlementPlanFeatureHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntitlementPlanFeatureHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// EntitlementPlanFeatureHistoryWhereInput is used for filtering EntitlementPlanFeatureHistory objects.
// Input was generated by ent.
type EntitlementPlanFeatureHistoryWhereInput struct {
	Not *EntitlementPlanFeatureHistoryWhereInput   `json:"not,omitempty"`
	And []*EntitlementPlanFeatureHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntitlementPlanFeatureHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// plan_id field predicates
	PlanID             *string  `json:"planID,omitempty"`
	PlanIdneq          *string  `json:"planIDNEQ,omitempty"`
	PlanIDIn           []string `json:"planIDIn,omitempty"`
	PlanIDNotIn        []string `json:"planIDNotIn,omitempty"`
	PlanIdgt           *string  `json:"planIDGT,omitempty"`
	PlanIdgte          *string  `json:"planIDGTE,omitempty"`
	PlanIdlt           *string  `json:"planIDLT,omitempty"`
	PlanIdlte          *string  `json:"planIDLTE,omitempty"`
	PlanIDContains     *string  `json:"planIDContains,omitempty"`
	PlanIDHasPrefix    *string  `json:"planIDHasPrefix,omitempty"`
	PlanIDHasSuffix    *string  `json:"planIDHasSuffix,omitempty"`
	PlanIDEqualFold    *string  `json:"planIDEqualFold,omitempty"`
	PlanIDContainsFold *string  `json:"planIDContainsFold,omitempty"`
	// feature_id field predicates
	FeatureID             *string  `json:"featureID,omitempty"`
	FeatureIdneq          *string  `json:"featureIDNEQ,omitempty"`
	FeatureIDIn           []string `json:"featureIDIn,omitempty"`
	FeatureIDNotIn        []string `json:"featureIDNotIn,omitempty"`
	FeatureIdgt           *string  `json:"featureIDGT,omitempty"`
	FeatureIdgte          *string  `json:"featureIDGTE,omitempty"`
	FeatureIdlt           *string  `json:"featureIDLT,omitempty"`
	FeatureIdlte          *string  `json:"featureIDLTE,omitempty"`
	FeatureIDContains     *string  `json:"featureIDContains,omitempty"`
	FeatureIDHasPrefix    *string  `json:"featureIDHasPrefix,omitempty"`
	FeatureIDHasSuffix    *string  `json:"featureIDHasSuffix,omitempty"`
	FeatureIDEqualFold    *string  `json:"featureIDEqualFold,omitempty"`
	FeatureIDContainsFold *string  `json:"featureIDContainsFold,omitempty"`
}

type EntitlementPlanFeatureSearchResult struct {
	EntitlementPlanFeatures []*EntitlementPlanFeature `json:"entitlementPlanFeatures,omitempty"`
}

func (EntitlementPlanFeatureSearchResult) IsSearchResult() {}

// Return response for updateEntitlementPlanFeature mutation
type EntitlementPlanFeatureUpdatePayload struct {
	// Updated entitlementPlanFeature
	EntitlementPlanFeature *EntitlementPlanFeature `json:"entitlementPlanFeature"`
}

// EntitlementPlanFeatureWhereInput is used for filtering EntitlementPlanFeature objects.
// Input was generated by ent.
type EntitlementPlanFeatureWhereInput struct {
	Not *EntitlementPlanFeatureWhereInput   `json:"not,omitempty"`
	And []*EntitlementPlanFeatureWhereInput `json:"and,omitempty"`
	Or  []*EntitlementPlanFeatureWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
}

type EntitlementPlanHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the displayed 'friendly' name of the plan
	DisplayName *string `json:"displayName,omitempty"`
	// the unique name of the plan
	Name string `json:"name"`
	// a description of the plan
	Description *string `json:"description,omitempty"`
	// the version of the plan
	Version string `json:"version"`
	// metadata for the plan
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

func (EntitlementPlanHistory) IsNode() {}

// A connection to a list of items.
type EntitlementPlanHistoryConnection struct {
	// A list of edges.
	Edges []*EntitlementPlanHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntitlementPlanHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntitlementPlanHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// EntitlementPlanHistoryWhereInput is used for filtering EntitlementPlanHistory objects.
// Input was generated by ent.
type EntitlementPlanHistoryWhereInput struct {
	Not *EntitlementPlanHistoryWhereInput   `json:"not,omitempty"`
	And []*EntitlementPlanHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntitlementPlanHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
}

type EntitlementPlanSearchResult struct {
	EntitlementPlans []*EntitlementPlan `json:"entitlementPlans,omitempty"`
}

func (EntitlementPlanSearchResult) IsSearchResult() {}

// Return response for updateEntitlementPlan mutation
type EntitlementPlanUpdatePayload struct {
	// Updated entitlementPlan
	EntitlementPlan *EntitlementPlan `json:"entitlementPlan"`
}

// EntitlementPlanWhereInput is used for filtering EntitlementPlan objects.
// Input was generated by ent.
type EntitlementPlanWhereInput struct {
	Not *EntitlementPlanWhereInput   `json:"not,omitempty"`
	And []*EntitlementPlanWhereInput `json:"and,omitempty"`
	Or  []*EntitlementPlanWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// entitlements edge predicates
	HasEntitlements     *bool                    `json:"hasEntitlements,omitempty"`
	HasEntitlementsWith []*EntitlementWhereInput `json:"hasEntitlementsWith,omitempty"`
	// base_features edge predicates
	HasBaseFeatures     *bool                `json:"hasBaseFeatures,omitempty"`
	HasBaseFeaturesWith []*FeatureWhereInput `json:"hasBaseFeaturesWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// features edge predicates
	HasFeatures     *bool                               `json:"hasFeatures,omitempty"`
	HasFeaturesWith []*EntitlementPlanFeatureWhereInput `json:"hasFeaturesWith,omitempty"`
}

type EntitlementSearchResult struct {
	Entitlements []*Entitlement `json:"entitlements,omitempty"`
}

func (EntitlementSearchResult) IsSearchResult() {}

// Return response for updateEntitlement mutation
type EntitlementUpdatePayload struct {
	// Updated entitlement
	Entitlement *Entitlement `json:"entitlement"`
}

// EntitlementWhereInput is used for filtering Entitlement objects.
// Input was generated by ent.
type EntitlementWhereInput struct {
	Not *EntitlementWhereInput   `json:"not,omitempty"`
	And []*EntitlementWhereInput `json:"and,omitempty"`
	Or  []*EntitlementWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// plan_id field predicates
	PlanID             *string  `json:"planID,omitempty"`
	PlanIdneq          *string  `json:"planIDNEQ,omitempty"`
	PlanIDIn           []string `json:"planIDIn,omitempty"`
	PlanIDNotIn        []string `json:"planIDNotIn,omitempty"`
	PlanIdgt           *string  `json:"planIDGT,omitempty"`
	PlanIdgte          *string  `json:"planIDGTE,omitempty"`
	PlanIdlt           *string  `json:"planIDLT,omitempty"`
	PlanIdlte          *string  `json:"planIDLTE,omitempty"`
	PlanIDContains     *string  `json:"planIDContains,omitempty"`
	PlanIDHasPrefix    *string  `json:"planIDHasPrefix,omitempty"`
	PlanIDHasSuffix    *string  `json:"planIDHasSuffix,omitempty"`
	PlanIDEqualFold    *string  `json:"planIDEqualFold,omitempty"`
	PlanIDContainsFold *string  `json:"planIDContainsFold,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// external_customer_id field predicates
	ExternalCustomerID             *string  `json:"externalCustomerID,omitempty"`
	ExternalCustomerIdneq          *string  `json:"externalCustomerIDNEQ,omitempty"`
	ExternalCustomerIDIn           []string `json:"externalCustomerIDIn,omitempty"`
	ExternalCustomerIDNotIn        []string `json:"externalCustomerIDNotIn,omitempty"`
	ExternalCustomerIdgt           *string  `json:"externalCustomerIDGT,omitempty"`
	ExternalCustomerIdgte          *string  `json:"externalCustomerIDGTE,omitempty"`
	ExternalCustomerIdlt           *string  `json:"externalCustomerIDLT,omitempty"`
	ExternalCustomerIdlte          *string  `json:"externalCustomerIDLTE,omitempty"`
	ExternalCustomerIDContains     *string  `json:"externalCustomerIDContains,omitempty"`
	ExternalCustomerIDHasPrefix    *string  `json:"externalCustomerIDHasPrefix,omitempty"`
	ExternalCustomerIDHasSuffix    *string  `json:"externalCustomerIDHasSuffix,omitempty"`
	ExternalCustomerIDIsNil        *bool    `json:"externalCustomerIDIsNil,omitempty"`
	ExternalCustomerIDNotNil       *bool    `json:"externalCustomerIDNotNil,omitempty"`
	ExternalCustomerIDEqualFold    *string  `json:"externalCustomerIDEqualFold,omitempty"`
	ExternalCustomerIDContainsFold *string  `json:"externalCustomerIDContainsFold,omitempty"`
	// external_subscription_id field predicates
	ExternalSubscriptionID             *string  `json:"externalSubscriptionID,omitempty"`
	ExternalSubscriptionIdneq          *string  `json:"externalSubscriptionIDNEQ,omitempty"`
	ExternalSubscriptionIDIn           []string `json:"externalSubscriptionIDIn,omitempty"`
	ExternalSubscriptionIDNotIn        []string `json:"externalSubscriptionIDNotIn,omitempty"`
	ExternalSubscriptionIdgt           *string  `json:"externalSubscriptionIDGT,omitempty"`
	ExternalSubscriptionIdgte          *string  `json:"externalSubscriptionIDGTE,omitempty"`
	ExternalSubscriptionIdlt           *string  `json:"externalSubscriptionIDLT,omitempty"`
	ExternalSubscriptionIdlte          *string  `json:"externalSubscriptionIDLTE,omitempty"`
	ExternalSubscriptionIDContains     *string  `json:"externalSubscriptionIDContains,omitempty"`
	ExternalSubscriptionIDHasPrefix    *string  `json:"externalSubscriptionIDHasPrefix,omitempty"`
	ExternalSubscriptionIDHasSuffix    *string  `json:"externalSubscriptionIDHasSuffix,omitempty"`
	ExternalSubscriptionIDIsNil        *bool    `json:"externalSubscriptionIDIsNil,omitempty"`
	ExternalSubscriptionIDNotNil       *bool    `json:"externalSubscriptionIDNotNil,omitempty"`
	ExternalSubscriptionIDEqualFold    *string  `json:"externalSubscriptionIDEqualFold,omitempty"`
	ExternalSubscriptionIDContainsFold *string  `json:"externalSubscriptionIDContainsFold,omitempty"`
	// expires field predicates
	Expires    *bool `json:"expires,omitempty"`
	ExpiresNeq *bool `json:"expiresNEQ,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// cancelled field predicates
	Cancelled    *bool `json:"cancelled,omitempty"`
	CancelledNeq *bool `json:"cancelledNEQ,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// plan edge predicates
	HasPlan     *bool                        `json:"hasPlan,omitempty"`
	HasPlanWith []*EntitlementPlanWhereInput `json:"hasPlanWith,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Entity struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name *string `json:"name,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the entity
	Description *string `json:"description,omitempty"`
	// domains associated with the entity
	Domains []string `json:"domains,omitempty"`
	// The type of the entity
	EntityTypeID *string `json:"entityTypeID,omitempty"`
	// status of the entity
	Status     *string         `json:"status,omitempty"`
	Owner      *Organization   `json:"owner,omitempty"`
	Contacts   []*Contact      `json:"contacts,omitempty"`
	Documents  []*DocumentData `json:"documents,omitempty"`
	Notes      []*Note         `json:"notes,omitempty"`
	Files      []*File         `json:"files,omitempty"`
	EntityType *EntityType     `json:"entityType,omitempty"`
}

func (Entity) IsNode() {}

// Return response for createBulkEntity mutation
type EntityBulkCreatePayload struct {
	// Created entities
	Entities []*Entity `json:"entities,omitempty"`
}

// A connection to a list of items.
type EntityConnection struct {
	// A list of edges.
	Edges []*EntityEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntity mutation
type EntityCreatePayload struct {
	// Created entity
	Entity *Entity `json:"entity"`
}

// Return response for deleteEntity mutation
type EntityDeletePayload struct {
	// Deleted entity ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntityEdge struct {
	// The item at the end of the edge.
	Node *Entity `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntityHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name *string `json:"name,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the entity
	Description *string `json:"description,omitempty"`
	// domains associated with the entity
	Domains []string `json:"domains,omitempty"`
	// The type of the entity
	EntityTypeID *string `json:"entityTypeID,omitempty"`
	// status of the entity
	Status *string `json:"status,omitempty"`
}

func (EntityHistory) IsNode() {}

// A connection to a list of items.
type EntityHistoryConnection struct {
	// A list of edges.
	Edges []*EntityHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntityHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntityHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for EntityHistory connections
type EntityHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EntityHistories.
	Field EntityHistoryOrderField `json:"field"`
}

// EntityHistoryWhereInput is used for filtering EntityHistory objects.
// Input was generated by ent.
type EntityHistoryWhereInput struct {
	Not *EntityHistoryWhereInput   `json:"not,omitempty"`
	And []*EntityHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntityHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        *bool    `json:"nameIsNil,omitempty"`
	NameNotNil       *bool    `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// entity_type_id field predicates
	EntityTypeID             *string  `json:"entityTypeID,omitempty"`
	EntityTypeIdneq          *string  `json:"entityTypeIDNEQ,omitempty"`
	EntityTypeIDIn           []string `json:"entityTypeIDIn,omitempty"`
	EntityTypeIDNotIn        []string `json:"entityTypeIDNotIn,omitempty"`
	EntityTypeIdgt           *string  `json:"entityTypeIDGT,omitempty"`
	EntityTypeIdgte          *string  `json:"entityTypeIDGTE,omitempty"`
	EntityTypeIdlt           *string  `json:"entityTypeIDLT,omitempty"`
	EntityTypeIdlte          *string  `json:"entityTypeIDLTE,omitempty"`
	EntityTypeIDContains     *string  `json:"entityTypeIDContains,omitempty"`
	EntityTypeIDHasPrefix    *string  `json:"entityTypeIDHasPrefix,omitempty"`
	EntityTypeIDHasSuffix    *string  `json:"entityTypeIDHasSuffix,omitempty"`
	EntityTypeIDIsNil        *bool    `json:"entityTypeIDIsNil,omitempty"`
	EntityTypeIDNotNil       *bool    `json:"entityTypeIDNotNil,omitempty"`
	EntityTypeIDEqualFold    *string  `json:"entityTypeIDEqualFold,omitempty"`
	EntityTypeIDContainsFold *string  `json:"entityTypeIDContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
}

// Ordering options for Entity connections
type EntityOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Entities.
	Field EntityOrderField `json:"field"`
}

type EntitySearchResult struct {
	Entities []*Entity `json:"entities,omitempty"`
}

func (EntitySearchResult) IsSearchResult() {}

type EntityType struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name     string        `json:"name"`
	Owner    *Organization `json:"owner,omitempty"`
	Entities []*Entity     `json:"entities,omitempty"`
}

func (EntityType) IsNode() {}

// Return response for createBulkEntityType mutation
type EntityTypeBulkCreatePayload struct {
	// Created entityTypes
	EntityTypes []*EntityType `json:"entityTypes,omitempty"`
}

// A connection to a list of items.
type EntityTypeConnection struct {
	// A list of edges.
	Edges []*EntityTypeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntityType mutation
type EntityTypeCreatePayload struct {
	// Created entityType
	EntityType *EntityType `json:"entityType"`
}

// Return response for deleteEntityType mutation
type EntityTypeDeletePayload struct {
	// Deleted entityType ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntityTypeEdge struct {
	// The item at the end of the edge.
	Node *EntityType `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntityTypeHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name string `json:"name"`
}

func (EntityTypeHistory) IsNode() {}

// A connection to a list of items.
type EntityTypeHistoryConnection struct {
	// A list of edges.
	Edges []*EntityTypeHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntityTypeHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntityTypeHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for EntityTypeHistory connections
type EntityTypeHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EntityTypeHistories.
	Field EntityTypeHistoryOrderField `json:"field"`
}

// EntityTypeHistoryWhereInput is used for filtering EntityTypeHistory objects.
// Input was generated by ent.
type EntityTypeHistoryWhereInput struct {
	Not *EntityTypeHistoryWhereInput   `json:"not,omitempty"`
	And []*EntityTypeHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntityTypeHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// Ordering options for EntityType connections
type EntityTypeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EntityTypes.
	Field EntityTypeOrderField `json:"field"`
}

type EntityTypeSearchResult struct {
	EntityTypes []*EntityType `json:"entityTypes,omitempty"`
}

func (EntityTypeSearchResult) IsSearchResult() {}

// Return response for updateEntityType mutation
type EntityTypeUpdatePayload struct {
	// Updated entityType
	EntityType *EntityType `json:"entityType"`
}

// EntityTypeWhereInput is used for filtering EntityType objects.
// Input was generated by ent.
type EntityTypeWhereInput struct {
	Not *EntityTypeWhereInput   `json:"not,omitempty"`
	And []*EntityTypeWhereInput `json:"and,omitempty"`
	Or  []*EntityTypeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
}

// Return response for updateEntity mutation
type EntityUpdatePayload struct {
	// Updated entity
	Entity *Entity `json:"entity"`
}

// EntityWhereInput is used for filtering Entity objects.
// Input was generated by ent.
type EntityWhereInput struct {
	Not *EntityWhereInput   `json:"not,omitempty"`
	And []*EntityWhereInput `json:"and,omitempty"`
	Or  []*EntityWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        *bool    `json:"nameIsNil,omitempty"`
	NameNotNil       *bool    `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// entity_type_id field predicates
	EntityTypeID             *string  `json:"entityTypeID,omitempty"`
	EntityTypeIdneq          *string  `json:"entityTypeIDNEQ,omitempty"`
	EntityTypeIDIn           []string `json:"entityTypeIDIn,omitempty"`
	EntityTypeIDNotIn        []string `json:"entityTypeIDNotIn,omitempty"`
	EntityTypeIdgt           *string  `json:"entityTypeIDGT,omitempty"`
	EntityTypeIdgte          *string  `json:"entityTypeIDGTE,omitempty"`
	EntityTypeIdlt           *string  `json:"entityTypeIDLT,omitempty"`
	EntityTypeIdlte          *string  `json:"entityTypeIDLTE,omitempty"`
	EntityTypeIDContains     *string  `json:"entityTypeIDContains,omitempty"`
	EntityTypeIDHasPrefix    *string  `json:"entityTypeIDHasPrefix,omitempty"`
	EntityTypeIDHasSuffix    *string  `json:"entityTypeIDHasSuffix,omitempty"`
	EntityTypeIDIsNil        *bool    `json:"entityTypeIDIsNil,omitempty"`
	EntityTypeIDNotNil       *bool    `json:"entityTypeIDNotNil,omitempty"`
	EntityTypeIDEqualFold    *string  `json:"entityTypeIDEqualFold,omitempty"`
	EntityTypeIDContainsFold *string  `json:"entityTypeIDContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// contacts edge predicates
	HasContacts     *bool                `json:"hasContacts,omitempty"`
	HasContactsWith []*ContactWhereInput `json:"hasContactsWith,omitempty"`
	// documents edge predicates
	HasDocuments     *bool                     `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentDataWhereInput `json:"hasDocumentsWith,omitempty"`
	// notes edge predicates
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// entity_type edge predicates
	HasEntityType     *bool                   `json:"hasEntityType,omitempty"`
	HasEntityTypeWith []*EntityTypeWhereInput `json:"hasEntityTypeWith,omitempty"`
}

type Event struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags                   []string                  `json:"tags,omitempty"`
	EventID                *string                   `json:"eventID,omitempty"`
	CorrelationID          *string                   `json:"correlationID,omitempty"`
	EventType              string                    `json:"eventType"`
	Metadata               map[string]interface{}    `json:"metadata,omitempty"`
	User                   []*User                   `json:"user,omitempty"`
	Group                  []*Group                  `json:"group,omitempty"`
	Integration            []*Integration            `json:"integration,omitempty"`
	Organization           []*Organization           `json:"organization,omitempty"`
	Invite                 []*Invite                 `json:"invite,omitempty"`
	Feature                []*Feature                `json:"feature,omitempty"`
	Entitlementplan        []*EntitlementPlan        `json:"entitlementplan,omitempty"`
	Entitlementplanfeature []*EntitlementPlanFeature `json:"entitlementplanfeature,omitempty"`
	PersonalAccessToken    []*PersonalAccessToken    `json:"personalAccessToken,omitempty"`
	Oauth2token            []*OhAuthTooToken         `json:"oauth2token,omitempty"`
	Hush                   []*Hush                   `json:"hush,omitempty"`
	Orgmembership          []*OrgMembership          `json:"orgmembership,omitempty"`
	Groupmembership        []*GroupMembership        `json:"groupmembership,omitempty"`
	Entitlement            []*Entitlement            `json:"entitlement,omitempty"`
	Webhook                []*Webhook                `json:"webhook,omitempty"`
	Subscriber             []*Subscriber             `json:"subscriber,omitempty"`
	File                   []*File                   `json:"file,omitempty"`
}

func (Event) IsNode() {}

// Return response for createBulkEvent mutation
type EventBulkCreatePayload struct {
	// Created events
	Events []*Event `json:"events,omitempty"`
}

// A connection to a list of items.
type EventConnection struct {
	// A list of edges.
	Edges []*EventEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEvent mutation
type EventCreatePayload struct {
	// Created event
	Event *Event `json:"event"`
}

// Return response for deleteEvent mutation
type EventDeletePayload struct {
	// Deleted event ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EventEdge struct {
	// The item at the end of the edge.
	Node *Event `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EventHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags          []string               `json:"tags,omitempty"`
	EventID       *string                `json:"eventID,omitempty"`
	CorrelationID *string                `json:"correlationID,omitempty"`
	EventType     string                 `json:"eventType"`
	Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

func (EventHistory) IsNode() {}

// A connection to a list of items.
type EventHistoryConnection struct {
	// A list of edges.
	Edges []*EventHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EventHistoryEdge struct {
	// The item at the end of the edge.
	Node *EventHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// EventHistoryWhereInput is used for filtering EventHistory objects.
// Input was generated by ent.
type EventHistoryWhereInput struct {
	Not *EventHistoryWhereInput   `json:"not,omitempty"`
	And []*EventHistoryWhereInput `json:"and,omitempty"`
	Or  []*EventHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// event_id field predicates
	EventID             *string  `json:"eventID,omitempty"`
	EventIdneq          *string  `json:"eventIDNEQ,omitempty"`
	EventIDIn           []string `json:"eventIDIn,omitempty"`
	EventIDNotIn        []string `json:"eventIDNotIn,omitempty"`
	EventIdgt           *string  `json:"eventIDGT,omitempty"`
	EventIdgte          *string  `json:"eventIDGTE,omitempty"`
	EventIdlt           *string  `json:"eventIDLT,omitempty"`
	EventIdlte          *string  `json:"eventIDLTE,omitempty"`
	EventIDContains     *string  `json:"eventIDContains,omitempty"`
	EventIDHasPrefix    *string  `json:"eventIDHasPrefix,omitempty"`
	EventIDHasSuffix    *string  `json:"eventIDHasSuffix,omitempty"`
	EventIDIsNil        *bool    `json:"eventIDIsNil,omitempty"`
	EventIDNotNil       *bool    `json:"eventIDNotNil,omitempty"`
	EventIDEqualFold    *string  `json:"eventIDEqualFold,omitempty"`
	EventIDContainsFold *string  `json:"eventIDContainsFold,omitempty"`
	// correlation_id field predicates
	CorrelationID             *string  `json:"correlationID,omitempty"`
	CorrelationIdneq          *string  `json:"correlationIDNEQ,omitempty"`
	CorrelationIDIn           []string `json:"correlationIDIn,omitempty"`
	CorrelationIDNotIn        []string `json:"correlationIDNotIn,omitempty"`
	CorrelationIdgt           *string  `json:"correlationIDGT,omitempty"`
	CorrelationIdgte          *string  `json:"correlationIDGTE,omitempty"`
	CorrelationIdlt           *string  `json:"correlationIDLT,omitempty"`
	CorrelationIdlte          *string  `json:"correlationIDLTE,omitempty"`
	CorrelationIDContains     *string  `json:"correlationIDContains,omitempty"`
	CorrelationIDHasPrefix    *string  `json:"correlationIDHasPrefix,omitempty"`
	CorrelationIDHasSuffix    *string  `json:"correlationIDHasSuffix,omitempty"`
	CorrelationIDIsNil        *bool    `json:"correlationIDIsNil,omitempty"`
	CorrelationIDNotNil       *bool    `json:"correlationIDNotNil,omitempty"`
	CorrelationIDEqualFold    *string  `json:"correlationIDEqualFold,omitempty"`
	CorrelationIDContainsFold *string  `json:"correlationIDContainsFold,omitempty"`
	// event_type field predicates
	EventType             *string  `json:"eventType,omitempty"`
	EventTypeNeq          *string  `json:"eventTypeNEQ,omitempty"`
	EventTypeIn           []string `json:"eventTypeIn,omitempty"`
	EventTypeNotIn        []string `json:"eventTypeNotIn,omitempty"`
	EventTypeGt           *string  `json:"eventTypeGT,omitempty"`
	EventTypeGte          *string  `json:"eventTypeGTE,omitempty"`
	EventTypeLt           *string  `json:"eventTypeLT,omitempty"`
	EventTypeLte          *string  `json:"eventTypeLTE,omitempty"`
	EventTypeContains     *string  `json:"eventTypeContains,omitempty"`
	EventTypeHasPrefix    *string  `json:"eventTypeHasPrefix,omitempty"`
	EventTypeHasSuffix    *string  `json:"eventTypeHasSuffix,omitempty"`
	EventTypeEqualFold    *string  `json:"eventTypeEqualFold,omitempty"`
	EventTypeContainsFold *string  `json:"eventTypeContainsFold,omitempty"`
}

type EventSearchResult struct {
	Events []*Event `json:"events,omitempty"`
}

func (EventSearchResult) IsSearchResult() {}

// Return response for updateEvent mutation
type EventUpdatePayload struct {
	// Updated event
	Event *Event `json:"event"`
}

// EventWhereInput is used for filtering Event objects.
// Input was generated by ent.
type EventWhereInput struct {
	Not *EventWhereInput   `json:"not,omitempty"`
	And []*EventWhereInput `json:"and,omitempty"`
	Or  []*EventWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// event_id field predicates
	EventID             *string  `json:"eventID,omitempty"`
	EventIdneq          *string  `json:"eventIDNEQ,omitempty"`
	EventIDIn           []string `json:"eventIDIn,omitempty"`
	EventIDNotIn        []string `json:"eventIDNotIn,omitempty"`
	EventIdgt           *string  `json:"eventIDGT,omitempty"`
	EventIdgte          *string  `json:"eventIDGTE,omitempty"`
	EventIdlt           *string  `json:"eventIDLT,omitempty"`
	EventIdlte          *string  `json:"eventIDLTE,omitempty"`
	EventIDContains     *string  `json:"eventIDContains,omitempty"`
	EventIDHasPrefix    *string  `json:"eventIDHasPrefix,omitempty"`
	EventIDHasSuffix    *string  `json:"eventIDHasSuffix,omitempty"`
	EventIDIsNil        *bool    `json:"eventIDIsNil,omitempty"`
	EventIDNotNil       *bool    `json:"eventIDNotNil,omitempty"`
	EventIDEqualFold    *string  `json:"eventIDEqualFold,omitempty"`
	EventIDContainsFold *string  `json:"eventIDContainsFold,omitempty"`
	// correlation_id field predicates
	CorrelationID             *string  `json:"correlationID,omitempty"`
	CorrelationIdneq          *string  `json:"correlationIDNEQ,omitempty"`
	CorrelationIDIn           []string `json:"correlationIDIn,omitempty"`
	CorrelationIDNotIn        []string `json:"correlationIDNotIn,omitempty"`
	CorrelationIdgt           *string  `json:"correlationIDGT,omitempty"`
	CorrelationIdgte          *string  `json:"correlationIDGTE,omitempty"`
	CorrelationIdlt           *string  `json:"correlationIDLT,omitempty"`
	CorrelationIdlte          *string  `json:"correlationIDLTE,omitempty"`
	CorrelationIDContains     *string  `json:"correlationIDContains,omitempty"`
	CorrelationIDHasPrefix    *string  `json:"correlationIDHasPrefix,omitempty"`
	CorrelationIDHasSuffix    *string  `json:"correlationIDHasSuffix,omitempty"`
	CorrelationIDIsNil        *bool    `json:"correlationIDIsNil,omitempty"`
	CorrelationIDNotNil       *bool    `json:"correlationIDNotNil,omitempty"`
	CorrelationIDEqualFold    *string  `json:"correlationIDEqualFold,omitempty"`
	CorrelationIDContainsFold *string  `json:"correlationIDContainsFold,omitempty"`
	// event_type field predicates
	EventType             *string  `json:"eventType,omitempty"`
	EventTypeNeq          *string  `json:"eventTypeNEQ,omitempty"`
	EventTypeIn           []string `json:"eventTypeIn,omitempty"`
	EventTypeNotIn        []string `json:"eventTypeNotIn,omitempty"`
	EventTypeGt           *string  `json:"eventTypeGT,omitempty"`
	EventTypeGte          *string  `json:"eventTypeGTE,omitempty"`
	EventTypeLt           *string  `json:"eventTypeLT,omitempty"`
	EventTypeLte          *string  `json:"eventTypeLTE,omitempty"`
	EventTypeContains     *string  `json:"eventTypeContains,omitempty"`
	EventTypeHasPrefix    *string  `json:"eventTypeHasPrefix,omitempty"`
	EventTypeHasSuffix    *string  `json:"eventTypeHasSuffix,omitempty"`
	EventTypeEqualFold    *string  `json:"eventTypeEqualFold,omitempty"`
	EventTypeContainsFold *string  `json:"eventTypeContainsFold,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
	// integration edge predicates
	HasIntegration     *bool                    `json:"hasIntegration,omitempty"`
	HasIntegrationWith []*IntegrationWhereInput `json:"hasIntegrationWith,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// invite edge predicates
	HasInvite     *bool               `json:"hasInvite,omitempty"`
	HasInviteWith []*InviteWhereInput `json:"hasInviteWith,omitempty"`
	// feature edge predicates
	HasFeature     *bool                `json:"hasFeature,omitempty"`
	HasFeatureWith []*FeatureWhereInput `json:"hasFeatureWith,omitempty"`
	// entitlementplan edge predicates
	HasEntitlementplan     *bool                        `json:"hasEntitlementplan,omitempty"`
	HasEntitlementplanWith []*EntitlementPlanWhereInput `json:"hasEntitlementplanWith,omitempty"`
	// entitlementplanfeature edge predicates
	HasEntitlementplanfeature     *bool                               `json:"hasEntitlementplanfeature,omitempty"`
	HasEntitlementplanfeatureWith []*EntitlementPlanFeatureWhereInput `json:"hasEntitlementplanfeatureWith,omitempty"`
	// personal_access_token edge predicates
	HasPersonalAccessToken     *bool                            `json:"hasPersonalAccessToken,omitempty"`
	HasPersonalAccessTokenWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokenWith,omitempty"`
	// oauth2token edge predicates
	HasOauth2token     *bool                       `json:"hasOauth2token,omitempty"`
	HasOauth2tokenWith []*OhAuthTooTokenWhereInput `json:"hasOauth2tokenWith,omitempty"`
	// hush edge predicates
	HasHush     *bool             `json:"hasHush,omitempty"`
	HasHushWith []*HushWhereInput `json:"hasHushWith,omitempty"`
	// orgmembership edge predicates
	HasOrgmembership     *bool                      `json:"hasOrgmembership,omitempty"`
	HasOrgmembershipWith []*OrgMembershipWhereInput `json:"hasOrgmembershipWith,omitempty"`
	// groupmembership edge predicates
	HasGroupmembership     *bool                        `json:"hasGroupmembership,omitempty"`
	HasGroupmembershipWith []*GroupMembershipWhereInput `json:"hasGroupmembershipWith,omitempty"`
	// entitlement edge predicates
	HasEntitlement     *bool                    `json:"hasEntitlement,omitempty"`
	HasEntitlementWith []*EntitlementWhereInput `json:"hasEntitlementWith,omitempty"`
	// webhook edge predicates
	HasWebhook     *bool                `json:"hasWebhook,omitempty"`
	HasWebhookWith []*WebhookWhereInput `json:"hasWebhookWith,omitempty"`
	// subscriber edge predicates
	HasSubscriber     *bool                   `json:"hasSubscriber,omitempty"`
	HasSubscriberWith []*SubscriberWhereInput `json:"hasSubscriberWith,omitempty"`
	// file edge predicates
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`
}

type Feature struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the unique name of the feature
	Name string `json:"name"`
	// the displayed 'friendly' name of the feature
	DisplayName *string `json:"displayName,omitempty"`
	// enabled features are available for use
	Enabled bool `json:"enabled"`
	// a description of the feature
	Description *string `json:"description,omitempty"`
	// metadata for the feature
	Metadata map[string]interface{}    `json:"metadata,omitempty"`
	Owner    *Organization             `json:"owner,omitempty"`
	Plans    []*EntitlementPlan        `json:"plans,omitempty"`
	Events   []*Event                  `json:"events,omitempty"`
	Features []*EntitlementPlanFeature `json:"features,omitempty"`
}

func (Feature) IsNode() {}

// Return response for createBulkFeature mutation
type FeatureBulkCreatePayload struct {
	// Created features
	Features []*Feature `json:"features,omitempty"`
}

// A connection to a list of items.
type FeatureConnection struct {
	// A list of edges.
	Edges []*FeatureEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createFeature mutation
type FeatureCreatePayload struct {
	// Created feature
	Feature *Feature `json:"feature"`
}

// Return response for deleteFeature mutation
type FeatureDeletePayload struct {
	// Deleted feature ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type FeatureEdge struct {
	// The item at the end of the edge.
	Node *Feature `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type FeatureHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the unique name of the feature
	Name string `json:"name"`
	// the displayed 'friendly' name of the feature
	DisplayName *string `json:"displayName,omitempty"`
	// enabled features are available for use
	Enabled bool `json:"enabled"`
	// a description of the feature
	Description *string `json:"description,omitempty"`
	// metadata for the feature
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

func (FeatureHistory) IsNode() {}

// A connection to a list of items.
type FeatureHistoryConnection struct {
	// A list of edges.
	Edges []*FeatureHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type FeatureHistoryEdge struct {
	// The item at the end of the edge.
	Node *FeatureHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// FeatureHistoryWhereInput is used for filtering FeatureHistory objects.
// Input was generated by ent.
type FeatureHistoryWhereInput struct {
	Not *FeatureHistoryWhereInput   `json:"not,omitempty"`
	And []*FeatureHistoryWhereInput `json:"and,omitempty"`
	Or  []*FeatureHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// enabled field predicates
	Enabled    *bool `json:"enabled,omitempty"`
	EnabledNeq *bool `json:"enabledNEQ,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
}

type FeatureSearchResult struct {
	Features []*Feature `json:"features,omitempty"`
}

func (FeatureSearchResult) IsSearchResult() {}

// Return response for updateFeature mutation
type FeatureUpdatePayload struct {
	// Updated feature
	Feature *Feature `json:"feature"`
}

// FeatureWhereInput is used for filtering Feature objects.
// Input was generated by ent.
type FeatureWhereInput struct {
	Not *FeatureWhereInput   `json:"not,omitempty"`
	And []*FeatureWhereInput `json:"and,omitempty"`
	Or  []*FeatureWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// enabled field predicates
	Enabled    *bool `json:"enabled,omitempty"`
	EnabledNeq *bool `json:"enabledNEQ,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// plans edge predicates
	HasPlans     *bool                        `json:"hasPlans,omitempty"`
	HasPlansWith []*EntitlementPlanWhereInput `json:"hasPlansWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// features edge predicates
	HasFeatures     *bool                               `json:"hasFeatures,omitempty"`
	HasFeaturesWith []*EntitlementPlanFeatureWhereInput `json:"hasFeaturesWith,omitempty"`
}

type File struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName string `json:"providedFileName"`
	// the extension of the file provided
	ProvidedFileExtension string `json:"providedFileExtension"`
	// the computed size of the file in the original http request
	ProvidedFileSize  *int64 `json:"providedFileSize,omitempty"`
	PersistedFileSize *int64 `json:"persistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType *string `json:"detectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash *string `json:"md5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType string `json:"detectedContentType"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey *string `json:"storeKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType *string `json:"categoryType,omitempty"`
	// the full URI of the file
	URI *string `json:"uri,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme *string `json:"storageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume *string `json:"storageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath         *string                `json:"storagePath,omitempty"`
	User                []*User                `json:"user,omitempty"`
	Organization        []*Organization        `json:"organization,omitempty"`
	Group               []*Group               `json:"group,omitempty"`
	Contact             []*Contact             `json:"contact,omitempty"`
	Entity              []*Entity              `json:"entity,omitempty"`
	Usersetting         []*UserSetting         `json:"usersetting,omitempty"`
	Organizationsetting []*OrganizationSetting `json:"organizationsetting,omitempty"`
	Template            []*Template            `json:"template,omitempty"`
	Documentdata        []*DocumentData        `json:"documentdata,omitempty"`
	Events              []*Event               `json:"events,omitempty"`
	Program             []*Program             `json:"program,omitempty"`
}

func (File) IsNode() {}

// A connection to a list of items.
type FileConnection struct {
	// A list of edges.
	Edges []*FileEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for deleteFile mutation
type FileDeletePayload struct {
	// Deleted file ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type FileEdge struct {
	// The item at the end of the edge.
	Node *File `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type FileHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName string `json:"providedFileName"`
	// the extension of the file provided
	ProvidedFileExtension string `json:"providedFileExtension"`
	// the computed size of the file in the original http request
	ProvidedFileSize  *int64 `json:"providedFileSize,omitempty"`
	PersistedFileSize *int64 `json:"persistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType *string `json:"detectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash *string `json:"md5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType string `json:"detectedContentType"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey *string `json:"storeKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType *string `json:"categoryType,omitempty"`
	// the full URI of the file
	URI *string `json:"uri,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme *string `json:"storageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume *string `json:"storageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath *string `json:"storagePath,omitempty"`
}

func (FileHistory) IsNode() {}

// A connection to a list of items.
type FileHistoryConnection struct {
	// A list of edges.
	Edges []*FileHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type FileHistoryEdge struct {
	// The item at the end of the edge.
	Node *FileHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// FileHistoryWhereInput is used for filtering FileHistory objects.
// Input was generated by ent.
type FileHistoryWhereInput struct {
	Not *FileHistoryWhereInput   `json:"not,omitempty"`
	And []*FileHistoryWhereInput `json:"and,omitempty"`
	Or  []*FileHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// provided_file_name field predicates
	ProvidedFileName             *string  `json:"providedFileName,omitempty"`
	ProvidedFileNameNeq          *string  `json:"providedFileNameNEQ,omitempty"`
	ProvidedFileNameIn           []string `json:"providedFileNameIn,omitempty"`
	ProvidedFileNameNotIn        []string `json:"providedFileNameNotIn,omitempty"`
	ProvidedFileNameGt           *string  `json:"providedFileNameGT,omitempty"`
	ProvidedFileNameGte          *string  `json:"providedFileNameGTE,omitempty"`
	ProvidedFileNameLt           *string  `json:"providedFileNameLT,omitempty"`
	ProvidedFileNameLte          *string  `json:"providedFileNameLTE,omitempty"`
	ProvidedFileNameContains     *string  `json:"providedFileNameContains,omitempty"`
	ProvidedFileNameHasPrefix    *string  `json:"providedFileNameHasPrefix,omitempty"`
	ProvidedFileNameHasSuffix    *string  `json:"providedFileNameHasSuffix,omitempty"`
	ProvidedFileNameEqualFold    *string  `json:"providedFileNameEqualFold,omitempty"`
	ProvidedFileNameContainsFold *string  `json:"providedFileNameContainsFold,omitempty"`
	// provided_file_extension field predicates
	ProvidedFileExtension             *string  `json:"providedFileExtension,omitempty"`
	ProvidedFileExtensionNeq          *string  `json:"providedFileExtensionNEQ,omitempty"`
	ProvidedFileExtensionIn           []string `json:"providedFileExtensionIn,omitempty"`
	ProvidedFileExtensionNotIn        []string `json:"providedFileExtensionNotIn,omitempty"`
	ProvidedFileExtensionGt           *string  `json:"providedFileExtensionGT,omitempty"`
	ProvidedFileExtensionGte          *string  `json:"providedFileExtensionGTE,omitempty"`
	ProvidedFileExtensionLt           *string  `json:"providedFileExtensionLT,omitempty"`
	ProvidedFileExtensionLte          *string  `json:"providedFileExtensionLTE,omitempty"`
	ProvidedFileExtensionContains     *string  `json:"providedFileExtensionContains,omitempty"`
	ProvidedFileExtensionHasPrefix    *string  `json:"providedFileExtensionHasPrefix,omitempty"`
	ProvidedFileExtensionHasSuffix    *string  `json:"providedFileExtensionHasSuffix,omitempty"`
	ProvidedFileExtensionEqualFold    *string  `json:"providedFileExtensionEqualFold,omitempty"`
	ProvidedFileExtensionContainsFold *string  `json:"providedFileExtensionContainsFold,omitempty"`
	// provided_file_size field predicates
	ProvidedFileSize       *int64  `json:"providedFileSize,omitempty"`
	ProvidedFileSizeNeq    *int64  `json:"providedFileSizeNEQ,omitempty"`
	ProvidedFileSizeIn     []int64 `json:"providedFileSizeIn,omitempty"`
	ProvidedFileSizeNotIn  []int64 `json:"providedFileSizeNotIn,omitempty"`
	ProvidedFileSizeGt     *int64  `json:"providedFileSizeGT,omitempty"`
	ProvidedFileSizeGte    *int64  `json:"providedFileSizeGTE,omitempty"`
	ProvidedFileSizeLt     *int64  `json:"providedFileSizeLT,omitempty"`
	ProvidedFileSizeLte    *int64  `json:"providedFileSizeLTE,omitempty"`
	ProvidedFileSizeIsNil  *bool   `json:"providedFileSizeIsNil,omitempty"`
	ProvidedFileSizeNotNil *bool   `json:"providedFileSizeNotNil,omitempty"`
	// persisted_file_size field predicates
	PersistedFileSize       *int64  `json:"persistedFileSize,omitempty"`
	PersistedFileSizeNeq    *int64  `json:"persistedFileSizeNEQ,omitempty"`
	PersistedFileSizeIn     []int64 `json:"persistedFileSizeIn,omitempty"`
	PersistedFileSizeNotIn  []int64 `json:"persistedFileSizeNotIn,omitempty"`
	PersistedFileSizeGt     *int64  `json:"persistedFileSizeGT,omitempty"`
	PersistedFileSizeGte    *int64  `json:"persistedFileSizeGTE,omitempty"`
	PersistedFileSizeLt     *int64  `json:"persistedFileSizeLT,omitempty"`
	PersistedFileSizeLte    *int64  `json:"persistedFileSizeLTE,omitempty"`
	PersistedFileSizeIsNil  *bool   `json:"persistedFileSizeIsNil,omitempty"`
	PersistedFileSizeNotNil *bool   `json:"persistedFileSizeNotNil,omitempty"`
	// detected_mime_type field predicates
	DetectedMimeType             *string  `json:"detectedMimeType,omitempty"`
	DetectedMimeTypeNeq          *string  `json:"detectedMimeTypeNEQ,omitempty"`
	DetectedMimeTypeIn           []string `json:"detectedMimeTypeIn,omitempty"`
	DetectedMimeTypeNotIn        []string `json:"detectedMimeTypeNotIn,omitempty"`
	DetectedMimeTypeGt           *string  `json:"detectedMimeTypeGT,omitempty"`
	DetectedMimeTypeGte          *string  `json:"detectedMimeTypeGTE,omitempty"`
	DetectedMimeTypeLt           *string  `json:"detectedMimeTypeLT,omitempty"`
	DetectedMimeTypeLte          *string  `json:"detectedMimeTypeLTE,omitempty"`
	DetectedMimeTypeContains     *string  `json:"detectedMimeTypeContains,omitempty"`
	DetectedMimeTypeHasPrefix    *string  `json:"detectedMimeTypeHasPrefix,omitempty"`
	DetectedMimeTypeHasSuffix    *string  `json:"detectedMimeTypeHasSuffix,omitempty"`
	DetectedMimeTypeIsNil        *bool    `json:"detectedMimeTypeIsNil,omitempty"`
	DetectedMimeTypeNotNil       *bool    `json:"detectedMimeTypeNotNil,omitempty"`
	DetectedMimeTypeEqualFold    *string  `json:"detectedMimeTypeEqualFold,omitempty"`
	DetectedMimeTypeContainsFold *string  `json:"detectedMimeTypeContainsFold,omitempty"`
	// md5_hash field predicates
	Md5Hash             *string  `json:"md5Hash,omitempty"`
	Md5HashNeq          *string  `json:"md5HashNEQ,omitempty"`
	Md5HashIn           []string `json:"md5HashIn,omitempty"`
	Md5HashNotIn        []string `json:"md5HashNotIn,omitempty"`
	Md5HashGt           *string  `json:"md5HashGT,omitempty"`
	Md5HashGte          *string  `json:"md5HashGTE,omitempty"`
	Md5HashLt           *string  `json:"md5HashLT,omitempty"`
	Md5HashLte          *string  `json:"md5HashLTE,omitempty"`
	Md5HashContains     *string  `json:"md5HashContains,omitempty"`
	Md5HashHasPrefix    *string  `json:"md5HashHasPrefix,omitempty"`
	Md5HashHasSuffix    *string  `json:"md5HashHasSuffix,omitempty"`
	Md5HashIsNil        *bool    `json:"md5HashIsNil,omitempty"`
	Md5HashNotNil       *bool    `json:"md5HashNotNil,omitempty"`
	Md5HashEqualFold    *string  `json:"md5HashEqualFold,omitempty"`
	Md5HashContainsFold *string  `json:"md5HashContainsFold,omitempty"`
	// detected_content_type field predicates
	DetectedContentType             *string  `json:"detectedContentType,omitempty"`
	DetectedContentTypeNeq          *string  `json:"detectedContentTypeNEQ,omitempty"`
	DetectedContentTypeIn           []string `json:"detectedContentTypeIn,omitempty"`
	DetectedContentTypeNotIn        []string `json:"detectedContentTypeNotIn,omitempty"`
	DetectedContentTypeGt           *string  `json:"detectedContentTypeGT,omitempty"`
	DetectedContentTypeGte          *string  `json:"detectedContentTypeGTE,omitempty"`
	DetectedContentTypeLt           *string  `json:"detectedContentTypeLT,omitempty"`
	DetectedContentTypeLte          *string  `json:"detectedContentTypeLTE,omitempty"`
	DetectedContentTypeContains     *string  `json:"detectedContentTypeContains,omitempty"`
	DetectedContentTypeHasPrefix    *string  `json:"detectedContentTypeHasPrefix,omitempty"`
	DetectedContentTypeHasSuffix    *string  `json:"detectedContentTypeHasSuffix,omitempty"`
	DetectedContentTypeEqualFold    *string  `json:"detectedContentTypeEqualFold,omitempty"`
	DetectedContentTypeContainsFold *string  `json:"detectedContentTypeContainsFold,omitempty"`
	// store_key field predicates
	StoreKey             *string  `json:"storeKey,omitempty"`
	StoreKeyNeq          *string  `json:"storeKeyNEQ,omitempty"`
	StoreKeyIn           []string `json:"storeKeyIn,omitempty"`
	StoreKeyNotIn        []string `json:"storeKeyNotIn,omitempty"`
	StoreKeyGt           *string  `json:"storeKeyGT,omitempty"`
	StoreKeyGte          *string  `json:"storeKeyGTE,omitempty"`
	StoreKeyLt           *string  `json:"storeKeyLT,omitempty"`
	StoreKeyLte          *string  `json:"storeKeyLTE,omitempty"`
	StoreKeyContains     *string  `json:"storeKeyContains,omitempty"`
	StoreKeyHasPrefix    *string  `json:"storeKeyHasPrefix,omitempty"`
	StoreKeyHasSuffix    *string  `json:"storeKeyHasSuffix,omitempty"`
	StoreKeyIsNil        *bool    `json:"storeKeyIsNil,omitempty"`
	StoreKeyNotNil       *bool    `json:"storeKeyNotNil,omitempty"`
	StoreKeyEqualFold    *string  `json:"storeKeyEqualFold,omitempty"`
	StoreKeyContainsFold *string  `json:"storeKeyContainsFold,omitempty"`
	// category_type field predicates
	CategoryType             *string  `json:"categoryType,omitempty"`
	CategoryTypeNeq          *string  `json:"categoryTypeNEQ,omitempty"`
	CategoryTypeIn           []string `json:"categoryTypeIn,omitempty"`
	CategoryTypeNotIn        []string `json:"categoryTypeNotIn,omitempty"`
	CategoryTypeGt           *string  `json:"categoryTypeGT,omitempty"`
	CategoryTypeGte          *string  `json:"categoryTypeGTE,omitempty"`
	CategoryTypeLt           *string  `json:"categoryTypeLT,omitempty"`
	CategoryTypeLte          *string  `json:"categoryTypeLTE,omitempty"`
	CategoryTypeContains     *string  `json:"categoryTypeContains,omitempty"`
	CategoryTypeHasPrefix    *string  `json:"categoryTypeHasPrefix,omitempty"`
	CategoryTypeHasSuffix    *string  `json:"categoryTypeHasSuffix,omitempty"`
	CategoryTypeIsNil        *bool    `json:"categoryTypeIsNil,omitempty"`
	CategoryTypeNotNil       *bool    `json:"categoryTypeNotNil,omitempty"`
	CategoryTypeEqualFold    *string  `json:"categoryTypeEqualFold,omitempty"`
	CategoryTypeContainsFold *string  `json:"categoryTypeContainsFold,omitempty"`
	// uri field predicates
	URI             *string  `json:"uri,omitempty"`
	URINeq          *string  `json:"uriNEQ,omitempty"`
	URIIn           []string `json:"uriIn,omitempty"`
	URINotIn        []string `json:"uriNotIn,omitempty"`
	URIGt           *string  `json:"uriGT,omitempty"`
	URIGte          *string  `json:"uriGTE,omitempty"`
	URILt           *string  `json:"uriLT,omitempty"`
	URILte          *string  `json:"uriLTE,omitempty"`
	URIContains     *string  `json:"uriContains,omitempty"`
	URIHasPrefix    *string  `json:"uriHasPrefix,omitempty"`
	URIHasSuffix    *string  `json:"uriHasSuffix,omitempty"`
	URIIsNil        *bool    `json:"uriIsNil,omitempty"`
	URINotNil       *bool    `json:"uriNotNil,omitempty"`
	URIEqualFold    *string  `json:"uriEqualFold,omitempty"`
	URIContainsFold *string  `json:"uriContainsFold,omitempty"`
	// storage_scheme field predicates
	StorageScheme             *string  `json:"storageScheme,omitempty"`
	StorageSchemeNeq          *string  `json:"storageSchemeNEQ,omitempty"`
	StorageSchemeIn           []string `json:"storageSchemeIn,omitempty"`
	StorageSchemeNotIn        []string `json:"storageSchemeNotIn,omitempty"`
	StorageSchemeGt           *string  `json:"storageSchemeGT,omitempty"`
	StorageSchemeGte          *string  `json:"storageSchemeGTE,omitempty"`
	StorageSchemeLt           *string  `json:"storageSchemeLT,omitempty"`
	StorageSchemeLte          *string  `json:"storageSchemeLTE,omitempty"`
	StorageSchemeContains     *string  `json:"storageSchemeContains,omitempty"`
	StorageSchemeHasPrefix    *string  `json:"storageSchemeHasPrefix,omitempty"`
	StorageSchemeHasSuffix    *string  `json:"storageSchemeHasSuffix,omitempty"`
	StorageSchemeIsNil        *bool    `json:"storageSchemeIsNil,omitempty"`
	StorageSchemeNotNil       *bool    `json:"storageSchemeNotNil,omitempty"`
	StorageSchemeEqualFold    *string  `json:"storageSchemeEqualFold,omitempty"`
	StorageSchemeContainsFold *string  `json:"storageSchemeContainsFold,omitempty"`
	// storage_volume field predicates
	StorageVolume             *string  `json:"storageVolume,omitempty"`
	StorageVolumeNeq          *string  `json:"storageVolumeNEQ,omitempty"`
	StorageVolumeIn           []string `json:"storageVolumeIn,omitempty"`
	StorageVolumeNotIn        []string `json:"storageVolumeNotIn,omitempty"`
	StorageVolumeGt           *string  `json:"storageVolumeGT,omitempty"`
	StorageVolumeGte          *string  `json:"storageVolumeGTE,omitempty"`
	StorageVolumeLt           *string  `json:"storageVolumeLT,omitempty"`
	StorageVolumeLte          *string  `json:"storageVolumeLTE,omitempty"`
	StorageVolumeContains     *string  `json:"storageVolumeContains,omitempty"`
	StorageVolumeHasPrefix    *string  `json:"storageVolumeHasPrefix,omitempty"`
	StorageVolumeHasSuffix    *string  `json:"storageVolumeHasSuffix,omitempty"`
	StorageVolumeIsNil        *bool    `json:"storageVolumeIsNil,omitempty"`
	StorageVolumeNotNil       *bool    `json:"storageVolumeNotNil,omitempty"`
	StorageVolumeEqualFold    *string  `json:"storageVolumeEqualFold,omitempty"`
	StorageVolumeContainsFold *string  `json:"storageVolumeContainsFold,omitempty"`
	// storage_path field predicates
	StoragePath             *string  `json:"storagePath,omitempty"`
	StoragePathNeq          *string  `json:"storagePathNEQ,omitempty"`
	StoragePathIn           []string `json:"storagePathIn,omitempty"`
	StoragePathNotIn        []string `json:"storagePathNotIn,omitempty"`
	StoragePathGt           *string  `json:"storagePathGT,omitempty"`
	StoragePathGte          *string  `json:"storagePathGTE,omitempty"`
	StoragePathLt           *string  `json:"storagePathLT,omitempty"`
	StoragePathLte          *string  `json:"storagePathLTE,omitempty"`
	StoragePathContains     *string  `json:"storagePathContains,omitempty"`
	StoragePathHasPrefix    *string  `json:"storagePathHasPrefix,omitempty"`
	StoragePathHasSuffix    *string  `json:"storagePathHasSuffix,omitempty"`
	StoragePathIsNil        *bool    `json:"storagePathIsNil,omitempty"`
	StoragePathNotNil       *bool    `json:"storagePathNotNil,omitempty"`
	StoragePathEqualFold    *string  `json:"storagePathEqualFold,omitempty"`
	StoragePathContainsFold *string  `json:"storagePathContainsFold,omitempty"`
}

type FileSearchResult struct {
	Files []*File `json:"files,omitempty"`
}

func (FileSearchResult) IsSearchResult() {}

// FileWhereInput is used for filtering File objects.
// Input was generated by ent.
type FileWhereInput struct {
	Not *FileWhereInput   `json:"not,omitempty"`
	And []*FileWhereInput `json:"and,omitempty"`
	Or  []*FileWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// provided_file_name field predicates
	ProvidedFileName             *string  `json:"providedFileName,omitempty"`
	ProvidedFileNameNeq          *string  `json:"providedFileNameNEQ,omitempty"`
	ProvidedFileNameIn           []string `json:"providedFileNameIn,omitempty"`
	ProvidedFileNameNotIn        []string `json:"providedFileNameNotIn,omitempty"`
	ProvidedFileNameGt           *string  `json:"providedFileNameGT,omitempty"`
	ProvidedFileNameGte          *string  `json:"providedFileNameGTE,omitempty"`
	ProvidedFileNameLt           *string  `json:"providedFileNameLT,omitempty"`
	ProvidedFileNameLte          *string  `json:"providedFileNameLTE,omitempty"`
	ProvidedFileNameContains     *string  `json:"providedFileNameContains,omitempty"`
	ProvidedFileNameHasPrefix    *string  `json:"providedFileNameHasPrefix,omitempty"`
	ProvidedFileNameHasSuffix    *string  `json:"providedFileNameHasSuffix,omitempty"`
	ProvidedFileNameEqualFold    *string  `json:"providedFileNameEqualFold,omitempty"`
	ProvidedFileNameContainsFold *string  `json:"providedFileNameContainsFold,omitempty"`
	// provided_file_extension field predicates
	ProvidedFileExtension             *string  `json:"providedFileExtension,omitempty"`
	ProvidedFileExtensionNeq          *string  `json:"providedFileExtensionNEQ,omitempty"`
	ProvidedFileExtensionIn           []string `json:"providedFileExtensionIn,omitempty"`
	ProvidedFileExtensionNotIn        []string `json:"providedFileExtensionNotIn,omitempty"`
	ProvidedFileExtensionGt           *string  `json:"providedFileExtensionGT,omitempty"`
	ProvidedFileExtensionGte          *string  `json:"providedFileExtensionGTE,omitempty"`
	ProvidedFileExtensionLt           *string  `json:"providedFileExtensionLT,omitempty"`
	ProvidedFileExtensionLte          *string  `json:"providedFileExtensionLTE,omitempty"`
	ProvidedFileExtensionContains     *string  `json:"providedFileExtensionContains,omitempty"`
	ProvidedFileExtensionHasPrefix    *string  `json:"providedFileExtensionHasPrefix,omitempty"`
	ProvidedFileExtensionHasSuffix    *string  `json:"providedFileExtensionHasSuffix,omitempty"`
	ProvidedFileExtensionEqualFold    *string  `json:"providedFileExtensionEqualFold,omitempty"`
	ProvidedFileExtensionContainsFold *string  `json:"providedFileExtensionContainsFold,omitempty"`
	// provided_file_size field predicates
	ProvidedFileSize       *int64  `json:"providedFileSize,omitempty"`
	ProvidedFileSizeNeq    *int64  `json:"providedFileSizeNEQ,omitempty"`
	ProvidedFileSizeIn     []int64 `json:"providedFileSizeIn,omitempty"`
	ProvidedFileSizeNotIn  []int64 `json:"providedFileSizeNotIn,omitempty"`
	ProvidedFileSizeGt     *int64  `json:"providedFileSizeGT,omitempty"`
	ProvidedFileSizeGte    *int64  `json:"providedFileSizeGTE,omitempty"`
	ProvidedFileSizeLt     *int64  `json:"providedFileSizeLT,omitempty"`
	ProvidedFileSizeLte    *int64  `json:"providedFileSizeLTE,omitempty"`
	ProvidedFileSizeIsNil  *bool   `json:"providedFileSizeIsNil,omitempty"`
	ProvidedFileSizeNotNil *bool   `json:"providedFileSizeNotNil,omitempty"`
	// persisted_file_size field predicates
	PersistedFileSize       *int64  `json:"persistedFileSize,omitempty"`
	PersistedFileSizeNeq    *int64  `json:"persistedFileSizeNEQ,omitempty"`
	PersistedFileSizeIn     []int64 `json:"persistedFileSizeIn,omitempty"`
	PersistedFileSizeNotIn  []int64 `json:"persistedFileSizeNotIn,omitempty"`
	PersistedFileSizeGt     *int64  `json:"persistedFileSizeGT,omitempty"`
	PersistedFileSizeGte    *int64  `json:"persistedFileSizeGTE,omitempty"`
	PersistedFileSizeLt     *int64  `json:"persistedFileSizeLT,omitempty"`
	PersistedFileSizeLte    *int64  `json:"persistedFileSizeLTE,omitempty"`
	PersistedFileSizeIsNil  *bool   `json:"persistedFileSizeIsNil,omitempty"`
	PersistedFileSizeNotNil *bool   `json:"persistedFileSizeNotNil,omitempty"`
	// detected_mime_type field predicates
	DetectedMimeType             *string  `json:"detectedMimeType,omitempty"`
	DetectedMimeTypeNeq          *string  `json:"detectedMimeTypeNEQ,omitempty"`
	DetectedMimeTypeIn           []string `json:"detectedMimeTypeIn,omitempty"`
	DetectedMimeTypeNotIn        []string `json:"detectedMimeTypeNotIn,omitempty"`
	DetectedMimeTypeGt           *string  `json:"detectedMimeTypeGT,omitempty"`
	DetectedMimeTypeGte          *string  `json:"detectedMimeTypeGTE,omitempty"`
	DetectedMimeTypeLt           *string  `json:"detectedMimeTypeLT,omitempty"`
	DetectedMimeTypeLte          *string  `json:"detectedMimeTypeLTE,omitempty"`
	DetectedMimeTypeContains     *string  `json:"detectedMimeTypeContains,omitempty"`
	DetectedMimeTypeHasPrefix    *string  `json:"detectedMimeTypeHasPrefix,omitempty"`
	DetectedMimeTypeHasSuffix    *string  `json:"detectedMimeTypeHasSuffix,omitempty"`
	DetectedMimeTypeIsNil        *bool    `json:"detectedMimeTypeIsNil,omitempty"`
	DetectedMimeTypeNotNil       *bool    `json:"detectedMimeTypeNotNil,omitempty"`
	DetectedMimeTypeEqualFold    *string  `json:"detectedMimeTypeEqualFold,omitempty"`
	DetectedMimeTypeContainsFold *string  `json:"detectedMimeTypeContainsFold,omitempty"`
	// md5_hash field predicates
	Md5Hash             *string  `json:"md5Hash,omitempty"`
	Md5HashNeq          *string  `json:"md5HashNEQ,omitempty"`
	Md5HashIn           []string `json:"md5HashIn,omitempty"`
	Md5HashNotIn        []string `json:"md5HashNotIn,omitempty"`
	Md5HashGt           *string  `json:"md5HashGT,omitempty"`
	Md5HashGte          *string  `json:"md5HashGTE,omitempty"`
	Md5HashLt           *string  `json:"md5HashLT,omitempty"`
	Md5HashLte          *string  `json:"md5HashLTE,omitempty"`
	Md5HashContains     *string  `json:"md5HashContains,omitempty"`
	Md5HashHasPrefix    *string  `json:"md5HashHasPrefix,omitempty"`
	Md5HashHasSuffix    *string  `json:"md5HashHasSuffix,omitempty"`
	Md5HashIsNil        *bool    `json:"md5HashIsNil,omitempty"`
	Md5HashNotNil       *bool    `json:"md5HashNotNil,omitempty"`
	Md5HashEqualFold    *string  `json:"md5HashEqualFold,omitempty"`
	Md5HashContainsFold *string  `json:"md5HashContainsFold,omitempty"`
	// detected_content_type field predicates
	DetectedContentType             *string  `json:"detectedContentType,omitempty"`
	DetectedContentTypeNeq          *string  `json:"detectedContentTypeNEQ,omitempty"`
	DetectedContentTypeIn           []string `json:"detectedContentTypeIn,omitempty"`
	DetectedContentTypeNotIn        []string `json:"detectedContentTypeNotIn,omitempty"`
	DetectedContentTypeGt           *string  `json:"detectedContentTypeGT,omitempty"`
	DetectedContentTypeGte          *string  `json:"detectedContentTypeGTE,omitempty"`
	DetectedContentTypeLt           *string  `json:"detectedContentTypeLT,omitempty"`
	DetectedContentTypeLte          *string  `json:"detectedContentTypeLTE,omitempty"`
	DetectedContentTypeContains     *string  `json:"detectedContentTypeContains,omitempty"`
	DetectedContentTypeHasPrefix    *string  `json:"detectedContentTypeHasPrefix,omitempty"`
	DetectedContentTypeHasSuffix    *string  `json:"detectedContentTypeHasSuffix,omitempty"`
	DetectedContentTypeEqualFold    *string  `json:"detectedContentTypeEqualFold,omitempty"`
	DetectedContentTypeContainsFold *string  `json:"detectedContentTypeContainsFold,omitempty"`
	// store_key field predicates
	StoreKey             *string  `json:"storeKey,omitempty"`
	StoreKeyNeq          *string  `json:"storeKeyNEQ,omitempty"`
	StoreKeyIn           []string `json:"storeKeyIn,omitempty"`
	StoreKeyNotIn        []string `json:"storeKeyNotIn,omitempty"`
	StoreKeyGt           *string  `json:"storeKeyGT,omitempty"`
	StoreKeyGte          *string  `json:"storeKeyGTE,omitempty"`
	StoreKeyLt           *string  `json:"storeKeyLT,omitempty"`
	StoreKeyLte          *string  `json:"storeKeyLTE,omitempty"`
	StoreKeyContains     *string  `json:"storeKeyContains,omitempty"`
	StoreKeyHasPrefix    *string  `json:"storeKeyHasPrefix,omitempty"`
	StoreKeyHasSuffix    *string  `json:"storeKeyHasSuffix,omitempty"`
	StoreKeyIsNil        *bool    `json:"storeKeyIsNil,omitempty"`
	StoreKeyNotNil       *bool    `json:"storeKeyNotNil,omitempty"`
	StoreKeyEqualFold    *string  `json:"storeKeyEqualFold,omitempty"`
	StoreKeyContainsFold *string  `json:"storeKeyContainsFold,omitempty"`
	// category_type field predicates
	CategoryType             *string  `json:"categoryType,omitempty"`
	CategoryTypeNeq          *string  `json:"categoryTypeNEQ,omitempty"`
	CategoryTypeIn           []string `json:"categoryTypeIn,omitempty"`
	CategoryTypeNotIn        []string `json:"categoryTypeNotIn,omitempty"`
	CategoryTypeGt           *string  `json:"categoryTypeGT,omitempty"`
	CategoryTypeGte          *string  `json:"categoryTypeGTE,omitempty"`
	CategoryTypeLt           *string  `json:"categoryTypeLT,omitempty"`
	CategoryTypeLte          *string  `json:"categoryTypeLTE,omitempty"`
	CategoryTypeContains     *string  `json:"categoryTypeContains,omitempty"`
	CategoryTypeHasPrefix    *string  `json:"categoryTypeHasPrefix,omitempty"`
	CategoryTypeHasSuffix    *string  `json:"categoryTypeHasSuffix,omitempty"`
	CategoryTypeIsNil        *bool    `json:"categoryTypeIsNil,omitempty"`
	CategoryTypeNotNil       *bool    `json:"categoryTypeNotNil,omitempty"`
	CategoryTypeEqualFold    *string  `json:"categoryTypeEqualFold,omitempty"`
	CategoryTypeContainsFold *string  `json:"categoryTypeContainsFold,omitempty"`
	// uri field predicates
	URI             *string  `json:"uri,omitempty"`
	URINeq          *string  `json:"uriNEQ,omitempty"`
	URIIn           []string `json:"uriIn,omitempty"`
	URINotIn        []string `json:"uriNotIn,omitempty"`
	URIGt           *string  `json:"uriGT,omitempty"`
	URIGte          *string  `json:"uriGTE,omitempty"`
	URILt           *string  `json:"uriLT,omitempty"`
	URILte          *string  `json:"uriLTE,omitempty"`
	URIContains     *string  `json:"uriContains,omitempty"`
	URIHasPrefix    *string  `json:"uriHasPrefix,omitempty"`
	URIHasSuffix    *string  `json:"uriHasSuffix,omitempty"`
	URIIsNil        *bool    `json:"uriIsNil,omitempty"`
	URINotNil       *bool    `json:"uriNotNil,omitempty"`
	URIEqualFold    *string  `json:"uriEqualFold,omitempty"`
	URIContainsFold *string  `json:"uriContainsFold,omitempty"`
	// storage_scheme field predicates
	StorageScheme             *string  `json:"storageScheme,omitempty"`
	StorageSchemeNeq          *string  `json:"storageSchemeNEQ,omitempty"`
	StorageSchemeIn           []string `json:"storageSchemeIn,omitempty"`
	StorageSchemeNotIn        []string `json:"storageSchemeNotIn,omitempty"`
	StorageSchemeGt           *string  `json:"storageSchemeGT,omitempty"`
	StorageSchemeGte          *string  `json:"storageSchemeGTE,omitempty"`
	StorageSchemeLt           *string  `json:"storageSchemeLT,omitempty"`
	StorageSchemeLte          *string  `json:"storageSchemeLTE,omitempty"`
	StorageSchemeContains     *string  `json:"storageSchemeContains,omitempty"`
	StorageSchemeHasPrefix    *string  `json:"storageSchemeHasPrefix,omitempty"`
	StorageSchemeHasSuffix    *string  `json:"storageSchemeHasSuffix,omitempty"`
	StorageSchemeIsNil        *bool    `json:"storageSchemeIsNil,omitempty"`
	StorageSchemeNotNil       *bool    `json:"storageSchemeNotNil,omitempty"`
	StorageSchemeEqualFold    *string  `json:"storageSchemeEqualFold,omitempty"`
	StorageSchemeContainsFold *string  `json:"storageSchemeContainsFold,omitempty"`
	// storage_volume field predicates
	StorageVolume             *string  `json:"storageVolume,omitempty"`
	StorageVolumeNeq          *string  `json:"storageVolumeNEQ,omitempty"`
	StorageVolumeIn           []string `json:"storageVolumeIn,omitempty"`
	StorageVolumeNotIn        []string `json:"storageVolumeNotIn,omitempty"`
	StorageVolumeGt           *string  `json:"storageVolumeGT,omitempty"`
	StorageVolumeGte          *string  `json:"storageVolumeGTE,omitempty"`
	StorageVolumeLt           *string  `json:"storageVolumeLT,omitempty"`
	StorageVolumeLte          *string  `json:"storageVolumeLTE,omitempty"`
	StorageVolumeContains     *string  `json:"storageVolumeContains,omitempty"`
	StorageVolumeHasPrefix    *string  `json:"storageVolumeHasPrefix,omitempty"`
	StorageVolumeHasSuffix    *string  `json:"storageVolumeHasSuffix,omitempty"`
	StorageVolumeIsNil        *bool    `json:"storageVolumeIsNil,omitempty"`
	StorageVolumeNotNil       *bool    `json:"storageVolumeNotNil,omitempty"`
	StorageVolumeEqualFold    *string  `json:"storageVolumeEqualFold,omitempty"`
	StorageVolumeContainsFold *string  `json:"storageVolumeContainsFold,omitempty"`
	// storage_path field predicates
	StoragePath             *string  `json:"storagePath,omitempty"`
	StoragePathNeq          *string  `json:"storagePathNEQ,omitempty"`
	StoragePathIn           []string `json:"storagePathIn,omitempty"`
	StoragePathNotIn        []string `json:"storagePathNotIn,omitempty"`
	StoragePathGt           *string  `json:"storagePathGT,omitempty"`
	StoragePathGte          *string  `json:"storagePathGTE,omitempty"`
	StoragePathLt           *string  `json:"storagePathLT,omitempty"`
	StoragePathLte          *string  `json:"storagePathLTE,omitempty"`
	StoragePathContains     *string  `json:"storagePathContains,omitempty"`
	StoragePathHasPrefix    *string  `json:"storagePathHasPrefix,omitempty"`
	StoragePathHasSuffix    *string  `json:"storagePathHasSuffix,omitempty"`
	StoragePathIsNil        *bool    `json:"storagePathIsNil,omitempty"`
	StoragePathNotNil       *bool    `json:"storagePathNotNil,omitempty"`
	StoragePathEqualFold    *string  `json:"storagePathEqualFold,omitempty"`
	StoragePathContainsFold *string  `json:"storagePathContainsFold,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
	// contact edge predicates
	HasContact     *bool                `json:"hasContact,omitempty"`
	HasContactWith []*ContactWhereInput `json:"hasContactWith,omitempty"`
	// entity edge predicates
	HasEntity     *bool               `json:"hasEntity,omitempty"`
	HasEntityWith []*EntityWhereInput `json:"hasEntityWith,omitempty"`
	// usersetting edge predicates
	HasUsersetting     *bool                    `json:"hasUsersetting,omitempty"`
	HasUsersettingWith []*UserSettingWhereInput `json:"hasUsersettingWith,omitempty"`
	// organizationsetting edge predicates
	HasOrganizationsetting     *bool                            `json:"hasOrganizationsetting,omitempty"`
	HasOrganizationsettingWith []*OrganizationSettingWhereInput `json:"hasOrganizationsettingWith,omitempty"`
	// template edge predicates
	HasTemplate     *bool                 `json:"hasTemplate,omitempty"`
	HasTemplateWith []*TemplateWhereInput `json:"hasTemplateWith,omitempty"`
	// documentdata edge predicates
	HasDocumentdata     *bool                     `json:"hasDocumentdata,omitempty"`
	HasDocumentdataWith []*DocumentDataWhereInput `json:"hasDocumentdataWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// program edge predicates
	HasProgram     *bool                `json:"hasProgram,omitempty"`
	HasProgramWith []*ProgramWhereInput `json:"hasProgramWith,omitempty"`
}

type Group struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the group - must be unique within the organization
	Name string `json:"name"`
	// the groups description
	Description *string `json:"description,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL *string `json:"gravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL *string `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName  string             `json:"displayName"`
	Owner        *Organization      `json:"owner,omitempty"`
	Setting      *GroupSetting      `json:"setting"`
	Users        []*User            `json:"users,omitempty"`
	Events       []*Event           `json:"events,omitempty"`
	Integrations []*Integration     `json:"integrations,omitempty"`
	Files        []*File            `json:"files,omitempty"`
	Tasks        []*Task            `json:"tasks,omitempty"`
	Members      []*GroupMembership `json:"members,omitempty"`
}

func (Group) IsNode() {}

// Return response for createBulkGroup mutation
type GroupBulkCreatePayload struct {
	// Created groups
	Groups []*Group `json:"groups,omitempty"`
}

// A connection to a list of items.
type GroupConnection struct {
	// A list of edges.
	Edges []*GroupEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroup mutation
type GroupCreatePayload struct {
	// Created group
	Group *Group `json:"group"`
}

// Return response for deleteGroup mutation
type GroupDeletePayload struct {
	// Deleted group ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupEdge struct {
	// The item at the end of the edge.
	Node *Group `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type GroupHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the group - must be unique within the organization
	Name string `json:"name"`
	// the groups description
	Description *string `json:"description,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL *string `json:"gravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL *string `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName string `json:"displayName"`
}

func (GroupHistory) IsNode() {}

// A connection to a list of items.
type GroupHistoryConnection struct {
	// A list of edges.
	Edges []*GroupHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupHistoryEdge struct {
	// The item at the end of the edge.
	Node *GroupHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for GroupHistory connections
type GroupHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order GroupHistories.
	Field GroupHistoryOrderField `json:"field"`
}

// GroupHistoryWhereInput is used for filtering GroupHistory objects.
// Input was generated by ent.
type GroupHistoryWhereInput struct {
	Not *GroupHistoryWhereInput   `json:"not,omitempty"`
	And []*GroupHistoryWhereInput `json:"and,omitempty"`
	Or  []*GroupHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
}

type GroupMembership struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	Role      enums.Role `json:"role"`
	GroupID   string     `json:"groupID"`
	UserID    string     `json:"userID"`
	Group     *Group     `json:"group"`
	User      *User      `json:"user"`
	Events    []*Event   `json:"events,omitempty"`
}

func (GroupMembership) IsNode() {}

// Return response for createBulkGroupMembership mutation
type GroupMembershipBulkCreatePayload struct {
	// Created groupMemberships
	GroupMemberships []*GroupMembership `json:"groupMemberships,omitempty"`
}

// A connection to a list of items.
type GroupMembershipConnection struct {
	// A list of edges.
	Edges []*GroupMembershipEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroupMembership mutation
type GroupMembershipCreatePayload struct {
	// Created groupMembership
	GroupMembership *GroupMembership `json:"groupMembership"`
}

// Return response for deleteGroupMembership mutation
type GroupMembershipDeletePayload struct {
	// Deleted groupMembership ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupMembershipEdge struct {
	// The item at the end of the edge.
	Node *GroupMembership `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type GroupMembershipHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	Role        enums.Role     `json:"role"`
	GroupID     string         `json:"groupID"`
	UserID      string         `json:"userID"`
}

func (GroupMembershipHistory) IsNode() {}

// A connection to a list of items.
type GroupMembershipHistoryConnection struct {
	// A list of edges.
	Edges []*GroupMembershipHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupMembershipHistoryEdge struct {
	// The item at the end of the edge.
	Node *GroupMembershipHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// GroupMembershipHistoryWhereInput is used for filtering GroupMembershipHistory objects.
// Input was generated by ent.
type GroupMembershipHistoryWhereInput struct {
	Not *GroupMembershipHistoryWhereInput   `json:"not,omitempty"`
	And []*GroupMembershipHistoryWhereInput `json:"and,omitempty"`
	Or  []*GroupMembershipHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// group_id field predicates
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIdneq          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIdgt           *string  `json:"groupIDGT,omitempty"`
	GroupIdgte          *string  `json:"groupIDGTE,omitempty"`
	GroupIdlt           *string  `json:"groupIDLT,omitempty"`
	GroupIdlte          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// Return response for updateGroupMembership mutation
type GroupMembershipUpdatePayload struct {
	// Updated groupMembership
	GroupMembership *GroupMembership `json:"groupMembership"`
}

// GroupMembershipWhereInput is used for filtering GroupMembership objects.
// Input was generated by ent.
type GroupMembershipWhereInput struct {
	Not *GroupMembershipWhereInput   `json:"not,omitempty"`
	And []*GroupMembershipWhereInput `json:"and,omitempty"`
	Or  []*GroupMembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	GroupID   *string      `json:"groupID,omitempty"`
	UserID    *string      `json:"userID,omitempty"`
}

// Ordering options for Group connections
type GroupOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Groups.
	Field GroupOrderField `json:"field"`
}

type GroupSearchResult struct {
	Groups []*Group `json:"groups,omitempty"`
}

func (GroupSearchResult) IsSearchResult() {}

type GroupSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility enums.Visibility `json:"visibility"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy enums.JoinPolicy `json:"joinPolicy"`
	// whether to sync group members to slack groups
	SyncToSlack *bool `json:"syncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub *bool `json:"syncToGithub,omitempty"`
	// the group id associated with the settings
	GroupID *string `json:"groupID,omitempty"`
	Group   *Group  `json:"group,omitempty"`
}

func (GroupSetting) IsNode() {}

// Return response for createBulkGroupSetting mutation
type GroupSettingBulkCreatePayload struct {
	// Created groupSettings
	GroupSettings []*GroupSetting `json:"groupSettings,omitempty"`
}

// A connection to a list of items.
type GroupSettingConnection struct {
	// A list of edges.
	Edges []*GroupSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroupSetting mutation
type GroupSettingCreatePayload struct {
	// Created groupSetting
	GroupSetting *GroupSetting `json:"groupSetting"`
}

// Return response for deleteGroupSetting mutation
type GroupSettingDeletePayload struct {
	// Deleted groupSetting ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupSettingEdge struct {
	// The item at the end of the edge.
	Node *GroupSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type GroupSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility enums.Visibility `json:"visibility"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy enums.JoinPolicy `json:"joinPolicy"`
	// whether to sync group members to slack groups
	SyncToSlack *bool `json:"syncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub *bool `json:"syncToGithub,omitempty"`
	// the group id associated with the settings
	GroupID *string `json:"groupID,omitempty"`
}

func (GroupSettingHistory) IsNode() {}

// A connection to a list of items.
type GroupSettingHistoryConnection struct {
	// A list of edges.
	Edges []*GroupSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *GroupSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// GroupSettingHistoryWhereInput is used for filtering GroupSettingHistory objects.
// Input was generated by ent.
type GroupSettingHistoryWhereInput struct {
	Not *GroupSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*GroupSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*GroupSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// visibility field predicates
	Visibility      *enums.Visibility  `json:"visibility,omitempty"`
	VisibilityNeq   *enums.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []enums.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []enums.Visibility `json:"visibilityNotIn,omitempty"`
	// join_policy field predicates
	JoinPolicy      *enums.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNeq   *enums.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []enums.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []enums.JoinPolicy `json:"joinPolicyNotIn,omitempty"`
	// sync_to_slack field predicates
	SyncToSlack       *bool `json:"syncToSlack,omitempty"`
	SyncToSlackNeq    *bool `json:"syncToSlackNEQ,omitempty"`
	SyncToSlackIsNil  *bool `json:"syncToSlackIsNil,omitempty"`
	SyncToSlackNotNil *bool `json:"syncToSlackNotNil,omitempty"`
	// sync_to_github field predicates
	SyncToGithub       *bool `json:"syncToGithub,omitempty"`
	SyncToGithubNeq    *bool `json:"syncToGithubNEQ,omitempty"`
	SyncToGithubIsNil  *bool `json:"syncToGithubIsNil,omitempty"`
	SyncToGithubNotNil *bool `json:"syncToGithubNotNil,omitempty"`
	// group_id field predicates
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIdneq          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIdgt           *string  `json:"groupIDGT,omitempty"`
	GroupIdgte          *string  `json:"groupIDGTE,omitempty"`
	GroupIdlt           *string  `json:"groupIDLT,omitempty"`
	GroupIdlte          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDIsNil        *bool    `json:"groupIDIsNil,omitempty"`
	GroupIDNotNil       *bool    `json:"groupIDNotNil,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
}

type GroupSettingSearchResult struct {
	GroupSettings []*GroupSetting `json:"groupSettings,omitempty"`
}

func (GroupSettingSearchResult) IsSearchResult() {}

// Return response for updateGroupSetting mutation
type GroupSettingUpdatePayload struct {
	// Updated groupSetting
	GroupSetting *GroupSetting `json:"groupSetting"`
}

// GroupSettingWhereInput is used for filtering GroupSetting objects.
// Input was generated by ent.
type GroupSettingWhereInput struct {
	Not *GroupSettingWhereInput   `json:"not,omitempty"`
	And []*GroupSettingWhereInput `json:"and,omitempty"`
	Or  []*GroupSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// visibility field predicates
	Visibility      *enums.Visibility  `json:"visibility,omitempty"`
	VisibilityNeq   *enums.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []enums.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []enums.Visibility `json:"visibilityNotIn,omitempty"`
	// join_policy field predicates
	JoinPolicy      *enums.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNeq   *enums.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []enums.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []enums.JoinPolicy `json:"joinPolicyNotIn,omitempty"`
	// sync_to_slack field predicates
	SyncToSlack       *bool `json:"syncToSlack,omitempty"`
	SyncToSlackNeq    *bool `json:"syncToSlackNEQ,omitempty"`
	SyncToSlackIsNil  *bool `json:"syncToSlackIsNil,omitempty"`
	SyncToSlackNotNil *bool `json:"syncToSlackNotNil,omitempty"`
	// sync_to_github field predicates
	SyncToGithub       *bool `json:"syncToGithub,omitempty"`
	SyncToGithubNeq    *bool `json:"syncToGithubNEQ,omitempty"`
	SyncToGithubIsNil  *bool `json:"syncToGithubIsNil,omitempty"`
	SyncToGithubNotNil *bool `json:"syncToGithubNotNil,omitempty"`
	// group_id field predicates
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIdneq          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIdgt           *string  `json:"groupIDGT,omitempty"`
	GroupIdgte          *string  `json:"groupIDGTE,omitempty"`
	GroupIdlt           *string  `json:"groupIDLT,omitempty"`
	GroupIdlte          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDIsNil        *bool    `json:"groupIDIsNil,omitempty"`
	GroupIDNotNil       *bool    `json:"groupIDNotNil,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
}

// Return response for updateGroup mutation
type GroupUpdatePayload struct {
	// Updated group
	Group *Group `json:"group"`
}

// GroupWhereInput is used for filtering Group objects.
// Input was generated by ent.
type GroupWhereInput struct {
	Not *GroupWhereInput   `json:"not,omitempty"`
	And []*GroupWhereInput `json:"and,omitempty"`
	Or  []*GroupWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                     `json:"hasSetting,omitempty"`
	HasSettingWith []*GroupSettingWhereInput `json:"hasSettingWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// members edge predicates
	HasMembers     *bool                        `json:"hasMembers,omitempty"`
	HasMembersWith []*GroupMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

type Hush struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the logical name of the corresponding hush secret or it's general grouping
	Name string `json:"name"`
	// a description of the hush value or purpose, such as github PAT
	Description *string `json:"description,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind *string `json:"kind,omitempty"`
	// the generic name of a secret associated with the organization
	SecretName *string `json:"secretName,omitempty"`
	// the integration associated with the secret
	Integrations []*Integration  `json:"integrations,omitempty"`
	Organization []*Organization `json:"organization,omitempty"`
	Events       []*Event        `json:"events,omitempty"`
}

func (Hush) IsNode() {}

// Return response for createBulkHush mutation
type HushBulkCreatePayload struct {
	// Created hushs
	Hushes []*Hush `json:"hushes,omitempty"`
}

// A connection to a list of items.
type HushConnection struct {
	// A list of edges.
	Edges []*HushEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createHush mutation
type HushCreatePayload struct {
	// Created hush
	Hush *Hush `json:"hush"`
}

// Return response for deleteHush mutation
type HushDeletePayload struct {
	// Deleted hush ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type HushEdge struct {
	// The item at the end of the edge.
	Node *Hush `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type HushHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// the logical name of the corresponding hush secret or it's general grouping
	Name string `json:"name"`
	// a description of the hush value or purpose, such as github PAT
	Description *string `json:"description,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind *string `json:"kind,omitempty"`
	// the generic name of a secret associated with the organization
	SecretName *string `json:"secretName,omitempty"`
}

func (HushHistory) IsNode() {}

// A connection to a list of items.
type HushHistoryConnection struct {
	// A list of edges.
	Edges []*HushHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type HushHistoryEdge struct {
	// The item at the end of the edge.
	Node *HushHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for HushHistory connections
type HushHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order HushHistories.
	Field HushHistoryOrderField `json:"field"`
}

// HushHistoryWhereInput is used for filtering HushHistory objects.
// Input was generated by ent.
type HushHistoryWhereInput struct {
	Not *HushHistoryWhereInput   `json:"not,omitempty"`
	And []*HushHistoryWhereInput `json:"and,omitempty"`
	Or  []*HushHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// secret_name field predicates
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNeq          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGt           *string  `json:"secretNameGT,omitempty"`
	SecretNameGte          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLt           *string  `json:"secretNameLT,omitempty"`
	SecretNameLte          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameIsNil        *bool    `json:"secretNameIsNil,omitempty"`
	SecretNameNotNil       *bool    `json:"secretNameNotNil,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`
}

// Ordering options for Hush connections
type HushOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Hushes.
	Field HushOrderField `json:"field"`
}

// Return response for updateHush mutation
type HushUpdatePayload struct {
	// Updated hush
	Hush *Hush `json:"hush"`
}

// HushWhereInput is used for filtering Hush objects.
// Input was generated by ent.
type HushWhereInput struct {
	Not *HushWhereInput   `json:"not,omitempty"`
	And []*HushWhereInput `json:"and,omitempty"`
	Or  []*HushWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// secret_name field predicates
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNeq          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGt           *string  `json:"secretNameGT,omitempty"`
	SecretNameGte          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLt           *string  `json:"secretNameLT,omitempty"`
	SecretNameLte          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameIsNil        *bool    `json:"secretNameIsNil,omitempty"`
	SecretNameNotNil       *bool    `json:"secretNameNotNil,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Integration struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the integration - must be unique within the organization
	Name string `json:"name"`
	// a description of the integration
	Description *string       `json:"description,omitempty"`
	Kind        *string       `json:"kind,omitempty"`
	Owner       *Organization `json:"owner,omitempty"`
	// the secrets associated with the integration
	Secrets []*Hush `json:"secrets,omitempty"`
	// the oauth2 tokens associated with the integration
	Oauth2tokens []*OhAuthTooToken `json:"oauth2tokens,omitempty"`
	Events       []*Event          `json:"events,omitempty"`
	Webhooks     []*Webhook        `json:"webhooks,omitempty"`
}

func (Integration) IsNode() {}

// Return response for createBulkIntegration mutation
type IntegrationBulkCreatePayload struct {
	// Created integrations
	Integrations []*Integration `json:"integrations,omitempty"`
}

// A connection to a list of items.
type IntegrationConnection struct {
	// A list of edges.
	Edges []*IntegrationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createIntegration mutation
type IntegrationCreatePayload struct {
	// Created integration
	Integration *Integration `json:"integration"`
}

// Return response for deleteIntegration mutation
type IntegrationDeletePayload struct {
	// Deleted integration ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type IntegrationEdge struct {
	// The item at the end of the edge.
	Node *Integration `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type IntegrationHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the integration - must be unique within the organization
	Name string `json:"name"`
	// a description of the integration
	Description *string `json:"description,omitempty"`
	Kind        *string `json:"kind,omitempty"`
}

func (IntegrationHistory) IsNode() {}

// A connection to a list of items.
type IntegrationHistoryConnection struct {
	// A list of edges.
	Edges []*IntegrationHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type IntegrationHistoryEdge struct {
	// The item at the end of the edge.
	Node *IntegrationHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for IntegrationHistory connections
type IntegrationHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order IntegrationHistories.
	Field IntegrationHistoryOrderField `json:"field"`
}

// IntegrationHistoryWhereInput is used for filtering IntegrationHistory objects.
// Input was generated by ent.
type IntegrationHistoryWhereInput struct {
	Not *IntegrationHistoryWhereInput   `json:"not,omitempty"`
	And []*IntegrationHistoryWhereInput `json:"and,omitempty"`
	Or  []*IntegrationHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
}

// Ordering options for Integration connections
type IntegrationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Integrations.
	Field IntegrationOrderField `json:"field"`
}

type IntegrationSearchResult struct {
	Integrations []*Integration `json:"integrations,omitempty"`
}

func (IntegrationSearchResult) IsSearchResult() {}

// Return response for updateIntegration mutation
type IntegrationUpdatePayload struct {
	// Updated integration
	Integration *Integration `json:"integration"`
}

// IntegrationWhereInput is used for filtering Integration objects.
// Input was generated by ent.
type IntegrationWhereInput struct {
	Not *IntegrationWhereInput   `json:"not,omitempty"`
	And []*IntegrationWhereInput `json:"and,omitempty"`
	Or  []*IntegrationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// secrets edge predicates
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`
	// oauth2tokens edge predicates
	HasOauth2tokens     *bool                       `json:"hasOauth2tokens,omitempty"`
	HasOauth2tokensWith []*OhAuthTooTokenWhereInput `json:"hasOauth2tokensWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// webhooks edge predicates
	HasWebhooks     *bool                `json:"hasWebhooks,omitempty"`
	HasWebhooksWith []*WebhookWhereInput `json:"hasWebhooksWith,omitempty"`
}

type InternalPolicy struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the policy
	Name string `json:"name"`
	// description of the policy
	Description string `json:"description"`
	// status of the policy
	Status *string `json:"status,omitempty"`
	// type of the policy
	PolicyType *string `json:"policyType,omitempty"`
	// version of the policy
	Version *string `json:"version,omitempty"`
	// purpose and scope
	PurposeAndScope *string `json:"purposeAndScope,omitempty"`
	// background of the policy
	Background *string `json:"background,omitempty"`
	// json data for the policy document
	Details           map[string]interface{} `json:"details,omitempty"`
	Controlobjectives []*ControlObjective    `json:"controlobjectives,omitempty"`
	Controls          []*Control             `json:"controls,omitempty"`
	Procedures        []*Procedure           `json:"procedures,omitempty"`
	Narratives        []*Narrative           `json:"narratives,omitempty"`
	Tasks             []*Task                `json:"tasks,omitempty"`
	Programs          []*Program             `json:"programs,omitempty"`
}

func (InternalPolicy) IsNode() {}

// Return response for createBulkInternalPolicy mutation
type InternalPolicyBulkCreatePayload struct {
	// Created internalPolicys
	InternalPolicies []*InternalPolicy `json:"internalPolicies,omitempty"`
}

// A connection to a list of items.
type InternalPolicyConnection struct {
	// A list of edges.
	Edges []*InternalPolicyEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createInternalPolicy mutation
type InternalPolicyCreatePayload struct {
	// Created internalPolicy
	InternalPolicy *InternalPolicy `json:"internalPolicy"`
}

// Return response for deleteInternalPolicy mutation
type InternalPolicyDeletePayload struct {
	// Deleted internalPolicy ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type InternalPolicyEdge struct {
	// The item at the end of the edge.
	Node *InternalPolicy `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type InternalPolicyHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the policy
	Name string `json:"name"`
	// description of the policy
	Description string `json:"description"`
	// status of the policy
	Status *string `json:"status,omitempty"`
	// type of the policy
	PolicyType *string `json:"policyType,omitempty"`
	// version of the policy
	Version *string `json:"version,omitempty"`
	// purpose and scope
	PurposeAndScope *string `json:"purposeAndScope,omitempty"`
	// background of the policy
	Background *string `json:"background,omitempty"`
	// json data for the policy document
	Details map[string]interface{} `json:"details,omitempty"`
}

func (InternalPolicyHistory) IsNode() {}

// A connection to a list of items.
type InternalPolicyHistoryConnection struct {
	// A list of edges.
	Edges []*InternalPolicyHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type InternalPolicyHistoryEdge struct {
	// The item at the end of the edge.
	Node *InternalPolicyHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// InternalPolicyHistoryWhereInput is used for filtering InternalPolicyHistory objects.
// Input was generated by ent.
type InternalPolicyHistoryWhereInput struct {
	Not *InternalPolicyHistoryWhereInput   `json:"not,omitempty"`
	And []*InternalPolicyHistoryWhereInput `json:"and,omitempty"`
	Or  []*InternalPolicyHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// policy_type field predicates
	PolicyType             *string  `json:"policyType,omitempty"`
	PolicyTypeNeq          *string  `json:"policyTypeNEQ,omitempty"`
	PolicyTypeIn           []string `json:"policyTypeIn,omitempty"`
	PolicyTypeNotIn        []string `json:"policyTypeNotIn,omitempty"`
	PolicyTypeGt           *string  `json:"policyTypeGT,omitempty"`
	PolicyTypeGte          *string  `json:"policyTypeGTE,omitempty"`
	PolicyTypeLt           *string  `json:"policyTypeLT,omitempty"`
	PolicyTypeLte          *string  `json:"policyTypeLTE,omitempty"`
	PolicyTypeContains     *string  `json:"policyTypeContains,omitempty"`
	PolicyTypeHasPrefix    *string  `json:"policyTypeHasPrefix,omitempty"`
	PolicyTypeHasSuffix    *string  `json:"policyTypeHasSuffix,omitempty"`
	PolicyTypeIsNil        *bool    `json:"policyTypeIsNil,omitempty"`
	PolicyTypeNotNil       *bool    `json:"policyTypeNotNil,omitempty"`
	PolicyTypeEqualFold    *string  `json:"policyTypeEqualFold,omitempty"`
	PolicyTypeContainsFold *string  `json:"policyTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// purpose_and_scope field predicates
	PurposeAndScope             *string  `json:"purposeAndScope,omitempty"`
	PurposeAndScopeNeq          *string  `json:"purposeAndScopeNEQ,omitempty"`
	PurposeAndScopeIn           []string `json:"purposeAndScopeIn,omitempty"`
	PurposeAndScopeNotIn        []string `json:"purposeAndScopeNotIn,omitempty"`
	PurposeAndScopeGt           *string  `json:"purposeAndScopeGT,omitempty"`
	PurposeAndScopeGte          *string  `json:"purposeAndScopeGTE,omitempty"`
	PurposeAndScopeLt           *string  `json:"purposeAndScopeLT,omitempty"`
	PurposeAndScopeLte          *string  `json:"purposeAndScopeLTE,omitempty"`
	PurposeAndScopeContains     *string  `json:"purposeAndScopeContains,omitempty"`
	PurposeAndScopeHasPrefix    *string  `json:"purposeAndScopeHasPrefix,omitempty"`
	PurposeAndScopeHasSuffix    *string  `json:"purposeAndScopeHasSuffix,omitempty"`
	PurposeAndScopeIsNil        *bool    `json:"purposeAndScopeIsNil,omitempty"`
	PurposeAndScopeNotNil       *bool    `json:"purposeAndScopeNotNil,omitempty"`
	PurposeAndScopeEqualFold    *string  `json:"purposeAndScopeEqualFold,omitempty"`
	PurposeAndScopeContainsFold *string  `json:"purposeAndScopeContainsFold,omitempty"`
	// background field predicates
	Background             *string  `json:"background,omitempty"`
	BackgroundNeq          *string  `json:"backgroundNEQ,omitempty"`
	BackgroundIn           []string `json:"backgroundIn,omitempty"`
	BackgroundNotIn        []string `json:"backgroundNotIn,omitempty"`
	BackgroundGt           *string  `json:"backgroundGT,omitempty"`
	BackgroundGte          *string  `json:"backgroundGTE,omitempty"`
	BackgroundLt           *string  `json:"backgroundLT,omitempty"`
	BackgroundLte          *string  `json:"backgroundLTE,omitempty"`
	BackgroundContains     *string  `json:"backgroundContains,omitempty"`
	BackgroundHasPrefix    *string  `json:"backgroundHasPrefix,omitempty"`
	BackgroundHasSuffix    *string  `json:"backgroundHasSuffix,omitempty"`
	BackgroundIsNil        *bool    `json:"backgroundIsNil,omitempty"`
	BackgroundNotNil       *bool    `json:"backgroundNotNil,omitempty"`
	BackgroundEqualFold    *string  `json:"backgroundEqualFold,omitempty"`
	BackgroundContainsFold *string  `json:"backgroundContainsFold,omitempty"`
}

type InternalPolicySearchResult struct {
	InternalPolicies []*InternalPolicy `json:"internalPolicies,omitempty"`
}

func (InternalPolicySearchResult) IsSearchResult() {}

// Return response for updateInternalPolicy mutation
type InternalPolicyUpdatePayload struct {
	// Updated internalPolicy
	InternalPolicy *InternalPolicy `json:"internalPolicy"`
}

// InternalPolicyWhereInput is used for filtering InternalPolicy objects.
// Input was generated by ent.
type InternalPolicyWhereInput struct {
	Not *InternalPolicyWhereInput   `json:"not,omitempty"`
	And []*InternalPolicyWhereInput `json:"and,omitempty"`
	Or  []*InternalPolicyWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// policy_type field predicates
	PolicyType             *string  `json:"policyType,omitempty"`
	PolicyTypeNeq          *string  `json:"policyTypeNEQ,omitempty"`
	PolicyTypeIn           []string `json:"policyTypeIn,omitempty"`
	PolicyTypeNotIn        []string `json:"policyTypeNotIn,omitempty"`
	PolicyTypeGt           *string  `json:"policyTypeGT,omitempty"`
	PolicyTypeGte          *string  `json:"policyTypeGTE,omitempty"`
	PolicyTypeLt           *string  `json:"policyTypeLT,omitempty"`
	PolicyTypeLte          *string  `json:"policyTypeLTE,omitempty"`
	PolicyTypeContains     *string  `json:"policyTypeContains,omitempty"`
	PolicyTypeHasPrefix    *string  `json:"policyTypeHasPrefix,omitempty"`
	PolicyTypeHasSuffix    *string  `json:"policyTypeHasSuffix,omitempty"`
	PolicyTypeIsNil        *bool    `json:"policyTypeIsNil,omitempty"`
	PolicyTypeNotNil       *bool    `json:"policyTypeNotNil,omitempty"`
	PolicyTypeEqualFold    *string  `json:"policyTypeEqualFold,omitempty"`
	PolicyTypeContainsFold *string  `json:"policyTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// purpose_and_scope field predicates
	PurposeAndScope             *string  `json:"purposeAndScope,omitempty"`
	PurposeAndScopeNeq          *string  `json:"purposeAndScopeNEQ,omitempty"`
	PurposeAndScopeIn           []string `json:"purposeAndScopeIn,omitempty"`
	PurposeAndScopeNotIn        []string `json:"purposeAndScopeNotIn,omitempty"`
	PurposeAndScopeGt           *string  `json:"purposeAndScopeGT,omitempty"`
	PurposeAndScopeGte          *string  `json:"purposeAndScopeGTE,omitempty"`
	PurposeAndScopeLt           *string  `json:"purposeAndScopeLT,omitempty"`
	PurposeAndScopeLte          *string  `json:"purposeAndScopeLTE,omitempty"`
	PurposeAndScopeContains     *string  `json:"purposeAndScopeContains,omitempty"`
	PurposeAndScopeHasPrefix    *string  `json:"purposeAndScopeHasPrefix,omitempty"`
	PurposeAndScopeHasSuffix    *string  `json:"purposeAndScopeHasSuffix,omitempty"`
	PurposeAndScopeIsNil        *bool    `json:"purposeAndScopeIsNil,omitempty"`
	PurposeAndScopeNotNil       *bool    `json:"purposeAndScopeNotNil,omitempty"`
	PurposeAndScopeEqualFold    *string  `json:"purposeAndScopeEqualFold,omitempty"`
	PurposeAndScopeContainsFold *string  `json:"purposeAndScopeContainsFold,omitempty"`
	// background field predicates
	Background             *string  `json:"background,omitempty"`
	BackgroundNeq          *string  `json:"backgroundNEQ,omitempty"`
	BackgroundIn           []string `json:"backgroundIn,omitempty"`
	BackgroundNotIn        []string `json:"backgroundNotIn,omitempty"`
	BackgroundGt           *string  `json:"backgroundGT,omitempty"`
	BackgroundGte          *string  `json:"backgroundGTE,omitempty"`
	BackgroundLt           *string  `json:"backgroundLT,omitempty"`
	BackgroundLte          *string  `json:"backgroundLTE,omitempty"`
	BackgroundContains     *string  `json:"backgroundContains,omitempty"`
	BackgroundHasPrefix    *string  `json:"backgroundHasPrefix,omitempty"`
	BackgroundHasSuffix    *string  `json:"backgroundHasSuffix,omitempty"`
	BackgroundIsNil        *bool    `json:"backgroundIsNil,omitempty"`
	BackgroundNotNil       *bool    `json:"backgroundNotNil,omitempty"`
	BackgroundEqualFold    *string  `json:"backgroundEqualFold,omitempty"`
	BackgroundContainsFold *string  `json:"backgroundContainsFold,omitempty"`
	// controlobjectives edge predicates
	HasControlobjectives     *bool                         `json:"hasControlobjectives,omitempty"`
	HasControlobjectivesWith []*ControlObjectiveWhereInput `json:"hasControlobjectivesWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

type Invite struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires *time.Time `json:"expires,omitempty"`
	// the email used as input to generate the invitation token and is the destination person the invitation is sent to who is required to accept to join the organization
	Recipient string `json:"recipient"`
	// the status of the invitation
	Status enums.InviteStatus `json:"status"`
	Role   enums.Role         `json:"role"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts int64 `json:"sendAttempts"`
	// the user who initiated the invitation
	RequestorID *string       `json:"requestorID,omitempty"`
	Owner       *Organization `json:"owner,omitempty"`
	Events      []*Event      `json:"events,omitempty"`
}

func (Invite) IsNode() {}

// Return response for createBulkInvite mutation
type InviteBulkCreatePayload struct {
	// Created invites
	Invites []*Invite `json:"invites,omitempty"`
}

// A connection to a list of items.
type InviteConnection struct {
	// A list of edges.
	Edges []*InviteEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createInvite mutation
type InviteCreatePayload struct {
	// Created invite
	Invite *Invite `json:"invite"`
}

// Return response for deleteInvite mutation
type InviteDeletePayload struct {
	// Deleted invite ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type InviteEdge struct {
	// The item at the end of the edge.
	Node *Invite `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateInvite mutation
type InviteUpdatePayload struct {
	// Updated invite
	Invite *Invite `json:"invite"`
}

// InviteWhereInput is used for filtering Invite objects.
// Input was generated by ent.
type InviteWhereInput struct {
	Not *InviteWhereInput   `json:"not,omitempty"`
	And []*InviteWhereInput `json:"and,omitempty"`
	Or  []*InviteWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// expires field predicates
	Expires       *time.Time   `json:"expires,omitempty"`
	ExpiresNeq    *time.Time   `json:"expiresNEQ,omitempty"`
	ExpiresIn     []*time.Time `json:"expiresIn,omitempty"`
	ExpiresNotIn  []*time.Time `json:"expiresNotIn,omitempty"`
	ExpiresGt     *time.Time   `json:"expiresGT,omitempty"`
	ExpiresGte    *time.Time   `json:"expiresGTE,omitempty"`
	ExpiresLt     *time.Time   `json:"expiresLT,omitempty"`
	ExpiresLte    *time.Time   `json:"expiresLTE,omitempty"`
	ExpiresIsNil  *bool        `json:"expiresIsNil,omitempty"`
	ExpiresNotNil *bool        `json:"expiresNotNil,omitempty"`
	// recipient field predicates
	Recipient             *string  `json:"recipient,omitempty"`
	RecipientNeq          *string  `json:"recipientNEQ,omitempty"`
	RecipientIn           []string `json:"recipientIn,omitempty"`
	RecipientNotIn        []string `json:"recipientNotIn,omitempty"`
	RecipientGt           *string  `json:"recipientGT,omitempty"`
	RecipientGte          *string  `json:"recipientGTE,omitempty"`
	RecipientLt           *string  `json:"recipientLT,omitempty"`
	RecipientLte          *string  `json:"recipientLTE,omitempty"`
	RecipientContains     *string  `json:"recipientContains,omitempty"`
	RecipientHasPrefix    *string  `json:"recipientHasPrefix,omitempty"`
	RecipientHasSuffix    *string  `json:"recipientHasSuffix,omitempty"`
	RecipientEqualFold    *string  `json:"recipientEqualFold,omitempty"`
	RecipientContainsFold *string  `json:"recipientContainsFold,omitempty"`
	// status field predicates
	Status      *enums.InviteStatus  `json:"status,omitempty"`
	StatusNeq   *enums.InviteStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.InviteStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.InviteStatus `json:"statusNotIn,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// send_attempts field predicates
	SendAttempts      *int64  `json:"sendAttempts,omitempty"`
	SendAttemptsNeq   *int64  `json:"sendAttemptsNEQ,omitempty"`
	SendAttemptsIn    []int64 `json:"sendAttemptsIn,omitempty"`
	SendAttemptsNotIn []int64 `json:"sendAttemptsNotIn,omitempty"`
	SendAttemptsGt    *int64  `json:"sendAttemptsGT,omitempty"`
	SendAttemptsGte   *int64  `json:"sendAttemptsGTE,omitempty"`
	SendAttemptsLt    *int64  `json:"sendAttemptsLT,omitempty"`
	SendAttemptsLte   *int64  `json:"sendAttemptsLTE,omitempty"`
	// requestor_id field predicates
	RequestorID             *string  `json:"requestorID,omitempty"`
	RequestorIdneq          *string  `json:"requestorIDNEQ,omitempty"`
	RequestorIDIn           []string `json:"requestorIDIn,omitempty"`
	RequestorIDNotIn        []string `json:"requestorIDNotIn,omitempty"`
	RequestorIdgt           *string  `json:"requestorIDGT,omitempty"`
	RequestorIdgte          *string  `json:"requestorIDGTE,omitempty"`
	RequestorIdlt           *string  `json:"requestorIDLT,omitempty"`
	RequestorIdlte          *string  `json:"requestorIDLTE,omitempty"`
	RequestorIDContains     *string  `json:"requestorIDContains,omitempty"`
	RequestorIDHasPrefix    *string  `json:"requestorIDHasPrefix,omitempty"`
	RequestorIDHasSuffix    *string  `json:"requestorIDHasSuffix,omitempty"`
	RequestorIDIsNil        *bool    `json:"requestorIDIsNil,omitempty"`
	RequestorIDNotNil       *bool    `json:"requestorIDNotNil,omitempty"`
	RequestorIDEqualFold    *string  `json:"requestorIDEqualFold,omitempty"`
	RequestorIDContainsFold *string  `json:"requestorIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Mutation struct {
}

type Narrative struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the narrative
	Name string `json:"name"`
	// the description of the narrative
	Description *string `json:"description,omitempty"`
	// which controls are satisfied by the narrative
	Satisfies *string `json:"satisfies,omitempty"`
	// json data for the narrative document
	Details          map[string]interface{} `json:"details,omitempty"`
	Policy           []*InternalPolicy      `json:"policy,omitempty"`
	Control          []*Control             `json:"control,omitempty"`
	Procedure        []*Procedure           `json:"procedure,omitempty"`
	Controlobjective []*ControlObjective    `json:"controlobjective,omitempty"`
	Program          []*Program             `json:"program,omitempty"`
}

func (Narrative) IsNode() {}

// Return response for createBulkNarrative mutation
type NarrativeBulkCreatePayload struct {
	// Created narratives
	Narratives []*Narrative `json:"narratives,omitempty"`
}

// A connection to a list of items.
type NarrativeConnection struct {
	// A list of edges.
	Edges []*NarrativeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createNarrative mutation
type NarrativeCreatePayload struct {
	// Created narrative
	Narrative *Narrative `json:"narrative"`
}

// Return response for deleteNarrative mutation
type NarrativeDeletePayload struct {
	// Deleted narrative ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type NarrativeEdge struct {
	// The item at the end of the edge.
	Node *Narrative `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type NarrativeHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the narrative
	Name string `json:"name"`
	// the description of the narrative
	Description *string `json:"description,omitempty"`
	// which controls are satisfied by the narrative
	Satisfies *string `json:"satisfies,omitempty"`
	// json data for the narrative document
	Details map[string]interface{} `json:"details,omitempty"`
}

func (NarrativeHistory) IsNode() {}

// A connection to a list of items.
type NarrativeHistoryConnection struct {
	// A list of edges.
	Edges []*NarrativeHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type NarrativeHistoryEdge struct {
	// The item at the end of the edge.
	Node *NarrativeHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// NarrativeHistoryWhereInput is used for filtering NarrativeHistory objects.
// Input was generated by ent.
type NarrativeHistoryWhereInput struct {
	Not *NarrativeHistoryWhereInput   `json:"not,omitempty"`
	And []*NarrativeHistoryWhereInput `json:"and,omitempty"`
	Or  []*NarrativeHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// satisfies field predicates
	Satisfies             *string  `json:"satisfies,omitempty"`
	SatisfiesNeq          *string  `json:"satisfiesNEQ,omitempty"`
	SatisfiesIn           []string `json:"satisfiesIn,omitempty"`
	SatisfiesNotIn        []string `json:"satisfiesNotIn,omitempty"`
	SatisfiesGt           *string  `json:"satisfiesGT,omitempty"`
	SatisfiesGte          *string  `json:"satisfiesGTE,omitempty"`
	SatisfiesLt           *string  `json:"satisfiesLT,omitempty"`
	SatisfiesLte          *string  `json:"satisfiesLTE,omitempty"`
	SatisfiesContains     *string  `json:"satisfiesContains,omitempty"`
	SatisfiesHasPrefix    *string  `json:"satisfiesHasPrefix,omitempty"`
	SatisfiesHasSuffix    *string  `json:"satisfiesHasSuffix,omitempty"`
	SatisfiesIsNil        *bool    `json:"satisfiesIsNil,omitempty"`
	SatisfiesNotNil       *bool    `json:"satisfiesNotNil,omitempty"`
	SatisfiesEqualFold    *string  `json:"satisfiesEqualFold,omitempty"`
	SatisfiesContainsFold *string  `json:"satisfiesContainsFold,omitempty"`
}

type NarrativeSearchResult struct {
	Narratives []*Narrative `json:"narratives,omitempty"`
}

func (NarrativeSearchResult) IsSearchResult() {}

// Return response for updateNarrative mutation
type NarrativeUpdatePayload struct {
	// Updated narrative
	Narrative *Narrative `json:"narrative"`
}

// NarrativeWhereInput is used for filtering Narrative objects.
// Input was generated by ent.
type NarrativeWhereInput struct {
	Not *NarrativeWhereInput   `json:"not,omitempty"`
	And []*NarrativeWhereInput `json:"and,omitempty"`
	Or  []*NarrativeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// satisfies field predicates
	Satisfies             *string  `json:"satisfies,omitempty"`
	SatisfiesNeq          *string  `json:"satisfiesNEQ,omitempty"`
	SatisfiesIn           []string `json:"satisfiesIn,omitempty"`
	SatisfiesNotIn        []string `json:"satisfiesNotIn,omitempty"`
	SatisfiesGt           *string  `json:"satisfiesGT,omitempty"`
	SatisfiesGte          *string  `json:"satisfiesGTE,omitempty"`
	SatisfiesLt           *string  `json:"satisfiesLT,omitempty"`
	SatisfiesLte          *string  `json:"satisfiesLTE,omitempty"`
	SatisfiesContains     *string  `json:"satisfiesContains,omitempty"`
	SatisfiesHasPrefix    *string  `json:"satisfiesHasPrefix,omitempty"`
	SatisfiesHasSuffix    *string  `json:"satisfiesHasSuffix,omitempty"`
	SatisfiesIsNil        *bool    `json:"satisfiesIsNil,omitempty"`
	SatisfiesNotNil       *bool    `json:"satisfiesNotNil,omitempty"`
	SatisfiesEqualFold    *string  `json:"satisfiesEqualFold,omitempty"`
	SatisfiesContainsFold *string  `json:"satisfiesContainsFold,omitempty"`
	// policy edge predicates
	HasPolicy     *bool                       `json:"hasPolicy,omitempty"`
	HasPolicyWith []*InternalPolicyWhereInput `json:"hasPolicyWith,omitempty"`
	// control edge predicates
	HasControl     *bool                `json:"hasControl,omitempty"`
	HasControlWith []*ControlWhereInput `json:"hasControlWith,omitempty"`
	// procedure edge predicates
	HasProcedure     *bool                  `json:"hasProcedure,omitempty"`
	HasProcedureWith []*ProcedureWhereInput `json:"hasProcedureWith,omitempty"`
	// controlobjective edge predicates
	HasControlobjective     *bool                         `json:"hasControlobjective,omitempty"`
	HasControlobjectiveWith []*ControlObjectiveWhereInput `json:"hasControlobjectiveWith,omitempty"`
	// program edge predicates
	HasProgram     *bool                `json:"hasProgram,omitempty"`
	HasProgramWith []*ProgramWhereInput `json:"hasProgramWith,omitempty"`
}

type Note struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the text of the note
	Text        string        `json:"text"`
	Owner       *Organization `json:"owner,omitempty"`
	Entity      *Entity       `json:"entity,omitempty"`
	Subcontrols []*Subcontrol `json:"subcontrols,omitempty"`
	Program     []*Program    `json:"program,omitempty"`
}

func (Note) IsNode() {}

// A connection to a list of items.
type NoteConnection struct {
	// A list of edges.
	Edges []*NoteEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type NoteEdge struct {
	// The item at the end of the edge.
	Node *Note `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type NoteHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the text of the note
	Text string `json:"text"`
}

func (NoteHistory) IsNode() {}

// A connection to a list of items.
type NoteHistoryConnection struct {
	// A list of edges.
	Edges []*NoteHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type NoteHistoryEdge struct {
	// The item at the end of the edge.
	Node *NoteHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// NoteHistoryWhereInput is used for filtering NoteHistory objects.
// Input was generated by ent.
type NoteHistoryWhereInput struct {
	Not *NoteHistoryWhereInput   `json:"not,omitempty"`
	And []*NoteHistoryWhereInput `json:"and,omitempty"`
	Or  []*NoteHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// text field predicates
	Text             *string  `json:"text,omitempty"`
	TextNeq          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGt           *string  `json:"textGT,omitempty"`
	TextGte          *string  `json:"textGTE,omitempty"`
	TextLt           *string  `json:"textLT,omitempty"`
	TextLte          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`
}

// NoteWhereInput is used for filtering Note objects.
// Input was generated by ent.
type NoteWhereInput struct {
	Not *NoteWhereInput   `json:"not,omitempty"`
	And []*NoteWhereInput `json:"and,omitempty"`
	Or  []*NoteWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// text field predicates
	Text             *string  `json:"text,omitempty"`
	TextNeq          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGt           *string  `json:"textGT,omitempty"`
	TextGte          *string  `json:"textGTE,omitempty"`
	TextLt           *string  `json:"textLT,omitempty"`
	TextLte          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// entity edge predicates
	HasEntity     *bool               `json:"hasEntity,omitempty"`
	HasEntityWith []*EntityWhereInput `json:"hasEntityWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// program edge predicates
	HasProgram     *bool                `json:"hasProgram,omitempty"`
	HasProgramWith []*ProgramWhereInput `json:"hasProgramWith,omitempty"`
}

type OauthProvider struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the oauth provider's name
	Name string `json:"name"`
	// the client id for the oauth provider
	ClientID string `json:"clientID"`
	// the client secret
	ClientSecret string `json:"clientSecret"`
	// the redirect url
	RedirectURL string `json:"redirectURL"`
	// the scopes
	Scopes string `json:"scopes"`
	// the auth url of the provider
	AuthURL string `json:"authURL"`
	// the token url of the provider
	TokenURL string `json:"tokenURL"`
	// the auth style, 0: auto detect 1: third party log in 2: log in with username and password
	AuthStyle string `json:"authStyle"`
	// the URL to request user information by token
	InfoURL string        `json:"infoURL"`
	Owner   *Organization `json:"owner,omitempty"`
}

func (OauthProvider) IsNode() {}

// Return response for createBulkOauthProvider mutation
type OauthProviderBulkCreatePayload struct {
	// Created oauthProviders
	OauthProviders []*OauthProvider `json:"oauthProviders,omitempty"`
}

// A connection to a list of items.
type OauthProviderConnection struct {
	// A list of edges.
	Edges []*OauthProviderEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOauthProvider mutation
type OauthProviderCreatePayload struct {
	// Created oauthProvider
	OauthProvider *OauthProvider `json:"oauthProvider"`
}

// Return response for deleteOauthProvider mutation
type OauthProviderDeletePayload struct {
	// Deleted oauthProvider ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OauthProviderEdge struct {
	// The item at the end of the edge.
	Node *OauthProvider `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OauthProviderHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the oauth provider's name
	Name string `json:"name"`
	// the client id for the oauth provider
	ClientID string `json:"clientID"`
	// the client secret
	ClientSecret string `json:"clientSecret"`
	// the redirect url
	RedirectURL string `json:"redirectURL"`
	// the scopes
	Scopes string `json:"scopes"`
	// the auth url of the provider
	AuthURL string `json:"authURL"`
	// the token url of the provider
	TokenURL string `json:"tokenURL"`
	// the auth style, 0: auto detect 1: third party log in 2: log in with username and password
	AuthStyle string `json:"authStyle"`
	// the URL to request user information by token
	InfoURL string `json:"infoURL"`
}

func (OauthProviderHistory) IsNode() {}

// A connection to a list of items.
type OauthProviderHistoryConnection struct {
	// A list of edges.
	Edges []*OauthProviderHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OauthProviderHistoryEdge struct {
	// The item at the end of the edge.
	Node *OauthProviderHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// OauthProviderHistoryWhereInput is used for filtering OauthProviderHistory objects.
// Input was generated by ent.
type OauthProviderHistoryWhereInput struct {
	Not *OauthProviderHistoryWhereInput   `json:"not,omitempty"`
	And []*OauthProviderHistoryWhereInput `json:"and,omitempty"`
	Or  []*OauthProviderHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// client_id field predicates
	ClientID             *string  `json:"clientID,omitempty"`
	ClientIdneq          *string  `json:"clientIDNEQ,omitempty"`
	ClientIDIn           []string `json:"clientIDIn,omitempty"`
	ClientIDNotIn        []string `json:"clientIDNotIn,omitempty"`
	ClientIdgt           *string  `json:"clientIDGT,omitempty"`
	ClientIdgte          *string  `json:"clientIDGTE,omitempty"`
	ClientIdlt           *string  `json:"clientIDLT,omitempty"`
	ClientIdlte          *string  `json:"clientIDLTE,omitempty"`
	ClientIDContains     *string  `json:"clientIDContains,omitempty"`
	ClientIDHasPrefix    *string  `json:"clientIDHasPrefix,omitempty"`
	ClientIDHasSuffix    *string  `json:"clientIDHasSuffix,omitempty"`
	ClientIDEqualFold    *string  `json:"clientIDEqualFold,omitempty"`
	ClientIDContainsFold *string  `json:"clientIDContainsFold,omitempty"`
	// client_secret field predicates
	ClientSecret             *string  `json:"clientSecret,omitempty"`
	ClientSecretNeq          *string  `json:"clientSecretNEQ,omitempty"`
	ClientSecretIn           []string `json:"clientSecretIn,omitempty"`
	ClientSecretNotIn        []string `json:"clientSecretNotIn,omitempty"`
	ClientSecretGt           *string  `json:"clientSecretGT,omitempty"`
	ClientSecretGte          *string  `json:"clientSecretGTE,omitempty"`
	ClientSecretLt           *string  `json:"clientSecretLT,omitempty"`
	ClientSecretLte          *string  `json:"clientSecretLTE,omitempty"`
	ClientSecretContains     *string  `json:"clientSecretContains,omitempty"`
	ClientSecretHasPrefix    *string  `json:"clientSecretHasPrefix,omitempty"`
	ClientSecretHasSuffix    *string  `json:"clientSecretHasSuffix,omitempty"`
	ClientSecretEqualFold    *string  `json:"clientSecretEqualFold,omitempty"`
	ClientSecretContainsFold *string  `json:"clientSecretContainsFold,omitempty"`
	// redirect_url field predicates
	RedirectURL             *string  `json:"redirectURL,omitempty"`
	RedirectURLNeq          *string  `json:"redirectURLNEQ,omitempty"`
	RedirectURLIn           []string `json:"redirectURLIn,omitempty"`
	RedirectURLNotIn        []string `json:"redirectURLNotIn,omitempty"`
	RedirectURLGt           *string  `json:"redirectURLGT,omitempty"`
	RedirectURLGte          *string  `json:"redirectURLGTE,omitempty"`
	RedirectURLLt           *string  `json:"redirectURLLT,omitempty"`
	RedirectURLLte          *string  `json:"redirectURLLTE,omitempty"`
	RedirectURLContains     *string  `json:"redirectURLContains,omitempty"`
	RedirectURLHasPrefix    *string  `json:"redirectURLHasPrefix,omitempty"`
	RedirectURLHasSuffix    *string  `json:"redirectURLHasSuffix,omitempty"`
	RedirectURLEqualFold    *string  `json:"redirectURLEqualFold,omitempty"`
	RedirectURLContainsFold *string  `json:"redirectURLContainsFold,omitempty"`
	// scopes field predicates
	Scopes             *string  `json:"scopes,omitempty"`
	ScopesNeq          *string  `json:"scopesNEQ,omitempty"`
	ScopesIn           []string `json:"scopesIn,omitempty"`
	ScopesNotIn        []string `json:"scopesNotIn,omitempty"`
	ScopesGt           *string  `json:"scopesGT,omitempty"`
	ScopesGte          *string  `json:"scopesGTE,omitempty"`
	ScopesLt           *string  `json:"scopesLT,omitempty"`
	ScopesLte          *string  `json:"scopesLTE,omitempty"`
	ScopesContains     *string  `json:"scopesContains,omitempty"`
	ScopesHasPrefix    *string  `json:"scopesHasPrefix,omitempty"`
	ScopesHasSuffix    *string  `json:"scopesHasSuffix,omitempty"`
	ScopesEqualFold    *string  `json:"scopesEqualFold,omitempty"`
	ScopesContainsFold *string  `json:"scopesContainsFold,omitempty"`
	// auth_url field predicates
	AuthURL             *string  `json:"authURL,omitempty"`
	AuthURLNeq          *string  `json:"authURLNEQ,omitempty"`
	AuthURLIn           []string `json:"authURLIn,omitempty"`
	AuthURLNotIn        []string `json:"authURLNotIn,omitempty"`
	AuthURLGt           *string  `json:"authURLGT,omitempty"`
	AuthURLGte          *string  `json:"authURLGTE,omitempty"`
	AuthURLLt           *string  `json:"authURLLT,omitempty"`
	AuthURLLte          *string  `json:"authURLLTE,omitempty"`
	AuthURLContains     *string  `json:"authURLContains,omitempty"`
	AuthURLHasPrefix    *string  `json:"authURLHasPrefix,omitempty"`
	AuthURLHasSuffix    *string  `json:"authURLHasSuffix,omitempty"`
	AuthURLEqualFold    *string  `json:"authURLEqualFold,omitempty"`
	AuthURLContainsFold *string  `json:"authURLContainsFold,omitempty"`
	// token_url field predicates
	TokenURL             *string  `json:"tokenURL,omitempty"`
	TokenURLNeq          *string  `json:"tokenURLNEQ,omitempty"`
	TokenURLIn           []string `json:"tokenURLIn,omitempty"`
	TokenURLNotIn        []string `json:"tokenURLNotIn,omitempty"`
	TokenURLGt           *string  `json:"tokenURLGT,omitempty"`
	TokenURLGte          *string  `json:"tokenURLGTE,omitempty"`
	TokenURLLt           *string  `json:"tokenURLLT,omitempty"`
	TokenURLLte          *string  `json:"tokenURLLTE,omitempty"`
	TokenURLContains     *string  `json:"tokenURLContains,omitempty"`
	TokenURLHasPrefix    *string  `json:"tokenURLHasPrefix,omitempty"`
	TokenURLHasSuffix    *string  `json:"tokenURLHasSuffix,omitempty"`
	TokenURLEqualFold    *string  `json:"tokenURLEqualFold,omitempty"`
	TokenURLContainsFold *string  `json:"tokenURLContainsFold,omitempty"`
	// auth_style field predicates
	AuthStyle      *string  `json:"authStyle,omitempty"`
	AuthStyleNeq   *string  `json:"authStyleNEQ,omitempty"`
	AuthStyleIn    []string `json:"authStyleIn,omitempty"`
	AuthStyleNotIn []string `json:"authStyleNotIn,omitempty"`
	AuthStyleGt    *string  `json:"authStyleGT,omitempty"`
	AuthStyleGte   *string  `json:"authStyleGTE,omitempty"`
	AuthStyleLt    *string  `json:"authStyleLT,omitempty"`
	AuthStyleLte   *string  `json:"authStyleLTE,omitempty"`
	// info_url field predicates
	InfoURL             *string  `json:"infoURL,omitempty"`
	InfoURLNeq          *string  `json:"infoURLNEQ,omitempty"`
	InfoURLIn           []string `json:"infoURLIn,omitempty"`
	InfoURLNotIn        []string `json:"infoURLNotIn,omitempty"`
	InfoURLGt           *string  `json:"infoURLGT,omitempty"`
	InfoURLGte          *string  `json:"infoURLGTE,omitempty"`
	InfoURLLt           *string  `json:"infoURLLT,omitempty"`
	InfoURLLte          *string  `json:"infoURLLTE,omitempty"`
	InfoURLContains     *string  `json:"infoURLContains,omitempty"`
	InfoURLHasPrefix    *string  `json:"infoURLHasPrefix,omitempty"`
	InfoURLHasSuffix    *string  `json:"infoURLHasSuffix,omitempty"`
	InfoURLEqualFold    *string  `json:"infoURLEqualFold,omitempty"`
	InfoURLContainsFold *string  `json:"infoURLContainsFold,omitempty"`
}

type OauthProviderSearchResult struct {
	OauthProviders []*OauthProvider `json:"oauthProviders,omitempty"`
}

func (OauthProviderSearchResult) IsSearchResult() {}

// Return response for updateOauthProvider mutation
type OauthProviderUpdatePayload struct {
	// Updated oauthProvider
	OauthProvider *OauthProvider `json:"oauthProvider"`
}

// OauthProviderWhereInput is used for filtering OauthProvider objects.
// Input was generated by ent.
type OauthProviderWhereInput struct {
	Not *OauthProviderWhereInput   `json:"not,omitempty"`
	And []*OauthProviderWhereInput `json:"and,omitempty"`
	Or  []*OauthProviderWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// client_id field predicates
	ClientID             *string  `json:"clientID,omitempty"`
	ClientIdneq          *string  `json:"clientIDNEQ,omitempty"`
	ClientIDIn           []string `json:"clientIDIn,omitempty"`
	ClientIDNotIn        []string `json:"clientIDNotIn,omitempty"`
	ClientIdgt           *string  `json:"clientIDGT,omitempty"`
	ClientIdgte          *string  `json:"clientIDGTE,omitempty"`
	ClientIdlt           *string  `json:"clientIDLT,omitempty"`
	ClientIdlte          *string  `json:"clientIDLTE,omitempty"`
	ClientIDContains     *string  `json:"clientIDContains,omitempty"`
	ClientIDHasPrefix    *string  `json:"clientIDHasPrefix,omitempty"`
	ClientIDHasSuffix    *string  `json:"clientIDHasSuffix,omitempty"`
	ClientIDEqualFold    *string  `json:"clientIDEqualFold,omitempty"`
	ClientIDContainsFold *string  `json:"clientIDContainsFold,omitempty"`
	// client_secret field predicates
	ClientSecret             *string  `json:"clientSecret,omitempty"`
	ClientSecretNeq          *string  `json:"clientSecretNEQ,omitempty"`
	ClientSecretIn           []string `json:"clientSecretIn,omitempty"`
	ClientSecretNotIn        []string `json:"clientSecretNotIn,omitempty"`
	ClientSecretGt           *string  `json:"clientSecretGT,omitempty"`
	ClientSecretGte          *string  `json:"clientSecretGTE,omitempty"`
	ClientSecretLt           *string  `json:"clientSecretLT,omitempty"`
	ClientSecretLte          *string  `json:"clientSecretLTE,omitempty"`
	ClientSecretContains     *string  `json:"clientSecretContains,omitempty"`
	ClientSecretHasPrefix    *string  `json:"clientSecretHasPrefix,omitempty"`
	ClientSecretHasSuffix    *string  `json:"clientSecretHasSuffix,omitempty"`
	ClientSecretEqualFold    *string  `json:"clientSecretEqualFold,omitempty"`
	ClientSecretContainsFold *string  `json:"clientSecretContainsFold,omitempty"`
	// redirect_url field predicates
	RedirectURL             *string  `json:"redirectURL,omitempty"`
	RedirectURLNeq          *string  `json:"redirectURLNEQ,omitempty"`
	RedirectURLIn           []string `json:"redirectURLIn,omitempty"`
	RedirectURLNotIn        []string `json:"redirectURLNotIn,omitempty"`
	RedirectURLGt           *string  `json:"redirectURLGT,omitempty"`
	RedirectURLGte          *string  `json:"redirectURLGTE,omitempty"`
	RedirectURLLt           *string  `json:"redirectURLLT,omitempty"`
	RedirectURLLte          *string  `json:"redirectURLLTE,omitempty"`
	RedirectURLContains     *string  `json:"redirectURLContains,omitempty"`
	RedirectURLHasPrefix    *string  `json:"redirectURLHasPrefix,omitempty"`
	RedirectURLHasSuffix    *string  `json:"redirectURLHasSuffix,omitempty"`
	RedirectURLEqualFold    *string  `json:"redirectURLEqualFold,omitempty"`
	RedirectURLContainsFold *string  `json:"redirectURLContainsFold,omitempty"`
	// scopes field predicates
	Scopes             *string  `json:"scopes,omitempty"`
	ScopesNeq          *string  `json:"scopesNEQ,omitempty"`
	ScopesIn           []string `json:"scopesIn,omitempty"`
	ScopesNotIn        []string `json:"scopesNotIn,omitempty"`
	ScopesGt           *string  `json:"scopesGT,omitempty"`
	ScopesGte          *string  `json:"scopesGTE,omitempty"`
	ScopesLt           *string  `json:"scopesLT,omitempty"`
	ScopesLte          *string  `json:"scopesLTE,omitempty"`
	ScopesContains     *string  `json:"scopesContains,omitempty"`
	ScopesHasPrefix    *string  `json:"scopesHasPrefix,omitempty"`
	ScopesHasSuffix    *string  `json:"scopesHasSuffix,omitempty"`
	ScopesEqualFold    *string  `json:"scopesEqualFold,omitempty"`
	ScopesContainsFold *string  `json:"scopesContainsFold,omitempty"`
	// auth_url field predicates
	AuthURL             *string  `json:"authURL,omitempty"`
	AuthURLNeq          *string  `json:"authURLNEQ,omitempty"`
	AuthURLIn           []string `json:"authURLIn,omitempty"`
	AuthURLNotIn        []string `json:"authURLNotIn,omitempty"`
	AuthURLGt           *string  `json:"authURLGT,omitempty"`
	AuthURLGte          *string  `json:"authURLGTE,omitempty"`
	AuthURLLt           *string  `json:"authURLLT,omitempty"`
	AuthURLLte          *string  `json:"authURLLTE,omitempty"`
	AuthURLContains     *string  `json:"authURLContains,omitempty"`
	AuthURLHasPrefix    *string  `json:"authURLHasPrefix,omitempty"`
	AuthURLHasSuffix    *string  `json:"authURLHasSuffix,omitempty"`
	AuthURLEqualFold    *string  `json:"authURLEqualFold,omitempty"`
	AuthURLContainsFold *string  `json:"authURLContainsFold,omitempty"`
	// token_url field predicates
	TokenURL             *string  `json:"tokenURL,omitempty"`
	TokenURLNeq          *string  `json:"tokenURLNEQ,omitempty"`
	TokenURLIn           []string `json:"tokenURLIn,omitempty"`
	TokenURLNotIn        []string `json:"tokenURLNotIn,omitempty"`
	TokenURLGt           *string  `json:"tokenURLGT,omitempty"`
	TokenURLGte          *string  `json:"tokenURLGTE,omitempty"`
	TokenURLLt           *string  `json:"tokenURLLT,omitempty"`
	TokenURLLte          *string  `json:"tokenURLLTE,omitempty"`
	TokenURLContains     *string  `json:"tokenURLContains,omitempty"`
	TokenURLHasPrefix    *string  `json:"tokenURLHasPrefix,omitempty"`
	TokenURLHasSuffix    *string  `json:"tokenURLHasSuffix,omitempty"`
	TokenURLEqualFold    *string  `json:"tokenURLEqualFold,omitempty"`
	TokenURLContainsFold *string  `json:"tokenURLContainsFold,omitempty"`
	// auth_style field predicates
	AuthStyle      *string  `json:"authStyle,omitempty"`
	AuthStyleNeq   *string  `json:"authStyleNEQ,omitempty"`
	AuthStyleIn    []string `json:"authStyleIn,omitempty"`
	AuthStyleNotIn []string `json:"authStyleNotIn,omitempty"`
	AuthStyleGt    *string  `json:"authStyleGT,omitempty"`
	AuthStyleGte   *string  `json:"authStyleGTE,omitempty"`
	AuthStyleLt    *string  `json:"authStyleLT,omitempty"`
	AuthStyleLte   *string  `json:"authStyleLTE,omitempty"`
	// info_url field predicates
	InfoURL             *string  `json:"infoURL,omitempty"`
	InfoURLNeq          *string  `json:"infoURLNEQ,omitempty"`
	InfoURLIn           []string `json:"infoURLIn,omitempty"`
	InfoURLNotIn        []string `json:"infoURLNotIn,omitempty"`
	InfoURLGt           *string  `json:"infoURLGT,omitempty"`
	InfoURLGte          *string  `json:"infoURLGTE,omitempty"`
	InfoURLLt           *string  `json:"infoURLLT,omitempty"`
	InfoURLLte          *string  `json:"infoURLLTE,omitempty"`
	InfoURLContains     *string  `json:"infoURLContains,omitempty"`
	InfoURLHasPrefix    *string  `json:"infoURLHasPrefix,omitempty"`
	InfoURLHasSuffix    *string  `json:"infoURLHasSuffix,omitempty"`
	InfoURLEqualFold    *string  `json:"infoURLEqualFold,omitempty"`
	InfoURLContainsFold *string  `json:"infoURLContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type OhAuthTooToken struct {
	ID string `json:"id"`
	// tags associated with the object
	Tags                    []string       `json:"tags,omitempty"`
	ClientID                string         `json:"clientID"`
	Scopes                  []string       `json:"scopes,omitempty"`
	Nonce                   string         `json:"nonce"`
	ClaimsUserID            string         `json:"claimsUserID"`
	ClaimsUsername          string         `json:"claimsUsername"`
	ClaimsEmail             string         `json:"claimsEmail"`
	ClaimsEmailVerified     bool           `json:"claimsEmailVerified"`
	ClaimsGroups            []string       `json:"claimsGroups,omitempty"`
	ClaimsPreferredUsername string         `json:"claimsPreferredUsername"`
	ConnectorID             string         `json:"connectorID"`
	ConnectorData           []string       `json:"connectorData,omitempty"`
	LastUsed                time.Time      `json:"lastUsed"`
	Integration             []*Integration `json:"integration,omitempty"`
	Events                  []*Event       `json:"events,omitempty"`
}

func (OhAuthTooToken) IsNode() {}

// Return response for createBulkOhAuthTooToken mutation
type OhAuthTooTokenBulkCreatePayload struct {
	// Created ohAuthTooTokens
	OhAuthTooTokens []*OhAuthTooToken `json:"ohAuthTooTokens,omitempty"`
}

// A connection to a list of items.
type OhAuthTooTokenConnection struct {
	// A list of edges.
	Edges []*OhAuthTooTokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOhAuthTooToken mutation
type OhAuthTooTokenCreatePayload struct {
	// Created ohAuthTooToken
	OhAuthTooToken *OhAuthTooToken `json:"ohAuthTooToken"`
}

// Return response for deleteOhAuthTooToken mutation
type OhAuthTooTokenDeletePayload struct {
	// Deleted ohAuthTooToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OhAuthTooTokenEdge struct {
	// The item at the end of the edge.
	Node *OhAuthTooToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OhAuthTooTokenSearchResult struct {
	OhAuthTooTokens []*OhAuthTooToken `json:"ohAuthTooTokens,omitempty"`
}

func (OhAuthTooTokenSearchResult) IsSearchResult() {}

// Return response for updateOhAuthTooToken mutation
type OhAuthTooTokenUpdatePayload struct {
	// Updated ohAuthTooToken
	OhAuthTooToken *OhAuthTooToken `json:"ohAuthTooToken"`
}

// OhAuthTooTokenWhereInput is used for filtering OhAuthTooToken objects.
// Input was generated by ent.
type OhAuthTooTokenWhereInput struct {
	Not *OhAuthTooTokenWhereInput   `json:"not,omitempty"`
	And []*OhAuthTooTokenWhereInput `json:"and,omitempty"`
	Or  []*OhAuthTooTokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// client_id field predicates
	ClientID             *string  `json:"clientID,omitempty"`
	ClientIdneq          *string  `json:"clientIDNEQ,omitempty"`
	ClientIDIn           []string `json:"clientIDIn,omitempty"`
	ClientIDNotIn        []string `json:"clientIDNotIn,omitempty"`
	ClientIdgt           *string  `json:"clientIDGT,omitempty"`
	ClientIdgte          *string  `json:"clientIDGTE,omitempty"`
	ClientIdlt           *string  `json:"clientIDLT,omitempty"`
	ClientIdlte          *string  `json:"clientIDLTE,omitempty"`
	ClientIDContains     *string  `json:"clientIDContains,omitempty"`
	ClientIDHasPrefix    *string  `json:"clientIDHasPrefix,omitempty"`
	ClientIDHasSuffix    *string  `json:"clientIDHasSuffix,omitempty"`
	ClientIDEqualFold    *string  `json:"clientIDEqualFold,omitempty"`
	ClientIDContainsFold *string  `json:"clientIDContainsFold,omitempty"`
	// nonce field predicates
	Nonce             *string  `json:"nonce,omitempty"`
	NonceNeq          *string  `json:"nonceNEQ,omitempty"`
	NonceIn           []string `json:"nonceIn,omitempty"`
	NonceNotIn        []string `json:"nonceNotIn,omitempty"`
	NonceGt           *string  `json:"nonceGT,omitempty"`
	NonceGte          *string  `json:"nonceGTE,omitempty"`
	NonceLt           *string  `json:"nonceLT,omitempty"`
	NonceLte          *string  `json:"nonceLTE,omitempty"`
	NonceContains     *string  `json:"nonceContains,omitempty"`
	NonceHasPrefix    *string  `json:"nonceHasPrefix,omitempty"`
	NonceHasSuffix    *string  `json:"nonceHasSuffix,omitempty"`
	NonceEqualFold    *string  `json:"nonceEqualFold,omitempty"`
	NonceContainsFold *string  `json:"nonceContainsFold,omitempty"`
	// claims_user_id field predicates
	ClaimsUserID             *string  `json:"claimsUserID,omitempty"`
	ClaimsUserIdneq          *string  `json:"claimsUserIDNEQ,omitempty"`
	ClaimsUserIDIn           []string `json:"claimsUserIDIn,omitempty"`
	ClaimsUserIDNotIn        []string `json:"claimsUserIDNotIn,omitempty"`
	ClaimsUserIdgt           *string  `json:"claimsUserIDGT,omitempty"`
	ClaimsUserIdgte          *string  `json:"claimsUserIDGTE,omitempty"`
	ClaimsUserIdlt           *string  `json:"claimsUserIDLT,omitempty"`
	ClaimsUserIdlte          *string  `json:"claimsUserIDLTE,omitempty"`
	ClaimsUserIDContains     *string  `json:"claimsUserIDContains,omitempty"`
	ClaimsUserIDHasPrefix    *string  `json:"claimsUserIDHasPrefix,omitempty"`
	ClaimsUserIDHasSuffix    *string  `json:"claimsUserIDHasSuffix,omitempty"`
	ClaimsUserIDEqualFold    *string  `json:"claimsUserIDEqualFold,omitempty"`
	ClaimsUserIDContainsFold *string  `json:"claimsUserIDContainsFold,omitempty"`
	// claims_username field predicates
	ClaimsUsername             *string  `json:"claimsUsername,omitempty"`
	ClaimsUsernameNeq          *string  `json:"claimsUsernameNEQ,omitempty"`
	ClaimsUsernameIn           []string `json:"claimsUsernameIn,omitempty"`
	ClaimsUsernameNotIn        []string `json:"claimsUsernameNotIn,omitempty"`
	ClaimsUsernameGt           *string  `json:"claimsUsernameGT,omitempty"`
	ClaimsUsernameGte          *string  `json:"claimsUsernameGTE,omitempty"`
	ClaimsUsernameLt           *string  `json:"claimsUsernameLT,omitempty"`
	ClaimsUsernameLte          *string  `json:"claimsUsernameLTE,omitempty"`
	ClaimsUsernameContains     *string  `json:"claimsUsernameContains,omitempty"`
	ClaimsUsernameHasPrefix    *string  `json:"claimsUsernameHasPrefix,omitempty"`
	ClaimsUsernameHasSuffix    *string  `json:"claimsUsernameHasSuffix,omitempty"`
	ClaimsUsernameEqualFold    *string  `json:"claimsUsernameEqualFold,omitempty"`
	ClaimsUsernameContainsFold *string  `json:"claimsUsernameContainsFold,omitempty"`
	// claims_email field predicates
	ClaimsEmail             *string  `json:"claimsEmail,omitempty"`
	ClaimsEmailNeq          *string  `json:"claimsEmailNEQ,omitempty"`
	ClaimsEmailIn           []string `json:"claimsEmailIn,omitempty"`
	ClaimsEmailNotIn        []string `json:"claimsEmailNotIn,omitempty"`
	ClaimsEmailGt           *string  `json:"claimsEmailGT,omitempty"`
	ClaimsEmailGte          *string  `json:"claimsEmailGTE,omitempty"`
	ClaimsEmailLt           *string  `json:"claimsEmailLT,omitempty"`
	ClaimsEmailLte          *string  `json:"claimsEmailLTE,omitempty"`
	ClaimsEmailContains     *string  `json:"claimsEmailContains,omitempty"`
	ClaimsEmailHasPrefix    *string  `json:"claimsEmailHasPrefix,omitempty"`
	ClaimsEmailHasSuffix    *string  `json:"claimsEmailHasSuffix,omitempty"`
	ClaimsEmailEqualFold    *string  `json:"claimsEmailEqualFold,omitempty"`
	ClaimsEmailContainsFold *string  `json:"claimsEmailContainsFold,omitempty"`
	// claims_email_verified field predicates
	ClaimsEmailVerified    *bool `json:"claimsEmailVerified,omitempty"`
	ClaimsEmailVerifiedNeq *bool `json:"claimsEmailVerifiedNEQ,omitempty"`
	// claims_preferred_username field predicates
	ClaimsPreferredUsername             *string  `json:"claimsPreferredUsername,omitempty"`
	ClaimsPreferredUsernameNeq          *string  `json:"claimsPreferredUsernameNEQ,omitempty"`
	ClaimsPreferredUsernameIn           []string `json:"claimsPreferredUsernameIn,omitempty"`
	ClaimsPreferredUsernameNotIn        []string `json:"claimsPreferredUsernameNotIn,omitempty"`
	ClaimsPreferredUsernameGt           *string  `json:"claimsPreferredUsernameGT,omitempty"`
	ClaimsPreferredUsernameGte          *string  `json:"claimsPreferredUsernameGTE,omitempty"`
	ClaimsPreferredUsernameLt           *string  `json:"claimsPreferredUsernameLT,omitempty"`
	ClaimsPreferredUsernameLte          *string  `json:"claimsPreferredUsernameLTE,omitempty"`
	ClaimsPreferredUsernameContains     *string  `json:"claimsPreferredUsernameContains,omitempty"`
	ClaimsPreferredUsernameHasPrefix    *string  `json:"claimsPreferredUsernameHasPrefix,omitempty"`
	ClaimsPreferredUsernameHasSuffix    *string  `json:"claimsPreferredUsernameHasSuffix,omitempty"`
	ClaimsPreferredUsernameEqualFold    *string  `json:"claimsPreferredUsernameEqualFold,omitempty"`
	ClaimsPreferredUsernameContainsFold *string  `json:"claimsPreferredUsernameContainsFold,omitempty"`
	// connector_id field predicates
	ConnectorID             *string  `json:"connectorID,omitempty"`
	ConnectorIdneq          *string  `json:"connectorIDNEQ,omitempty"`
	ConnectorIDIn           []string `json:"connectorIDIn,omitempty"`
	ConnectorIDNotIn        []string `json:"connectorIDNotIn,omitempty"`
	ConnectorIdgt           *string  `json:"connectorIDGT,omitempty"`
	ConnectorIdgte          *string  `json:"connectorIDGTE,omitempty"`
	ConnectorIdlt           *string  `json:"connectorIDLT,omitempty"`
	ConnectorIdlte          *string  `json:"connectorIDLTE,omitempty"`
	ConnectorIDContains     *string  `json:"connectorIDContains,omitempty"`
	ConnectorIDHasPrefix    *string  `json:"connectorIDHasPrefix,omitempty"`
	ConnectorIDHasSuffix    *string  `json:"connectorIDHasSuffix,omitempty"`
	ConnectorIDEqualFold    *string  `json:"connectorIDEqualFold,omitempty"`
	ConnectorIDContainsFold *string  `json:"connectorIDContainsFold,omitempty"`
	// last_used field predicates
	LastUsed      *time.Time   `json:"lastUsed,omitempty"`
	LastUsedNeq   *time.Time   `json:"lastUsedNEQ,omitempty"`
	LastUsedIn    []*time.Time `json:"lastUsedIn,omitempty"`
	LastUsedNotIn []*time.Time `json:"lastUsedNotIn,omitempty"`
	LastUsedGt    *time.Time   `json:"lastUsedGT,omitempty"`
	LastUsedGte   *time.Time   `json:"lastUsedGTE,omitempty"`
	LastUsedLt    *time.Time   `json:"lastUsedLT,omitempty"`
	LastUsedLte   *time.Time   `json:"lastUsedLTE,omitempty"`
	// integration edge predicates
	HasIntegration     *bool                    `json:"hasIntegration,omitempty"`
	HasIntegrationWith []*IntegrationWhereInput `json:"hasIntegrationWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type OrgMembership struct {
	ID             string        `json:"id"`
	CreatedAt      *time.Time    `json:"createdAt,omitempty"`
	UpdatedAt      *time.Time    `json:"updatedAt,omitempty"`
	CreatedBy      *string       `json:"createdBy,omitempty"`
	UpdatedBy      *string       `json:"updatedBy,omitempty"`
	DeletedAt      *time.Time    `json:"deletedAt,omitempty"`
	DeletedBy      *string       `json:"deletedBy,omitempty"`
	Role           enums.Role    `json:"role"`
	OrganizationID string        `json:"organizationID"`
	UserID         string        `json:"userID"`
	Organization   *Organization `json:"organization"`
	User           *User         `json:"user"`
	Events         []*Event      `json:"events,omitempty"`
}

func (OrgMembership) IsNode() {}

// Return response for createBulkOrgMembership mutation
type OrgMembershipBulkCreatePayload struct {
	// Created orgMemberships
	OrgMemberships []*OrgMembership `json:"orgMemberships,omitempty"`
}

// A connection to a list of items.
type OrgMembershipConnection struct {
	// A list of edges.
	Edges []*OrgMembershipEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrgMembership mutation
type OrgMembershipCreatePayload struct {
	// Created orgMembership
	OrgMembership *OrgMembership `json:"orgMembership"`
}

// Return response for deleteOrgMembership mutation
type OrgMembershipDeletePayload struct {
	// Deleted orgMembership ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrgMembershipEdge struct {
	// The item at the end of the edge.
	Node *OrgMembership `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrgMembershipHistory struct {
	ID             string         `json:"id"`
	HistoryTime    time.Time      `json:"historyTime"`
	Ref            *string        `json:"ref,omitempty"`
	Operation      history.OpType `json:"operation"`
	CreatedAt      *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt      *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy      *string        `json:"createdBy,omitempty"`
	UpdatedBy      *string        `json:"updatedBy,omitempty"`
	DeletedAt      *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy      *string        `json:"deletedBy,omitempty"`
	Role           enums.Role     `json:"role"`
	OrganizationID string         `json:"organizationID"`
	UserID         string         `json:"userID"`
}

func (OrgMembershipHistory) IsNode() {}

// A connection to a list of items.
type OrgMembershipHistoryConnection struct {
	// A list of edges.
	Edges []*OrgMembershipHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrgMembershipHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrgMembershipHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// OrgMembershipHistoryWhereInput is used for filtering OrgMembershipHistory objects.
// Input was generated by ent.
type OrgMembershipHistoryWhereInput struct {
	Not *OrgMembershipHistoryWhereInput   `json:"not,omitempty"`
	And []*OrgMembershipHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrgMembershipHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// Return response for updateOrgMembership mutation
type OrgMembershipUpdatePayload struct {
	// Updated orgMembership
	OrgMembership *OrgMembership `json:"orgMembership"`
}

// OrgMembershipWhereInput is used for filtering OrgMembership objects.
// Input was generated by ent.
type OrgMembershipWhereInput struct {
	Not *OrgMembershipWhereInput   `json:"not,omitempty"`
	And []*OrgMembershipWhereInput `json:"and,omitempty"`
	Or  []*OrgMembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role           *enums.Role  `json:"role,omitempty"`
	RoleNeq        *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn         []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn      []enums.Role `json:"roleNotIn,omitempty"`
	OrganizationID *string      `json:"organizationID,omitempty"`
	UserID         *string      `json:"userID,omitempty"`
}

type Organization struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the name of the organization
	Name string `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// An optional description of the organization
	Description *string `json:"description,omitempty"`
	// orgs directly associated with a user
	PersonalOrg *bool `json:"personalOrg,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// Whether the organization has a dedicated database
	DedicatedDb             bool                      `json:"dedicatedDb"`
	Parent                  *Organization             `json:"parent,omitempty"`
	Children                *OrganizationConnection   `json:"children"`
	Groups                  []*Group                  `json:"groups,omitempty"`
	Templates               []*Template               `json:"templates,omitempty"`
	Integrations            []*Integration            `json:"integrations,omitempty"`
	Setting                 *OrganizationSetting      `json:"setting,omitempty"`
	Documentdata            []*DocumentData           `json:"documentdata,omitempty"`
	Entitlements            []*Entitlement            `json:"entitlements,omitempty"`
	OrganizationEntitlement []*Entitlement            `json:"organizationEntitlement,omitempty"`
	PersonalAccessTokens    []*PersonalAccessToken    `json:"personalAccessTokens,omitempty"`
	APITokens               []*APIToken               `json:"apiTokens,omitempty"`
	Oauthprovider           []*OauthProvider          `json:"oauthprovider,omitempty"`
	Users                   []*User                   `json:"users,omitempty"`
	Invites                 []*Invite                 `json:"invites,omitempty"`
	Subscribers             []*Subscriber             `json:"subscribers,omitempty"`
	Webhooks                []*Webhook                `json:"webhooks,omitempty"`
	Events                  []*Event                  `json:"events,omitempty"`
	Secrets                 []*Hush                   `json:"secrets,omitempty"`
	Features                []*Feature                `json:"features,omitempty"`
	Files                   []*File                   `json:"files,omitempty"`
	Entitlementplans        []*EntitlementPlan        `json:"entitlementplans,omitempty"`
	Entitlementplanfeatures []*EntitlementPlanFeature `json:"entitlementplanfeatures,omitempty"`
	Entities                []*Entity                 `json:"entities,omitempty"`
	Entitytypes             []*EntityType             `json:"entitytypes,omitempty"`
	Contacts                []*Contact                `json:"contacts,omitempty"`
	Notes                   []*Note                   `json:"notes,omitempty"`
	Tasks                   []*Task                   `json:"tasks,omitempty"`
	Programs                []*Program                `json:"programs,omitempty"`
	Members                 []*OrgMembership          `json:"members,omitempty"`
}

func (Organization) IsNode() {}

// Return response for createBulkOrganization mutation
type OrganizationBulkCreatePayload struct {
	// Created organizations
	Organizations []*Organization `json:"organizations,omitempty"`
}

// A connection to a list of items.
type OrganizationConnection struct {
	// A list of edges.
	Edges []*OrganizationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrganization mutation
type OrganizationCreatePayload struct {
	// Created organization
	Organization *Organization `json:"organization"`
}

// Return response for deleteOrganization mutation
type OrganizationDeletePayload struct {
	// Deleted organization ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrganizationEdge struct {
	// The item at the end of the edge.
	Node *Organization `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrganizationHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the name of the organization
	Name string `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// An optional description of the organization
	Description *string `json:"description,omitempty"`
	// orgs directly associated with a user
	PersonalOrg *bool `json:"personalOrg,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// Whether the organization has a dedicated database
	DedicatedDb bool `json:"dedicatedDb"`
}

func (OrganizationHistory) IsNode() {}

// A connection to a list of items.
type OrganizationHistoryConnection struct {
	// A list of edges.
	Edges []*OrganizationHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrganizationHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrganizationHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for OrganizationHistory connections
type OrganizationHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrganizationHistories.
	Field OrganizationHistoryOrderField `json:"field"`
}

// OrganizationHistoryWhereInput is used for filtering OrganizationHistory objects.
// Input was generated by ent.
type OrganizationHistoryWhereInput struct {
	Not *OrganizationHistoryWhereInput   `json:"not,omitempty"`
	And []*OrganizationHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrganizationHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// parent_organization_id field predicates
	ParentOrganizationID             *string  `json:"parentOrganizationID,omitempty"`
	ParentOrganizationIdneq          *string  `json:"parentOrganizationIDNEQ,omitempty"`
	ParentOrganizationIDIn           []string `json:"parentOrganizationIDIn,omitempty"`
	ParentOrganizationIDNotIn        []string `json:"parentOrganizationIDNotIn,omitempty"`
	ParentOrganizationIdgt           *string  `json:"parentOrganizationIDGT,omitempty"`
	ParentOrganizationIdgte          *string  `json:"parentOrganizationIDGTE,omitempty"`
	ParentOrganizationIdlt           *string  `json:"parentOrganizationIDLT,omitempty"`
	ParentOrganizationIdlte          *string  `json:"parentOrganizationIDLTE,omitempty"`
	ParentOrganizationIDContains     *string  `json:"parentOrganizationIDContains,omitempty"`
	ParentOrganizationIDHasPrefix    *string  `json:"parentOrganizationIDHasPrefix,omitempty"`
	ParentOrganizationIDHasSuffix    *string  `json:"parentOrganizationIDHasSuffix,omitempty"`
	ParentOrganizationIDIsNil        *bool    `json:"parentOrganizationIDIsNil,omitempty"`
	ParentOrganizationIDNotNil       *bool    `json:"parentOrganizationIDNotNil,omitempty"`
	ParentOrganizationIDEqualFold    *string  `json:"parentOrganizationIDEqualFold,omitempty"`
	ParentOrganizationIDContainsFold *string  `json:"parentOrganizationIDContainsFold,omitempty"`
	// personal_org field predicates
	PersonalOrg       *bool `json:"personalOrg,omitempty"`
	PersonalOrgNeq    *bool `json:"personalOrgNEQ,omitempty"`
	PersonalOrgIsNil  *bool `json:"personalOrgIsNil,omitempty"`
	PersonalOrgNotNil *bool `json:"personalOrgNotNil,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
}

// Ordering options for Organization connections
type OrganizationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Organizations.
	Field OrganizationOrderField `json:"field"`
}

type OrganizationSearchResult struct {
	Organizations []*Organization `json:"organizations,omitempty"`
}

func (OrganizationSearchResult) IsSearchResult() {}

type OrganizationSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// domains associated with the organization
	Domains []string `json:"domains,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone *string `json:"billingPhone,omitempty"`
	// Address to send billing information to
	BillingAddress *string `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation *enums.Region `json:"geoLocation,omitempty"`
	// the ID of the organization the settings belong to
	OrganizationID *string       `json:"organizationID,omitempty"`
	Organization   *Organization `json:"organization,omitempty"`
	Files          []*File       `json:"files,omitempty"`
}

func (OrganizationSetting) IsNode() {}

// Return response for createBulkOrganizationSetting mutation
type OrganizationSettingBulkCreatePayload struct {
	// Created organizationSettings
	OrganizationSettings []*OrganizationSetting `json:"organizationSettings,omitempty"`
}

// A connection to a list of items.
type OrganizationSettingConnection struct {
	// A list of edges.
	Edges []*OrganizationSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrganizationSetting mutation
type OrganizationSettingCreatePayload struct {
	// Created organizationSetting
	OrganizationSetting *OrganizationSetting `json:"organizationSetting"`
}

// Return response for deleteOrganizationSetting mutation
type OrganizationSettingDeletePayload struct {
	// Deleted organizationSetting ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrganizationSettingEdge struct {
	// The item at the end of the edge.
	Node *OrganizationSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrganizationSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// domains associated with the organization
	Domains []string `json:"domains,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone *string `json:"billingPhone,omitempty"`
	// Address to send billing information to
	BillingAddress *string `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation *enums.Region `json:"geoLocation,omitempty"`
	// the ID of the organization the settings belong to
	OrganizationID *string `json:"organizationID,omitempty"`
}

func (OrganizationSettingHistory) IsNode() {}

// A connection to a list of items.
type OrganizationSettingHistoryConnection struct {
	// A list of edges.
	Edges []*OrganizationSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrganizationSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrganizationSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// OrganizationSettingHistoryWhereInput is used for filtering OrganizationSettingHistory objects.
// Input was generated by ent.
type OrganizationSettingHistoryWhereInput struct {
	Not *OrganizationSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*OrganizationSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrganizationSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// billing_contact field predicates
	BillingContact             *string  `json:"billingContact,omitempty"`
	BillingContactNeq          *string  `json:"billingContactNEQ,omitempty"`
	BillingContactIn           []string `json:"billingContactIn,omitempty"`
	BillingContactNotIn        []string `json:"billingContactNotIn,omitempty"`
	BillingContactGt           *string  `json:"billingContactGT,omitempty"`
	BillingContactGte          *string  `json:"billingContactGTE,omitempty"`
	BillingContactLt           *string  `json:"billingContactLT,omitempty"`
	BillingContactLte          *string  `json:"billingContactLTE,omitempty"`
	BillingContactContains     *string  `json:"billingContactContains,omitempty"`
	BillingContactHasPrefix    *string  `json:"billingContactHasPrefix,omitempty"`
	BillingContactHasSuffix    *string  `json:"billingContactHasSuffix,omitempty"`
	BillingContactIsNil        *bool    `json:"billingContactIsNil,omitempty"`
	BillingContactNotNil       *bool    `json:"billingContactNotNil,omitempty"`
	BillingContactEqualFold    *string  `json:"billingContactEqualFold,omitempty"`
	BillingContactContainsFold *string  `json:"billingContactContainsFold,omitempty"`
	// billing_email field predicates
	BillingEmail             *string  `json:"billingEmail,omitempty"`
	BillingEmailNeq          *string  `json:"billingEmailNEQ,omitempty"`
	BillingEmailIn           []string `json:"billingEmailIn,omitempty"`
	BillingEmailNotIn        []string `json:"billingEmailNotIn,omitempty"`
	BillingEmailGt           *string  `json:"billingEmailGT,omitempty"`
	BillingEmailGte          *string  `json:"billingEmailGTE,omitempty"`
	BillingEmailLt           *string  `json:"billingEmailLT,omitempty"`
	BillingEmailLte          *string  `json:"billingEmailLTE,omitempty"`
	BillingEmailContains     *string  `json:"billingEmailContains,omitempty"`
	BillingEmailHasPrefix    *string  `json:"billingEmailHasPrefix,omitempty"`
	BillingEmailHasSuffix    *string  `json:"billingEmailHasSuffix,omitempty"`
	BillingEmailIsNil        *bool    `json:"billingEmailIsNil,omitempty"`
	BillingEmailNotNil       *bool    `json:"billingEmailNotNil,omitempty"`
	BillingEmailEqualFold    *string  `json:"billingEmailEqualFold,omitempty"`
	BillingEmailContainsFold *string  `json:"billingEmailContainsFold,omitempty"`
	// billing_phone field predicates
	BillingPhone             *string  `json:"billingPhone,omitempty"`
	BillingPhoneNeq          *string  `json:"billingPhoneNEQ,omitempty"`
	BillingPhoneIn           []string `json:"billingPhoneIn,omitempty"`
	BillingPhoneNotIn        []string `json:"billingPhoneNotIn,omitempty"`
	BillingPhoneGt           *string  `json:"billingPhoneGT,omitempty"`
	BillingPhoneGte          *string  `json:"billingPhoneGTE,omitempty"`
	BillingPhoneLt           *string  `json:"billingPhoneLT,omitempty"`
	BillingPhoneLte          *string  `json:"billingPhoneLTE,omitempty"`
	BillingPhoneContains     *string  `json:"billingPhoneContains,omitempty"`
	BillingPhoneHasPrefix    *string  `json:"billingPhoneHasPrefix,omitempty"`
	BillingPhoneHasSuffix    *string  `json:"billingPhoneHasSuffix,omitempty"`
	BillingPhoneIsNil        *bool    `json:"billingPhoneIsNil,omitempty"`
	BillingPhoneNotNil       *bool    `json:"billingPhoneNotNil,omitempty"`
	BillingPhoneEqualFold    *string  `json:"billingPhoneEqualFold,omitempty"`
	BillingPhoneContainsFold *string  `json:"billingPhoneContainsFold,omitempty"`
	// billing_address field predicates
	BillingAddress             *string  `json:"billingAddress,omitempty"`
	BillingAddressNeq          *string  `json:"billingAddressNEQ,omitempty"`
	BillingAddressIn           []string `json:"billingAddressIn,omitempty"`
	BillingAddressNotIn        []string `json:"billingAddressNotIn,omitempty"`
	BillingAddressGt           *string  `json:"billingAddressGT,omitempty"`
	BillingAddressGte          *string  `json:"billingAddressGTE,omitempty"`
	BillingAddressLt           *string  `json:"billingAddressLT,omitempty"`
	BillingAddressLte          *string  `json:"billingAddressLTE,omitempty"`
	BillingAddressContains     *string  `json:"billingAddressContains,omitempty"`
	BillingAddressHasPrefix    *string  `json:"billingAddressHasPrefix,omitempty"`
	BillingAddressHasSuffix    *string  `json:"billingAddressHasSuffix,omitempty"`
	BillingAddressIsNil        *bool    `json:"billingAddressIsNil,omitempty"`
	BillingAddressNotNil       *bool    `json:"billingAddressNotNil,omitempty"`
	BillingAddressEqualFold    *string  `json:"billingAddressEqualFold,omitempty"`
	BillingAddressContainsFold *string  `json:"billingAddressContainsFold,omitempty"`
	// tax_identifier field predicates
	TaxIdentifier             *string  `json:"taxIdentifier,omitempty"`
	TaxIdentifierNeq          *string  `json:"taxIdentifierNEQ,omitempty"`
	TaxIdentifierIn           []string `json:"taxIdentifierIn,omitempty"`
	TaxIdentifierNotIn        []string `json:"taxIdentifierNotIn,omitempty"`
	TaxIdentifierGt           *string  `json:"taxIdentifierGT,omitempty"`
	TaxIdentifierGte          *string  `json:"taxIdentifierGTE,omitempty"`
	TaxIdentifierLt           *string  `json:"taxIdentifierLT,omitempty"`
	TaxIdentifierLte          *string  `json:"taxIdentifierLTE,omitempty"`
	TaxIdentifierContains     *string  `json:"taxIdentifierContains,omitempty"`
	TaxIdentifierHasPrefix    *string  `json:"taxIdentifierHasPrefix,omitempty"`
	TaxIdentifierHasSuffix    *string  `json:"taxIdentifierHasSuffix,omitempty"`
	TaxIdentifierIsNil        *bool    `json:"taxIdentifierIsNil,omitempty"`
	TaxIdentifierNotNil       *bool    `json:"taxIdentifierNotNil,omitempty"`
	TaxIdentifierEqualFold    *string  `json:"taxIdentifierEqualFold,omitempty"`
	TaxIdentifierContainsFold *string  `json:"taxIdentifierContainsFold,omitempty"`
	// geo_location field predicates
	GeoLocation       *enums.Region  `json:"geoLocation,omitempty"`
	GeoLocationNeq    *enums.Region  `json:"geoLocationNEQ,omitempty"`
	GeoLocationIn     []enums.Region `json:"geoLocationIn,omitempty"`
	GeoLocationNotIn  []enums.Region `json:"geoLocationNotIn,omitempty"`
	GeoLocationIsNil  *bool          `json:"geoLocationIsNil,omitempty"`
	GeoLocationNotNil *bool          `json:"geoLocationNotNil,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        *bool    `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       *bool    `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
}

type OrganizationSettingSearchResult struct {
	OrganizationSettings []*OrganizationSetting `json:"organizationSettings,omitempty"`
}

func (OrganizationSettingSearchResult) IsSearchResult() {}

// Return response for updateOrganizationSetting mutation
type OrganizationSettingUpdatePayload struct {
	// Updated organizationSetting
	OrganizationSetting *OrganizationSetting `json:"organizationSetting"`
}

// OrganizationSettingWhereInput is used for filtering OrganizationSetting objects.
// Input was generated by ent.
type OrganizationSettingWhereInput struct {
	Not *OrganizationSettingWhereInput   `json:"not,omitempty"`
	And []*OrganizationSettingWhereInput `json:"and,omitempty"`
	Or  []*OrganizationSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// billing_contact field predicates
	BillingContact             *string  `json:"billingContact,omitempty"`
	BillingContactNeq          *string  `json:"billingContactNEQ,omitempty"`
	BillingContactIn           []string `json:"billingContactIn,omitempty"`
	BillingContactNotIn        []string `json:"billingContactNotIn,omitempty"`
	BillingContactGt           *string  `json:"billingContactGT,omitempty"`
	BillingContactGte          *string  `json:"billingContactGTE,omitempty"`
	BillingContactLt           *string  `json:"billingContactLT,omitempty"`
	BillingContactLte          *string  `json:"billingContactLTE,omitempty"`
	BillingContactContains     *string  `json:"billingContactContains,omitempty"`
	BillingContactHasPrefix    *string  `json:"billingContactHasPrefix,omitempty"`
	BillingContactHasSuffix    *string  `json:"billingContactHasSuffix,omitempty"`
	BillingContactIsNil        *bool    `json:"billingContactIsNil,omitempty"`
	BillingContactNotNil       *bool    `json:"billingContactNotNil,omitempty"`
	BillingContactEqualFold    *string  `json:"billingContactEqualFold,omitempty"`
	BillingContactContainsFold *string  `json:"billingContactContainsFold,omitempty"`
	// billing_email field predicates
	BillingEmail             *string  `json:"billingEmail,omitempty"`
	BillingEmailNeq          *string  `json:"billingEmailNEQ,omitempty"`
	BillingEmailIn           []string `json:"billingEmailIn,omitempty"`
	BillingEmailNotIn        []string `json:"billingEmailNotIn,omitempty"`
	BillingEmailGt           *string  `json:"billingEmailGT,omitempty"`
	BillingEmailGte          *string  `json:"billingEmailGTE,omitempty"`
	BillingEmailLt           *string  `json:"billingEmailLT,omitempty"`
	BillingEmailLte          *string  `json:"billingEmailLTE,omitempty"`
	BillingEmailContains     *string  `json:"billingEmailContains,omitempty"`
	BillingEmailHasPrefix    *string  `json:"billingEmailHasPrefix,omitempty"`
	BillingEmailHasSuffix    *string  `json:"billingEmailHasSuffix,omitempty"`
	BillingEmailIsNil        *bool    `json:"billingEmailIsNil,omitempty"`
	BillingEmailNotNil       *bool    `json:"billingEmailNotNil,omitempty"`
	BillingEmailEqualFold    *string  `json:"billingEmailEqualFold,omitempty"`
	BillingEmailContainsFold *string  `json:"billingEmailContainsFold,omitempty"`
	// billing_phone field predicates
	BillingPhone             *string  `json:"billingPhone,omitempty"`
	BillingPhoneNeq          *string  `json:"billingPhoneNEQ,omitempty"`
	BillingPhoneIn           []string `json:"billingPhoneIn,omitempty"`
	BillingPhoneNotIn        []string `json:"billingPhoneNotIn,omitempty"`
	BillingPhoneGt           *string  `json:"billingPhoneGT,omitempty"`
	BillingPhoneGte          *string  `json:"billingPhoneGTE,omitempty"`
	BillingPhoneLt           *string  `json:"billingPhoneLT,omitempty"`
	BillingPhoneLte          *string  `json:"billingPhoneLTE,omitempty"`
	BillingPhoneContains     *string  `json:"billingPhoneContains,omitempty"`
	BillingPhoneHasPrefix    *string  `json:"billingPhoneHasPrefix,omitempty"`
	BillingPhoneHasSuffix    *string  `json:"billingPhoneHasSuffix,omitempty"`
	BillingPhoneIsNil        *bool    `json:"billingPhoneIsNil,omitempty"`
	BillingPhoneNotNil       *bool    `json:"billingPhoneNotNil,omitempty"`
	BillingPhoneEqualFold    *string  `json:"billingPhoneEqualFold,omitempty"`
	BillingPhoneContainsFold *string  `json:"billingPhoneContainsFold,omitempty"`
	// billing_address field predicates
	BillingAddress             *string  `json:"billingAddress,omitempty"`
	BillingAddressNeq          *string  `json:"billingAddressNEQ,omitempty"`
	BillingAddressIn           []string `json:"billingAddressIn,omitempty"`
	BillingAddressNotIn        []string `json:"billingAddressNotIn,omitempty"`
	BillingAddressGt           *string  `json:"billingAddressGT,omitempty"`
	BillingAddressGte          *string  `json:"billingAddressGTE,omitempty"`
	BillingAddressLt           *string  `json:"billingAddressLT,omitempty"`
	BillingAddressLte          *string  `json:"billingAddressLTE,omitempty"`
	BillingAddressContains     *string  `json:"billingAddressContains,omitempty"`
	BillingAddressHasPrefix    *string  `json:"billingAddressHasPrefix,omitempty"`
	BillingAddressHasSuffix    *string  `json:"billingAddressHasSuffix,omitempty"`
	BillingAddressIsNil        *bool    `json:"billingAddressIsNil,omitempty"`
	BillingAddressNotNil       *bool    `json:"billingAddressNotNil,omitempty"`
	BillingAddressEqualFold    *string  `json:"billingAddressEqualFold,omitempty"`
	BillingAddressContainsFold *string  `json:"billingAddressContainsFold,omitempty"`
	// tax_identifier field predicates
	TaxIdentifier             *string  `json:"taxIdentifier,omitempty"`
	TaxIdentifierNeq          *string  `json:"taxIdentifierNEQ,omitempty"`
	TaxIdentifierIn           []string `json:"taxIdentifierIn,omitempty"`
	TaxIdentifierNotIn        []string `json:"taxIdentifierNotIn,omitempty"`
	TaxIdentifierGt           *string  `json:"taxIdentifierGT,omitempty"`
	TaxIdentifierGte          *string  `json:"taxIdentifierGTE,omitempty"`
	TaxIdentifierLt           *string  `json:"taxIdentifierLT,omitempty"`
	TaxIdentifierLte          *string  `json:"taxIdentifierLTE,omitempty"`
	TaxIdentifierContains     *string  `json:"taxIdentifierContains,omitempty"`
	TaxIdentifierHasPrefix    *string  `json:"taxIdentifierHasPrefix,omitempty"`
	TaxIdentifierHasSuffix    *string  `json:"taxIdentifierHasSuffix,omitempty"`
	TaxIdentifierIsNil        *bool    `json:"taxIdentifierIsNil,omitempty"`
	TaxIdentifierNotNil       *bool    `json:"taxIdentifierNotNil,omitempty"`
	TaxIdentifierEqualFold    *string  `json:"taxIdentifierEqualFold,omitempty"`
	TaxIdentifierContainsFold *string  `json:"taxIdentifierContainsFold,omitempty"`
	// geo_location field predicates
	GeoLocation       *enums.Region  `json:"geoLocation,omitempty"`
	GeoLocationNeq    *enums.Region  `json:"geoLocationNEQ,omitempty"`
	GeoLocationIn     []enums.Region `json:"geoLocationIn,omitempty"`
	GeoLocationNotIn  []enums.Region `json:"geoLocationNotIn,omitempty"`
	GeoLocationIsNil  *bool          `json:"geoLocationIsNil,omitempty"`
	GeoLocationNotNil *bool          `json:"geoLocationNotNil,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        *bool    `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       *bool    `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// Return response for updateOrganization mutation
type OrganizationUpdatePayload struct {
	// Updated organization
	Organization *Organization `json:"organization"`
}

// OrganizationWhereInput is used for filtering Organization objects.
// Input was generated by ent.
type OrganizationWhereInput struct {
	Not *OrganizationWhereInput   `json:"not,omitempty"`
	And []*OrganizationWhereInput `json:"and,omitempty"`
	Or  []*OrganizationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// parent_organization_id field predicates
	ParentOrganizationID             *string  `json:"parentOrganizationID,omitempty"`
	ParentOrganizationIdneq          *string  `json:"parentOrganizationIDNEQ,omitempty"`
	ParentOrganizationIDIn           []string `json:"parentOrganizationIDIn,omitempty"`
	ParentOrganizationIDNotIn        []string `json:"parentOrganizationIDNotIn,omitempty"`
	ParentOrganizationIdgt           *string  `json:"parentOrganizationIDGT,omitempty"`
	ParentOrganizationIdgte          *string  `json:"parentOrganizationIDGTE,omitempty"`
	ParentOrganizationIdlt           *string  `json:"parentOrganizationIDLT,omitempty"`
	ParentOrganizationIdlte          *string  `json:"parentOrganizationIDLTE,omitempty"`
	ParentOrganizationIDContains     *string  `json:"parentOrganizationIDContains,omitempty"`
	ParentOrganizationIDHasPrefix    *string  `json:"parentOrganizationIDHasPrefix,omitempty"`
	ParentOrganizationIDHasSuffix    *string  `json:"parentOrganizationIDHasSuffix,omitempty"`
	ParentOrganizationIDIsNil        *bool    `json:"parentOrganizationIDIsNil,omitempty"`
	ParentOrganizationIDNotNil       *bool    `json:"parentOrganizationIDNotNil,omitempty"`
	ParentOrganizationIDEqualFold    *string  `json:"parentOrganizationIDEqualFold,omitempty"`
	ParentOrganizationIDContainsFold *string  `json:"parentOrganizationIDContainsFold,omitempty"`
	// personal_org field predicates
	PersonalOrg       *bool `json:"personalOrg,omitempty"`
	PersonalOrgNeq    *bool `json:"personalOrgNEQ,omitempty"`
	PersonalOrgIsNil  *bool `json:"personalOrgIsNil,omitempty"`
	PersonalOrgNotNil *bool `json:"personalOrgNotNil,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// parent edge predicates
	HasParent     *bool                     `json:"hasParent,omitempty"`
	HasParentWith []*OrganizationWhereInput `json:"hasParentWith,omitempty"`
	// children edge predicates
	HasChildren     *bool                     `json:"hasChildren,omitempty"`
	HasChildrenWith []*OrganizationWhereInput `json:"hasChildrenWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// templates edge predicates
	HasTemplates     *bool                 `json:"hasTemplates,omitempty"`
	HasTemplatesWith []*TemplateWhereInput `json:"hasTemplatesWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                            `json:"hasSetting,omitempty"`
	HasSettingWith []*OrganizationSettingWhereInput `json:"hasSettingWith,omitempty"`
	// documentdata edge predicates
	HasDocumentdata     *bool                     `json:"hasDocumentdata,omitempty"`
	HasDocumentdataWith []*DocumentDataWhereInput `json:"hasDocumentdataWith,omitempty"`
	// entitlements edge predicates
	HasEntitlements     *bool                    `json:"hasEntitlements,omitempty"`
	HasEntitlementsWith []*EntitlementWhereInput `json:"hasEntitlementsWith,omitempty"`
	// organization_entitlement edge predicates
	HasOrganizationEntitlement     *bool                    `json:"hasOrganizationEntitlement,omitempty"`
	HasOrganizationEntitlementWith []*EntitlementWhereInput `json:"hasOrganizationEntitlementWith,omitempty"`
	// personal_access_tokens edge predicates
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`
	// api_tokens edge predicates
	HasAPITokens     *bool                 `json:"hasAPITokens,omitempty"`
	HasAPITokensWith []*APITokenWhereInput `json:"hasAPITokensWith,omitempty"`
	// oauthprovider edge predicates
	HasOauthprovider     *bool                      `json:"hasOauthprovider,omitempty"`
	HasOauthproviderWith []*OauthProviderWhereInput `json:"hasOauthproviderWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// invites edge predicates
	HasInvites     *bool               `json:"hasInvites,omitempty"`
	HasInvitesWith []*InviteWhereInput `json:"hasInvitesWith,omitempty"`
	// subscribers edge predicates
	HasSubscribers     *bool                   `json:"hasSubscribers,omitempty"`
	HasSubscribersWith []*SubscriberWhereInput `json:"hasSubscribersWith,omitempty"`
	// webhooks edge predicates
	HasWebhooks     *bool                `json:"hasWebhooks,omitempty"`
	HasWebhooksWith []*WebhookWhereInput `json:"hasWebhooksWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// secrets edge predicates
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`
	// features edge predicates
	HasFeatures     *bool                `json:"hasFeatures,omitempty"`
	HasFeaturesWith []*FeatureWhereInput `json:"hasFeaturesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// entitlementplans edge predicates
	HasEntitlementplans     *bool                        `json:"hasEntitlementplans,omitempty"`
	HasEntitlementplansWith []*EntitlementPlanWhereInput `json:"hasEntitlementplansWith,omitempty"`
	// entitlementplanfeatures edge predicates
	HasEntitlementplanfeatures     *bool                               `json:"hasEntitlementplanfeatures,omitempty"`
	HasEntitlementplanfeaturesWith []*EntitlementPlanFeatureWhereInput `json:"hasEntitlementplanfeaturesWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// entitytypes edge predicates
	HasEntitytypes     *bool                   `json:"hasEntitytypes,omitempty"`
	HasEntitytypesWith []*EntityTypeWhereInput `json:"hasEntitytypesWith,omitempty"`
	// contacts edge predicates
	HasContacts     *bool                `json:"hasContacts,omitempty"`
	HasContactsWith []*ContactWhereInput `json:"hasContactsWith,omitempty"`
	// notes edge predicates
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// members edge predicates
	HasMembers     *bool                      `json:"hasMembers,omitempty"`
	HasMembersWith []*OrgMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

type PersonalAccessToken struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name associated with the token
	Name  string `json:"name"`
	Token string `json:"token"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string    `json:"description,omitempty"`
	Scopes      []string   `json:"scopes,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	Owner       *User      `json:"owner"`
	// the organization(s) the token is associated with
	Organizations []*Organization `json:"organizations,omitempty"`
	Events        []*Event        `json:"events,omitempty"`
}

func (PersonalAccessToken) IsNode() {}

// Return response for createBulkPersonalAccessToken mutation
type PersonalAccessTokenBulkCreatePayload struct {
	// Created personalAccessTokens
	PersonalAccessTokens []*PersonalAccessToken `json:"personalAccessTokens,omitempty"`
}

// A connection to a list of items.
type PersonalAccessTokenConnection struct {
	// A list of edges.
	Edges []*PersonalAccessTokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createPersonalAccessToken mutation
type PersonalAccessTokenCreatePayload struct {
	// Created personalAccessToken
	PersonalAccessToken *PersonalAccessToken `json:"personalAccessToken"`
}

// Return response for deletePersonalAccessToken mutation
type PersonalAccessTokenDeletePayload struct {
	// Deleted personalAccessToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type PersonalAccessTokenEdge struct {
	// The item at the end of the edge.
	Node *PersonalAccessToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type PersonalAccessTokenSearchResult struct {
	PersonalAccessTokens []*PersonalAccessToken `json:"personalAccessTokens,omitempty"`
}

func (PersonalAccessTokenSearchResult) IsSearchResult() {}

// Return response for updatePersonalAccessToken mutation
type PersonalAccessTokenUpdatePayload struct {
	// Updated personalAccessToken
	PersonalAccessToken *PersonalAccessToken `json:"personalAccessToken"`
}

// PersonalAccessTokenWhereInput is used for filtering PersonalAccessToken objects.
// Input was generated by ent.
type PersonalAccessTokenWhereInput struct {
	Not *PersonalAccessTokenWhereInput   `json:"not,omitempty"`
	And []*PersonalAccessTokenWhereInput `json:"and,omitempty"`
	Or  []*PersonalAccessTokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
	// organizations edge predicates
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Procedure struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the procedure
	Name string `json:"name"`
	// description of the procedure
	Description *string `json:"description,omitempty"`
	// status of the procedure
	Status *string `json:"status,omitempty"`
	// type of the procedure
	ProcedureType *string `json:"procedureType,omitempty"`
	// version of the procedure
	Version *string `json:"version,omitempty"`
	// purpose and scope
	PurposeAndScope *string `json:"purposeAndScope,omitempty"`
	// background of the procedure
	Background *string `json:"background,omitempty"`
	// which controls are satisfied by the procedure
	Satisfies *string `json:"satisfies,omitempty"`
	// json data for the procedure document
	Details        map[string]interface{} `json:"details,omitempty"`
	Control        []*Control             `json:"control,omitempty"`
	Internalpolicy []*InternalPolicy      `json:"internalpolicy,omitempty"`
	Narratives     []*Narrative           `json:"narratives,omitempty"`
	Risks          []*Risk                `json:"risks,omitempty"`
	Tasks          []*Task                `json:"tasks,omitempty"`
	Programs       []*Program             `json:"programs,omitempty"`
}

func (Procedure) IsNode() {}

// Return response for createBulkProcedure mutation
type ProcedureBulkCreatePayload struct {
	// Created procedures
	Procedures []*Procedure `json:"procedures,omitempty"`
}

// A connection to a list of items.
type ProcedureConnection struct {
	// A list of edges.
	Edges []*ProcedureEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createProcedure mutation
type ProcedureCreatePayload struct {
	// Created procedure
	Procedure *Procedure `json:"procedure"`
}

// Return response for deleteProcedure mutation
type ProcedureDeletePayload struct {
	// Deleted procedure ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ProcedureEdge struct {
	// The item at the end of the edge.
	Node *Procedure `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ProcedureHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the procedure
	Name string `json:"name"`
	// description of the procedure
	Description *string `json:"description,omitempty"`
	// status of the procedure
	Status *string `json:"status,omitempty"`
	// type of the procedure
	ProcedureType *string `json:"procedureType,omitempty"`
	// version of the procedure
	Version *string `json:"version,omitempty"`
	// purpose and scope
	PurposeAndScope *string `json:"purposeAndScope,omitempty"`
	// background of the procedure
	Background *string `json:"background,omitempty"`
	// which controls are satisfied by the procedure
	Satisfies *string `json:"satisfies,omitempty"`
	// json data for the procedure document
	Details map[string]interface{} `json:"details,omitempty"`
}

func (ProcedureHistory) IsNode() {}

// A connection to a list of items.
type ProcedureHistoryConnection struct {
	// A list of edges.
	Edges []*ProcedureHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ProcedureHistoryEdge struct {
	// The item at the end of the edge.
	Node *ProcedureHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ProcedureHistoryWhereInput is used for filtering ProcedureHistory objects.
// Input was generated by ent.
type ProcedureHistoryWhereInput struct {
	Not *ProcedureHistoryWhereInput   `json:"not,omitempty"`
	And []*ProcedureHistoryWhereInput `json:"and,omitempty"`
	Or  []*ProcedureHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// procedure_type field predicates
	ProcedureType             *string  `json:"procedureType,omitempty"`
	ProcedureTypeNeq          *string  `json:"procedureTypeNEQ,omitempty"`
	ProcedureTypeIn           []string `json:"procedureTypeIn,omitempty"`
	ProcedureTypeNotIn        []string `json:"procedureTypeNotIn,omitempty"`
	ProcedureTypeGt           *string  `json:"procedureTypeGT,omitempty"`
	ProcedureTypeGte          *string  `json:"procedureTypeGTE,omitempty"`
	ProcedureTypeLt           *string  `json:"procedureTypeLT,omitempty"`
	ProcedureTypeLte          *string  `json:"procedureTypeLTE,omitempty"`
	ProcedureTypeContains     *string  `json:"procedureTypeContains,omitempty"`
	ProcedureTypeHasPrefix    *string  `json:"procedureTypeHasPrefix,omitempty"`
	ProcedureTypeHasSuffix    *string  `json:"procedureTypeHasSuffix,omitempty"`
	ProcedureTypeIsNil        *bool    `json:"procedureTypeIsNil,omitempty"`
	ProcedureTypeNotNil       *bool    `json:"procedureTypeNotNil,omitempty"`
	ProcedureTypeEqualFold    *string  `json:"procedureTypeEqualFold,omitempty"`
	ProcedureTypeContainsFold *string  `json:"procedureTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// purpose_and_scope field predicates
	PurposeAndScope             *string  `json:"purposeAndScope,omitempty"`
	PurposeAndScopeNeq          *string  `json:"purposeAndScopeNEQ,omitempty"`
	PurposeAndScopeIn           []string `json:"purposeAndScopeIn,omitempty"`
	PurposeAndScopeNotIn        []string `json:"purposeAndScopeNotIn,omitempty"`
	PurposeAndScopeGt           *string  `json:"purposeAndScopeGT,omitempty"`
	PurposeAndScopeGte          *string  `json:"purposeAndScopeGTE,omitempty"`
	PurposeAndScopeLt           *string  `json:"purposeAndScopeLT,omitempty"`
	PurposeAndScopeLte          *string  `json:"purposeAndScopeLTE,omitempty"`
	PurposeAndScopeContains     *string  `json:"purposeAndScopeContains,omitempty"`
	PurposeAndScopeHasPrefix    *string  `json:"purposeAndScopeHasPrefix,omitempty"`
	PurposeAndScopeHasSuffix    *string  `json:"purposeAndScopeHasSuffix,omitempty"`
	PurposeAndScopeIsNil        *bool    `json:"purposeAndScopeIsNil,omitempty"`
	PurposeAndScopeNotNil       *bool    `json:"purposeAndScopeNotNil,omitempty"`
	PurposeAndScopeEqualFold    *string  `json:"purposeAndScopeEqualFold,omitempty"`
	PurposeAndScopeContainsFold *string  `json:"purposeAndScopeContainsFold,omitempty"`
	// background field predicates
	Background             *string  `json:"background,omitempty"`
	BackgroundNeq          *string  `json:"backgroundNEQ,omitempty"`
	BackgroundIn           []string `json:"backgroundIn,omitempty"`
	BackgroundNotIn        []string `json:"backgroundNotIn,omitempty"`
	BackgroundGt           *string  `json:"backgroundGT,omitempty"`
	BackgroundGte          *string  `json:"backgroundGTE,omitempty"`
	BackgroundLt           *string  `json:"backgroundLT,omitempty"`
	BackgroundLte          *string  `json:"backgroundLTE,omitempty"`
	BackgroundContains     *string  `json:"backgroundContains,omitempty"`
	BackgroundHasPrefix    *string  `json:"backgroundHasPrefix,omitempty"`
	BackgroundHasSuffix    *string  `json:"backgroundHasSuffix,omitempty"`
	BackgroundIsNil        *bool    `json:"backgroundIsNil,omitempty"`
	BackgroundNotNil       *bool    `json:"backgroundNotNil,omitempty"`
	BackgroundEqualFold    *string  `json:"backgroundEqualFold,omitempty"`
	BackgroundContainsFold *string  `json:"backgroundContainsFold,omitempty"`
	// satisfies field predicates
	Satisfies             *string  `json:"satisfies,omitempty"`
	SatisfiesNeq          *string  `json:"satisfiesNEQ,omitempty"`
	SatisfiesIn           []string `json:"satisfiesIn,omitempty"`
	SatisfiesNotIn        []string `json:"satisfiesNotIn,omitempty"`
	SatisfiesGt           *string  `json:"satisfiesGT,omitempty"`
	SatisfiesGte          *string  `json:"satisfiesGTE,omitempty"`
	SatisfiesLt           *string  `json:"satisfiesLT,omitempty"`
	SatisfiesLte          *string  `json:"satisfiesLTE,omitempty"`
	SatisfiesContains     *string  `json:"satisfiesContains,omitempty"`
	SatisfiesHasPrefix    *string  `json:"satisfiesHasPrefix,omitempty"`
	SatisfiesHasSuffix    *string  `json:"satisfiesHasSuffix,omitempty"`
	SatisfiesIsNil        *bool    `json:"satisfiesIsNil,omitempty"`
	SatisfiesNotNil       *bool    `json:"satisfiesNotNil,omitempty"`
	SatisfiesEqualFold    *string  `json:"satisfiesEqualFold,omitempty"`
	SatisfiesContainsFold *string  `json:"satisfiesContainsFold,omitempty"`
}

type ProcedureSearchResult struct {
	Procedures []*Procedure `json:"procedures,omitempty"`
}

func (ProcedureSearchResult) IsSearchResult() {}

// Return response for updateProcedure mutation
type ProcedureUpdatePayload struct {
	// Updated procedure
	Procedure *Procedure `json:"procedure"`
}

// ProcedureWhereInput is used for filtering Procedure objects.
// Input was generated by ent.
type ProcedureWhereInput struct {
	Not *ProcedureWhereInput   `json:"not,omitempty"`
	And []*ProcedureWhereInput `json:"and,omitempty"`
	Or  []*ProcedureWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// procedure_type field predicates
	ProcedureType             *string  `json:"procedureType,omitempty"`
	ProcedureTypeNeq          *string  `json:"procedureTypeNEQ,omitempty"`
	ProcedureTypeIn           []string `json:"procedureTypeIn,omitempty"`
	ProcedureTypeNotIn        []string `json:"procedureTypeNotIn,omitempty"`
	ProcedureTypeGt           *string  `json:"procedureTypeGT,omitempty"`
	ProcedureTypeGte          *string  `json:"procedureTypeGTE,omitempty"`
	ProcedureTypeLt           *string  `json:"procedureTypeLT,omitempty"`
	ProcedureTypeLte          *string  `json:"procedureTypeLTE,omitempty"`
	ProcedureTypeContains     *string  `json:"procedureTypeContains,omitempty"`
	ProcedureTypeHasPrefix    *string  `json:"procedureTypeHasPrefix,omitempty"`
	ProcedureTypeHasSuffix    *string  `json:"procedureTypeHasSuffix,omitempty"`
	ProcedureTypeIsNil        *bool    `json:"procedureTypeIsNil,omitempty"`
	ProcedureTypeNotNil       *bool    `json:"procedureTypeNotNil,omitempty"`
	ProcedureTypeEqualFold    *string  `json:"procedureTypeEqualFold,omitempty"`
	ProcedureTypeContainsFold *string  `json:"procedureTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// purpose_and_scope field predicates
	PurposeAndScope             *string  `json:"purposeAndScope,omitempty"`
	PurposeAndScopeNeq          *string  `json:"purposeAndScopeNEQ,omitempty"`
	PurposeAndScopeIn           []string `json:"purposeAndScopeIn,omitempty"`
	PurposeAndScopeNotIn        []string `json:"purposeAndScopeNotIn,omitempty"`
	PurposeAndScopeGt           *string  `json:"purposeAndScopeGT,omitempty"`
	PurposeAndScopeGte          *string  `json:"purposeAndScopeGTE,omitempty"`
	PurposeAndScopeLt           *string  `json:"purposeAndScopeLT,omitempty"`
	PurposeAndScopeLte          *string  `json:"purposeAndScopeLTE,omitempty"`
	PurposeAndScopeContains     *string  `json:"purposeAndScopeContains,omitempty"`
	PurposeAndScopeHasPrefix    *string  `json:"purposeAndScopeHasPrefix,omitempty"`
	PurposeAndScopeHasSuffix    *string  `json:"purposeAndScopeHasSuffix,omitempty"`
	PurposeAndScopeIsNil        *bool    `json:"purposeAndScopeIsNil,omitempty"`
	PurposeAndScopeNotNil       *bool    `json:"purposeAndScopeNotNil,omitempty"`
	PurposeAndScopeEqualFold    *string  `json:"purposeAndScopeEqualFold,omitempty"`
	PurposeAndScopeContainsFold *string  `json:"purposeAndScopeContainsFold,omitempty"`
	// background field predicates
	Background             *string  `json:"background,omitempty"`
	BackgroundNeq          *string  `json:"backgroundNEQ,omitempty"`
	BackgroundIn           []string `json:"backgroundIn,omitempty"`
	BackgroundNotIn        []string `json:"backgroundNotIn,omitempty"`
	BackgroundGt           *string  `json:"backgroundGT,omitempty"`
	BackgroundGte          *string  `json:"backgroundGTE,omitempty"`
	BackgroundLt           *string  `json:"backgroundLT,omitempty"`
	BackgroundLte          *string  `json:"backgroundLTE,omitempty"`
	BackgroundContains     *string  `json:"backgroundContains,omitempty"`
	BackgroundHasPrefix    *string  `json:"backgroundHasPrefix,omitempty"`
	BackgroundHasSuffix    *string  `json:"backgroundHasSuffix,omitempty"`
	BackgroundIsNil        *bool    `json:"backgroundIsNil,omitempty"`
	BackgroundNotNil       *bool    `json:"backgroundNotNil,omitempty"`
	BackgroundEqualFold    *string  `json:"backgroundEqualFold,omitempty"`
	BackgroundContainsFold *string  `json:"backgroundContainsFold,omitempty"`
	// satisfies field predicates
	Satisfies             *string  `json:"satisfies,omitempty"`
	SatisfiesNeq          *string  `json:"satisfiesNEQ,omitempty"`
	SatisfiesIn           []string `json:"satisfiesIn,omitempty"`
	SatisfiesNotIn        []string `json:"satisfiesNotIn,omitempty"`
	SatisfiesGt           *string  `json:"satisfiesGT,omitempty"`
	SatisfiesGte          *string  `json:"satisfiesGTE,omitempty"`
	SatisfiesLt           *string  `json:"satisfiesLT,omitempty"`
	SatisfiesLte          *string  `json:"satisfiesLTE,omitempty"`
	SatisfiesContains     *string  `json:"satisfiesContains,omitempty"`
	SatisfiesHasPrefix    *string  `json:"satisfiesHasPrefix,omitempty"`
	SatisfiesHasSuffix    *string  `json:"satisfiesHasSuffix,omitempty"`
	SatisfiesIsNil        *bool    `json:"satisfiesIsNil,omitempty"`
	SatisfiesNotNil       *bool    `json:"satisfiesNotNil,omitempty"`
	SatisfiesEqualFold    *string  `json:"satisfiesEqualFold,omitempty"`
	SatisfiesContainsFold *string  `json:"satisfiesContainsFold,omitempty"`
	// control edge predicates
	HasControl     *bool                `json:"hasControl,omitempty"`
	HasControlWith []*ControlWhereInput `json:"hasControlWith,omitempty"`
	// internalpolicy edge predicates
	HasInternalpolicy     *bool                       `json:"hasInternalpolicy,omitempty"`
	HasInternalpolicyWith []*InternalPolicyWhereInput `json:"hasInternalpolicyWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

type Program struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the program
	Name string `json:"name"`
	// the description of the program
	Description *string `json:"description,omitempty"`
	// the status of the program
	Status enums.ProgramStatus `json:"status"`
	// the start date of the period
	StartDate *time.Time `json:"startDate,omitempty"`
	// the end date of the period
	EndDate *time.Time `json:"endDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady bool `json:"auditorReady"`
	// can the auditor write comments
	AuditorWriteComments bool `json:"auditorWriteComments"`
	// can the auditor read comments
	AuditorReadComments bool                `json:"auditorReadComments"`
	Owner               *Organization       `json:"owner,omitempty"`
	Controls            []*Control          `json:"controls,omitempty"`
	Subcontrols         []*Subcontrol       `json:"subcontrols,omitempty"`
	Controlobjectives   []*ControlObjective `json:"controlobjectives,omitempty"`
	Policies            []*InternalPolicy   `json:"policies,omitempty"`
	Procedures          []*Procedure        `json:"procedures,omitempty"`
	Risks               []*Risk             `json:"risks,omitempty"`
	Tasks               []*Task             `json:"tasks,omitempty"`
	Notes               []*Note             `json:"notes,omitempty"`
	Files               []*File             `json:"files,omitempty"`
	Narratives          []*Narrative        `json:"narratives,omitempty"`
	Actionplans         []*ActionPlan       `json:"actionplans,omitempty"`
	// the framework(s) that the program is based on
	Standards []*Standard          `json:"standards,omitempty"`
	Users     []*User              `json:"users,omitempty"`
	Members   []*ProgramMembership `json:"members,omitempty"`
}

func (Program) IsNode() {}

// Return response for createBulkProgram mutation
type ProgramBulkCreatePayload struct {
	// Created programs
	Programs []*Program `json:"programs,omitempty"`
}

// A connection to a list of items.
type ProgramConnection struct {
	// A list of edges.
	Edges []*ProgramEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createProgram mutation
type ProgramCreatePayload struct {
	// Created program
	Program *Program `json:"program"`
}

// Return response for deleteProgram mutation
type ProgramDeletePayload struct {
	// Deleted program ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ProgramEdge struct {
	// The item at the end of the edge.
	Node *Program `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ProgramHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the program
	Name string `json:"name"`
	// the description of the program
	Description *string `json:"description,omitempty"`
	// the status of the program
	Status enums.ProgramStatus `json:"status"`
	// the start date of the period
	StartDate *time.Time `json:"startDate,omitempty"`
	// the end date of the period
	EndDate *time.Time `json:"endDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady bool `json:"auditorReady"`
	// can the auditor write comments
	AuditorWriteComments bool `json:"auditorWriteComments"`
	// can the auditor read comments
	AuditorReadComments bool `json:"auditorReadComments"`
}

func (ProgramHistory) IsNode() {}

// A connection to a list of items.
type ProgramHistoryConnection struct {
	// A list of edges.
	Edges []*ProgramHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ProgramHistoryEdge struct {
	// The item at the end of the edge.
	Node *ProgramHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ProgramHistoryWhereInput is used for filtering ProgramHistory objects.
// Input was generated by ent.
type ProgramHistoryWhereInput struct {
	Not *ProgramHistoryWhereInput   `json:"not,omitempty"`
	And []*ProgramHistoryWhereInput `json:"and,omitempty"`
	Or  []*ProgramHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status      *enums.ProgramStatus  `json:"status,omitempty"`
	StatusNeq   *enums.ProgramStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ProgramStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ProgramStatus `json:"statusNotIn,omitempty"`
	// start_date field predicates
	StartDate       *time.Time   `json:"startDate,omitempty"`
	StartDateNeq    *time.Time   `json:"startDateNEQ,omitempty"`
	StartDateIn     []*time.Time `json:"startDateIn,omitempty"`
	StartDateNotIn  []*time.Time `json:"startDateNotIn,omitempty"`
	StartDateGt     *time.Time   `json:"startDateGT,omitempty"`
	StartDateGte    *time.Time   `json:"startDateGTE,omitempty"`
	StartDateLt     *time.Time   `json:"startDateLT,omitempty"`
	StartDateLte    *time.Time   `json:"startDateLTE,omitempty"`
	StartDateIsNil  *bool        `json:"startDateIsNil,omitempty"`
	StartDateNotNil *bool        `json:"startDateNotNil,omitempty"`
	// end_date field predicates
	EndDate       *time.Time   `json:"endDate,omitempty"`
	EndDateNeq    *time.Time   `json:"endDateNEQ,omitempty"`
	EndDateIn     []*time.Time `json:"endDateIn,omitempty"`
	EndDateNotIn  []*time.Time `json:"endDateNotIn,omitempty"`
	EndDateGt     *time.Time   `json:"endDateGT,omitempty"`
	EndDateGte    *time.Time   `json:"endDateGTE,omitempty"`
	EndDateLt     *time.Time   `json:"endDateLT,omitempty"`
	EndDateLte    *time.Time   `json:"endDateLTE,omitempty"`
	EndDateIsNil  *bool        `json:"endDateIsNil,omitempty"`
	EndDateNotNil *bool        `json:"endDateNotNil,omitempty"`
	// auditor_ready field predicates
	AuditorReady    *bool `json:"auditorReady,omitempty"`
	AuditorReadyNeq *bool `json:"auditorReadyNEQ,omitempty"`
	// auditor_write_comments field predicates
	AuditorWriteComments    *bool `json:"auditorWriteComments,omitempty"`
	AuditorWriteCommentsNeq *bool `json:"auditorWriteCommentsNEQ,omitempty"`
	// auditor_read_comments field predicates
	AuditorReadComments    *bool `json:"auditorReadComments,omitempty"`
	AuditorReadCommentsNeq *bool `json:"auditorReadCommentsNEQ,omitempty"`
}

type ProgramMembership struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	Role      enums.Role `json:"role"`
	ProgramID string     `json:"programID"`
	UserID    string     `json:"userID"`
	Program   *Program   `json:"program"`
	User      *User      `json:"user"`
}

func (ProgramMembership) IsNode() {}

// Return response for createBulkProgramMembership mutation
type ProgramMembershipBulkCreatePayload struct {
	// Created programMemberships
	ProgramMemberships []*ProgramMembership `json:"programMemberships,omitempty"`
}

// A connection to a list of items.
type ProgramMembershipConnection struct {
	// A list of edges.
	Edges []*ProgramMembershipEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createProgramMembership mutation
type ProgramMembershipCreatePayload struct {
	// Created programMembership
	ProgramMembership *ProgramMembership `json:"programMembership"`
}

// Return response for deleteProgramMembership mutation
type ProgramMembershipDeletePayload struct {
	// Deleted programMembership ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ProgramMembershipEdge struct {
	// The item at the end of the edge.
	Node *ProgramMembership `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ProgramMembershipHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	Role        enums.Role     `json:"role"`
	ProgramID   string         `json:"programID"`
	UserID      string         `json:"userID"`
}

func (ProgramMembershipHistory) IsNode() {}

// A connection to a list of items.
type ProgramMembershipHistoryConnection struct {
	// A list of edges.
	Edges []*ProgramMembershipHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ProgramMembershipHistoryEdge struct {
	// The item at the end of the edge.
	Node *ProgramMembershipHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ProgramMembershipHistoryWhereInput is used for filtering ProgramMembershipHistory objects.
// Input was generated by ent.
type ProgramMembershipHistoryWhereInput struct {
	Not *ProgramMembershipHistoryWhereInput   `json:"not,omitempty"`
	And []*ProgramMembershipHistoryWhereInput `json:"and,omitempty"`
	Or  []*ProgramMembershipHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// program_id field predicates
	ProgramID             *string  `json:"programID,omitempty"`
	ProgramIdneq          *string  `json:"programIDNEQ,omitempty"`
	ProgramIDIn           []string `json:"programIDIn,omitempty"`
	ProgramIDNotIn        []string `json:"programIDNotIn,omitempty"`
	ProgramIdgt           *string  `json:"programIDGT,omitempty"`
	ProgramIdgte          *string  `json:"programIDGTE,omitempty"`
	ProgramIdlt           *string  `json:"programIDLT,omitempty"`
	ProgramIdlte          *string  `json:"programIDLTE,omitempty"`
	ProgramIDContains     *string  `json:"programIDContains,omitempty"`
	ProgramIDHasPrefix    *string  `json:"programIDHasPrefix,omitempty"`
	ProgramIDHasSuffix    *string  `json:"programIDHasSuffix,omitempty"`
	ProgramIDEqualFold    *string  `json:"programIDEqualFold,omitempty"`
	ProgramIDContainsFold *string  `json:"programIDContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// Return response for updateProgramMembership mutation
type ProgramMembershipUpdatePayload struct {
	// Updated programMembership
	ProgramMembership *ProgramMembership `json:"programMembership"`
}

// ProgramMembershipWhereInput is used for filtering ProgramMembership objects.
// Input was generated by ent.
type ProgramMembershipWhereInput struct {
	Not *ProgramMembershipWhereInput   `json:"not,omitempty"`
	And []*ProgramMembershipWhereInput `json:"and,omitempty"`
	Or  []*ProgramMembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
}

type ProgramSearchResult struct {
	Programs []*Program `json:"programs,omitempty"`
}

func (ProgramSearchResult) IsSearchResult() {}

// Return response for updateProgram mutation
type ProgramUpdatePayload struct {
	// Updated program
	Program *Program `json:"program"`
}

// ProgramWhereInput is used for filtering Program objects.
// Input was generated by ent.
type ProgramWhereInput struct {
	Not *ProgramWhereInput   `json:"not,omitempty"`
	And []*ProgramWhereInput `json:"and,omitempty"`
	Or  []*ProgramWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status      *enums.ProgramStatus  `json:"status,omitempty"`
	StatusNeq   *enums.ProgramStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ProgramStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ProgramStatus `json:"statusNotIn,omitempty"`
	// start_date field predicates
	StartDate       *time.Time   `json:"startDate,omitempty"`
	StartDateNeq    *time.Time   `json:"startDateNEQ,omitempty"`
	StartDateIn     []*time.Time `json:"startDateIn,omitempty"`
	StartDateNotIn  []*time.Time `json:"startDateNotIn,omitempty"`
	StartDateGt     *time.Time   `json:"startDateGT,omitempty"`
	StartDateGte    *time.Time   `json:"startDateGTE,omitempty"`
	StartDateLt     *time.Time   `json:"startDateLT,omitempty"`
	StartDateLte    *time.Time   `json:"startDateLTE,omitempty"`
	StartDateIsNil  *bool        `json:"startDateIsNil,omitempty"`
	StartDateNotNil *bool        `json:"startDateNotNil,omitempty"`
	// end_date field predicates
	EndDate       *time.Time   `json:"endDate,omitempty"`
	EndDateNeq    *time.Time   `json:"endDateNEQ,omitempty"`
	EndDateIn     []*time.Time `json:"endDateIn,omitempty"`
	EndDateNotIn  []*time.Time `json:"endDateNotIn,omitempty"`
	EndDateGt     *time.Time   `json:"endDateGT,omitempty"`
	EndDateGte    *time.Time   `json:"endDateGTE,omitempty"`
	EndDateLt     *time.Time   `json:"endDateLT,omitempty"`
	EndDateLte    *time.Time   `json:"endDateLTE,omitempty"`
	EndDateIsNil  *bool        `json:"endDateIsNil,omitempty"`
	EndDateNotNil *bool        `json:"endDateNotNil,omitempty"`
	// auditor_ready field predicates
	AuditorReady    *bool `json:"auditorReady,omitempty"`
	AuditorReadyNeq *bool `json:"auditorReadyNEQ,omitempty"`
	// auditor_write_comments field predicates
	AuditorWriteComments    *bool `json:"auditorWriteComments,omitempty"`
	AuditorWriteCommentsNeq *bool `json:"auditorWriteCommentsNEQ,omitempty"`
	// auditor_read_comments field predicates
	AuditorReadComments    *bool `json:"auditorReadComments,omitempty"`
	AuditorReadCommentsNeq *bool `json:"auditorReadCommentsNEQ,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// controlobjectives edge predicates
	HasControlobjectives     *bool                         `json:"hasControlobjectives,omitempty"`
	HasControlobjectivesWith []*ControlObjectiveWhereInput `json:"hasControlobjectivesWith,omitempty"`
	// policies edge predicates
	HasPolicies     *bool                       `json:"hasPolicies,omitempty"`
	HasPoliciesWith []*InternalPolicyWhereInput `json:"hasPoliciesWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// notes edge predicates
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// actionplans edge predicates
	HasActionplans     *bool                   `json:"hasActionplans,omitempty"`
	HasActionplansWith []*ActionPlanWhereInput `json:"hasActionplansWith,omitempty"`
	// standards edge predicates
	HasStandards     *bool                 `json:"hasStandards,omitempty"`
	HasStandardsWith []*StandardWhereInput `json:"hasStandardsWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// members edge predicates
	HasMembers     *bool                          `json:"hasMembers,omitempty"`
	HasMembersWith []*ProgramMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

type Query struct {
}

type Risk struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the risk
	Name string `json:"name"`
	// description of the risk
	Description *string `json:"description,omitempty"`
	// status of the risk - mitigated or not, inflight, etc.
	Status *string `json:"status,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType *string `json:"riskType,omitempty"`
	// business costs associated with the risk
	BusinessCosts *string `json:"businessCosts,omitempty"`
	// impact of the risk - high, medium, low
	Impact *enums.RiskImpact `json:"impact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood *enums.RiskLikelihood `json:"likelihood,omitempty"`
	// mitigation for the risk
	Mitigation *string `json:"mitigation,omitempty"`
	// which controls are satisfied by the risk
	Satisfies *string `json:"satisfies,omitempty"`
	// json data for the risk document
	Details     map[string]interface{} `json:"details,omitempty"`
	Control     []*Control             `json:"control,omitempty"`
	Procedure   []*Procedure           `json:"procedure,omitempty"`
	Actionplans []*ActionPlan          `json:"actionplans,omitempty"`
	Program     []*Program             `json:"program,omitempty"`
}

func (Risk) IsNode() {}

// Return response for createBulkRisk mutation
type RiskBulkCreatePayload struct {
	// Created risks
	Risks []*Risk `json:"risks,omitempty"`
}

// A connection to a list of items.
type RiskConnection struct {
	// A list of edges.
	Edges []*RiskEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createRisk mutation
type RiskCreatePayload struct {
	// Created risk
	Risk *Risk `json:"risk"`
}

// Return response for deleteRisk mutation
type RiskDeletePayload struct {
	// Deleted risk ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type RiskEdge struct {
	// The item at the end of the edge.
	Node *Risk `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type RiskHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the risk
	Name string `json:"name"`
	// description of the risk
	Description *string `json:"description,omitempty"`
	// status of the risk - mitigated or not, inflight, etc.
	Status *string `json:"status,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType *string `json:"riskType,omitempty"`
	// business costs associated with the risk
	BusinessCosts *string `json:"businessCosts,omitempty"`
	// impact of the risk - high, medium, low
	Impact *enums.RiskImpact `json:"impact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood *enums.RiskLikelihood `json:"likelihood,omitempty"`
	// mitigation for the risk
	Mitigation *string `json:"mitigation,omitempty"`
	// which controls are satisfied by the risk
	Satisfies *string `json:"satisfies,omitempty"`
	// json data for the risk document
	Details map[string]interface{} `json:"details,omitempty"`
}

func (RiskHistory) IsNode() {}

// A connection to a list of items.
type RiskHistoryConnection struct {
	// A list of edges.
	Edges []*RiskHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type RiskHistoryEdge struct {
	// The item at the end of the edge.
	Node *RiskHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// RiskHistoryWhereInput is used for filtering RiskHistory objects.
// Input was generated by ent.
type RiskHistoryWhereInput struct {
	Not *RiskHistoryWhereInput   `json:"not,omitempty"`
	And []*RiskHistoryWhereInput `json:"and,omitempty"`
	Or  []*RiskHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// risk_type field predicates
	RiskType             *string  `json:"riskType,omitempty"`
	RiskTypeNeq          *string  `json:"riskTypeNEQ,omitempty"`
	RiskTypeIn           []string `json:"riskTypeIn,omitempty"`
	RiskTypeNotIn        []string `json:"riskTypeNotIn,omitempty"`
	RiskTypeGt           *string  `json:"riskTypeGT,omitempty"`
	RiskTypeGte          *string  `json:"riskTypeGTE,omitempty"`
	RiskTypeLt           *string  `json:"riskTypeLT,omitempty"`
	RiskTypeLte          *string  `json:"riskTypeLTE,omitempty"`
	RiskTypeContains     *string  `json:"riskTypeContains,omitempty"`
	RiskTypeHasPrefix    *string  `json:"riskTypeHasPrefix,omitempty"`
	RiskTypeHasSuffix    *string  `json:"riskTypeHasSuffix,omitempty"`
	RiskTypeIsNil        *bool    `json:"riskTypeIsNil,omitempty"`
	RiskTypeNotNil       *bool    `json:"riskTypeNotNil,omitempty"`
	RiskTypeEqualFold    *string  `json:"riskTypeEqualFold,omitempty"`
	RiskTypeContainsFold *string  `json:"riskTypeContainsFold,omitempty"`
	// business_costs field predicates
	BusinessCosts             *string  `json:"businessCosts,omitempty"`
	BusinessCostsNeq          *string  `json:"businessCostsNEQ,omitempty"`
	BusinessCostsIn           []string `json:"businessCostsIn,omitempty"`
	BusinessCostsNotIn        []string `json:"businessCostsNotIn,omitempty"`
	BusinessCostsGt           *string  `json:"businessCostsGT,omitempty"`
	BusinessCostsGte          *string  `json:"businessCostsGTE,omitempty"`
	BusinessCostsLt           *string  `json:"businessCostsLT,omitempty"`
	BusinessCostsLte          *string  `json:"businessCostsLTE,omitempty"`
	BusinessCostsContains     *string  `json:"businessCostsContains,omitempty"`
	BusinessCostsHasPrefix    *string  `json:"businessCostsHasPrefix,omitempty"`
	BusinessCostsHasSuffix    *string  `json:"businessCostsHasSuffix,omitempty"`
	BusinessCostsIsNil        *bool    `json:"businessCostsIsNil,omitempty"`
	BusinessCostsNotNil       *bool    `json:"businessCostsNotNil,omitempty"`
	BusinessCostsEqualFold    *string  `json:"businessCostsEqualFold,omitempty"`
	BusinessCostsContainsFold *string  `json:"businessCostsContainsFold,omitempty"`
	// impact field predicates
	Impact       *enums.RiskImpact  `json:"impact,omitempty"`
	ImpactNeq    *enums.RiskImpact  `json:"impactNEQ,omitempty"`
	ImpactIn     []enums.RiskImpact `json:"impactIn,omitempty"`
	ImpactNotIn  []enums.RiskImpact `json:"impactNotIn,omitempty"`
	ImpactIsNil  *bool              `json:"impactIsNil,omitempty"`
	ImpactNotNil *bool              `json:"impactNotNil,omitempty"`
	// likelihood field predicates
	Likelihood       *enums.RiskLikelihood  `json:"likelihood,omitempty"`
	LikelihoodNeq    *enums.RiskLikelihood  `json:"likelihoodNEQ,omitempty"`
	LikelihoodIn     []enums.RiskLikelihood `json:"likelihoodIn,omitempty"`
	LikelihoodNotIn  []enums.RiskLikelihood `json:"likelihoodNotIn,omitempty"`
	LikelihoodIsNil  *bool                  `json:"likelihoodIsNil,omitempty"`
	LikelihoodNotNil *bool                  `json:"likelihoodNotNil,omitempty"`
	// mitigation field predicates
	Mitigation             *string  `json:"mitigation,omitempty"`
	MitigationNeq          *string  `json:"mitigationNEQ,omitempty"`
	MitigationIn           []string `json:"mitigationIn,omitempty"`
	MitigationNotIn        []string `json:"mitigationNotIn,omitempty"`
	MitigationGt           *string  `json:"mitigationGT,omitempty"`
	MitigationGte          *string  `json:"mitigationGTE,omitempty"`
	MitigationLt           *string  `json:"mitigationLT,omitempty"`
	MitigationLte          *string  `json:"mitigationLTE,omitempty"`
	MitigationContains     *string  `json:"mitigationContains,omitempty"`
	MitigationHasPrefix    *string  `json:"mitigationHasPrefix,omitempty"`
	MitigationHasSuffix    *string  `json:"mitigationHasSuffix,omitempty"`
	MitigationIsNil        *bool    `json:"mitigationIsNil,omitempty"`
	MitigationNotNil       *bool    `json:"mitigationNotNil,omitempty"`
	MitigationEqualFold    *string  `json:"mitigationEqualFold,omitempty"`
	MitigationContainsFold *string  `json:"mitigationContainsFold,omitempty"`
	// satisfies field predicates
	Satisfies             *string  `json:"satisfies,omitempty"`
	SatisfiesNeq          *string  `json:"satisfiesNEQ,omitempty"`
	SatisfiesIn           []string `json:"satisfiesIn,omitempty"`
	SatisfiesNotIn        []string `json:"satisfiesNotIn,omitempty"`
	SatisfiesGt           *string  `json:"satisfiesGT,omitempty"`
	SatisfiesGte          *string  `json:"satisfiesGTE,omitempty"`
	SatisfiesLt           *string  `json:"satisfiesLT,omitempty"`
	SatisfiesLte          *string  `json:"satisfiesLTE,omitempty"`
	SatisfiesContains     *string  `json:"satisfiesContains,omitempty"`
	SatisfiesHasPrefix    *string  `json:"satisfiesHasPrefix,omitempty"`
	SatisfiesHasSuffix    *string  `json:"satisfiesHasSuffix,omitempty"`
	SatisfiesIsNil        *bool    `json:"satisfiesIsNil,omitempty"`
	SatisfiesNotNil       *bool    `json:"satisfiesNotNil,omitempty"`
	SatisfiesEqualFold    *string  `json:"satisfiesEqualFold,omitempty"`
	SatisfiesContainsFold *string  `json:"satisfiesContainsFold,omitempty"`
}

type RiskSearchResult struct {
	Risks []*Risk `json:"risks,omitempty"`
}

func (RiskSearchResult) IsSearchResult() {}

// Return response for updateRisk mutation
type RiskUpdatePayload struct {
	// Updated risk
	Risk *Risk `json:"risk"`
}

// RiskWhereInput is used for filtering Risk objects.
// Input was generated by ent.
type RiskWhereInput struct {
	Not *RiskWhereInput   `json:"not,omitempty"`
	And []*RiskWhereInput `json:"and,omitempty"`
	Or  []*RiskWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// risk_type field predicates
	RiskType             *string  `json:"riskType,omitempty"`
	RiskTypeNeq          *string  `json:"riskTypeNEQ,omitempty"`
	RiskTypeIn           []string `json:"riskTypeIn,omitempty"`
	RiskTypeNotIn        []string `json:"riskTypeNotIn,omitempty"`
	RiskTypeGt           *string  `json:"riskTypeGT,omitempty"`
	RiskTypeGte          *string  `json:"riskTypeGTE,omitempty"`
	RiskTypeLt           *string  `json:"riskTypeLT,omitempty"`
	RiskTypeLte          *string  `json:"riskTypeLTE,omitempty"`
	RiskTypeContains     *string  `json:"riskTypeContains,omitempty"`
	RiskTypeHasPrefix    *string  `json:"riskTypeHasPrefix,omitempty"`
	RiskTypeHasSuffix    *string  `json:"riskTypeHasSuffix,omitempty"`
	RiskTypeIsNil        *bool    `json:"riskTypeIsNil,omitempty"`
	RiskTypeNotNil       *bool    `json:"riskTypeNotNil,omitempty"`
	RiskTypeEqualFold    *string  `json:"riskTypeEqualFold,omitempty"`
	RiskTypeContainsFold *string  `json:"riskTypeContainsFold,omitempty"`
	// business_costs field predicates
	BusinessCosts             *string  `json:"businessCosts,omitempty"`
	BusinessCostsNeq          *string  `json:"businessCostsNEQ,omitempty"`
	BusinessCostsIn           []string `json:"businessCostsIn,omitempty"`
	BusinessCostsNotIn        []string `json:"businessCostsNotIn,omitempty"`
	BusinessCostsGt           *string  `json:"businessCostsGT,omitempty"`
	BusinessCostsGte          *string  `json:"businessCostsGTE,omitempty"`
	BusinessCostsLt           *string  `json:"businessCostsLT,omitempty"`
	BusinessCostsLte          *string  `json:"businessCostsLTE,omitempty"`
	BusinessCostsContains     *string  `json:"businessCostsContains,omitempty"`
	BusinessCostsHasPrefix    *string  `json:"businessCostsHasPrefix,omitempty"`
	BusinessCostsHasSuffix    *string  `json:"businessCostsHasSuffix,omitempty"`
	BusinessCostsIsNil        *bool    `json:"businessCostsIsNil,omitempty"`
	BusinessCostsNotNil       *bool    `json:"businessCostsNotNil,omitempty"`
	BusinessCostsEqualFold    *string  `json:"businessCostsEqualFold,omitempty"`
	BusinessCostsContainsFold *string  `json:"businessCostsContainsFold,omitempty"`
	// impact field predicates
	Impact       *enums.RiskImpact  `json:"impact,omitempty"`
	ImpactNeq    *enums.RiskImpact  `json:"impactNEQ,omitempty"`
	ImpactIn     []enums.RiskImpact `json:"impactIn,omitempty"`
	ImpactNotIn  []enums.RiskImpact `json:"impactNotIn,omitempty"`
	ImpactIsNil  *bool              `json:"impactIsNil,omitempty"`
	ImpactNotNil *bool              `json:"impactNotNil,omitempty"`
	// likelihood field predicates
	Likelihood       *enums.RiskLikelihood  `json:"likelihood,omitempty"`
	LikelihoodNeq    *enums.RiskLikelihood  `json:"likelihoodNEQ,omitempty"`
	LikelihoodIn     []enums.RiskLikelihood `json:"likelihoodIn,omitempty"`
	LikelihoodNotIn  []enums.RiskLikelihood `json:"likelihoodNotIn,omitempty"`
	LikelihoodIsNil  *bool                  `json:"likelihoodIsNil,omitempty"`
	LikelihoodNotNil *bool                  `json:"likelihoodNotNil,omitempty"`
	// mitigation field predicates
	Mitigation             *string  `json:"mitigation,omitempty"`
	MitigationNeq          *string  `json:"mitigationNEQ,omitempty"`
	MitigationIn           []string `json:"mitigationIn,omitempty"`
	MitigationNotIn        []string `json:"mitigationNotIn,omitempty"`
	MitigationGt           *string  `json:"mitigationGT,omitempty"`
	MitigationGte          *string  `json:"mitigationGTE,omitempty"`
	MitigationLt           *string  `json:"mitigationLT,omitempty"`
	MitigationLte          *string  `json:"mitigationLTE,omitempty"`
	MitigationContains     *string  `json:"mitigationContains,omitempty"`
	MitigationHasPrefix    *string  `json:"mitigationHasPrefix,omitempty"`
	MitigationHasSuffix    *string  `json:"mitigationHasSuffix,omitempty"`
	MitigationIsNil        *bool    `json:"mitigationIsNil,omitempty"`
	MitigationNotNil       *bool    `json:"mitigationNotNil,omitempty"`
	MitigationEqualFold    *string  `json:"mitigationEqualFold,omitempty"`
	MitigationContainsFold *string  `json:"mitigationContainsFold,omitempty"`
	// satisfies field predicates
	Satisfies             *string  `json:"satisfies,omitempty"`
	SatisfiesNeq          *string  `json:"satisfiesNEQ,omitempty"`
	SatisfiesIn           []string `json:"satisfiesIn,omitempty"`
	SatisfiesNotIn        []string `json:"satisfiesNotIn,omitempty"`
	SatisfiesGt           *string  `json:"satisfiesGT,omitempty"`
	SatisfiesGte          *string  `json:"satisfiesGTE,omitempty"`
	SatisfiesLt           *string  `json:"satisfiesLT,omitempty"`
	SatisfiesLte          *string  `json:"satisfiesLTE,omitempty"`
	SatisfiesContains     *string  `json:"satisfiesContains,omitempty"`
	SatisfiesHasPrefix    *string  `json:"satisfiesHasPrefix,omitempty"`
	SatisfiesHasSuffix    *string  `json:"satisfiesHasSuffix,omitempty"`
	SatisfiesIsNil        *bool    `json:"satisfiesIsNil,omitempty"`
	SatisfiesNotNil       *bool    `json:"satisfiesNotNil,omitempty"`
	SatisfiesEqualFold    *string  `json:"satisfiesEqualFold,omitempty"`
	SatisfiesContainsFold *string  `json:"satisfiesContainsFold,omitempty"`
	// control edge predicates
	HasControl     *bool                `json:"hasControl,omitempty"`
	HasControlWith []*ControlWhereInput `json:"hasControlWith,omitempty"`
	// procedure edge predicates
	HasProcedure     *bool                  `json:"hasProcedure,omitempty"`
	HasProcedureWith []*ProcedureWhereInput `json:"hasProcedureWith,omitempty"`
	// actionplans edge predicates
	HasActionplans     *bool                   `json:"hasActionplans,omitempty"`
	HasActionplansWith []*ActionPlanWhereInput `json:"hasActionplansWith,omitempty"`
	// program edge predicates
	HasProgram     *bool                `json:"hasProgram,omitempty"`
	HasProgramWith []*ProgramWhereInput `json:"hasProgramWith,omitempty"`
}

type SearchResultConnection struct {
	Page  *PageInfo      `json:"page"`
	Nodes []SearchResult `json:"nodes"`
}

type Standard struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the standard body, e.g. TSC, NIST, SOC, HITRUST, FedRamp, etc.
	Name string `json:"name"`
	// description of the standard
	Description *string `json:"description,omitempty"`
	// family of the standard, e.g. 800-53, 800-171, 27001, etc.
	Family *string `json:"family,omitempty"`
	// status of the standard - active, deprecated, etc.
	Status *string `json:"status,omitempty"`
	// type of the standard - security, privacy, etc.
	StandardType *string `json:"standardType,omitempty"`
	// version of the standard
	Version *string `json:"version,omitempty"`
	// purpose and scope
	PurposeAndScope *string `json:"purposeAndScope,omitempty"`
	// background of the standard
	Background *string `json:"background,omitempty"`
	// which controls are satisfied by the standard
	Satisfies *string `json:"satisfies,omitempty"`
	// json data with details of the standard
	Details           map[string]interface{} `json:"details,omitempty"`
	Controlobjectives []*ControlObjective    `json:"controlobjectives,omitempty"`
	Controls          []*Control             `json:"controls,omitempty"`
	Procedures        []*Procedure           `json:"procedures,omitempty"`
	Actionplans       []*ActionPlan          `json:"actionplans,omitempty"`
	Programs          []*Program             `json:"programs,omitempty"`
}

func (Standard) IsNode() {}

// Return response for createBulkStandard mutation
type StandardBulkCreatePayload struct {
	// Created standards
	Standards []*Standard `json:"standards,omitempty"`
}

// A connection to a list of items.
type StandardConnection struct {
	// A list of edges.
	Edges []*StandardEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createStandard mutation
type StandardCreatePayload struct {
	// Created standard
	Standard *Standard `json:"standard"`
}

// Return response for deleteStandard mutation
type StandardDeletePayload struct {
	// Deleted standard ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type StandardEdge struct {
	// The item at the end of the edge.
	Node *Standard `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type StandardHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the standard body, e.g. TSC, NIST, SOC, HITRUST, FedRamp, etc.
	Name string `json:"name"`
	// description of the standard
	Description *string `json:"description,omitempty"`
	// family of the standard, e.g. 800-53, 800-171, 27001, etc.
	Family *string `json:"family,omitempty"`
	// status of the standard - active, deprecated, etc.
	Status *string `json:"status,omitempty"`
	// type of the standard - security, privacy, etc.
	StandardType *string `json:"standardType,omitempty"`
	// version of the standard
	Version *string `json:"version,omitempty"`
	// purpose and scope
	PurposeAndScope *string `json:"purposeAndScope,omitempty"`
	// background of the standard
	Background *string `json:"background,omitempty"`
	// which controls are satisfied by the standard
	Satisfies *string `json:"satisfies,omitempty"`
	// json data with details of the standard
	Details map[string]interface{} `json:"details,omitempty"`
}

func (StandardHistory) IsNode() {}

// A connection to a list of items.
type StandardHistoryConnection struct {
	// A list of edges.
	Edges []*StandardHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type StandardHistoryEdge struct {
	// The item at the end of the edge.
	Node *StandardHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// StandardHistoryWhereInput is used for filtering StandardHistory objects.
// Input was generated by ent.
type StandardHistoryWhereInput struct {
	Not *StandardHistoryWhereInput   `json:"not,omitempty"`
	And []*StandardHistoryWhereInput `json:"and,omitempty"`
	Or  []*StandardHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// family field predicates
	Family             *string  `json:"family,omitempty"`
	FamilyNeq          *string  `json:"familyNEQ,omitempty"`
	FamilyIn           []string `json:"familyIn,omitempty"`
	FamilyNotIn        []string `json:"familyNotIn,omitempty"`
	FamilyGt           *string  `json:"familyGT,omitempty"`
	FamilyGte          *string  `json:"familyGTE,omitempty"`
	FamilyLt           *string  `json:"familyLT,omitempty"`
	FamilyLte          *string  `json:"familyLTE,omitempty"`
	FamilyContains     *string  `json:"familyContains,omitempty"`
	FamilyHasPrefix    *string  `json:"familyHasPrefix,omitempty"`
	FamilyHasSuffix    *string  `json:"familyHasSuffix,omitempty"`
	FamilyIsNil        *bool    `json:"familyIsNil,omitempty"`
	FamilyNotNil       *bool    `json:"familyNotNil,omitempty"`
	FamilyEqualFold    *string  `json:"familyEqualFold,omitempty"`
	FamilyContainsFold *string  `json:"familyContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// standard_type field predicates
	StandardType             *string  `json:"standardType,omitempty"`
	StandardTypeNeq          *string  `json:"standardTypeNEQ,omitempty"`
	StandardTypeIn           []string `json:"standardTypeIn,omitempty"`
	StandardTypeNotIn        []string `json:"standardTypeNotIn,omitempty"`
	StandardTypeGt           *string  `json:"standardTypeGT,omitempty"`
	StandardTypeGte          *string  `json:"standardTypeGTE,omitempty"`
	StandardTypeLt           *string  `json:"standardTypeLT,omitempty"`
	StandardTypeLte          *string  `json:"standardTypeLTE,omitempty"`
	StandardTypeContains     *string  `json:"standardTypeContains,omitempty"`
	StandardTypeHasPrefix    *string  `json:"standardTypeHasPrefix,omitempty"`
	StandardTypeHasSuffix    *string  `json:"standardTypeHasSuffix,omitempty"`
	StandardTypeIsNil        *bool    `json:"standardTypeIsNil,omitempty"`
	StandardTypeNotNil       *bool    `json:"standardTypeNotNil,omitempty"`
	StandardTypeEqualFold    *string  `json:"standardTypeEqualFold,omitempty"`
	StandardTypeContainsFold *string  `json:"standardTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// purpose_and_scope field predicates
	PurposeAndScope             *string  `json:"purposeAndScope,omitempty"`
	PurposeAndScopeNeq          *string  `json:"purposeAndScopeNEQ,omitempty"`
	PurposeAndScopeIn           []string `json:"purposeAndScopeIn,omitempty"`
	PurposeAndScopeNotIn        []string `json:"purposeAndScopeNotIn,omitempty"`
	PurposeAndScopeGt           *string  `json:"purposeAndScopeGT,omitempty"`
	PurposeAndScopeGte          *string  `json:"purposeAndScopeGTE,omitempty"`
	PurposeAndScopeLt           *string  `json:"purposeAndScopeLT,omitempty"`
	PurposeAndScopeLte          *string  `json:"purposeAndScopeLTE,omitempty"`
	PurposeAndScopeContains     *string  `json:"purposeAndScopeContains,omitempty"`
	PurposeAndScopeHasPrefix    *string  `json:"purposeAndScopeHasPrefix,omitempty"`
	PurposeAndScopeHasSuffix    *string  `json:"purposeAndScopeHasSuffix,omitempty"`
	PurposeAndScopeIsNil        *bool    `json:"purposeAndScopeIsNil,omitempty"`
	PurposeAndScopeNotNil       *bool    `json:"purposeAndScopeNotNil,omitempty"`
	PurposeAndScopeEqualFold    *string  `json:"purposeAndScopeEqualFold,omitempty"`
	PurposeAndScopeContainsFold *string  `json:"purposeAndScopeContainsFold,omitempty"`
	// background field predicates
	Background             *string  `json:"background,omitempty"`
	BackgroundNeq          *string  `json:"backgroundNEQ,omitempty"`
	BackgroundIn           []string `json:"backgroundIn,omitempty"`
	BackgroundNotIn        []string `json:"backgroundNotIn,omitempty"`
	BackgroundGt           *string  `json:"backgroundGT,omitempty"`
	BackgroundGte          *string  `json:"backgroundGTE,omitempty"`
	BackgroundLt           *string  `json:"backgroundLT,omitempty"`
	BackgroundLte          *string  `json:"backgroundLTE,omitempty"`
	BackgroundContains     *string  `json:"backgroundContains,omitempty"`
	BackgroundHasPrefix    *string  `json:"backgroundHasPrefix,omitempty"`
	BackgroundHasSuffix    *string  `json:"backgroundHasSuffix,omitempty"`
	BackgroundIsNil        *bool    `json:"backgroundIsNil,omitempty"`
	BackgroundNotNil       *bool    `json:"backgroundNotNil,omitempty"`
	BackgroundEqualFold    *string  `json:"backgroundEqualFold,omitempty"`
	BackgroundContainsFold *string  `json:"backgroundContainsFold,omitempty"`
	// satisfies field predicates
	Satisfies             *string  `json:"satisfies,omitempty"`
	SatisfiesNeq          *string  `json:"satisfiesNEQ,omitempty"`
	SatisfiesIn           []string `json:"satisfiesIn,omitempty"`
	SatisfiesNotIn        []string `json:"satisfiesNotIn,omitempty"`
	SatisfiesGt           *string  `json:"satisfiesGT,omitempty"`
	SatisfiesGte          *string  `json:"satisfiesGTE,omitempty"`
	SatisfiesLt           *string  `json:"satisfiesLT,omitempty"`
	SatisfiesLte          *string  `json:"satisfiesLTE,omitempty"`
	SatisfiesContains     *string  `json:"satisfiesContains,omitempty"`
	SatisfiesHasPrefix    *string  `json:"satisfiesHasPrefix,omitempty"`
	SatisfiesHasSuffix    *string  `json:"satisfiesHasSuffix,omitempty"`
	SatisfiesIsNil        *bool    `json:"satisfiesIsNil,omitempty"`
	SatisfiesNotNil       *bool    `json:"satisfiesNotNil,omitempty"`
	SatisfiesEqualFold    *string  `json:"satisfiesEqualFold,omitempty"`
	SatisfiesContainsFold *string  `json:"satisfiesContainsFold,omitempty"`
}

type StandardSearchResult struct {
	Standards []*Standard `json:"standards,omitempty"`
}

func (StandardSearchResult) IsSearchResult() {}

// Return response for updateStandard mutation
type StandardUpdatePayload struct {
	// Updated standard
	Standard *Standard `json:"standard"`
}

// StandardWhereInput is used for filtering Standard objects.
// Input was generated by ent.
type StandardWhereInput struct {
	Not *StandardWhereInput   `json:"not,omitempty"`
	And []*StandardWhereInput `json:"and,omitempty"`
	Or  []*StandardWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// family field predicates
	Family             *string  `json:"family,omitempty"`
	FamilyNeq          *string  `json:"familyNEQ,omitempty"`
	FamilyIn           []string `json:"familyIn,omitempty"`
	FamilyNotIn        []string `json:"familyNotIn,omitempty"`
	FamilyGt           *string  `json:"familyGT,omitempty"`
	FamilyGte          *string  `json:"familyGTE,omitempty"`
	FamilyLt           *string  `json:"familyLT,omitempty"`
	FamilyLte          *string  `json:"familyLTE,omitempty"`
	FamilyContains     *string  `json:"familyContains,omitempty"`
	FamilyHasPrefix    *string  `json:"familyHasPrefix,omitempty"`
	FamilyHasSuffix    *string  `json:"familyHasSuffix,omitempty"`
	FamilyIsNil        *bool    `json:"familyIsNil,omitempty"`
	FamilyNotNil       *bool    `json:"familyNotNil,omitempty"`
	FamilyEqualFold    *string  `json:"familyEqualFold,omitempty"`
	FamilyContainsFold *string  `json:"familyContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// standard_type field predicates
	StandardType             *string  `json:"standardType,omitempty"`
	StandardTypeNeq          *string  `json:"standardTypeNEQ,omitempty"`
	StandardTypeIn           []string `json:"standardTypeIn,omitempty"`
	StandardTypeNotIn        []string `json:"standardTypeNotIn,omitempty"`
	StandardTypeGt           *string  `json:"standardTypeGT,omitempty"`
	StandardTypeGte          *string  `json:"standardTypeGTE,omitempty"`
	StandardTypeLt           *string  `json:"standardTypeLT,omitempty"`
	StandardTypeLte          *string  `json:"standardTypeLTE,omitempty"`
	StandardTypeContains     *string  `json:"standardTypeContains,omitempty"`
	StandardTypeHasPrefix    *string  `json:"standardTypeHasPrefix,omitempty"`
	StandardTypeHasSuffix    *string  `json:"standardTypeHasSuffix,omitempty"`
	StandardTypeIsNil        *bool    `json:"standardTypeIsNil,omitempty"`
	StandardTypeNotNil       *bool    `json:"standardTypeNotNil,omitempty"`
	StandardTypeEqualFold    *string  `json:"standardTypeEqualFold,omitempty"`
	StandardTypeContainsFold *string  `json:"standardTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// purpose_and_scope field predicates
	PurposeAndScope             *string  `json:"purposeAndScope,omitempty"`
	PurposeAndScopeNeq          *string  `json:"purposeAndScopeNEQ,omitempty"`
	PurposeAndScopeIn           []string `json:"purposeAndScopeIn,omitempty"`
	PurposeAndScopeNotIn        []string `json:"purposeAndScopeNotIn,omitempty"`
	PurposeAndScopeGt           *string  `json:"purposeAndScopeGT,omitempty"`
	PurposeAndScopeGte          *string  `json:"purposeAndScopeGTE,omitempty"`
	PurposeAndScopeLt           *string  `json:"purposeAndScopeLT,omitempty"`
	PurposeAndScopeLte          *string  `json:"purposeAndScopeLTE,omitempty"`
	PurposeAndScopeContains     *string  `json:"purposeAndScopeContains,omitempty"`
	PurposeAndScopeHasPrefix    *string  `json:"purposeAndScopeHasPrefix,omitempty"`
	PurposeAndScopeHasSuffix    *string  `json:"purposeAndScopeHasSuffix,omitempty"`
	PurposeAndScopeIsNil        *bool    `json:"purposeAndScopeIsNil,omitempty"`
	PurposeAndScopeNotNil       *bool    `json:"purposeAndScopeNotNil,omitempty"`
	PurposeAndScopeEqualFold    *string  `json:"purposeAndScopeEqualFold,omitempty"`
	PurposeAndScopeContainsFold *string  `json:"purposeAndScopeContainsFold,omitempty"`
	// background field predicates
	Background             *string  `json:"background,omitempty"`
	BackgroundNeq          *string  `json:"backgroundNEQ,omitempty"`
	BackgroundIn           []string `json:"backgroundIn,omitempty"`
	BackgroundNotIn        []string `json:"backgroundNotIn,omitempty"`
	BackgroundGt           *string  `json:"backgroundGT,omitempty"`
	BackgroundGte          *string  `json:"backgroundGTE,omitempty"`
	BackgroundLt           *string  `json:"backgroundLT,omitempty"`
	BackgroundLte          *string  `json:"backgroundLTE,omitempty"`
	BackgroundContains     *string  `json:"backgroundContains,omitempty"`
	BackgroundHasPrefix    *string  `json:"backgroundHasPrefix,omitempty"`
	BackgroundHasSuffix    *string  `json:"backgroundHasSuffix,omitempty"`
	BackgroundIsNil        *bool    `json:"backgroundIsNil,omitempty"`
	BackgroundNotNil       *bool    `json:"backgroundNotNil,omitempty"`
	BackgroundEqualFold    *string  `json:"backgroundEqualFold,omitempty"`
	BackgroundContainsFold *string  `json:"backgroundContainsFold,omitempty"`
	// satisfies field predicates
	Satisfies             *string  `json:"satisfies,omitempty"`
	SatisfiesNeq          *string  `json:"satisfiesNEQ,omitempty"`
	SatisfiesIn           []string `json:"satisfiesIn,omitempty"`
	SatisfiesNotIn        []string `json:"satisfiesNotIn,omitempty"`
	SatisfiesGt           *string  `json:"satisfiesGT,omitempty"`
	SatisfiesGte          *string  `json:"satisfiesGTE,omitempty"`
	SatisfiesLt           *string  `json:"satisfiesLT,omitempty"`
	SatisfiesLte          *string  `json:"satisfiesLTE,omitempty"`
	SatisfiesContains     *string  `json:"satisfiesContains,omitempty"`
	SatisfiesHasPrefix    *string  `json:"satisfiesHasPrefix,omitempty"`
	SatisfiesHasSuffix    *string  `json:"satisfiesHasSuffix,omitempty"`
	SatisfiesIsNil        *bool    `json:"satisfiesIsNil,omitempty"`
	SatisfiesNotNil       *bool    `json:"satisfiesNotNil,omitempty"`
	SatisfiesEqualFold    *string  `json:"satisfiesEqualFold,omitempty"`
	SatisfiesContainsFold *string  `json:"satisfiesContainsFold,omitempty"`
	// controlobjectives edge predicates
	HasControlobjectives     *bool                         `json:"hasControlobjectives,omitempty"`
	HasControlobjectivesWith []*ControlObjectiveWhereInput `json:"hasControlobjectivesWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// actionplans edge predicates
	HasActionplans     *bool                   `json:"hasActionplans,omitempty"`
	HasActionplansWith []*ActionPlanWhereInput `json:"hasActionplansWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

type Subcontrol struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the subcontrol
	Name string `json:"name"`
	// description of the subcontrol
	Description *string `json:"description,omitempty"`
	// status of the subcontrol
	Status *string `json:"status,omitempty"`
	// type of the subcontrol
	SubcontrolType *string `json:"subcontrolType,omitempty"`
	// version of the control
	Version *string `json:"version,omitempty"`
	// number of the subcontrol
	SubcontrolNumber *string `json:"subcontrolNumber,omitempty"`
	// subcontrol family
	Family *string `json:"family,omitempty"`
	// subcontrol class
	Class *string `json:"class,omitempty"`
	// source of the control, e.g. framework, template, user-defined, etc.
	Source *string `json:"source,omitempty"`
	// mapped frameworks that the subcontrol is part of
	MappedFrameworks *string `json:"mappedFrameworks,omitempty"`
	// implementation evidence of the subcontrol
	ImplementationEvidence *string `json:"implementationEvidence,omitempty"`
	// implementation status
	ImplementationStatus *string `json:"implementationStatus,omitempty"`
	// date the subcontrol was implemented
	ImplementationDate *time.Time `json:"implementationDate,omitempty"`
	// implementation verification
	ImplementationVerification *string `json:"implementationVerification,omitempty"`
	// date the subcontrol implementation was verified
	ImplementationVerificationDate *time.Time `json:"implementationVerificationDate,omitempty"`
	// json data details of the subcontrol
	Details  map[string]interface{} `json:"details,omitempty"`
	Control  []*Control             `json:"control,omitempty"`
	User     []*User                `json:"user,omitempty"`
	Tasks    []*Task                `json:"tasks,omitempty"`
	Notes    *Note                  `json:"notes,omitempty"`
	Programs []*Program             `json:"programs,omitempty"`
}

func (Subcontrol) IsNode() {}

// Return response for createBulkSubcontrol mutation
type SubcontrolBulkCreatePayload struct {
	// Created subcontrols
	Subcontrols []*Subcontrol `json:"subcontrols,omitempty"`
}

// A connection to a list of items.
type SubcontrolConnection struct {
	// A list of edges.
	Edges []*SubcontrolEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createSubcontrol mutation
type SubcontrolCreatePayload struct {
	// Created subcontrol
	Subcontrol *Subcontrol `json:"subcontrol"`
}

// Return response for deleteSubcontrol mutation
type SubcontrolDeletePayload struct {
	// Deleted subcontrol ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type SubcontrolEdge struct {
	// The item at the end of the edge.
	Node *Subcontrol `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type SubcontrolHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the subcontrol
	Name string `json:"name"`
	// description of the subcontrol
	Description *string `json:"description,omitempty"`
	// status of the subcontrol
	Status *string `json:"status,omitempty"`
	// type of the subcontrol
	SubcontrolType *string `json:"subcontrolType,omitempty"`
	// version of the control
	Version *string `json:"version,omitempty"`
	// number of the subcontrol
	SubcontrolNumber *string `json:"subcontrolNumber,omitempty"`
	// subcontrol family
	Family *string `json:"family,omitempty"`
	// subcontrol class
	Class *string `json:"class,omitempty"`
	// source of the control, e.g. framework, template, user-defined, etc.
	Source *string `json:"source,omitempty"`
	// mapped frameworks that the subcontrol is part of
	MappedFrameworks *string `json:"mappedFrameworks,omitempty"`
	// implementation evidence of the subcontrol
	ImplementationEvidence *string `json:"implementationEvidence,omitempty"`
	// implementation status
	ImplementationStatus *string `json:"implementationStatus,omitempty"`
	// date the subcontrol was implemented
	ImplementationDate *time.Time `json:"implementationDate,omitempty"`
	// implementation verification
	ImplementationVerification *string `json:"implementationVerification,omitempty"`
	// date the subcontrol implementation was verified
	ImplementationVerificationDate *time.Time `json:"implementationVerificationDate,omitempty"`
	// json data details of the subcontrol
	Details map[string]interface{} `json:"details,omitempty"`
}

func (SubcontrolHistory) IsNode() {}

// A connection to a list of items.
type SubcontrolHistoryConnection struct {
	// A list of edges.
	Edges []*SubcontrolHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type SubcontrolHistoryEdge struct {
	// The item at the end of the edge.
	Node *SubcontrolHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// SubcontrolHistoryWhereInput is used for filtering SubcontrolHistory objects.
// Input was generated by ent.
type SubcontrolHistoryWhereInput struct {
	Not *SubcontrolHistoryWhereInput   `json:"not,omitempty"`
	And []*SubcontrolHistoryWhereInput `json:"and,omitempty"`
	Or  []*SubcontrolHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// subcontrol_type field predicates
	SubcontrolType             *string  `json:"subcontrolType,omitempty"`
	SubcontrolTypeNeq          *string  `json:"subcontrolTypeNEQ,omitempty"`
	SubcontrolTypeIn           []string `json:"subcontrolTypeIn,omitempty"`
	SubcontrolTypeNotIn        []string `json:"subcontrolTypeNotIn,omitempty"`
	SubcontrolTypeGt           *string  `json:"subcontrolTypeGT,omitempty"`
	SubcontrolTypeGte          *string  `json:"subcontrolTypeGTE,omitempty"`
	SubcontrolTypeLt           *string  `json:"subcontrolTypeLT,omitempty"`
	SubcontrolTypeLte          *string  `json:"subcontrolTypeLTE,omitempty"`
	SubcontrolTypeContains     *string  `json:"subcontrolTypeContains,omitempty"`
	SubcontrolTypeHasPrefix    *string  `json:"subcontrolTypeHasPrefix,omitempty"`
	SubcontrolTypeHasSuffix    *string  `json:"subcontrolTypeHasSuffix,omitempty"`
	SubcontrolTypeIsNil        *bool    `json:"subcontrolTypeIsNil,omitempty"`
	SubcontrolTypeNotNil       *bool    `json:"subcontrolTypeNotNil,omitempty"`
	SubcontrolTypeEqualFold    *string  `json:"subcontrolTypeEqualFold,omitempty"`
	SubcontrolTypeContainsFold *string  `json:"subcontrolTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// subcontrol_number field predicates
	SubcontrolNumber             *string  `json:"subcontrolNumber,omitempty"`
	SubcontrolNumberNeq          *string  `json:"subcontrolNumberNEQ,omitempty"`
	SubcontrolNumberIn           []string `json:"subcontrolNumberIn,omitempty"`
	SubcontrolNumberNotIn        []string `json:"subcontrolNumberNotIn,omitempty"`
	SubcontrolNumberGt           *string  `json:"subcontrolNumberGT,omitempty"`
	SubcontrolNumberGte          *string  `json:"subcontrolNumberGTE,omitempty"`
	SubcontrolNumberLt           *string  `json:"subcontrolNumberLT,omitempty"`
	SubcontrolNumberLte          *string  `json:"subcontrolNumberLTE,omitempty"`
	SubcontrolNumberContains     *string  `json:"subcontrolNumberContains,omitempty"`
	SubcontrolNumberHasPrefix    *string  `json:"subcontrolNumberHasPrefix,omitempty"`
	SubcontrolNumberHasSuffix    *string  `json:"subcontrolNumberHasSuffix,omitempty"`
	SubcontrolNumberIsNil        *bool    `json:"subcontrolNumberIsNil,omitempty"`
	SubcontrolNumberNotNil       *bool    `json:"subcontrolNumberNotNil,omitempty"`
	SubcontrolNumberEqualFold    *string  `json:"subcontrolNumberEqualFold,omitempty"`
	SubcontrolNumberContainsFold *string  `json:"subcontrolNumberContainsFold,omitempty"`
	// family field predicates
	Family             *string  `json:"family,omitempty"`
	FamilyNeq          *string  `json:"familyNEQ,omitempty"`
	FamilyIn           []string `json:"familyIn,omitempty"`
	FamilyNotIn        []string `json:"familyNotIn,omitempty"`
	FamilyGt           *string  `json:"familyGT,omitempty"`
	FamilyGte          *string  `json:"familyGTE,omitempty"`
	FamilyLt           *string  `json:"familyLT,omitempty"`
	FamilyLte          *string  `json:"familyLTE,omitempty"`
	FamilyContains     *string  `json:"familyContains,omitempty"`
	FamilyHasPrefix    *string  `json:"familyHasPrefix,omitempty"`
	FamilyHasSuffix    *string  `json:"familyHasSuffix,omitempty"`
	FamilyIsNil        *bool    `json:"familyIsNil,omitempty"`
	FamilyNotNil       *bool    `json:"familyNotNil,omitempty"`
	FamilyEqualFold    *string  `json:"familyEqualFold,omitempty"`
	FamilyContainsFold *string  `json:"familyContainsFold,omitempty"`
	// class field predicates
	Class             *string  `json:"class,omitempty"`
	ClassNeq          *string  `json:"classNEQ,omitempty"`
	ClassIn           []string `json:"classIn,omitempty"`
	ClassNotIn        []string `json:"classNotIn,omitempty"`
	ClassGt           *string  `json:"classGT,omitempty"`
	ClassGte          *string  `json:"classGTE,omitempty"`
	ClassLt           *string  `json:"classLT,omitempty"`
	ClassLte          *string  `json:"classLTE,omitempty"`
	ClassContains     *string  `json:"classContains,omitempty"`
	ClassHasPrefix    *string  `json:"classHasPrefix,omitempty"`
	ClassHasSuffix    *string  `json:"classHasSuffix,omitempty"`
	ClassIsNil        *bool    `json:"classIsNil,omitempty"`
	ClassNotNil       *bool    `json:"classNotNil,omitempty"`
	ClassEqualFold    *string  `json:"classEqualFold,omitempty"`
	ClassContainsFold *string  `json:"classContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// mapped_frameworks field predicates
	MappedFrameworks             *string  `json:"mappedFrameworks,omitempty"`
	MappedFrameworksNeq          *string  `json:"mappedFrameworksNEQ,omitempty"`
	MappedFrameworksIn           []string `json:"mappedFrameworksIn,omitempty"`
	MappedFrameworksNotIn        []string `json:"mappedFrameworksNotIn,omitempty"`
	MappedFrameworksGt           *string  `json:"mappedFrameworksGT,omitempty"`
	MappedFrameworksGte          *string  `json:"mappedFrameworksGTE,omitempty"`
	MappedFrameworksLt           *string  `json:"mappedFrameworksLT,omitempty"`
	MappedFrameworksLte          *string  `json:"mappedFrameworksLTE,omitempty"`
	MappedFrameworksContains     *string  `json:"mappedFrameworksContains,omitempty"`
	MappedFrameworksHasPrefix    *string  `json:"mappedFrameworksHasPrefix,omitempty"`
	MappedFrameworksHasSuffix    *string  `json:"mappedFrameworksHasSuffix,omitempty"`
	MappedFrameworksIsNil        *bool    `json:"mappedFrameworksIsNil,omitempty"`
	MappedFrameworksNotNil       *bool    `json:"mappedFrameworksNotNil,omitempty"`
	MappedFrameworksEqualFold    *string  `json:"mappedFrameworksEqualFold,omitempty"`
	MappedFrameworksContainsFold *string  `json:"mappedFrameworksContainsFold,omitempty"`
	// implementation_evidence field predicates
	ImplementationEvidence             *string  `json:"implementationEvidence,omitempty"`
	ImplementationEvidenceNeq          *string  `json:"implementationEvidenceNEQ,omitempty"`
	ImplementationEvidenceIn           []string `json:"implementationEvidenceIn,omitempty"`
	ImplementationEvidenceNotIn        []string `json:"implementationEvidenceNotIn,omitempty"`
	ImplementationEvidenceGt           *string  `json:"implementationEvidenceGT,omitempty"`
	ImplementationEvidenceGte          *string  `json:"implementationEvidenceGTE,omitempty"`
	ImplementationEvidenceLt           *string  `json:"implementationEvidenceLT,omitempty"`
	ImplementationEvidenceLte          *string  `json:"implementationEvidenceLTE,omitempty"`
	ImplementationEvidenceContains     *string  `json:"implementationEvidenceContains,omitempty"`
	ImplementationEvidenceHasPrefix    *string  `json:"implementationEvidenceHasPrefix,omitempty"`
	ImplementationEvidenceHasSuffix    *string  `json:"implementationEvidenceHasSuffix,omitempty"`
	ImplementationEvidenceIsNil        *bool    `json:"implementationEvidenceIsNil,omitempty"`
	ImplementationEvidenceNotNil       *bool    `json:"implementationEvidenceNotNil,omitempty"`
	ImplementationEvidenceEqualFold    *string  `json:"implementationEvidenceEqualFold,omitempty"`
	ImplementationEvidenceContainsFold *string  `json:"implementationEvidenceContainsFold,omitempty"`
	// implementation_status field predicates
	ImplementationStatus             *string  `json:"implementationStatus,omitempty"`
	ImplementationStatusNeq          *string  `json:"implementationStatusNEQ,omitempty"`
	ImplementationStatusIn           []string `json:"implementationStatusIn,omitempty"`
	ImplementationStatusNotIn        []string `json:"implementationStatusNotIn,omitempty"`
	ImplementationStatusGt           *string  `json:"implementationStatusGT,omitempty"`
	ImplementationStatusGte          *string  `json:"implementationStatusGTE,omitempty"`
	ImplementationStatusLt           *string  `json:"implementationStatusLT,omitempty"`
	ImplementationStatusLte          *string  `json:"implementationStatusLTE,omitempty"`
	ImplementationStatusContains     *string  `json:"implementationStatusContains,omitempty"`
	ImplementationStatusHasPrefix    *string  `json:"implementationStatusHasPrefix,omitempty"`
	ImplementationStatusHasSuffix    *string  `json:"implementationStatusHasSuffix,omitempty"`
	ImplementationStatusIsNil        *bool    `json:"implementationStatusIsNil,omitempty"`
	ImplementationStatusNotNil       *bool    `json:"implementationStatusNotNil,omitempty"`
	ImplementationStatusEqualFold    *string  `json:"implementationStatusEqualFold,omitempty"`
	ImplementationStatusContainsFold *string  `json:"implementationStatusContainsFold,omitempty"`
	// implementation_date field predicates
	ImplementationDate       *time.Time   `json:"implementationDate,omitempty"`
	ImplementationDateNeq    *time.Time   `json:"implementationDateNEQ,omitempty"`
	ImplementationDateIn     []*time.Time `json:"implementationDateIn,omitempty"`
	ImplementationDateNotIn  []*time.Time `json:"implementationDateNotIn,omitempty"`
	ImplementationDateGt     *time.Time   `json:"implementationDateGT,omitempty"`
	ImplementationDateGte    *time.Time   `json:"implementationDateGTE,omitempty"`
	ImplementationDateLt     *time.Time   `json:"implementationDateLT,omitempty"`
	ImplementationDateLte    *time.Time   `json:"implementationDateLTE,omitempty"`
	ImplementationDateIsNil  *bool        `json:"implementationDateIsNil,omitempty"`
	ImplementationDateNotNil *bool        `json:"implementationDateNotNil,omitempty"`
	// implementation_verification field predicates
	ImplementationVerification             *string  `json:"implementationVerification,omitempty"`
	ImplementationVerificationNeq          *string  `json:"implementationVerificationNEQ,omitempty"`
	ImplementationVerificationIn           []string `json:"implementationVerificationIn,omitempty"`
	ImplementationVerificationNotIn        []string `json:"implementationVerificationNotIn,omitempty"`
	ImplementationVerificationGt           *string  `json:"implementationVerificationGT,omitempty"`
	ImplementationVerificationGte          *string  `json:"implementationVerificationGTE,omitempty"`
	ImplementationVerificationLt           *string  `json:"implementationVerificationLT,omitempty"`
	ImplementationVerificationLte          *string  `json:"implementationVerificationLTE,omitempty"`
	ImplementationVerificationContains     *string  `json:"implementationVerificationContains,omitempty"`
	ImplementationVerificationHasPrefix    *string  `json:"implementationVerificationHasPrefix,omitempty"`
	ImplementationVerificationHasSuffix    *string  `json:"implementationVerificationHasSuffix,omitempty"`
	ImplementationVerificationIsNil        *bool    `json:"implementationVerificationIsNil,omitempty"`
	ImplementationVerificationNotNil       *bool    `json:"implementationVerificationNotNil,omitempty"`
	ImplementationVerificationEqualFold    *string  `json:"implementationVerificationEqualFold,omitempty"`
	ImplementationVerificationContainsFold *string  `json:"implementationVerificationContainsFold,omitempty"`
	// implementation_verification_date field predicates
	ImplementationVerificationDate       *time.Time   `json:"implementationVerificationDate,omitempty"`
	ImplementationVerificationDateNeq    *time.Time   `json:"implementationVerificationDateNEQ,omitempty"`
	ImplementationVerificationDateIn     []*time.Time `json:"implementationVerificationDateIn,omitempty"`
	ImplementationVerificationDateNotIn  []*time.Time `json:"implementationVerificationDateNotIn,omitempty"`
	ImplementationVerificationDateGt     *time.Time   `json:"implementationVerificationDateGT,omitempty"`
	ImplementationVerificationDateGte    *time.Time   `json:"implementationVerificationDateGTE,omitempty"`
	ImplementationVerificationDateLt     *time.Time   `json:"implementationVerificationDateLT,omitempty"`
	ImplementationVerificationDateLte    *time.Time   `json:"implementationVerificationDateLTE,omitempty"`
	ImplementationVerificationDateIsNil  *bool        `json:"implementationVerificationDateIsNil,omitempty"`
	ImplementationVerificationDateNotNil *bool        `json:"implementationVerificationDateNotNil,omitempty"`
}

type SubcontrolSearchResult struct {
	Subcontrols []*Subcontrol `json:"subcontrols,omitempty"`
}

func (SubcontrolSearchResult) IsSearchResult() {}

// Return response for updateSubcontrol mutation
type SubcontrolUpdatePayload struct {
	// Updated subcontrol
	Subcontrol *Subcontrol `json:"subcontrol"`
}

// SubcontrolWhereInput is used for filtering Subcontrol objects.
// Input was generated by ent.
type SubcontrolWhereInput struct {
	Not *SubcontrolWhereInput   `json:"not,omitempty"`
	And []*SubcontrolWhereInput `json:"and,omitempty"`
	Or  []*SubcontrolWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// subcontrol_type field predicates
	SubcontrolType             *string  `json:"subcontrolType,omitempty"`
	SubcontrolTypeNeq          *string  `json:"subcontrolTypeNEQ,omitempty"`
	SubcontrolTypeIn           []string `json:"subcontrolTypeIn,omitempty"`
	SubcontrolTypeNotIn        []string `json:"subcontrolTypeNotIn,omitempty"`
	SubcontrolTypeGt           *string  `json:"subcontrolTypeGT,omitempty"`
	SubcontrolTypeGte          *string  `json:"subcontrolTypeGTE,omitempty"`
	SubcontrolTypeLt           *string  `json:"subcontrolTypeLT,omitempty"`
	SubcontrolTypeLte          *string  `json:"subcontrolTypeLTE,omitempty"`
	SubcontrolTypeContains     *string  `json:"subcontrolTypeContains,omitempty"`
	SubcontrolTypeHasPrefix    *string  `json:"subcontrolTypeHasPrefix,omitempty"`
	SubcontrolTypeHasSuffix    *string  `json:"subcontrolTypeHasSuffix,omitempty"`
	SubcontrolTypeIsNil        *bool    `json:"subcontrolTypeIsNil,omitempty"`
	SubcontrolTypeNotNil       *bool    `json:"subcontrolTypeNotNil,omitempty"`
	SubcontrolTypeEqualFold    *string  `json:"subcontrolTypeEqualFold,omitempty"`
	SubcontrolTypeContainsFold *string  `json:"subcontrolTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// subcontrol_number field predicates
	SubcontrolNumber             *string  `json:"subcontrolNumber,omitempty"`
	SubcontrolNumberNeq          *string  `json:"subcontrolNumberNEQ,omitempty"`
	SubcontrolNumberIn           []string `json:"subcontrolNumberIn,omitempty"`
	SubcontrolNumberNotIn        []string `json:"subcontrolNumberNotIn,omitempty"`
	SubcontrolNumberGt           *string  `json:"subcontrolNumberGT,omitempty"`
	SubcontrolNumberGte          *string  `json:"subcontrolNumberGTE,omitempty"`
	SubcontrolNumberLt           *string  `json:"subcontrolNumberLT,omitempty"`
	SubcontrolNumberLte          *string  `json:"subcontrolNumberLTE,omitempty"`
	SubcontrolNumberContains     *string  `json:"subcontrolNumberContains,omitempty"`
	SubcontrolNumberHasPrefix    *string  `json:"subcontrolNumberHasPrefix,omitempty"`
	SubcontrolNumberHasSuffix    *string  `json:"subcontrolNumberHasSuffix,omitempty"`
	SubcontrolNumberIsNil        *bool    `json:"subcontrolNumberIsNil,omitempty"`
	SubcontrolNumberNotNil       *bool    `json:"subcontrolNumberNotNil,omitempty"`
	SubcontrolNumberEqualFold    *string  `json:"subcontrolNumberEqualFold,omitempty"`
	SubcontrolNumberContainsFold *string  `json:"subcontrolNumberContainsFold,omitempty"`
	// family field predicates
	Family             *string  `json:"family,omitempty"`
	FamilyNeq          *string  `json:"familyNEQ,omitempty"`
	FamilyIn           []string `json:"familyIn,omitempty"`
	FamilyNotIn        []string `json:"familyNotIn,omitempty"`
	FamilyGt           *string  `json:"familyGT,omitempty"`
	FamilyGte          *string  `json:"familyGTE,omitempty"`
	FamilyLt           *string  `json:"familyLT,omitempty"`
	FamilyLte          *string  `json:"familyLTE,omitempty"`
	FamilyContains     *string  `json:"familyContains,omitempty"`
	FamilyHasPrefix    *string  `json:"familyHasPrefix,omitempty"`
	FamilyHasSuffix    *string  `json:"familyHasSuffix,omitempty"`
	FamilyIsNil        *bool    `json:"familyIsNil,omitempty"`
	FamilyNotNil       *bool    `json:"familyNotNil,omitempty"`
	FamilyEqualFold    *string  `json:"familyEqualFold,omitempty"`
	FamilyContainsFold *string  `json:"familyContainsFold,omitempty"`
	// class field predicates
	Class             *string  `json:"class,omitempty"`
	ClassNeq          *string  `json:"classNEQ,omitempty"`
	ClassIn           []string `json:"classIn,omitempty"`
	ClassNotIn        []string `json:"classNotIn,omitempty"`
	ClassGt           *string  `json:"classGT,omitempty"`
	ClassGte          *string  `json:"classGTE,omitempty"`
	ClassLt           *string  `json:"classLT,omitempty"`
	ClassLte          *string  `json:"classLTE,omitempty"`
	ClassContains     *string  `json:"classContains,omitempty"`
	ClassHasPrefix    *string  `json:"classHasPrefix,omitempty"`
	ClassHasSuffix    *string  `json:"classHasSuffix,omitempty"`
	ClassIsNil        *bool    `json:"classIsNil,omitempty"`
	ClassNotNil       *bool    `json:"classNotNil,omitempty"`
	ClassEqualFold    *string  `json:"classEqualFold,omitempty"`
	ClassContainsFold *string  `json:"classContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// mapped_frameworks field predicates
	MappedFrameworks             *string  `json:"mappedFrameworks,omitempty"`
	MappedFrameworksNeq          *string  `json:"mappedFrameworksNEQ,omitempty"`
	MappedFrameworksIn           []string `json:"mappedFrameworksIn,omitempty"`
	MappedFrameworksNotIn        []string `json:"mappedFrameworksNotIn,omitempty"`
	MappedFrameworksGt           *string  `json:"mappedFrameworksGT,omitempty"`
	MappedFrameworksGte          *string  `json:"mappedFrameworksGTE,omitempty"`
	MappedFrameworksLt           *string  `json:"mappedFrameworksLT,omitempty"`
	MappedFrameworksLte          *string  `json:"mappedFrameworksLTE,omitempty"`
	MappedFrameworksContains     *string  `json:"mappedFrameworksContains,omitempty"`
	MappedFrameworksHasPrefix    *string  `json:"mappedFrameworksHasPrefix,omitempty"`
	MappedFrameworksHasSuffix    *string  `json:"mappedFrameworksHasSuffix,omitempty"`
	MappedFrameworksIsNil        *bool    `json:"mappedFrameworksIsNil,omitempty"`
	MappedFrameworksNotNil       *bool    `json:"mappedFrameworksNotNil,omitempty"`
	MappedFrameworksEqualFold    *string  `json:"mappedFrameworksEqualFold,omitempty"`
	MappedFrameworksContainsFold *string  `json:"mappedFrameworksContainsFold,omitempty"`
	// implementation_evidence field predicates
	ImplementationEvidence             *string  `json:"implementationEvidence,omitempty"`
	ImplementationEvidenceNeq          *string  `json:"implementationEvidenceNEQ,omitempty"`
	ImplementationEvidenceIn           []string `json:"implementationEvidenceIn,omitempty"`
	ImplementationEvidenceNotIn        []string `json:"implementationEvidenceNotIn,omitempty"`
	ImplementationEvidenceGt           *string  `json:"implementationEvidenceGT,omitempty"`
	ImplementationEvidenceGte          *string  `json:"implementationEvidenceGTE,omitempty"`
	ImplementationEvidenceLt           *string  `json:"implementationEvidenceLT,omitempty"`
	ImplementationEvidenceLte          *string  `json:"implementationEvidenceLTE,omitempty"`
	ImplementationEvidenceContains     *string  `json:"implementationEvidenceContains,omitempty"`
	ImplementationEvidenceHasPrefix    *string  `json:"implementationEvidenceHasPrefix,omitempty"`
	ImplementationEvidenceHasSuffix    *string  `json:"implementationEvidenceHasSuffix,omitempty"`
	ImplementationEvidenceIsNil        *bool    `json:"implementationEvidenceIsNil,omitempty"`
	ImplementationEvidenceNotNil       *bool    `json:"implementationEvidenceNotNil,omitempty"`
	ImplementationEvidenceEqualFold    *string  `json:"implementationEvidenceEqualFold,omitempty"`
	ImplementationEvidenceContainsFold *string  `json:"implementationEvidenceContainsFold,omitempty"`
	// implementation_status field predicates
	ImplementationStatus             *string  `json:"implementationStatus,omitempty"`
	ImplementationStatusNeq          *string  `json:"implementationStatusNEQ,omitempty"`
	ImplementationStatusIn           []string `json:"implementationStatusIn,omitempty"`
	ImplementationStatusNotIn        []string `json:"implementationStatusNotIn,omitempty"`
	ImplementationStatusGt           *string  `json:"implementationStatusGT,omitempty"`
	ImplementationStatusGte          *string  `json:"implementationStatusGTE,omitempty"`
	ImplementationStatusLt           *string  `json:"implementationStatusLT,omitempty"`
	ImplementationStatusLte          *string  `json:"implementationStatusLTE,omitempty"`
	ImplementationStatusContains     *string  `json:"implementationStatusContains,omitempty"`
	ImplementationStatusHasPrefix    *string  `json:"implementationStatusHasPrefix,omitempty"`
	ImplementationStatusHasSuffix    *string  `json:"implementationStatusHasSuffix,omitempty"`
	ImplementationStatusIsNil        *bool    `json:"implementationStatusIsNil,omitempty"`
	ImplementationStatusNotNil       *bool    `json:"implementationStatusNotNil,omitempty"`
	ImplementationStatusEqualFold    *string  `json:"implementationStatusEqualFold,omitempty"`
	ImplementationStatusContainsFold *string  `json:"implementationStatusContainsFold,omitempty"`
	// implementation_date field predicates
	ImplementationDate       *time.Time   `json:"implementationDate,omitempty"`
	ImplementationDateNeq    *time.Time   `json:"implementationDateNEQ,omitempty"`
	ImplementationDateIn     []*time.Time `json:"implementationDateIn,omitempty"`
	ImplementationDateNotIn  []*time.Time `json:"implementationDateNotIn,omitempty"`
	ImplementationDateGt     *time.Time   `json:"implementationDateGT,omitempty"`
	ImplementationDateGte    *time.Time   `json:"implementationDateGTE,omitempty"`
	ImplementationDateLt     *time.Time   `json:"implementationDateLT,omitempty"`
	ImplementationDateLte    *time.Time   `json:"implementationDateLTE,omitempty"`
	ImplementationDateIsNil  *bool        `json:"implementationDateIsNil,omitempty"`
	ImplementationDateNotNil *bool        `json:"implementationDateNotNil,omitempty"`
	// implementation_verification field predicates
	ImplementationVerification             *string  `json:"implementationVerification,omitempty"`
	ImplementationVerificationNeq          *string  `json:"implementationVerificationNEQ,omitempty"`
	ImplementationVerificationIn           []string `json:"implementationVerificationIn,omitempty"`
	ImplementationVerificationNotIn        []string `json:"implementationVerificationNotIn,omitempty"`
	ImplementationVerificationGt           *string  `json:"implementationVerificationGT,omitempty"`
	ImplementationVerificationGte          *string  `json:"implementationVerificationGTE,omitempty"`
	ImplementationVerificationLt           *string  `json:"implementationVerificationLT,omitempty"`
	ImplementationVerificationLte          *string  `json:"implementationVerificationLTE,omitempty"`
	ImplementationVerificationContains     *string  `json:"implementationVerificationContains,omitempty"`
	ImplementationVerificationHasPrefix    *string  `json:"implementationVerificationHasPrefix,omitempty"`
	ImplementationVerificationHasSuffix    *string  `json:"implementationVerificationHasSuffix,omitempty"`
	ImplementationVerificationIsNil        *bool    `json:"implementationVerificationIsNil,omitempty"`
	ImplementationVerificationNotNil       *bool    `json:"implementationVerificationNotNil,omitempty"`
	ImplementationVerificationEqualFold    *string  `json:"implementationVerificationEqualFold,omitempty"`
	ImplementationVerificationContainsFold *string  `json:"implementationVerificationContainsFold,omitempty"`
	// implementation_verification_date field predicates
	ImplementationVerificationDate       *time.Time   `json:"implementationVerificationDate,omitempty"`
	ImplementationVerificationDateNeq    *time.Time   `json:"implementationVerificationDateNEQ,omitempty"`
	ImplementationVerificationDateIn     []*time.Time `json:"implementationVerificationDateIn,omitempty"`
	ImplementationVerificationDateNotIn  []*time.Time `json:"implementationVerificationDateNotIn,omitempty"`
	ImplementationVerificationDateGt     *time.Time   `json:"implementationVerificationDateGT,omitempty"`
	ImplementationVerificationDateGte    *time.Time   `json:"implementationVerificationDateGTE,omitempty"`
	ImplementationVerificationDateLt     *time.Time   `json:"implementationVerificationDateLT,omitempty"`
	ImplementationVerificationDateLte    *time.Time   `json:"implementationVerificationDateLTE,omitempty"`
	ImplementationVerificationDateIsNil  *bool        `json:"implementationVerificationDateIsNil,omitempty"`
	ImplementationVerificationDateNotNil *bool        `json:"implementationVerificationDateNotNil,omitempty"`
	// control edge predicates
	HasControl     *bool                `json:"hasControl,omitempty"`
	HasControlWith []*ControlWhereInput `json:"hasControlWith,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// notes edge predicates
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

type Subscriber struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// email address of the subscriber
	Email string `json:"email"`
	// phone number of the subscriber
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// indicates if the email address has been verified
	VerifiedEmail bool `json:"verifiedEmail"`
	// indicates if the phone number has been verified
	VerifiedPhone bool `json:"verifiedPhone"`
	// indicates if the subscriber is active or not, active users will have at least one verified contact method
	Active bool          `json:"active"`
	Owner  *Organization `json:"owner,omitempty"`
	Events []*Event      `json:"events,omitempty"`
}

func (Subscriber) IsNode() {}

// Return response for createBulkSubscriber mutation
type SubscriberBulkCreatePayload struct {
	// Created subscribers
	Subscribers []*Subscriber `json:"subscribers,omitempty"`
}

// A connection to a list of items.
type SubscriberConnection struct {
	// A list of edges.
	Edges []*SubscriberEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createSubscriber mutation
type SubscriberCreatePayload struct {
	// Created subscriber
	Subscriber *Subscriber `json:"subscriber"`
}

// Return response for deleteSubscriber mutation
type SubscriberDeletePayload struct {
	// Deleted subscriber email
	Email string `json:"email"`
}

// An edge in a connection.
type SubscriberEdge struct {
	// The item at the end of the edge.
	Node *Subscriber `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type SubscriberSearchResult struct {
	Subscribers []*Subscriber `json:"subscribers,omitempty"`
}

func (SubscriberSearchResult) IsSearchResult() {}

// Return response for updateSubscriber mutation
type SubscriberUpdatePayload struct {
	// Updated subscriber
	Subscriber *Subscriber `json:"subscriber"`
}

// SubscriberWhereInput is used for filtering Subscriber objects.
// Input was generated by ent.
type SubscriberWhereInput struct {
	Not *SubscriberWhereInput   `json:"not,omitempty"`
	And []*SubscriberWhereInput `json:"and,omitempty"`
	Or  []*SubscriberWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// phone_number field predicates
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNeq          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGt           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGte          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLt           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLte          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        *bool    `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       *bool    `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`
	// verified_email field predicates
	VerifiedEmail    *bool `json:"verifiedEmail,omitempty"`
	VerifiedEmailNeq *bool `json:"verifiedEmailNEQ,omitempty"`
	// verified_phone field predicates
	VerifiedPhone    *bool `json:"verifiedPhone,omitempty"`
	VerifiedPhoneNeq *bool `json:"verifiedPhoneNEQ,omitempty"`
	// active field predicates
	Active    *bool `json:"active,omitempty"`
	ActiveNeq *bool `json:"activeNEQ,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type TFASetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// TFA secret for the user
	TfaSecret *string `json:"tfaSecret,omitempty"`
	// specifies if the TFA device has been verified
	Verified bool `json:"verified"`
	// recovery codes for 2fa
	RecoveryCodes []string `json:"recoveryCodes,omitempty"`
	// specifies a user may complete authentication by verifying a TOTP code delivered through an authenticator app
	TotpAllowed *bool `json:"totpAllowed,omitempty"`
	Owner       *User `json:"owner,omitempty"`
}

func (TFASetting) IsNode() {}

// A connection to a list of items.
type TFASettingConnection struct {
	// A list of edges.
	Edges []*TFASettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTFASetting mutation
type TFASettingCreatePayload struct {
	// Created tfaSetting
	TfaSetting *TFASetting `json:"tfaSetting"`
}

// An edge in a connection.
type TFASettingEdge struct {
	// The item at the end of the edge.
	Node *TFASetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TFASettingSearchResult struct {
	TFASettings []*TFASetting `json:"tFASettings,omitempty"`
}

func (TFASettingSearchResult) IsSearchResult() {}

// Return response for updateTFASetting mutation
type TFASettingUpdatePayload struct {
	// Updated tfaSetting
	TfaSetting *TFASetting `json:"tfaSetting"`
}

// TFASettingWhereInput is used for filtering TFASetting objects.
// Input was generated by ent.
type TFASettingWhereInput struct {
	Not *TFASettingWhereInput   `json:"not,omitempty"`
	And []*TFASettingWhereInput `json:"and,omitempty"`
	Or  []*TFASettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// tfa_secret field predicates
	TfaSecret             *string  `json:"tfaSecret,omitempty"`
	TfaSecretNeq          *string  `json:"tfaSecretNEQ,omitempty"`
	TfaSecretIn           []string `json:"tfaSecretIn,omitempty"`
	TfaSecretNotIn        []string `json:"tfaSecretNotIn,omitempty"`
	TfaSecretGt           *string  `json:"tfaSecretGT,omitempty"`
	TfaSecretGte          *string  `json:"tfaSecretGTE,omitempty"`
	TfaSecretLt           *string  `json:"tfaSecretLT,omitempty"`
	TfaSecretLte          *string  `json:"tfaSecretLTE,omitempty"`
	TfaSecretContains     *string  `json:"tfaSecretContains,omitempty"`
	TfaSecretHasPrefix    *string  `json:"tfaSecretHasPrefix,omitempty"`
	TfaSecretHasSuffix    *string  `json:"tfaSecretHasSuffix,omitempty"`
	TfaSecretIsNil        *bool    `json:"tfaSecretIsNil,omitempty"`
	TfaSecretNotNil       *bool    `json:"tfaSecretNotNil,omitempty"`
	TfaSecretEqualFold    *string  `json:"tfaSecretEqualFold,omitempty"`
	TfaSecretContainsFold *string  `json:"tfaSecretContainsFold,omitempty"`
	// verified field predicates
	Verified    *bool `json:"verified,omitempty"`
	VerifiedNeq *bool `json:"verifiedNEQ,omitempty"`
	// totp_allowed field predicates
	TotpAllowed       *bool `json:"totpAllowed,omitempty"`
	TotpAllowedNeq    *bool `json:"totpAllowedNEQ,omitempty"`
	TotpAllowedIsNil  *bool `json:"totpAllowedIsNil,omitempty"`
	TotpAllowedNotNil *bool `json:"totpAllowedNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

type Task struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the title of the task
	Title string `json:"title"`
	// the description of the task
	Description *string `json:"description,omitempty"`
	// the details of the task
	Details map[string]interface{} `json:"details,omitempty"`
	// the status of the task
	Status enums.TaskStatus `json:"status"`
	// the due date of the task
	Due *time.Time `json:"due,omitempty"`
	// the completion date of the task
	Completed        *time.Time          `json:"completed,omitempty"`
	Assigner         *User               `json:"assigner"`
	Assignee         *User               `json:"assignee,omitempty"`
	Organization     []*Organization     `json:"organization,omitempty"`
	Group            []*Group            `json:"group,omitempty"`
	Policy           []*InternalPolicy   `json:"policy,omitempty"`
	Procedure        []*Procedure        `json:"procedure,omitempty"`
	Control          []*Control          `json:"control,omitempty"`
	ControlObjective []*ControlObjective `json:"controlObjective,omitempty"`
	Subcontrol       []*Subcontrol       `json:"subcontrol,omitempty"`
	Program          []*Program          `json:"program,omitempty"`
}

func (Task) IsNode() {}

// Return response for createBulkTask mutation
type TaskBulkCreatePayload struct {
	// Created tasks
	Tasks []*Task `json:"tasks,omitempty"`
}

// A connection to a list of items.
type TaskConnection struct {
	// A list of edges.
	Edges []*TaskEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTask mutation
type TaskCreatePayload struct {
	// Created task
	Task *Task `json:"task"`
}

// Return response for deleteTask mutation
type TaskDeletePayload struct {
	// Deleted task ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TaskEdge struct {
	// The item at the end of the edge.
	Node *Task `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TaskHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the title of the task
	Title string `json:"title"`
	// the description of the task
	Description *string `json:"description,omitempty"`
	// the details of the task
	Details map[string]interface{} `json:"details,omitempty"`
	// the status of the task
	Status enums.TaskStatus `json:"status"`
	// the due date of the task
	Due *time.Time `json:"due,omitempty"`
	// the completion date of the task
	Completed *time.Time `json:"completed,omitempty"`
}

func (TaskHistory) IsNode() {}

// A connection to a list of items.
type TaskHistoryConnection struct {
	// A list of edges.
	Edges []*TaskHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TaskHistoryEdge struct {
	// The item at the end of the edge.
	Node *TaskHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// TaskHistoryWhereInput is used for filtering TaskHistory objects.
// Input was generated by ent.
type TaskHistoryWhereInput struct {
	Not *TaskHistoryWhereInput   `json:"not,omitempty"`
	And []*TaskHistoryWhereInput `json:"and,omitempty"`
	Or  []*TaskHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status      *enums.TaskStatus  `json:"status,omitempty"`
	StatusNeq   *enums.TaskStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.TaskStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.TaskStatus `json:"statusNotIn,omitempty"`
	// due field predicates
	Due       *time.Time   `json:"due,omitempty"`
	DueNeq    *time.Time   `json:"dueNEQ,omitempty"`
	DueIn     []*time.Time `json:"dueIn,omitempty"`
	DueNotIn  []*time.Time `json:"dueNotIn,omitempty"`
	DueGt     *time.Time   `json:"dueGT,omitempty"`
	DueGte    *time.Time   `json:"dueGTE,omitempty"`
	DueLt     *time.Time   `json:"dueLT,omitempty"`
	DueLte    *time.Time   `json:"dueLTE,omitempty"`
	DueIsNil  *bool        `json:"dueIsNil,omitempty"`
	DueNotNil *bool        `json:"dueNotNil,omitempty"`
	// completed field predicates
	Completed       *time.Time   `json:"completed,omitempty"`
	CompletedNeq    *time.Time   `json:"completedNEQ,omitempty"`
	CompletedIn     []*time.Time `json:"completedIn,omitempty"`
	CompletedNotIn  []*time.Time `json:"completedNotIn,omitempty"`
	CompletedGt     *time.Time   `json:"completedGT,omitempty"`
	CompletedGte    *time.Time   `json:"completedGTE,omitempty"`
	CompletedLt     *time.Time   `json:"completedLT,omitempty"`
	CompletedLte    *time.Time   `json:"completedLTE,omitempty"`
	CompletedIsNil  *bool        `json:"completedIsNil,omitempty"`
	CompletedNotNil *bool        `json:"completedNotNil,omitempty"`
}

type TaskSearchResult struct {
	Tasks []*Task `json:"tasks,omitempty"`
}

func (TaskSearchResult) IsSearchResult() {}

// Return response for updateTask mutation
type TaskUpdatePayload struct {
	// Updated task
	Task *Task `json:"task"`
}

// TaskWhereInput is used for filtering Task objects.
// Input was generated by ent.
type TaskWhereInput struct {
	Not *TaskWhereInput   `json:"not,omitempty"`
	And []*TaskWhereInput `json:"and,omitempty"`
	Or  []*TaskWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status      *enums.TaskStatus  `json:"status,omitempty"`
	StatusNeq   *enums.TaskStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.TaskStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.TaskStatus `json:"statusNotIn,omitempty"`
	// due field predicates
	Due       *time.Time   `json:"due,omitempty"`
	DueNeq    *time.Time   `json:"dueNEQ,omitempty"`
	DueIn     []*time.Time `json:"dueIn,omitempty"`
	DueNotIn  []*time.Time `json:"dueNotIn,omitempty"`
	DueGt     *time.Time   `json:"dueGT,omitempty"`
	DueGte    *time.Time   `json:"dueGTE,omitempty"`
	DueLt     *time.Time   `json:"dueLT,omitempty"`
	DueLte    *time.Time   `json:"dueLTE,omitempty"`
	DueIsNil  *bool        `json:"dueIsNil,omitempty"`
	DueNotNil *bool        `json:"dueNotNil,omitempty"`
	// completed field predicates
	Completed       *time.Time   `json:"completed,omitempty"`
	CompletedNeq    *time.Time   `json:"completedNEQ,omitempty"`
	CompletedIn     []*time.Time `json:"completedIn,omitempty"`
	CompletedNotIn  []*time.Time `json:"completedNotIn,omitempty"`
	CompletedGt     *time.Time   `json:"completedGT,omitempty"`
	CompletedGte    *time.Time   `json:"completedGTE,omitempty"`
	CompletedLt     *time.Time   `json:"completedLT,omitempty"`
	CompletedLte    *time.Time   `json:"completedLTE,omitempty"`
	CompletedIsNil  *bool        `json:"completedIsNil,omitempty"`
	CompletedNotNil *bool        `json:"completedNotNil,omitempty"`
	// assigner edge predicates
	HasAssigner     *bool             `json:"hasAssigner,omitempty"`
	HasAssignerWith []*UserWhereInput `json:"hasAssignerWith,omitempty"`
	// assignee edge predicates
	HasAssignee     *bool             `json:"hasAssignee,omitempty"`
	HasAssigneeWith []*UserWhereInput `json:"hasAssigneeWith,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
	// policy edge predicates
	HasPolicy     *bool                       `json:"hasPolicy,omitempty"`
	HasPolicyWith []*InternalPolicyWhereInput `json:"hasPolicyWith,omitempty"`
	// procedure edge predicates
	HasProcedure     *bool                  `json:"hasProcedure,omitempty"`
	HasProcedureWith []*ProcedureWhereInput `json:"hasProcedureWith,omitempty"`
	// control edge predicates
	HasControl     *bool                `json:"hasControl,omitempty"`
	HasControlWith []*ControlWhereInput `json:"hasControlWith,omitempty"`
	// control_objective edge predicates
	HasControlObjective     *bool                         `json:"hasControlObjective,omitempty"`
	HasControlObjectiveWith []*ControlObjectiveWhereInput `json:"hasControlObjectiveWith,omitempty"`
	// subcontrol edge predicates
	HasSubcontrol     *bool                   `json:"hasSubcontrol,omitempty"`
	HasSubcontrolWith []*SubcontrolWhereInput `json:"hasSubcontrolWith,omitempty"`
	// program edge predicates
	HasProgram     *bool                `json:"hasProgram,omitempty"`
	HasProgramWith []*ProgramWhereInput `json:"hasProgramWith,omitempty"`
}

type Template struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the template
	Name string `json:"name"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType enums.DocumentType `json:"templateType"`
	// the description of the template
	Description *string `json:"description,omitempty"`
	// the jsonschema object of the template
	Jsonconfig json.RawMessage `json:"jsonconfig"`
	// the uischema for the template to render in the UI
	Uischema  json.RawMessage `json:"uischema,omitempty"`
	Owner     *Organization   `json:"owner,omitempty"`
	Documents []*DocumentData `json:"documents,omitempty"`
	Files     []*File         `json:"files,omitempty"`
}

func (Template) IsNode() {}

// Return response for createBulkTemplate mutation
type TemplateBulkCreatePayload struct {
	// Created templates
	Templates []*Template `json:"templates,omitempty"`
}

// A connection to a list of items.
type TemplateConnection struct {
	// A list of edges.
	Edges []*TemplateEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTemplate mutation
type TemplateCreatePayload struct {
	// Created template
	Template *Template `json:"template"`
}

// Return response for deleteTemplate mutation
type TemplateDeletePayload struct {
	// Deleted template ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TemplateEdge struct {
	// The item at the end of the edge.
	Node *Template `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TemplateHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the template
	Name string `json:"name"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType enums.DocumentType `json:"templateType"`
	// the description of the template
	Description *string `json:"description,omitempty"`
	// the jsonschema object of the template
	Jsonconfig json.RawMessage `json:"jsonconfig"`
	// the uischema for the template to render in the UI
	Uischema json.RawMessage `json:"uischema,omitempty"`
}

func (TemplateHistory) IsNode() {}

// A connection to a list of items.
type TemplateHistoryConnection struct {
	// A list of edges.
	Edges []*TemplateHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TemplateHistoryEdge struct {
	// The item at the end of the edge.
	Node *TemplateHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TemplateHistory connections
type TemplateHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TemplateHistories.
	Field TemplateHistoryOrderField `json:"field"`
}

// TemplateHistoryWhereInput is used for filtering TemplateHistory objects.
// Input was generated by ent.
type TemplateHistoryWhereInput struct {
	Not *TemplateHistoryWhereInput   `json:"not,omitempty"`
	And []*TemplateHistoryWhereInput `json:"and,omitempty"`
	Or  []*TemplateHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// template_type field predicates
	TemplateType      *enums.DocumentType  `json:"templateType,omitempty"`
	TemplateTypeNeq   *enums.DocumentType  `json:"templateTypeNEQ,omitempty"`
	TemplateTypeIn    []enums.DocumentType `json:"templateTypeIn,omitempty"`
	TemplateTypeNotIn []enums.DocumentType `json:"templateTypeNotIn,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
}

// Ordering options for Template connections
type TemplateOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Templates.
	Field TemplateOrderField `json:"field"`
}

type TemplateSearchResult struct {
	Templates []*Template `json:"templates,omitempty"`
}

func (TemplateSearchResult) IsSearchResult() {}

// Return response for updateTemplate mutation
type TemplateUpdatePayload struct {
	// Updated template
	Template *Template `json:"template"`
}

// TemplateWhereInput is used for filtering Template objects.
// Input was generated by ent.
type TemplateWhereInput struct {
	Not *TemplateWhereInput   `json:"not,omitempty"`
	And []*TemplateWhereInput `json:"and,omitempty"`
	Or  []*TemplateWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// template_type field predicates
	TemplateType      *enums.DocumentType  `json:"templateType,omitempty"`
	TemplateTypeNeq   *enums.DocumentType  `json:"templateTypeNEQ,omitempty"`
	TemplateTypeIn    []enums.DocumentType `json:"templateTypeIn,omitempty"`
	TemplateTypeNotIn []enums.DocumentType `json:"templateTypeNotIn,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// documents edge predicates
	HasDocuments     *bool                     `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentDataWhereInput `json:"hasDocumentsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// UpdateAPITokenInput is used for update APIToken object.
// Input was generated by ent.
type UpdateAPITokenInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name associated with the token
	Name *string `json:"name,omitempty"`
	// a description of the token's purpose
	Description      *string    `json:"description,omitempty"`
	ClearDescription *bool      `json:"clearDescription,omitempty"`
	Scopes           []string   `json:"scopes,omitempty"`
	AppendScopes     []string   `json:"appendScopes,omitempty"`
	ClearScopes      *bool      `json:"clearScopes,omitempty"`
	LastUsedAt       *time.Time `json:"lastUsedAt,omitempty"`
	ClearLastUsedAt  *bool      `json:"clearLastUsedAt,omitempty"`
	OwnerID          *string    `json:"ownerID,omitempty"`
	ClearOwner       *bool      `json:"clearOwner,omitempty"`
}

// UpdateActionPlanInput is used for update ActionPlan object.
// Input was generated by ent.
type UpdateActionPlanInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the action plan
	Name *string `json:"name,omitempty"`
	// description of the action plan
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// status of the action plan
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// due date of the action plan
	DueDate      *time.Time `json:"dueDate,omitempty"`
	ClearDueDate *bool      `json:"clearDueDate,omitempty"`
	// priority of the action plan
	Priority      *string `json:"priority,omitempty"`
	ClearPriority *bool   `json:"clearPriority,omitempty"`
	// source of the action plan
	Source      *string `json:"source,omitempty"`
	ClearSource *bool   `json:"clearSource,omitempty"`
	// json data including details of the action plan
	Details           map[string]interface{} `json:"details,omitempty"`
	ClearDetails      *bool                  `json:"clearDetails,omitempty"`
	AddStandardIDs    []string               `json:"addStandardIDs,omitempty"`
	RemoveStandardIDs []string               `json:"removeStandardIDs,omitempty"`
	ClearStandard     *bool                  `json:"clearStandard,omitempty"`
	AddRiskIDs        []string               `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs     []string               `json:"removeRiskIDs,omitempty"`
	ClearRisk         *bool                  `json:"clearRisk,omitempty"`
	AddControlIDs     []string               `json:"addControlIDs,omitempty"`
	RemoveControlIDs  []string               `json:"removeControlIDs,omitempty"`
	ClearControl      *bool                  `json:"clearControl,omitempty"`
	AddUserIDs        []string               `json:"addUserIDs,omitempty"`
	RemoveUserIDs     []string               `json:"removeUserIDs,omitempty"`
	ClearUser         *bool                  `json:"clearUser,omitempty"`
	AddProgramIDs     []string               `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs  []string               `json:"removeProgramIDs,omitempty"`
	ClearProgram      *bool                  `json:"clearProgram,omitempty"`
}

// UpdateContactInput is used for update Contact object.
// Input was generated by ent.
type UpdateContactInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the full name of the contact
	FullName *string `json:"fullName,omitempty"`
	// the title of the contact
	Title      *string `json:"title,omitempty"`
	ClearTitle *bool   `json:"clearTitle,omitempty"`
	// the company of the contact
	Company      *string `json:"company,omitempty"`
	ClearCompany *bool   `json:"clearCompany,omitempty"`
	// the email of the contact
	Email      *string `json:"email,omitempty"`
	ClearEmail *bool   `json:"clearEmail,omitempty"`
	// the phone number of the contact
	PhoneNumber      *string `json:"phoneNumber,omitempty"`
	ClearPhoneNumber *bool   `json:"clearPhoneNumber,omitempty"`
	// the address of the contact
	Address      *string `json:"address,omitempty"`
	ClearAddress *bool   `json:"clearAddress,omitempty"`
	// status of the contact
	Status          *enums.UserStatus `json:"status,omitempty"`
	OwnerID         *string           `json:"ownerID,omitempty"`
	ClearOwner      *bool             `json:"clearOwner,omitempty"`
	AddEntityIDs    []string          `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs []string          `json:"removeEntityIDs,omitempty"`
	ClearEntities   *bool             `json:"clearEntities,omitempty"`
	AddFileIDs      []string          `json:"addFileIDs,omitempty"`
	RemoveFileIDs   []string          `json:"removeFileIDs,omitempty"`
	ClearFiles      *bool             `json:"clearFiles,omitempty"`
}

// UpdateControlInput is used for update Control object.
// Input was generated by ent.
type UpdateControlInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the control
	Name *string `json:"name,omitempty"`
	// description of the control
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// status of the control
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// type of the control
	ControlType      *string `json:"controlType,omitempty"`
	ClearControlType *bool   `json:"clearControlType,omitempty"`
	// version of the control
	Version      *string `json:"version,omitempty"`
	ClearVersion *bool   `json:"clearVersion,omitempty"`
	// control number or identifier
	ControlNumber      *string `json:"controlNumber,omitempty"`
	ClearControlNumber *bool   `json:"clearControlNumber,omitempty"`
	// family associated with the control
	Family      *string `json:"family,omitempty"`
	ClearFamily *bool   `json:"clearFamily,omitempty"`
	// class associated with the control
	Class      *string `json:"class,omitempty"`
	ClearClass *bool   `json:"clearClass,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source      *string `json:"source,omitempty"`
	ClearSource *bool   `json:"clearSource,omitempty"`
	// which control objectives are satisfied by the control
	Satisfies      *string `json:"satisfies,omitempty"`
	ClearSatisfies *bool   `json:"clearSatisfies,omitempty"`
	// mapped frameworks
	MappedFrameworks      *string `json:"mappedFrameworks,omitempty"`
	ClearMappedFrameworks *bool   `json:"clearMappedFrameworks,omitempty"`
	// json data including details of the control
	Details                   map[string]interface{} `json:"details,omitempty"`
	ClearDetails              *bool                  `json:"clearDetails,omitempty"`
	AddProcedureIDs           []string               `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs        []string               `json:"removeProcedureIDs,omitempty"`
	ClearProcedures           *bool                  `json:"clearProcedures,omitempty"`
	AddSubcontrolIDs          []string               `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs       []string               `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols          *bool                  `json:"clearSubcontrols,omitempty"`
	AddControlobjectiveIDs    []string               `json:"addControlobjectiveIDs,omitempty"`
	RemoveControlobjectiveIDs []string               `json:"removeControlobjectiveIDs,omitempty"`
	ClearControlobjectives    *bool                  `json:"clearControlobjectives,omitempty"`
	AddStandardIDs            []string               `json:"addStandardIDs,omitempty"`
	RemoveStandardIDs         []string               `json:"removeStandardIDs,omitempty"`
	ClearStandard             *bool                  `json:"clearStandard,omitempty"`
	AddNarrativeIDs           []string               `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs        []string               `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives           *bool                  `json:"clearNarratives,omitempty"`
	AddRiskIDs                []string               `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs             []string               `json:"removeRiskIDs,omitempty"`
	ClearRisks                *bool                  `json:"clearRisks,omitempty"`
	AddActionplanIDs          []string               `json:"addActionplanIDs,omitempty"`
	RemoveActionplanIDs       []string               `json:"removeActionplanIDs,omitempty"`
	ClearActionplans          *bool                  `json:"clearActionplans,omitempty"`
	AddTaskIDs                []string               `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs             []string               `json:"removeTaskIDs,omitempty"`
	ClearTasks                *bool                  `json:"clearTasks,omitempty"`
	AddProgramIDs             []string               `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs          []string               `json:"removeProgramIDs,omitempty"`
	ClearPrograms             *bool                  `json:"clearPrograms,omitempty"`
}

// UpdateControlObjectiveInput is used for update ControlObjective object.
// Input was generated by ent.
type UpdateControlObjectiveInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the control objective
	Name *string `json:"name,omitempty"`
	// description of the control objective
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// status of the control objective
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// type of the control objective
	ControlObjectiveType      *string `json:"controlObjectiveType,omitempty"`
	ClearControlObjectiveType *bool   `json:"clearControlObjectiveType,omitempty"`
	// version of the control objective
	Version      *string `json:"version,omitempty"`
	ClearVersion *bool   `json:"clearVersion,omitempty"`
	// number of the control objective
	ControlNumber      *string `json:"controlNumber,omitempty"`
	ClearControlNumber *bool   `json:"clearControlNumber,omitempty"`
	// family of the control objective
	Family      *string `json:"family,omitempty"`
	ClearFamily *bool   `json:"clearFamily,omitempty"`
	// class associated with the control objective
	Class      *string `json:"class,omitempty"`
	ClearClass *bool   `json:"clearClass,omitempty"`
	// source of the control objective, e.g. framework, template, user-defined, etc.
	Source      *string `json:"source,omitempty"`
	ClearSource *bool   `json:"clearSource,omitempty"`
	// mapped frameworks
	MappedFrameworks      *string `json:"mappedFrameworks,omitempty"`
	ClearMappedFrameworks *bool   `json:"clearMappedFrameworks,omitempty"`
	// json data including details of the control objective
	Details             map[string]interface{} `json:"details,omitempty"`
	ClearDetails        *bool                  `json:"clearDetails,omitempty"`
	AddPolicyIDs        []string               `json:"addPolicyIDs,omitempty"`
	RemovePolicyIDs     []string               `json:"removePolicyIDs,omitempty"`
	ClearPolicy         *bool                  `json:"clearPolicy,omitempty"`
	AddControlIDs       []string               `json:"addControlIDs,omitempty"`
	RemoveControlIDs    []string               `json:"removeControlIDs,omitempty"`
	ClearControls       *bool                  `json:"clearControls,omitempty"`
	AddProcedureIDs     []string               `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs  []string               `json:"removeProcedureIDs,omitempty"`
	ClearProcedures     *bool                  `json:"clearProcedures,omitempty"`
	AddRiskIDs          []string               `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs       []string               `json:"removeRiskIDs,omitempty"`
	ClearRisks          *bool                  `json:"clearRisks,omitempty"`
	AddSubcontrolIDs    []string               `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs []string               `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols    *bool                  `json:"clearSubcontrols,omitempty"`
	AddStandardIDs      []string               `json:"addStandardIDs,omitempty"`
	RemoveStandardIDs   []string               `json:"removeStandardIDs,omitempty"`
	ClearStandard       *bool                  `json:"clearStandard,omitempty"`
	AddNarrativeIDs     []string               `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs  []string               `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives     *bool                  `json:"clearNarratives,omitempty"`
	AddTaskIDs          []string               `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs       []string               `json:"removeTaskIDs,omitempty"`
	ClearTasks          *bool                  `json:"clearTasks,omitempty"`
	AddProgramIDs       []string               `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs    []string               `json:"removeProgramIDs,omitempty"`
	ClearPrograms       *bool                  `json:"clearPrograms,omitempty"`
}

// UpdateDocumentDataInput is used for update DocumentData object.
// Input was generated by ent.
type UpdateDocumentDataInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the json data of the document
	Data            json.RawMessage `json:"data,omitempty"`
	OwnerID         *string         `json:"ownerID,omitempty"`
	ClearOwner      *bool           `json:"clearOwner,omitempty"`
	TemplateID      *string         `json:"templateID,omitempty"`
	AddEntityIDs    []string        `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs []string        `json:"removeEntityIDs,omitempty"`
	ClearEntity     *bool           `json:"clearEntity,omitempty"`
	AddFileIDs      []string        `json:"addFileIDs,omitempty"`
	RemoveFileIDs   []string        `json:"removeFileIDs,omitempty"`
	ClearFiles      *bool           `json:"clearFiles,omitempty"`
}

// UpdateEntitlementInput is used for update Entitlement object.
// Input was generated by ent.
type UpdateEntitlementInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalCustomerID      *string `json:"externalCustomerID,omitempty"`
	ClearExternalCustomerID *bool   `json:"clearExternalCustomerID,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalSubscriptionID      *string `json:"externalSubscriptionID,omitempty"`
	ClearExternalSubscriptionID *bool   `json:"clearExternalSubscriptionID,omitempty"`
	// the time at which a customer's entitlement will expire, e.g. they've cancelled but paid through the end of the month
	ExpiresAt      *time.Time `json:"expiresAt,omitempty"`
	ClearExpiresAt *bool      `json:"clearExpiresAt,omitempty"`
	// whether or not the customer has cancelled their entitlement - usually used in conjunction with expires and expires at
	Cancelled      *bool    `json:"cancelled,omitempty"`
	OwnerID        *string  `json:"ownerID,omitempty"`
	ClearOwner     *bool    `json:"clearOwner,omitempty"`
	AddEventIDs    []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool    `json:"clearEvents,omitempty"`
}

// UpdateEntitlementPlanFeatureInput is used for update EntitlementPlanFeature object.
// Input was generated by ent.
type UpdateEntitlementPlanFeatureInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// metadata for the entitlement plan feature such as usage limits
	Metadata       map[string]interface{} `json:"metadata,omitempty"`
	ClearMetadata  *bool                  `json:"clearMetadata,omitempty"`
	OwnerID        *string                `json:"ownerID,omitempty"`
	ClearOwner     *bool                  `json:"clearOwner,omitempty"`
	AddEventIDs    []string               `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string               `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool                  `json:"clearEvents,omitempty"`
}

// UpdateEntitlementPlanInput is used for update EntitlementPlan object.
// Input was generated by ent.
type UpdateEntitlementPlanInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the displayed 'friendly' name of the plan
	DisplayName      *string `json:"displayName,omitempty"`
	ClearDisplayName *bool   `json:"clearDisplayName,omitempty"`
	// a description of the plan
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// metadata for the plan
	Metadata             map[string]interface{} `json:"metadata,omitempty"`
	ClearMetadata        *bool                  `json:"clearMetadata,omitempty"`
	OwnerID              *string                `json:"ownerID,omitempty"`
	ClearOwner           *bool                  `json:"clearOwner,omitempty"`
	AddEntitlementIDs    []string               `json:"addEntitlementIDs,omitempty"`
	RemoveEntitlementIDs []string               `json:"removeEntitlementIDs,omitempty"`
	ClearEntitlements    *bool                  `json:"clearEntitlements,omitempty"`
	AddBaseFeatureIDs    []string               `json:"addBaseFeatureIDs,omitempty"`
	RemoveBaseFeatureIDs []string               `json:"removeBaseFeatureIDs,omitempty"`
	ClearBaseFeatures    *bool                  `json:"clearBaseFeatures,omitempty"`
	AddEventIDs          []string               `json:"addEventIDs,omitempty"`
	RemoveEventIDs       []string               `json:"removeEventIDs,omitempty"`
	ClearEvents          *bool                  `json:"clearEvents,omitempty"`
}

// UpdateEntityInput is used for update Entity object.
// Input was generated by ent.
type UpdateEntityInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the entity
	Name      *string `json:"name,omitempty"`
	ClearName *bool   `json:"clearName,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName      *string `json:"displayName,omitempty"`
	ClearDisplayName *bool   `json:"clearDisplayName,omitempty"`
	// An optional description of the entity
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// domains associated with the entity
	Domains       []string `json:"domains,omitempty"`
	AppendDomains []string `json:"appendDomains,omitempty"`
	ClearDomains  *bool    `json:"clearDomains,omitempty"`
	// status of the entity
	Status            *string          `json:"status,omitempty"`
	ClearStatus       *bool            `json:"clearStatus,omitempty"`
	OwnerID           *string          `json:"ownerID,omitempty"`
	ClearOwner        *bool            `json:"clearOwner,omitempty"`
	AddContactIDs     []string         `json:"addContactIDs,omitempty"`
	RemoveContactIDs  []string         `json:"removeContactIDs,omitempty"`
	ClearContacts     *bool            `json:"clearContacts,omitempty"`
	AddDocumentIDs    []string         `json:"addDocumentIDs,omitempty"`
	RemoveDocumentIDs []string         `json:"removeDocumentIDs,omitempty"`
	ClearDocuments    *bool            `json:"clearDocuments,omitempty"`
	AddNoteIDs        []string         `json:"addNoteIDs,omitempty"`
	RemoveNoteIDs     []string         `json:"removeNoteIDs,omitempty"`
	ClearNotes        *bool            `json:"clearNotes,omitempty"`
	AddFileIDs        []string         `json:"addFileIDs,omitempty"`
	RemoveFileIDs     []string         `json:"removeFileIDs,omitempty"`
	ClearFiles        *bool            `json:"clearFiles,omitempty"`
	EntityTypeID      *string          `json:"entityTypeID,omitempty"`
	ClearEntityType   *bool            `json:"clearEntityType,omitempty"`
	Note              *CreateNoteInput `json:"note,omitempty"`
}

// UpdateEntityTypeInput is used for update EntityType object.
// Input was generated by ent.
type UpdateEntityTypeInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the entity
	Name            *string  `json:"name,omitempty"`
	OwnerID         *string  `json:"ownerID,omitempty"`
	ClearOwner      *bool    `json:"clearOwner,omitempty"`
	AddEntityIDs    []string `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs []string `json:"removeEntityIDs,omitempty"`
	ClearEntities   *bool    `json:"clearEntities,omitempty"`
}

// UpdateEventInput is used for update Event object.
// Input was generated by ent.
type UpdateEventInput struct {
	// tags associated with the object
	Tags                         []string               `json:"tags,omitempty"`
	AppendTags                   []string               `json:"appendTags,omitempty"`
	ClearTags                    *bool                  `json:"clearTags,omitempty"`
	EventID                      *string                `json:"eventID,omitempty"`
	ClearEventID                 *bool                  `json:"clearEventID,omitempty"`
	CorrelationID                *string                `json:"correlationID,omitempty"`
	ClearCorrelationID           *bool                  `json:"clearCorrelationID,omitempty"`
	EventType                    *string                `json:"eventType,omitempty"`
	Metadata                     map[string]interface{} `json:"metadata,omitempty"`
	ClearMetadata                *bool                  `json:"clearMetadata,omitempty"`
	AddUserIDs                   []string               `json:"addUserIDs,omitempty"`
	RemoveUserIDs                []string               `json:"removeUserIDs,omitempty"`
	ClearUser                    *bool                  `json:"clearUser,omitempty"`
	AddGroupIDs                  []string               `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs               []string               `json:"removeGroupIDs,omitempty"`
	ClearGroup                   *bool                  `json:"clearGroup,omitempty"`
	AddIntegrationIDs            []string               `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs         []string               `json:"removeIntegrationIDs,omitempty"`
	ClearIntegration             *bool                  `json:"clearIntegration,omitempty"`
	AddOrganizationIDs           []string               `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs        []string               `json:"removeOrganizationIDs,omitempty"`
	ClearOrganization            *bool                  `json:"clearOrganization,omitempty"`
	AddInviteIDs                 []string               `json:"addInviteIDs,omitempty"`
	RemoveInviteIDs              []string               `json:"removeInviteIDs,omitempty"`
	ClearInvite                  *bool                  `json:"clearInvite,omitempty"`
	AddFeatureIDs                []string               `json:"addFeatureIDs,omitempty"`
	RemoveFeatureIDs             []string               `json:"removeFeatureIDs,omitempty"`
	ClearFeature                 *bool                  `json:"clearFeature,omitempty"`
	AddEntitlementplanIDs        []string               `json:"addEntitlementplanIDs,omitempty"`
	RemoveEntitlementplanIDs     []string               `json:"removeEntitlementplanIDs,omitempty"`
	ClearEntitlementplan         *bool                  `json:"clearEntitlementplan,omitempty"`
	AddPersonalAccessTokenIDs    []string               `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs []string               `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessToken     *bool                  `json:"clearPersonalAccessToken,omitempty"`
	AddOauth2tokenIDs            []string               `json:"addOauth2tokenIDs,omitempty"`
	RemoveOauth2tokenIDs         []string               `json:"removeOauth2tokenIDs,omitempty"`
	ClearOauth2token             *bool                  `json:"clearOauth2token,omitempty"`
	AddHushIDs                   []string               `json:"addHushIDs,omitempty"`
	RemoveHushIDs                []string               `json:"removeHushIDs,omitempty"`
	ClearHush                    *bool                  `json:"clearHush,omitempty"`
	AddEntitlementIDs            []string               `json:"addEntitlementIDs,omitempty"`
	RemoveEntitlementIDs         []string               `json:"removeEntitlementIDs,omitempty"`
	ClearEntitlement             *bool                  `json:"clearEntitlement,omitempty"`
	AddWebhookIDs                []string               `json:"addWebhookIDs,omitempty"`
	RemoveWebhookIDs             []string               `json:"removeWebhookIDs,omitempty"`
	ClearWebhook                 *bool                  `json:"clearWebhook,omitempty"`
	AddSubscriberIDs             []string               `json:"addSubscriberIDs,omitempty"`
	RemoveSubscriberIDs          []string               `json:"removeSubscriberIDs,omitempty"`
	ClearSubscriber              *bool                  `json:"clearSubscriber,omitempty"`
	AddFileIDs                   []string               `json:"addFileIDs,omitempty"`
	RemoveFileIDs                []string               `json:"removeFileIDs,omitempty"`
	ClearFile                    *bool                  `json:"clearFile,omitempty"`
}

// UpdateFeatureInput is used for update Feature object.
// Input was generated by ent.
type UpdateFeatureInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the displayed 'friendly' name of the feature
	DisplayName      *string `json:"displayName,omitempty"`
	ClearDisplayName *bool   `json:"clearDisplayName,omitempty"`
	// enabled features are available for use
	Enabled *bool `json:"enabled,omitempty"`
	// a description of the feature
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// metadata for the feature
	Metadata       map[string]interface{} `json:"metadata,omitempty"`
	ClearMetadata  *bool                  `json:"clearMetadata,omitempty"`
	OwnerID        *string                `json:"ownerID,omitempty"`
	ClearOwner     *bool                  `json:"clearOwner,omitempty"`
	AddPlanIDs     []string               `json:"addPlanIDs,omitempty"`
	RemovePlanIDs  []string               `json:"removePlanIDs,omitempty"`
	ClearPlans     *bool                  `json:"clearPlans,omitempty"`
	AddEventIDs    []string               `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string               `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool                  `json:"clearEvents,omitempty"`
}

// UpdateFileInput is used for update File object.
// Input was generated by ent.
type UpdateFileInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName *string `json:"providedFileName,omitempty"`
	// the extension of the file provided
	ProvidedFileExtension *string `json:"providedFileExtension,omitempty"`
	// the computed size of the file in the original http request
	ProvidedFileSize       *int64 `json:"providedFileSize,omitempty"`
	ClearProvidedFileSize  *bool  `json:"clearProvidedFileSize,omitempty"`
	PersistedFileSize      *int64 `json:"persistedFileSize,omitempty"`
	ClearPersistedFileSize *bool  `json:"clearPersistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType      *string `json:"detectedMimeType,omitempty"`
	ClearDetectedMimeType *bool   `json:"clearDetectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash      *string `json:"md5Hash,omitempty"`
	ClearMd5Hash *bool   `json:"clearMd5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType *string `json:"detectedContentType,omitempty"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey      *string `json:"storeKey,omitempty"`
	ClearStoreKey *bool   `json:"clearStoreKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType      *string `json:"categoryType,omitempty"`
	ClearCategoryType *bool   `json:"clearCategoryType,omitempty"`
	// the full URI of the file
	URI      *string `json:"uri,omitempty"`
	ClearURI *bool   `json:"clearURI,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme      *string `json:"storageScheme,omitempty"`
	ClearStorageScheme *bool   `json:"clearStorageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume      *string `json:"storageVolume,omitempty"`
	ClearStorageVolume *bool   `json:"clearStorageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath                  *string  `json:"storagePath,omitempty"`
	ClearStoragePath             *bool    `json:"clearStoragePath,omitempty"`
	AddUserIDs                   []string `json:"addUserIDs,omitempty"`
	RemoveUserIDs                []string `json:"removeUserIDs,omitempty"`
	ClearUser                    *bool    `json:"clearUser,omitempty"`
	AddOrganizationIDs           []string `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs        []string `json:"removeOrganizationIDs,omitempty"`
	ClearOrganization            *bool    `json:"clearOrganization,omitempty"`
	AddGroupIDs                  []string `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs               []string `json:"removeGroupIDs,omitempty"`
	ClearGroup                   *bool    `json:"clearGroup,omitempty"`
	AddContactIDs                []string `json:"addContactIDs,omitempty"`
	RemoveContactIDs             []string `json:"removeContactIDs,omitempty"`
	ClearContact                 *bool    `json:"clearContact,omitempty"`
	AddEntityIDs                 []string `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs              []string `json:"removeEntityIDs,omitempty"`
	ClearEntity                  *bool    `json:"clearEntity,omitempty"`
	AddUsersettingIDs            []string `json:"addUsersettingIDs,omitempty"`
	RemoveUsersettingIDs         []string `json:"removeUsersettingIDs,omitempty"`
	ClearUsersetting             *bool    `json:"clearUsersetting,omitempty"`
	AddOrganizationsettingIDs    []string `json:"addOrganizationsettingIDs,omitempty"`
	RemoveOrganizationsettingIDs []string `json:"removeOrganizationsettingIDs,omitempty"`
	ClearOrganizationsetting     *bool    `json:"clearOrganizationsetting,omitempty"`
	AddTemplateIDs               []string `json:"addTemplateIDs,omitempty"`
	RemoveTemplateIDs            []string `json:"removeTemplateIDs,omitempty"`
	ClearTemplate                *bool    `json:"clearTemplate,omitempty"`
	AddDocumentdatumIDs          []string `json:"addDocumentdatumIDs,omitempty"`
	RemoveDocumentdatumIDs       []string `json:"removeDocumentdatumIDs,omitempty"`
	ClearDocumentdata            *bool    `json:"clearDocumentdata,omitempty"`
	AddEventIDs                  []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs               []string `json:"removeEventIDs,omitempty"`
	ClearEvents                  *bool    `json:"clearEvents,omitempty"`
	AddProgramIDs                []string `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs             []string `json:"removeProgramIDs,omitempty"`
	ClearProgram                 *bool    `json:"clearProgram,omitempty"`
}

// UpdateGroupInput is used for update Group object.
// Input was generated by ent.
type UpdateGroupInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the group - must be unique within the organization
	Name *string `json:"name,omitempty"`
	// the groups description
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL      *string `json:"gravatarLogoURL,omitempty"`
	ClearGravatarLogoURL *bool   `json:"clearGravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL      *string `json:"logoURL,omitempty"`
	ClearLogoURL *bool   `json:"clearLogoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName          *string                       `json:"displayName,omitempty"`
	OwnerID              *string                       `json:"ownerID,omitempty"`
	ClearOwner           *bool                         `json:"clearOwner,omitempty"`
	SettingID            *string                       `json:"settingID,omitempty"`
	AddUserIDs           []string                      `json:"addUserIDs,omitempty"`
	RemoveUserIDs        []string                      `json:"removeUserIDs,omitempty"`
	ClearUsers           *bool                         `json:"clearUsers,omitempty"`
	AddEventIDs          []string                      `json:"addEventIDs,omitempty"`
	RemoveEventIDs       []string                      `json:"removeEventIDs,omitempty"`
	ClearEvents          *bool                         `json:"clearEvents,omitempty"`
	AddIntegrationIDs    []string                      `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs []string                      `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations    *bool                         `json:"clearIntegrations,omitempty"`
	AddFileIDs           []string                      `json:"addFileIDs,omitempty"`
	RemoveFileIDs        []string                      `json:"removeFileIDs,omitempty"`
	ClearFiles           *bool                         `json:"clearFiles,omitempty"`
	AddTaskIDs           []string                      `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs        []string                      `json:"removeTaskIDs,omitempty"`
	ClearTasks           *bool                         `json:"clearTasks,omitempty"`
	AddGroupMembers      []*CreateGroupMembershipInput `json:"addGroupMembers,omitempty"`
	UpdateGroupSettings  *UpdateGroupSettingInput      `json:"updateGroupSettings,omitempty"`
}

// UpdateGroupMembershipInput is used for update GroupMembership object.
// Input was generated by ent.
type UpdateGroupMembershipInput struct {
	Role           *enums.Role `json:"role,omitempty"`
	AddEventIDs    []string    `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string    `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool       `json:"clearEvents,omitempty"`
}

// UpdateGroupSettingInput is used for update GroupSetting object.
// Input was generated by ent.
type UpdateGroupSettingInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility *enums.Visibility `json:"visibility,omitempty"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy *enums.JoinPolicy `json:"joinPolicy,omitempty"`
	// whether to sync group members to slack groups
	SyncToSlack      *bool `json:"syncToSlack,omitempty"`
	ClearSyncToSlack *bool `json:"clearSyncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub      *bool   `json:"syncToGithub,omitempty"`
	ClearSyncToGithub *bool   `json:"clearSyncToGithub,omitempty"`
	GroupID           *string `json:"groupID,omitempty"`
	ClearGroup        *bool   `json:"clearGroup,omitempty"`
}

// UpdateHushInput is used for update Hush object.
// Input was generated by ent.
type UpdateHushInput struct {
	// the logical name of the corresponding hush secret or it's general grouping
	Name *string `json:"name,omitempty"`
	// a description of the hush value or purpose, such as github PAT
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind                  *string  `json:"kind,omitempty"`
	ClearKind             *bool    `json:"clearKind,omitempty"`
	AddIntegrationIDs     []string `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs  []string `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations     *bool    `json:"clearIntegrations,omitempty"`
	AddOrganizationIDs    []string `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs []string `json:"removeOrganizationIDs,omitempty"`
	ClearOrganization     *bool    `json:"clearOrganization,omitempty"`
	AddEventIDs           []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs        []string `json:"removeEventIDs,omitempty"`
	ClearEvents           *bool    `json:"clearEvents,omitempty"`
}

// UpdateIntegrationInput is used for update Integration object.
// Input was generated by ent.
type UpdateIntegrationInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the integration - must be unique within the organization
	Name *string `json:"name,omitempty"`
	// a description of the integration
	Description          *string  `json:"description,omitempty"`
	ClearDescription     *bool    `json:"clearDescription,omitempty"`
	Kind                 *string  `json:"kind,omitempty"`
	ClearKind            *bool    `json:"clearKind,omitempty"`
	OwnerID              *string  `json:"ownerID,omitempty"`
	ClearOwner           *bool    `json:"clearOwner,omitempty"`
	AddSecretIDs         []string `json:"addSecretIDs,omitempty"`
	RemoveSecretIDs      []string `json:"removeSecretIDs,omitempty"`
	ClearSecrets         *bool    `json:"clearSecrets,omitempty"`
	AddOauth2tokenIDs    []string `json:"addOauth2tokenIDs,omitempty"`
	RemoveOauth2tokenIDs []string `json:"removeOauth2tokenIDs,omitempty"`
	ClearOauth2tokens    *bool    `json:"clearOauth2tokens,omitempty"`
	AddEventIDs          []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs       []string `json:"removeEventIDs,omitempty"`
	ClearEvents          *bool    `json:"clearEvents,omitempty"`
	AddWebhookIDs        []string `json:"addWebhookIDs,omitempty"`
	RemoveWebhookIDs     []string `json:"removeWebhookIDs,omitempty"`
	ClearWebhooks        *bool    `json:"clearWebhooks,omitempty"`
}

// UpdateInternalPolicyInput is used for update InternalPolicy object.
// Input was generated by ent.
type UpdateInternalPolicyInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the policy
	Name *string `json:"name,omitempty"`
	// description of the policy
	Description *string `json:"description,omitempty"`
	// status of the policy
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// type of the policy
	PolicyType      *string `json:"policyType,omitempty"`
	ClearPolicyType *bool   `json:"clearPolicyType,omitempty"`
	// version of the policy
	Version      *string `json:"version,omitempty"`
	ClearVersion *bool   `json:"clearVersion,omitempty"`
	// purpose and scope
	PurposeAndScope      *string `json:"purposeAndScope,omitempty"`
	ClearPurposeAndScope *bool   `json:"clearPurposeAndScope,omitempty"`
	// background of the policy
	Background      *string `json:"background,omitempty"`
	ClearBackground *bool   `json:"clearBackground,omitempty"`
	// json data for the policy document
	Details                   map[string]interface{} `json:"details,omitempty"`
	ClearDetails              *bool                  `json:"clearDetails,omitempty"`
	AddControlobjectiveIDs    []string               `json:"addControlobjectiveIDs,omitempty"`
	RemoveControlobjectiveIDs []string               `json:"removeControlobjectiveIDs,omitempty"`
	ClearControlobjectives    *bool                  `json:"clearControlobjectives,omitempty"`
	AddControlIDs             []string               `json:"addControlIDs,omitempty"`
	RemoveControlIDs          []string               `json:"removeControlIDs,omitempty"`
	ClearControls             *bool                  `json:"clearControls,omitempty"`
	AddProcedureIDs           []string               `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs        []string               `json:"removeProcedureIDs,omitempty"`
	ClearProcedures           *bool                  `json:"clearProcedures,omitempty"`
	AddNarrativeIDs           []string               `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs        []string               `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives           *bool                  `json:"clearNarratives,omitempty"`
	AddTaskIDs                []string               `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs             []string               `json:"removeTaskIDs,omitempty"`
	ClearTasks                *bool                  `json:"clearTasks,omitempty"`
	AddProgramIDs             []string               `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs          []string               `json:"removeProgramIDs,omitempty"`
	ClearPrograms             *bool                  `json:"clearPrograms,omitempty"`
}

// UpdateInviteInput is used for update Invite object.
// Input was generated by ent.
type UpdateInviteInput struct {
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires      *time.Time `json:"expires,omitempty"`
	ClearExpires *bool      `json:"clearExpires,omitempty"`
	// the status of the invitation
	Status *enums.InviteStatus `json:"status,omitempty"`
	Role   *enums.Role         `json:"role,omitempty"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts   *int64   `json:"sendAttempts,omitempty"`
	OwnerID        *string  `json:"ownerID,omitempty"`
	ClearOwner     *bool    `json:"clearOwner,omitempty"`
	AddEventIDs    []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool    `json:"clearEvents,omitempty"`
}

// UpdateNarrativeInput is used for update Narrative object.
// Input was generated by ent.
type UpdateNarrativeInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the narrative
	Name *string `json:"name,omitempty"`
	// the description of the narrative
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// which controls are satisfied by the narrative
	Satisfies      *string `json:"satisfies,omitempty"`
	ClearSatisfies *bool   `json:"clearSatisfies,omitempty"`
	// json data for the narrative document
	Details                   map[string]interface{} `json:"details,omitempty"`
	ClearDetails              *bool                  `json:"clearDetails,omitempty"`
	AddPolicyIDs              []string               `json:"addPolicyIDs,omitempty"`
	RemovePolicyIDs           []string               `json:"removePolicyIDs,omitempty"`
	ClearPolicy               *bool                  `json:"clearPolicy,omitempty"`
	AddControlIDs             []string               `json:"addControlIDs,omitempty"`
	RemoveControlIDs          []string               `json:"removeControlIDs,omitempty"`
	ClearControl              *bool                  `json:"clearControl,omitempty"`
	AddProcedureIDs           []string               `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs        []string               `json:"removeProcedureIDs,omitempty"`
	ClearProcedure            *bool                  `json:"clearProcedure,omitempty"`
	AddControlobjectiveIDs    []string               `json:"addControlobjectiveIDs,omitempty"`
	RemoveControlobjectiveIDs []string               `json:"removeControlobjectiveIDs,omitempty"`
	ClearControlobjective     *bool                  `json:"clearControlobjective,omitempty"`
	AddProgramIDs             []string               `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs          []string               `json:"removeProgramIDs,omitempty"`
	ClearProgram              *bool                  `json:"clearProgram,omitempty"`
}

// UpdateNoteInput is used for update Note object.
// Input was generated by ent.
type UpdateNoteInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the text of the note
	Text                *string  `json:"text,omitempty"`
	OwnerID             *string  `json:"ownerID,omitempty"`
	ClearOwner          *bool    `json:"clearOwner,omitempty"`
	EntityID            *string  `json:"entityID,omitempty"`
	ClearEntity         *bool    `json:"clearEntity,omitempty"`
	AddSubcontrolIDs    []string `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs []string `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols    *bool    `json:"clearSubcontrols,omitempty"`
	AddProgramIDs       []string `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs    []string `json:"removeProgramIDs,omitempty"`
	ClearProgram        *bool    `json:"clearProgram,omitempty"`
}

// UpdateOauthProviderInput is used for update OauthProvider object.
// Input was generated by ent.
type UpdateOauthProviderInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the oauth provider's name
	Name *string `json:"name,omitempty"`
	// the client id for the oauth provider
	ClientID *string `json:"clientID,omitempty"`
	// the client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// the redirect url
	RedirectURL *string `json:"redirectURL,omitempty"`
	// the scopes
	Scopes *string `json:"scopes,omitempty"`
	// the auth url of the provider
	AuthURL *string `json:"authURL,omitempty"`
	// the token url of the provider
	TokenURL *string `json:"tokenURL,omitempty"`
	// the auth style, 0: auto detect 1: third party log in 2: log in with username and password
	AuthStyle *string `json:"authStyle,omitempty"`
	// the URL to request user information by token
	InfoURL    *string `json:"infoURL,omitempty"`
	OwnerID    *string `json:"ownerID,omitempty"`
	ClearOwner *bool   `json:"clearOwner,omitempty"`
}

// UpdateOhAuthTooTokenInput is used for update OhAuthTooToken object.
// Input was generated by ent.
type UpdateOhAuthTooTokenInput struct {
	// tags associated with the object
	Tags                    []string   `json:"tags,omitempty"`
	AppendTags              []string   `json:"appendTags,omitempty"`
	ClearTags               *bool      `json:"clearTags,omitempty"`
	ClientID                *string    `json:"clientID,omitempty"`
	Scopes                  []string   `json:"scopes,omitempty"`
	AppendScopes            []string   `json:"appendScopes,omitempty"`
	ClearScopes             *bool      `json:"clearScopes,omitempty"`
	Nonce                   *string    `json:"nonce,omitempty"`
	ClaimsUserID            *string    `json:"claimsUserID,omitempty"`
	ClaimsUsername          *string    `json:"claimsUsername,omitempty"`
	ClaimsEmail             *string    `json:"claimsEmail,omitempty"`
	ClaimsEmailVerified     *bool      `json:"claimsEmailVerified,omitempty"`
	ClaimsGroups            []string   `json:"claimsGroups,omitempty"`
	AppendClaimsGroups      []string   `json:"appendClaimsGroups,omitempty"`
	ClearClaimsGroups       *bool      `json:"clearClaimsGroups,omitempty"`
	ClaimsPreferredUsername *string    `json:"claimsPreferredUsername,omitempty"`
	ConnectorID             *string    `json:"connectorID,omitempty"`
	ConnectorData           []string   `json:"connectorData,omitempty"`
	AppendConnectorData     []string   `json:"appendConnectorData,omitempty"`
	ClearConnectorData      *bool      `json:"clearConnectorData,omitempty"`
	LastUsed                *time.Time `json:"lastUsed,omitempty"`
	AddIntegrationIDs       []string   `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs    []string   `json:"removeIntegrationIDs,omitempty"`
	ClearIntegration        *bool      `json:"clearIntegration,omitempty"`
	AddEventIDs             []string   `json:"addEventIDs,omitempty"`
	RemoveEventIDs          []string   `json:"removeEventIDs,omitempty"`
	ClearEvents             *bool      `json:"clearEvents,omitempty"`
}

// UpdateOrgMembershipInput is used for update OrgMembership object.
// Input was generated by ent.
type UpdateOrgMembershipInput struct {
	Role           *enums.Role `json:"role,omitempty"`
	AddEventIDs    []string    `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string    `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool       `json:"clearEvents,omitempty"`
}

// UpdateOrganizationInput is used for update Organization object.
// Input was generated by ent.
type UpdateOrganizationInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the organization
	Name *string `json:"name,omitempty"`
	// The organization's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the organization
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL                  *string                         `json:"avatarRemoteURL,omitempty"`
	ClearAvatarRemoteURL             *bool                           `json:"clearAvatarRemoteURL,omitempty"`
	AddGroupIDs                      []string                        `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs                   []string                        `json:"removeGroupIDs,omitempty"`
	ClearGroups                      *bool                           `json:"clearGroups,omitempty"`
	AddTemplateIDs                   []string                        `json:"addTemplateIDs,omitempty"`
	RemoveTemplateIDs                []string                        `json:"removeTemplateIDs,omitempty"`
	ClearTemplates                   *bool                           `json:"clearTemplates,omitempty"`
	AddIntegrationIDs                []string                        `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs             []string                        `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations                *bool                           `json:"clearIntegrations,omitempty"`
	SettingID                        *string                         `json:"settingID,omitempty"`
	ClearSetting                     *bool                           `json:"clearSetting,omitempty"`
	AddDocumentdatumIDs              []string                        `json:"addDocumentdatumIDs,omitempty"`
	RemoveDocumentdatumIDs           []string                        `json:"removeDocumentdatumIDs,omitempty"`
	ClearDocumentdata                *bool                           `json:"clearDocumentdata,omitempty"`
	AddEntitlementIDs                []string                        `json:"addEntitlementIDs,omitempty"`
	RemoveEntitlementIDs             []string                        `json:"removeEntitlementIDs,omitempty"`
	ClearEntitlements                *bool                           `json:"clearEntitlements,omitempty"`
	AddOrganizationEntitlementIDs    []string                        `json:"addOrganizationEntitlementIDs,omitempty"`
	RemoveOrganizationEntitlementIDs []string                        `json:"removeOrganizationEntitlementIDs,omitempty"`
	ClearOrganizationEntitlement     *bool                           `json:"clearOrganizationEntitlement,omitempty"`
	AddPersonalAccessTokenIDs        []string                        `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs     []string                        `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessTokens        *bool                           `json:"clearPersonalAccessTokens,omitempty"`
	AddAPITokenIDs                   []string                        `json:"addAPITokenIDs,omitempty"`
	RemoveAPITokenIDs                []string                        `json:"removeAPITokenIDs,omitempty"`
	ClearAPITokens                   *bool                           `json:"clearAPITokens,omitempty"`
	AddOauthproviderIDs              []string                        `json:"addOauthproviderIDs,omitempty"`
	RemoveOauthproviderIDs           []string                        `json:"removeOauthproviderIDs,omitempty"`
	ClearOauthprovider               *bool                           `json:"clearOauthprovider,omitempty"`
	AddUserIDs                       []string                        `json:"addUserIDs,omitempty"`
	RemoveUserIDs                    []string                        `json:"removeUserIDs,omitempty"`
	ClearUsers                       *bool                           `json:"clearUsers,omitempty"`
	AddInviteIDs                     []string                        `json:"addInviteIDs,omitempty"`
	RemoveInviteIDs                  []string                        `json:"removeInviteIDs,omitempty"`
	ClearInvites                     *bool                           `json:"clearInvites,omitempty"`
	AddSubscriberIDs                 []string                        `json:"addSubscriberIDs,omitempty"`
	RemoveSubscriberIDs              []string                        `json:"removeSubscriberIDs,omitempty"`
	ClearSubscribers                 *bool                           `json:"clearSubscribers,omitempty"`
	AddWebhookIDs                    []string                        `json:"addWebhookIDs,omitempty"`
	RemoveWebhookIDs                 []string                        `json:"removeWebhookIDs,omitempty"`
	ClearWebhooks                    *bool                           `json:"clearWebhooks,omitempty"`
	AddEventIDs                      []string                        `json:"addEventIDs,omitempty"`
	RemoveEventIDs                   []string                        `json:"removeEventIDs,omitempty"`
	ClearEvents                      *bool                           `json:"clearEvents,omitempty"`
	AddSecretIDs                     []string                        `json:"addSecretIDs,omitempty"`
	RemoveSecretIDs                  []string                        `json:"removeSecretIDs,omitempty"`
	ClearSecrets                     *bool                           `json:"clearSecrets,omitempty"`
	AddFeatureIDs                    []string                        `json:"addFeatureIDs,omitempty"`
	RemoveFeatureIDs                 []string                        `json:"removeFeatureIDs,omitempty"`
	ClearFeatures                    *bool                           `json:"clearFeatures,omitempty"`
	AddFileIDs                       []string                        `json:"addFileIDs,omitempty"`
	RemoveFileIDs                    []string                        `json:"removeFileIDs,omitempty"`
	ClearFiles                       *bool                           `json:"clearFiles,omitempty"`
	AddEntitlementplanIDs            []string                        `json:"addEntitlementplanIDs,omitempty"`
	RemoveEntitlementplanIDs         []string                        `json:"removeEntitlementplanIDs,omitempty"`
	ClearEntitlementplans            *bool                           `json:"clearEntitlementplans,omitempty"`
	AddEntityIDs                     []string                        `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs                  []string                        `json:"removeEntityIDs,omitempty"`
	ClearEntities                    *bool                           `json:"clearEntities,omitempty"`
	AddEntitytypeIDs                 []string                        `json:"addEntitytypeIDs,omitempty"`
	RemoveEntitytypeIDs              []string                        `json:"removeEntitytypeIDs,omitempty"`
	ClearEntitytypes                 *bool                           `json:"clearEntitytypes,omitempty"`
	AddContactIDs                    []string                        `json:"addContactIDs,omitempty"`
	RemoveContactIDs                 []string                        `json:"removeContactIDs,omitempty"`
	ClearContacts                    *bool                           `json:"clearContacts,omitempty"`
	AddNoteIDs                       []string                        `json:"addNoteIDs,omitempty"`
	RemoveNoteIDs                    []string                        `json:"removeNoteIDs,omitempty"`
	ClearNotes                       *bool                           `json:"clearNotes,omitempty"`
	AddTaskIDs                       []string                        `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs                    []string                        `json:"removeTaskIDs,omitempty"`
	ClearTasks                       *bool                           `json:"clearTasks,omitempty"`
	AddProgramIDs                    []string                        `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs                 []string                        `json:"removeProgramIDs,omitempty"`
	ClearPrograms                    *bool                           `json:"clearPrograms,omitempty"`
	AddOrgMembers                    []*CreateOrgMembershipInput     `json:"addOrgMembers,omitempty"`
	UpdateOrgSettings                *UpdateOrganizationSettingInput `json:"updateOrgSettings,omitempty"`
}

// UpdateOrganizationSettingInput is used for update OrganizationSetting object.
// Input was generated by ent.
type UpdateOrganizationSettingInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// domains associated with the organization
	Domains       []string `json:"domains,omitempty"`
	AppendDomains []string `json:"appendDomains,omitempty"`
	ClearDomains  *bool    `json:"clearDomains,omitempty"`
	// Name of the person to contact for billing
	BillingContact      *string `json:"billingContact,omitempty"`
	ClearBillingContact *bool   `json:"clearBillingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail      *string `json:"billingEmail,omitempty"`
	ClearBillingEmail *bool   `json:"clearBillingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone      *string `json:"billingPhone,omitempty"`
	ClearBillingPhone *bool   `json:"clearBillingPhone,omitempty"`
	// Address to send billing information to
	BillingAddress      *string `json:"billingAddress,omitempty"`
	ClearBillingAddress *bool   `json:"clearBillingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier      *string `json:"taxIdentifier,omitempty"`
	ClearTaxIdentifier *bool   `json:"clearTaxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation       *enums.Region `json:"geoLocation,omitempty"`
	ClearGeoLocation  *bool         `json:"clearGeoLocation,omitempty"`
	OrganizationID    *string       `json:"organizationID,omitempty"`
	ClearOrganization *bool         `json:"clearOrganization,omitempty"`
	AddFileIDs        []string      `json:"addFileIDs,omitempty"`
	RemoveFileIDs     []string      `json:"removeFileIDs,omitempty"`
	ClearFiles        *bool         `json:"clearFiles,omitempty"`
}

// UpdatePersonalAccessTokenInput is used for update PersonalAccessToken object.
// Input was generated by ent.
type UpdatePersonalAccessTokenInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name associated with the token
	Name *string `json:"name,omitempty"`
	// a description of the token's purpose
	Description           *string    `json:"description,omitempty"`
	ClearDescription      *bool      `json:"clearDescription,omitempty"`
	Scopes                []string   `json:"scopes,omitempty"`
	AppendScopes          []string   `json:"appendScopes,omitempty"`
	ClearScopes           *bool      `json:"clearScopes,omitempty"`
	LastUsedAt            *time.Time `json:"lastUsedAt,omitempty"`
	ClearLastUsedAt       *bool      `json:"clearLastUsedAt,omitempty"`
	AddOrganizationIDs    []string   `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs []string   `json:"removeOrganizationIDs,omitempty"`
	ClearOrganizations    *bool      `json:"clearOrganizations,omitempty"`
	AddEventIDs           []string   `json:"addEventIDs,omitempty"`
	RemoveEventIDs        []string   `json:"removeEventIDs,omitempty"`
	ClearEvents           *bool      `json:"clearEvents,omitempty"`
}

// UpdateProcedureInput is used for update Procedure object.
// Input was generated by ent.
type UpdateProcedureInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the procedure
	Name *string `json:"name,omitempty"`
	// description of the procedure
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// status of the procedure
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// type of the procedure
	ProcedureType      *string `json:"procedureType,omitempty"`
	ClearProcedureType *bool   `json:"clearProcedureType,omitempty"`
	// version of the procedure
	Version      *string `json:"version,omitempty"`
	ClearVersion *bool   `json:"clearVersion,omitempty"`
	// purpose and scope
	PurposeAndScope      *string `json:"purposeAndScope,omitempty"`
	ClearPurposeAndScope *bool   `json:"clearPurposeAndScope,omitempty"`
	// background of the procedure
	Background      *string `json:"background,omitempty"`
	ClearBackground *bool   `json:"clearBackground,omitempty"`
	// which controls are satisfied by the procedure
	Satisfies      *string `json:"satisfies,omitempty"`
	ClearSatisfies *bool   `json:"clearSatisfies,omitempty"`
	// json data for the procedure document
	Details                 map[string]interface{} `json:"details,omitempty"`
	ClearDetails            *bool                  `json:"clearDetails,omitempty"`
	AddControlIDs           []string               `json:"addControlIDs,omitempty"`
	RemoveControlIDs        []string               `json:"removeControlIDs,omitempty"`
	ClearControl            *bool                  `json:"clearControl,omitempty"`
	AddInternalpolicyIDs    []string               `json:"addInternalpolicyIDs,omitempty"`
	RemoveInternalpolicyIDs []string               `json:"removeInternalpolicyIDs,omitempty"`
	ClearInternalpolicy     *bool                  `json:"clearInternalpolicy,omitempty"`
	AddNarrativeIDs         []string               `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs      []string               `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives         *bool                  `json:"clearNarratives,omitempty"`
	AddRiskIDs              []string               `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs           []string               `json:"removeRiskIDs,omitempty"`
	ClearRisks              *bool                  `json:"clearRisks,omitempty"`
	AddTaskIDs              []string               `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs           []string               `json:"removeTaskIDs,omitempty"`
	ClearTasks              *bool                  `json:"clearTasks,omitempty"`
	AddProgramIDs           []string               `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs        []string               `json:"removeProgramIDs,omitempty"`
	ClearPrograms           *bool                  `json:"clearPrograms,omitempty"`
}

// UpdateProgramInput is used for update Program object.
// Input was generated by ent.
type UpdateProgramInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the program
	Name *string `json:"name,omitempty"`
	// the description of the program
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the status of the program
	Status *enums.ProgramStatus `json:"status,omitempty"`
	// the start date of the period
	StartDate      *time.Time `json:"startDate,omitempty"`
	ClearStartDate *bool      `json:"clearStartDate,omitempty"`
	// the end date of the period
	EndDate      *time.Time `json:"endDate,omitempty"`
	ClearEndDate *bool      `json:"clearEndDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady *bool `json:"auditorReady,omitempty"`
	// can the auditor write comments
	AuditorWriteComments *bool `json:"auditorWriteComments,omitempty"`
	// can the auditor read comments
	AuditorReadComments       *bool    `json:"auditorReadComments,omitempty"`
	OwnerID                   *string  `json:"ownerID,omitempty"`
	ClearOwner                *bool    `json:"clearOwner,omitempty"`
	AddControlIDs             []string `json:"addControlIDs,omitempty"`
	RemoveControlIDs          []string `json:"removeControlIDs,omitempty"`
	ClearControls             *bool    `json:"clearControls,omitempty"`
	AddSubcontrolIDs          []string `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs       []string `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols          *bool    `json:"clearSubcontrols,omitempty"`
	AddControlobjectiveIDs    []string `json:"addControlobjectiveIDs,omitempty"`
	RemoveControlobjectiveIDs []string `json:"removeControlobjectiveIDs,omitempty"`
	ClearControlobjectives    *bool    `json:"clearControlobjectives,omitempty"`
	AddPolicyIDs              []string `json:"addPolicyIDs,omitempty"`
	RemovePolicyIDs           []string `json:"removePolicyIDs,omitempty"`
	ClearPolicies             *bool    `json:"clearPolicies,omitempty"`
	AddProcedureIDs           []string `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs        []string `json:"removeProcedureIDs,omitempty"`
	ClearProcedures           *bool    `json:"clearProcedures,omitempty"`
	AddRiskIDs                []string `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs             []string `json:"removeRiskIDs,omitempty"`
	ClearRisks                *bool    `json:"clearRisks,omitempty"`
	AddTaskIDs                []string `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs             []string `json:"removeTaskIDs,omitempty"`
	ClearTasks                *bool    `json:"clearTasks,omitempty"`
	AddNoteIDs                []string `json:"addNoteIDs,omitempty"`
	RemoveNoteIDs             []string `json:"removeNoteIDs,omitempty"`
	ClearNotes                *bool    `json:"clearNotes,omitempty"`
	AddFileIDs                []string `json:"addFileIDs,omitempty"`
	RemoveFileIDs             []string `json:"removeFileIDs,omitempty"`
	ClearFiles                *bool    `json:"clearFiles,omitempty"`
	AddNarrativeIDs           []string `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs        []string `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives           *bool    `json:"clearNarratives,omitempty"`
	AddActionplanIDs          []string `json:"addActionplanIDs,omitempty"`
	RemoveActionplanIDs       []string `json:"removeActionplanIDs,omitempty"`
	ClearActionplans          *bool    `json:"clearActionplans,omitempty"`
	AddStandardIDs            []string `json:"addStandardIDs,omitempty"`
	RemoveStandardIDs         []string `json:"removeStandardIDs,omitempty"`
	ClearStandards            *bool    `json:"clearStandards,omitempty"`
	AddUserIDs                []string `json:"addUserIDs,omitempty"`
	RemoveUserIDs             []string `json:"removeUserIDs,omitempty"`
	ClearUsers                *bool    `json:"clearUsers,omitempty"`
}

// UpdateProgramMembershipInput is used for update ProgramMembership object.
// Input was generated by ent.
type UpdateProgramMembershipInput struct {
	Role *enums.Role `json:"role,omitempty"`
}

// UpdateRiskInput is used for update Risk object.
// Input was generated by ent.
type UpdateRiskInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the risk
	Name *string `json:"name,omitempty"`
	// description of the risk
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// status of the risk - mitigated or not, inflight, etc.
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType      *string `json:"riskType,omitempty"`
	ClearRiskType *bool   `json:"clearRiskType,omitempty"`
	// business costs associated with the risk
	BusinessCosts      *string `json:"businessCosts,omitempty"`
	ClearBusinessCosts *bool   `json:"clearBusinessCosts,omitempty"`
	// impact of the risk - high, medium, low
	Impact      *enums.RiskImpact `json:"impact,omitempty"`
	ClearImpact *bool             `json:"clearImpact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood      *enums.RiskLikelihood `json:"likelihood,omitempty"`
	ClearLikelihood *bool                 `json:"clearLikelihood,omitempty"`
	// mitigation for the risk
	Mitigation      *string `json:"mitigation,omitempty"`
	ClearMitigation *bool   `json:"clearMitigation,omitempty"`
	// which controls are satisfied by the risk
	Satisfies      *string `json:"satisfies,omitempty"`
	ClearSatisfies *bool   `json:"clearSatisfies,omitempty"`
	// json data for the risk document
	Details             map[string]interface{} `json:"details,omitempty"`
	ClearDetails        *bool                  `json:"clearDetails,omitempty"`
	AddControlIDs       []string               `json:"addControlIDs,omitempty"`
	RemoveControlIDs    []string               `json:"removeControlIDs,omitempty"`
	ClearControl        *bool                  `json:"clearControl,omitempty"`
	AddProcedureIDs     []string               `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs  []string               `json:"removeProcedureIDs,omitempty"`
	ClearProcedure      *bool                  `json:"clearProcedure,omitempty"`
	AddActionplanIDs    []string               `json:"addActionplanIDs,omitempty"`
	RemoveActionplanIDs []string               `json:"removeActionplanIDs,omitempty"`
	ClearActionplans    *bool                  `json:"clearActionplans,omitempty"`
	AddProgramIDs       []string               `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs    []string               `json:"removeProgramIDs,omitempty"`
	ClearProgram        *bool                  `json:"clearProgram,omitempty"`
}

// UpdateStandardInput is used for update Standard object.
// Input was generated by ent.
type UpdateStandardInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the standard body, e.g. TSC, NIST, SOC, HITRUST, FedRamp, etc.
	Name *string `json:"name,omitempty"`
	// description of the standard
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// family of the standard, e.g. 800-53, 800-171, 27001, etc.
	Family      *string `json:"family,omitempty"`
	ClearFamily *bool   `json:"clearFamily,omitempty"`
	// status of the standard - active, deprecated, etc.
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// type of the standard - security, privacy, etc.
	StandardType      *string `json:"standardType,omitempty"`
	ClearStandardType *bool   `json:"clearStandardType,omitempty"`
	// version of the standard
	Version      *string `json:"version,omitempty"`
	ClearVersion *bool   `json:"clearVersion,omitempty"`
	// purpose and scope
	PurposeAndScope      *string `json:"purposeAndScope,omitempty"`
	ClearPurposeAndScope *bool   `json:"clearPurposeAndScope,omitempty"`
	// background of the standard
	Background      *string `json:"background,omitempty"`
	ClearBackground *bool   `json:"clearBackground,omitempty"`
	// which controls are satisfied by the standard
	Satisfies      *string `json:"satisfies,omitempty"`
	ClearSatisfies *bool   `json:"clearSatisfies,omitempty"`
	// json data with details of the standard
	Details                   map[string]interface{} `json:"details,omitempty"`
	ClearDetails              *bool                  `json:"clearDetails,omitempty"`
	AddControlobjectiveIDs    []string               `json:"addControlobjectiveIDs,omitempty"`
	RemoveControlobjectiveIDs []string               `json:"removeControlobjectiveIDs,omitempty"`
	ClearControlobjectives    *bool                  `json:"clearControlobjectives,omitempty"`
	AddControlIDs             []string               `json:"addControlIDs,omitempty"`
	RemoveControlIDs          []string               `json:"removeControlIDs,omitempty"`
	ClearControls             *bool                  `json:"clearControls,omitempty"`
	AddProcedureIDs           []string               `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs        []string               `json:"removeProcedureIDs,omitempty"`
	ClearProcedures           *bool                  `json:"clearProcedures,omitempty"`
	AddActionplanIDs          []string               `json:"addActionplanIDs,omitempty"`
	RemoveActionplanIDs       []string               `json:"removeActionplanIDs,omitempty"`
	ClearActionplans          *bool                  `json:"clearActionplans,omitempty"`
	AddProgramIDs             []string               `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs          []string               `json:"removeProgramIDs,omitempty"`
	ClearPrograms             *bool                  `json:"clearPrograms,omitempty"`
}

// UpdateSubcontrolInput is used for update Subcontrol object.
// Input was generated by ent.
type UpdateSubcontrolInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the subcontrol
	Name *string `json:"name,omitempty"`
	// description of the subcontrol
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// status of the subcontrol
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// type of the subcontrol
	SubcontrolType      *string `json:"subcontrolType,omitempty"`
	ClearSubcontrolType *bool   `json:"clearSubcontrolType,omitempty"`
	// version of the control
	Version      *string `json:"version,omitempty"`
	ClearVersion *bool   `json:"clearVersion,omitempty"`
	// number of the subcontrol
	SubcontrolNumber      *string `json:"subcontrolNumber,omitempty"`
	ClearSubcontrolNumber *bool   `json:"clearSubcontrolNumber,omitempty"`
	// subcontrol family
	Family      *string `json:"family,omitempty"`
	ClearFamily *bool   `json:"clearFamily,omitempty"`
	// subcontrol class
	Class      *string `json:"class,omitempty"`
	ClearClass *bool   `json:"clearClass,omitempty"`
	// source of the control, e.g. framework, template, user-defined, etc.
	Source      *string `json:"source,omitempty"`
	ClearSource *bool   `json:"clearSource,omitempty"`
	// mapped frameworks that the subcontrol is part of
	MappedFrameworks      *string `json:"mappedFrameworks,omitempty"`
	ClearMappedFrameworks *bool   `json:"clearMappedFrameworks,omitempty"`
	// implementation evidence of the subcontrol
	ImplementationEvidence      *string `json:"implementationEvidence,omitempty"`
	ClearImplementationEvidence *bool   `json:"clearImplementationEvidence,omitempty"`
	// implementation status
	ImplementationStatus      *string `json:"implementationStatus,omitempty"`
	ClearImplementationStatus *bool   `json:"clearImplementationStatus,omitempty"`
	// date the subcontrol was implemented
	ImplementationDate      *time.Time `json:"implementationDate,omitempty"`
	ClearImplementationDate *bool      `json:"clearImplementationDate,omitempty"`
	// implementation verification
	ImplementationVerification      *string `json:"implementationVerification,omitempty"`
	ClearImplementationVerification *bool   `json:"clearImplementationVerification,omitempty"`
	// date the subcontrol implementation was verified
	ImplementationVerificationDate      *time.Time `json:"implementationVerificationDate,omitempty"`
	ClearImplementationVerificationDate *bool      `json:"clearImplementationVerificationDate,omitempty"`
	// json data details of the subcontrol
	Details          map[string]interface{} `json:"details,omitempty"`
	ClearDetails     *bool                  `json:"clearDetails,omitempty"`
	AddControlIDs    []string               `json:"addControlIDs,omitempty"`
	RemoveControlIDs []string               `json:"removeControlIDs,omitempty"`
	ClearControl     *bool                  `json:"clearControl,omitempty"`
	AddUserIDs       []string               `json:"addUserIDs,omitempty"`
	RemoveUserIDs    []string               `json:"removeUserIDs,omitempty"`
	ClearUser        *bool                  `json:"clearUser,omitempty"`
	AddTaskIDs       []string               `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs    []string               `json:"removeTaskIDs,omitempty"`
	ClearTasks       *bool                  `json:"clearTasks,omitempty"`
	NotesID          *string                `json:"notesID,omitempty"`
	ClearNotes       *bool                  `json:"clearNotes,omitempty"`
	AddProgramIDs    []string               `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs []string               `json:"removeProgramIDs,omitempty"`
	ClearPrograms    *bool                  `json:"clearPrograms,omitempty"`
}

// UpdateSubscriberInput is used for update Subscriber object.
// Input was generated by ent.
type UpdateSubscriberInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// email address of the subscriber
	Email *string `json:"email,omitempty"`
	// phone number of the subscriber
	PhoneNumber      *string  `json:"phoneNumber,omitempty"`
	ClearPhoneNumber *bool    `json:"clearPhoneNumber,omitempty"`
	OwnerID          *string  `json:"ownerID,omitempty"`
	ClearOwner       *bool    `json:"clearOwner,omitempty"`
	AddEventIDs      []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs   []string `json:"removeEventIDs,omitempty"`
	ClearEvents      *bool    `json:"clearEvents,omitempty"`
}

// UpdateTFASettingInput is used for update TFASetting object.
// Input was generated by ent.
type UpdateTFASettingInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// specifies if the TFA device has been verified
	Verified *bool `json:"verified,omitempty"`
	// specifies a user may complete authentication by verifying a TOTP code delivered through an authenticator app
	TotpAllowed      *bool `json:"totpAllowed,omitempty"`
	ClearTotpAllowed *bool `json:"clearTotpAllowed,omitempty"`
	// Whether to regenerate backup codes
	RegenBackupCodes *bool `json:"regenBackupCodes,omitempty"`
}

// UpdateTaskInput is used for update Task object.
// Input was generated by ent.
type UpdateTaskInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the title of the task
	Title *string `json:"title,omitempty"`
	// the description of the task
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the details of the task
	Details      map[string]interface{} `json:"details,omitempty"`
	ClearDetails *bool                  `json:"clearDetails,omitempty"`
	// the status of the task
	Status *enums.TaskStatus `json:"status,omitempty"`
	// the due date of the task
	Due      *time.Time `json:"due,omitempty"`
	ClearDue *bool      `json:"clearDue,omitempty"`
	// the completion date of the task
	Completed                 *time.Time `json:"completed,omitempty"`
	ClearCompleted            *bool      `json:"clearCompleted,omitempty"`
	AssignerID                *string    `json:"assignerID,omitempty"`
	AssigneeID                *string    `json:"assigneeID,omitempty"`
	ClearAssignee             *bool      `json:"clearAssignee,omitempty"`
	AddOrganizationIDs        []string   `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs     []string   `json:"removeOrganizationIDs,omitempty"`
	ClearOrganization         *bool      `json:"clearOrganization,omitempty"`
	AddGroupIDs               []string   `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs            []string   `json:"removeGroupIDs,omitempty"`
	ClearGroup                *bool      `json:"clearGroup,omitempty"`
	AddPolicyIDs              []string   `json:"addPolicyIDs,omitempty"`
	RemovePolicyIDs           []string   `json:"removePolicyIDs,omitempty"`
	ClearPolicy               *bool      `json:"clearPolicy,omitempty"`
	AddProcedureIDs           []string   `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs        []string   `json:"removeProcedureIDs,omitempty"`
	ClearProcedure            *bool      `json:"clearProcedure,omitempty"`
	AddControlIDs             []string   `json:"addControlIDs,omitempty"`
	RemoveControlIDs          []string   `json:"removeControlIDs,omitempty"`
	ClearControl              *bool      `json:"clearControl,omitempty"`
	AddControlObjectiveIDs    []string   `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs []string   `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjective     *bool      `json:"clearControlObjective,omitempty"`
	AddSubcontrolIDs          []string   `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs       []string   `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrol           *bool      `json:"clearSubcontrol,omitempty"`
	AddProgramIDs             []string   `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs          []string   `json:"removeProgramIDs,omitempty"`
	ClearProgram              *bool      `json:"clearProgram,omitempty"`
}

// UpdateTemplateInput is used for update Template object.
// Input was generated by ent.
type UpdateTemplateInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the template
	Name *string `json:"name,omitempty"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType *enums.DocumentType `json:"templateType,omitempty"`
	// the description of the template
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the jsonschema object of the template
	Jsonconfig json.RawMessage `json:"jsonconfig,omitempty"`
	// the uischema for the template to render in the UI
	Uischema          json.RawMessage `json:"uischema,omitempty"`
	ClearUischema     *bool           `json:"clearUischema,omitempty"`
	OwnerID           *string         `json:"ownerID,omitempty"`
	ClearOwner        *bool           `json:"clearOwner,omitempty"`
	AddDocumentIDs    []string        `json:"addDocumentIDs,omitempty"`
	RemoveDocumentIDs []string        `json:"removeDocumentIDs,omitempty"`
	ClearDocuments    *bool           `json:"clearDocuments,omitempty"`
	AddFileIDs        []string        `json:"addFileIDs,omitempty"`
	RemoveFileIDs     []string        `json:"removeFileIDs,omitempty"`
	ClearFiles        *bool           `json:"clearFiles,omitempty"`
}

// UpdateUserInput is used for update User object.
// Input was generated by ent.
type UpdateUserInput struct {
	// tags associated with the object
	Tags           []string `json:"tags,omitempty"`
	AppendTags     []string `json:"appendTags,omitempty"`
	ClearTags      *bool    `json:"clearTags,omitempty"`
	Email          *string  `json:"email,omitempty"`
	FirstName      *string  `json:"firstName,omitempty"`
	ClearFirstName *bool    `json:"clearFirstName,omitempty"`
	LastName       *string  `json:"lastName,omitempty"`
	ClearLastName  *bool    `json:"clearLastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL      *string `json:"avatarRemoteURL,omitempty"`
	ClearAvatarRemoteURL *bool   `json:"clearAvatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile      *string `json:"avatarLocalFile,omitempty"`
	ClearAvatarLocalFile *bool   `json:"clearAvatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt      *time.Time `json:"avatarUpdatedAt,omitempty"`
	ClearAvatarUpdatedAt *bool      `json:"clearAvatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen      *time.Time `json:"lastSeen,omitempty"`
	ClearLastSeen *bool      `json:"clearLastSeen,omitempty"`
	// user password hash
	Password      *string `json:"password,omitempty"`
	ClearPassword *bool   `json:"clearPassword,omitempty"`
	// the Subject of the user JWT
	Sub      *string `json:"sub,omitempty"`
	ClearSub *bool   `json:"clearSub,omitempty"`
	// auth provider used to register the account
	AuthProvider *enums.AuthProvider `json:"authProvider,omitempty"`
	// the user's role
	Role                            *enums.Role `json:"role,omitempty"`
	ClearRole                       *bool       `json:"clearRole,omitempty"`
	AddPersonalAccessTokenIDs       []string    `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs    []string    `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessTokens       *bool       `json:"clearPersonalAccessTokens,omitempty"`
	AddTfaSettingIDs                []string    `json:"addTfaSettingIDs,omitempty"`
	RemoveTfaSettingIDs             []string    `json:"removeTfaSettingIDs,omitempty"`
	ClearTfaSettings                *bool       `json:"clearTfaSettings,omitempty"`
	SettingID                       *string     `json:"settingID,omitempty"`
	AddEmailVerificationTokenIDs    []string    `json:"addEmailVerificationTokenIDs,omitempty"`
	RemoveEmailVerificationTokenIDs []string    `json:"removeEmailVerificationTokenIDs,omitempty"`
	ClearEmailVerificationTokens    *bool       `json:"clearEmailVerificationTokens,omitempty"`
	AddPasswordResetTokenIDs        []string    `json:"addPasswordResetTokenIDs,omitempty"`
	RemovePasswordResetTokenIDs     []string    `json:"removePasswordResetTokenIDs,omitempty"`
	ClearPasswordResetTokens        *bool       `json:"clearPasswordResetTokens,omitempty"`
	AddGroupIDs                     []string    `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs                  []string    `json:"removeGroupIDs,omitempty"`
	ClearGroups                     *bool       `json:"clearGroups,omitempty"`
	AddOrganizationIDs              []string    `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs           []string    `json:"removeOrganizationIDs,omitempty"`
	ClearOrganizations              *bool       `json:"clearOrganizations,omitempty"`
	AddWebauthnIDs                  []string    `json:"addWebauthnIDs,omitempty"`
	RemoveWebauthnIDs               []string    `json:"removeWebauthnIDs,omitempty"`
	ClearWebauthn                   *bool       `json:"clearWebauthn,omitempty"`
	AddFileIDs                      []string    `json:"addFileIDs,omitempty"`
	RemoveFileIDs                   []string    `json:"removeFileIDs,omitempty"`
	ClearFiles                      *bool       `json:"clearFiles,omitempty"`
	FileID                          *string     `json:"fileID,omitempty"`
	ClearFile                       *bool       `json:"clearFile,omitempty"`
	AddEventIDs                     []string    `json:"addEventIDs,omitempty"`
	RemoveEventIDs                  []string    `json:"removeEventIDs,omitempty"`
	ClearEvents                     *bool       `json:"clearEvents,omitempty"`
	AddActionplanIDs                []string    `json:"addActionplanIDs,omitempty"`
	RemoveActionplanIDs             []string    `json:"removeActionplanIDs,omitempty"`
	ClearActionplans                *bool       `json:"clearActionplans,omitempty"`
	AddSubcontrolIDs                []string    `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs             []string    `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols                *bool       `json:"clearSubcontrols,omitempty"`
	AddAssignerTaskIDs              []string    `json:"addAssignerTaskIDs,omitempty"`
	RemoveAssignerTaskIDs           []string    `json:"removeAssignerTaskIDs,omitempty"`
	ClearAssignerTasks              *bool       `json:"clearAssignerTasks,omitempty"`
	AddAssigneeTaskIDs              []string    `json:"addAssigneeTaskIDs,omitempty"`
	RemoveAssigneeTaskIDs           []string    `json:"removeAssigneeTaskIDs,omitempty"`
	ClearAssigneeTasks              *bool       `json:"clearAssigneeTasks,omitempty"`
	AddProgramIDs                   []string    `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs                []string    `json:"removeProgramIDs,omitempty"`
	ClearPrograms                   *bool       `json:"clearPrograms,omitempty"`
}

// UpdateUserSettingInput is used for update UserSetting object.
// Input was generated by ent.
type UpdateUserSettingInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// The time notifications regarding the user were silenced
	SilencedAt      *time.Time `json:"silencedAt,omitempty"`
	ClearSilencedAt *bool      `json:"clearSilencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt      *time.Time `json:"suspendedAt,omitempty"`
	ClearSuspendedAt *bool      `json:"clearSuspendedAt,omitempty"`
	// status of the user account
	Status *enums.UserStatus `json:"status,omitempty"`
	// whether the user has confirmed their email address
	EmailConfirmed *bool `json:"emailConfirmed,omitempty"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed      *bool `json:"isWebauthnAllowed,omitempty"`
	ClearIsWebauthnAllowed *bool `json:"clearIsWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled      *bool    `json:"isTfaEnabled,omitempty"`
	ClearIsTfaEnabled *bool    `json:"clearIsTfaEnabled,omitempty"`
	UserID            *string  `json:"userID,omitempty"`
	ClearUser         *bool    `json:"clearUser,omitempty"`
	DefaultOrgID      *string  `json:"defaultOrgID,omitempty"`
	ClearDefaultOrg   *bool    `json:"clearDefaultOrg,omitempty"`
	AddFileIDs        []string `json:"addFileIDs,omitempty"`
	RemoveFileIDs     []string `json:"removeFileIDs,omitempty"`
	ClearFiles        *bool    `json:"clearFiles,omitempty"`
}

// UpdateWebhookInput is used for update Webhook object.
// Input was generated by ent.
type UpdateWebhookInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the webhook
	Name *string `json:"name,omitempty"`
	// a description of the webhook
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the url to send the webhook to
	DestinationURL *string `json:"destinationURL,omitempty"`
	// indicates if the webhook is active and enabled
	Enabled *bool `json:"enabled,omitempty"`
	// the number of failures
	Failures      *int64 `json:"failures,omitempty"`
	ClearFailures *bool  `json:"clearFailures,omitempty"`
	// the last error message
	LastError      *string `json:"lastError,omitempty"`
	ClearLastError *bool   `json:"clearLastError,omitempty"`
	// the last response
	LastResponse         *string  `json:"lastResponse,omitempty"`
	ClearLastResponse    *bool    `json:"clearLastResponse,omitempty"`
	OwnerID              *string  `json:"ownerID,omitempty"`
	ClearOwner           *bool    `json:"clearOwner,omitempty"`
	AddEventIDs          []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs       []string `json:"removeEventIDs,omitempty"`
	ClearEvents          *bool    `json:"clearEvents,omitempty"`
	AddIntegrationIDs    []string `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs []string `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations    *bool    `json:"clearIntegrations,omitempty"`
}

type User struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags      []string `json:"tags,omitempty"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName,omitempty"`
	LastName  *string  `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile *string `json:"avatarLocalFile,omitempty"`
	// The user's local avatar file id
	AvatarLocalFileID *string `json:"avatarLocalFileID,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// auth provider used to register the account
	AuthProvider enums.AuthProvider `json:"authProvider"`
	// the user's role
	Role                 *enums.Role            `json:"role,omitempty"`
	PersonalAccessTokens []*PersonalAccessToken `json:"personalAccessTokens,omitempty"`
	TfaSettings          []*TFASetting          `json:"tfaSettings,omitempty"`
	Setting              *UserSetting           `json:"setting"`
	Groups               []*Group               `json:"groups,omitempty"`
	Organizations        []*Organization        `json:"organizations,omitempty"`
	Files                []*File                `json:"files,omitempty"`
	File                 *File                  `json:"file,omitempty"`
	Events               []*Event               `json:"events,omitempty"`
	Actionplans          []*ActionPlan          `json:"actionplans,omitempty"`
	Subcontrols          []*Subcontrol          `json:"subcontrols,omitempty"`
	AssignerTasks        []*Task                `json:"assignerTasks,omitempty"`
	AssigneeTasks        []*Task                `json:"assigneeTasks,omitempty"`
	Programs             []*Program             `json:"programs,omitempty"`
	GroupMemberships     []*GroupMembership     `json:"groupMemberships,omitempty"`
	OrgMemberships       []*OrgMembership       `json:"orgMemberships,omitempty"`
	ProgramMemberships   []*ProgramMembership   `json:"programMemberships,omitempty"`
}

func (User) IsNode() {}

// Return response for createBulkUser mutation
type UserBulkCreatePayload struct {
	// Created users
	Users []*User `json:"users,omitempty"`
}

// A connection to a list of items.
type UserConnection struct {
	// A list of edges.
	Edges []*UserEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUser mutation
type UserCreatePayload struct {
	// Created user
	User *User `json:"user"`
}

// Return response for deleteUser mutation
type UserDeletePayload struct {
	// Deleted user ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type UserEdge struct {
	// The item at the end of the edge.
	Node *User `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type UserHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags      []string `json:"tags,omitempty"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName,omitempty"`
	LastName  *string  `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile *string `json:"avatarLocalFile,omitempty"`
	// The user's local avatar file id
	AvatarLocalFileID *string `json:"avatarLocalFileID,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// auth provider used to register the account
	AuthProvider enums.AuthProvider `json:"authProvider"`
	// the user's role
	Role *enums.Role `json:"role,omitempty"`
}

func (UserHistory) IsNode() {}

// A connection to a list of items.
type UserHistoryConnection struct {
	// A list of edges.
	Edges []*UserHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type UserHistoryEdge struct {
	// The item at the end of the edge.
	Node *UserHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for UserHistory connections
type UserHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order UserHistories.
	Field UserHistoryOrderField `json:"field"`
}

// UserHistoryWhereInput is used for filtering UserHistory objects.
// Input was generated by ent.
type UserHistoryWhereInput struct {
	Not *UserHistoryWhereInput   `json:"not,omitempty"`
	And []*UserHistoryWhereInput `json:"and,omitempty"`
	Or  []*UserHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// first_name field predicates
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNeq          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGt           *string  `json:"firstNameGT,omitempty"`
	FirstNameGte          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLt           *string  `json:"firstNameLT,omitempty"`
	FirstNameLte          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        *bool    `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       *bool    `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`
	// last_name field predicates
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNeq          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGt           *string  `json:"lastNameGT,omitempty"`
	LastNameGte          *string  `json:"lastNameGTE,omitempty"`
	LastNameLt           *string  `json:"lastNameLT,omitempty"`
	LastNameLte          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        *bool    `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       *bool    `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file field predicates
	AvatarLocalFile             *string  `json:"avatarLocalFile,omitempty"`
	AvatarLocalFileNeq          *string  `json:"avatarLocalFileNEQ,omitempty"`
	AvatarLocalFileIn           []string `json:"avatarLocalFileIn,omitempty"`
	AvatarLocalFileNotIn        []string `json:"avatarLocalFileNotIn,omitempty"`
	AvatarLocalFileGt           *string  `json:"avatarLocalFileGT,omitempty"`
	AvatarLocalFileGte          *string  `json:"avatarLocalFileGTE,omitempty"`
	AvatarLocalFileLt           *string  `json:"avatarLocalFileLT,omitempty"`
	AvatarLocalFileLte          *string  `json:"avatarLocalFileLTE,omitempty"`
	AvatarLocalFileContains     *string  `json:"avatarLocalFileContains,omitempty"`
	AvatarLocalFileHasPrefix    *string  `json:"avatarLocalFileHasPrefix,omitempty"`
	AvatarLocalFileHasSuffix    *string  `json:"avatarLocalFileHasSuffix,omitempty"`
	AvatarLocalFileIsNil        *bool    `json:"avatarLocalFileIsNil,omitempty"`
	AvatarLocalFileNotNil       *bool    `json:"avatarLocalFileNotNil,omitempty"`
	AvatarLocalFileEqualFold    *string  `json:"avatarLocalFileEqualFold,omitempty"`
	AvatarLocalFileContainsFold *string  `json:"avatarLocalFileContainsFold,omitempty"`
	// avatar_local_file_id field predicates
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIdneq          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIdgt           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIdgte          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIdlt           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIdlte          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        *bool    `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       *bool    `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// last_seen field predicates
	LastSeen       *time.Time   `json:"lastSeen,omitempty"`
	LastSeenNeq    *time.Time   `json:"lastSeenNEQ,omitempty"`
	LastSeenIn     []*time.Time `json:"lastSeenIn,omitempty"`
	LastSeenNotIn  []*time.Time `json:"lastSeenNotIn,omitempty"`
	LastSeenGt     *time.Time   `json:"lastSeenGT,omitempty"`
	LastSeenGte    *time.Time   `json:"lastSeenGTE,omitempty"`
	LastSeenLt     *time.Time   `json:"lastSeenLT,omitempty"`
	LastSeenLte    *time.Time   `json:"lastSeenLTE,omitempty"`
	LastSeenIsNil  *bool        `json:"lastSeenIsNil,omitempty"`
	LastSeenNotNil *bool        `json:"lastSeenNotNil,omitempty"`
	// sub field predicates
	Sub             *string  `json:"sub,omitempty"`
	SubNeq          *string  `json:"subNEQ,omitempty"`
	SubIn           []string `json:"subIn,omitempty"`
	SubNotIn        []string `json:"subNotIn,omitempty"`
	SubGt           *string  `json:"subGT,omitempty"`
	SubGte          *string  `json:"subGTE,omitempty"`
	SubLt           *string  `json:"subLT,omitempty"`
	SubLte          *string  `json:"subLTE,omitempty"`
	SubContains     *string  `json:"subContains,omitempty"`
	SubHasPrefix    *string  `json:"subHasPrefix,omitempty"`
	SubHasSuffix    *string  `json:"subHasSuffix,omitempty"`
	SubIsNil        *bool    `json:"subIsNil,omitempty"`
	SubNotNil       *bool    `json:"subNotNil,omitempty"`
	SubEqualFold    *string  `json:"subEqualFold,omitempty"`
	SubContainsFold *string  `json:"subContainsFold,omitempty"`
	// auth_provider field predicates
	AuthProvider      *enums.AuthProvider  `json:"authProvider,omitempty"`
	AuthProviderNeq   *enums.AuthProvider  `json:"authProviderNEQ,omitempty"`
	AuthProviderIn    []enums.AuthProvider `json:"authProviderIn,omitempty"`
	AuthProviderNotIn []enums.AuthProvider `json:"authProviderNotIn,omitempty"`
	// role field predicates
	Role       *enums.Role  `json:"role,omitempty"`
	RoleNeq    *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn     []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn  []enums.Role `json:"roleNotIn,omitempty"`
	RoleIsNil  *bool        `json:"roleIsNil,omitempty"`
	RoleNotNil *bool        `json:"roleNotNil,omitempty"`
}

// Ordering options for User connections
type UserOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Users.
	Field UserOrderField `json:"field"`
}

type UserSearchResult struct {
	Users []*User `json:"users,omitempty"`
}

func (UserSearchResult) IsSearchResult() {}

type UserSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	UserID    *string    `json:"userID,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked bool `json:"locked"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// status of the user account
	Status enums.UserStatus `json:"status"`
	// whether the user has confirmed their email address
	EmailConfirmed bool `json:"emailConfirmed"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed *bool `json:"isWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled *bool `json:"isTfaEnabled,omitempty"`
	User         *User `json:"user,omitempty"`
	// organization to load on user login
	DefaultOrg *Organization `json:"defaultOrg,omitempty"`
	Files      []*File       `json:"files,omitempty"`
}

func (UserSetting) IsNode() {}

// Return response for createBulkUserSetting mutation
type UserSettingBulkCreatePayload struct {
	// Created userSettings
	UserSettings []*UserSetting `json:"userSettings,omitempty"`
}

// A connection to a list of items.
type UserSettingConnection struct {
	// A list of edges.
	Edges []*UserSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUserSetting mutation
type UserSettingCreatePayload struct {
	// Created userSetting
	UserSetting *UserSetting `json:"userSetting"`
}

// An edge in a connection.
type UserSettingEdge struct {
	// The item at the end of the edge.
	Node *UserSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type UserSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	UserID    *string    `json:"userID,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked bool `json:"locked"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// status of the user account
	Status enums.UserStatus `json:"status"`
	// whether the user has confirmed their email address
	EmailConfirmed bool `json:"emailConfirmed"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed *bool `json:"isWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled *bool `json:"isTfaEnabled,omitempty"`
}

func (UserSettingHistory) IsNode() {}

// A connection to a list of items.
type UserSettingHistoryConnection struct {
	// A list of edges.
	Edges []*UserSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type UserSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *UserSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// UserSettingHistoryWhereInput is used for filtering UserSettingHistory objects.
// Input was generated by ent.
type UserSettingHistoryWhereInput struct {
	Not *UserSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*UserSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*UserSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        *bool    `json:"userIDIsNil,omitempty"`
	UserIDNotNil       *bool    `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
	// locked field predicates
	Locked    *bool `json:"locked,omitempty"`
	LockedNeq *bool `json:"lockedNEQ,omitempty"`
	// silenced_at field predicates
	SilencedAt       *time.Time   `json:"silencedAt,omitempty"`
	SilencedAtNeq    *time.Time   `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []*time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []*time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGt     *time.Time   `json:"silencedAtGT,omitempty"`
	SilencedAtGte    *time.Time   `json:"silencedAtGTE,omitempty"`
	SilencedAtLt     *time.Time   `json:"silencedAtLT,omitempty"`
	SilencedAtLte    *time.Time   `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  *bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil *bool        `json:"silencedAtNotNil,omitempty"`
	// suspended_at field predicates
	SuspendedAt       *time.Time   `json:"suspendedAt,omitempty"`
	SuspendedAtNeq    *time.Time   `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []*time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []*time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGt     *time.Time   `json:"suspendedAtGT,omitempty"`
	SuspendedAtGte    *time.Time   `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLt     *time.Time   `json:"suspendedAtLT,omitempty"`
	SuspendedAtLte    *time.Time   `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  *bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil *bool        `json:"suspendedAtNotNil,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
	// email_confirmed field predicates
	EmailConfirmed    *bool `json:"emailConfirmed,omitempty"`
	EmailConfirmedNeq *bool `json:"emailConfirmedNEQ,omitempty"`
	// is_webauthn_allowed field predicates
	IsWebauthnAllowed       *bool `json:"isWebauthnAllowed,omitempty"`
	IsWebauthnAllowedNeq    *bool `json:"isWebauthnAllowedNEQ,omitempty"`
	IsWebauthnAllowedIsNil  *bool `json:"isWebauthnAllowedIsNil,omitempty"`
	IsWebauthnAllowedNotNil *bool `json:"isWebauthnAllowedNotNil,omitempty"`
	// is_tfa_enabled field predicates
	IsTfaEnabled       *bool `json:"isTfaEnabled,omitempty"`
	IsTfaEnabledNeq    *bool `json:"isTfaEnabledNEQ,omitempty"`
	IsTfaEnabledIsNil  *bool `json:"isTfaEnabledIsNil,omitempty"`
	IsTfaEnabledNotNil *bool `json:"isTfaEnabledNotNil,omitempty"`
}

type UserSettingSearchResult struct {
	UserSettings []*UserSetting `json:"userSettings,omitempty"`
}

func (UserSettingSearchResult) IsSearchResult() {}

// Return response for updateUserSetting mutation
type UserSettingUpdatePayload struct {
	// Updated userSetting
	UserSetting *UserSetting `json:"userSetting"`
}

// UserSettingWhereInput is used for filtering UserSetting objects.
// Input was generated by ent.
type UserSettingWhereInput struct {
	Not *UserSettingWhereInput   `json:"not,omitempty"`
	And []*UserSettingWhereInput `json:"and,omitempty"`
	Or  []*UserSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        *bool    `json:"userIDIsNil,omitempty"`
	UserIDNotNil       *bool    `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
	// locked field predicates
	Locked    *bool `json:"locked,omitempty"`
	LockedNeq *bool `json:"lockedNEQ,omitempty"`
	// silenced_at field predicates
	SilencedAt       *time.Time   `json:"silencedAt,omitempty"`
	SilencedAtNeq    *time.Time   `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []*time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []*time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGt     *time.Time   `json:"silencedAtGT,omitempty"`
	SilencedAtGte    *time.Time   `json:"silencedAtGTE,omitempty"`
	SilencedAtLt     *time.Time   `json:"silencedAtLT,omitempty"`
	SilencedAtLte    *time.Time   `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  *bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil *bool        `json:"silencedAtNotNil,omitempty"`
	// suspended_at field predicates
	SuspendedAt       *time.Time   `json:"suspendedAt,omitempty"`
	SuspendedAtNeq    *time.Time   `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []*time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []*time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGt     *time.Time   `json:"suspendedAtGT,omitempty"`
	SuspendedAtGte    *time.Time   `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLt     *time.Time   `json:"suspendedAtLT,omitempty"`
	SuspendedAtLte    *time.Time   `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  *bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil *bool        `json:"suspendedAtNotNil,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
	// email_confirmed field predicates
	EmailConfirmed    *bool `json:"emailConfirmed,omitempty"`
	EmailConfirmedNeq *bool `json:"emailConfirmedNEQ,omitempty"`
	// is_webauthn_allowed field predicates
	IsWebauthnAllowed       *bool `json:"isWebauthnAllowed,omitempty"`
	IsWebauthnAllowedNeq    *bool `json:"isWebauthnAllowedNEQ,omitempty"`
	IsWebauthnAllowedIsNil  *bool `json:"isWebauthnAllowedIsNil,omitempty"`
	IsWebauthnAllowedNotNil *bool `json:"isWebauthnAllowedNotNil,omitempty"`
	// is_tfa_enabled field predicates
	IsTfaEnabled       *bool `json:"isTfaEnabled,omitempty"`
	IsTfaEnabledNeq    *bool `json:"isTfaEnabledNEQ,omitempty"`
	IsTfaEnabledIsNil  *bool `json:"isTfaEnabledIsNil,omitempty"`
	IsTfaEnabledNotNil *bool `json:"isTfaEnabledNotNil,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// default_org edge predicates
	HasDefaultOrg     *bool                     `json:"hasDefaultOrg,omitempty"`
	HasDefaultOrgWith []*OrganizationWhereInput `json:"hasDefaultOrgWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// Return response for updateUser mutation
type UserUpdatePayload struct {
	// Updated user
	User *User `json:"user"`
}

// UserWhereInput is used for filtering User objects.
// Input was generated by ent.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// first_name field predicates
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNeq          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGt           *string  `json:"firstNameGT,omitempty"`
	FirstNameGte          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLt           *string  `json:"firstNameLT,omitempty"`
	FirstNameLte          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        *bool    `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       *bool    `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`
	// last_name field predicates
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNeq          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGt           *string  `json:"lastNameGT,omitempty"`
	LastNameGte          *string  `json:"lastNameGTE,omitempty"`
	LastNameLt           *string  `json:"lastNameLT,omitempty"`
	LastNameLte          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        *bool    `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       *bool    `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file field predicates
	AvatarLocalFile             *string  `json:"avatarLocalFile,omitempty"`
	AvatarLocalFileNeq          *string  `json:"avatarLocalFileNEQ,omitempty"`
	AvatarLocalFileIn           []string `json:"avatarLocalFileIn,omitempty"`
	AvatarLocalFileNotIn        []string `json:"avatarLocalFileNotIn,omitempty"`
	AvatarLocalFileGt           *string  `json:"avatarLocalFileGT,omitempty"`
	AvatarLocalFileGte          *string  `json:"avatarLocalFileGTE,omitempty"`
	AvatarLocalFileLt           *string  `json:"avatarLocalFileLT,omitempty"`
	AvatarLocalFileLte          *string  `json:"avatarLocalFileLTE,omitempty"`
	AvatarLocalFileContains     *string  `json:"avatarLocalFileContains,omitempty"`
	AvatarLocalFileHasPrefix    *string  `json:"avatarLocalFileHasPrefix,omitempty"`
	AvatarLocalFileHasSuffix    *string  `json:"avatarLocalFileHasSuffix,omitempty"`
	AvatarLocalFileIsNil        *bool    `json:"avatarLocalFileIsNil,omitempty"`
	AvatarLocalFileNotNil       *bool    `json:"avatarLocalFileNotNil,omitempty"`
	AvatarLocalFileEqualFold    *string  `json:"avatarLocalFileEqualFold,omitempty"`
	AvatarLocalFileContainsFold *string  `json:"avatarLocalFileContainsFold,omitempty"`
	// avatar_local_file_id field predicates
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIdneq          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIdgt           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIdgte          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIdlt           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIdlte          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        *bool    `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       *bool    `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// last_seen field predicates
	LastSeen       *time.Time   `json:"lastSeen,omitempty"`
	LastSeenNeq    *time.Time   `json:"lastSeenNEQ,omitempty"`
	LastSeenIn     []*time.Time `json:"lastSeenIn,omitempty"`
	LastSeenNotIn  []*time.Time `json:"lastSeenNotIn,omitempty"`
	LastSeenGt     *time.Time   `json:"lastSeenGT,omitempty"`
	LastSeenGte    *time.Time   `json:"lastSeenGTE,omitempty"`
	LastSeenLt     *time.Time   `json:"lastSeenLT,omitempty"`
	LastSeenLte    *time.Time   `json:"lastSeenLTE,omitempty"`
	LastSeenIsNil  *bool        `json:"lastSeenIsNil,omitempty"`
	LastSeenNotNil *bool        `json:"lastSeenNotNil,omitempty"`
	// sub field predicates
	Sub             *string  `json:"sub,omitempty"`
	SubNeq          *string  `json:"subNEQ,omitempty"`
	SubIn           []string `json:"subIn,omitempty"`
	SubNotIn        []string `json:"subNotIn,omitempty"`
	SubGt           *string  `json:"subGT,omitempty"`
	SubGte          *string  `json:"subGTE,omitempty"`
	SubLt           *string  `json:"subLT,omitempty"`
	SubLte          *string  `json:"subLTE,omitempty"`
	SubContains     *string  `json:"subContains,omitempty"`
	SubHasPrefix    *string  `json:"subHasPrefix,omitempty"`
	SubHasSuffix    *string  `json:"subHasSuffix,omitempty"`
	SubIsNil        *bool    `json:"subIsNil,omitempty"`
	SubNotNil       *bool    `json:"subNotNil,omitempty"`
	SubEqualFold    *string  `json:"subEqualFold,omitempty"`
	SubContainsFold *string  `json:"subContainsFold,omitempty"`
	// auth_provider field predicates
	AuthProvider      *enums.AuthProvider  `json:"authProvider,omitempty"`
	AuthProviderNeq   *enums.AuthProvider  `json:"authProviderNEQ,omitempty"`
	AuthProviderIn    []enums.AuthProvider `json:"authProviderIn,omitempty"`
	AuthProviderNotIn []enums.AuthProvider `json:"authProviderNotIn,omitempty"`
	// role field predicates
	Role       *enums.Role  `json:"role,omitempty"`
	RoleNeq    *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn     []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn  []enums.Role `json:"roleNotIn,omitempty"`
	RoleIsNil  *bool        `json:"roleIsNil,omitempty"`
	RoleNotNil *bool        `json:"roleNotNil,omitempty"`
	// personal_access_tokens edge predicates
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`
	// tfa_settings edge predicates
	HasTfaSettings     *bool                   `json:"hasTfaSettings,omitempty"`
	HasTfaSettingsWith []*TFASettingWhereInput `json:"hasTfaSettingsWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                    `json:"hasSetting,omitempty"`
	HasSettingWith []*UserSettingWhereInput `json:"hasSettingWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// organizations edge predicates
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// file edge predicates
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// actionplans edge predicates
	HasActionplans     *bool                   `json:"hasActionplans,omitempty"`
	HasActionplansWith []*ActionPlanWhereInput `json:"hasActionplansWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// assigner_tasks edge predicates
	HasAssignerTasks     *bool             `json:"hasAssignerTasks,omitempty"`
	HasAssignerTasksWith []*TaskWhereInput `json:"hasAssignerTasksWith,omitempty"`
	// assignee_tasks edge predicates
	HasAssigneeTasks     *bool             `json:"hasAssigneeTasks,omitempty"`
	HasAssigneeTasksWith []*TaskWhereInput `json:"hasAssigneeTasksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// group_memberships edge predicates
	HasGroupMemberships     *bool                        `json:"hasGroupMemberships,omitempty"`
	HasGroupMembershipsWith []*GroupMembershipWhereInput `json:"hasGroupMembershipsWith,omitempty"`
	// org_memberships edge predicates
	HasOrgMemberships     *bool                      `json:"hasOrgMemberships,omitempty"`
	HasOrgMembershipsWith []*OrgMembershipWhereInput `json:"hasOrgMembershipsWith,omitempty"`
	// program_memberships edge predicates
	HasProgramMemberships     *bool                          `json:"hasProgramMemberships,omitempty"`
	HasProgramMembershipsWith []*ProgramMembershipWhereInput `json:"hasProgramMembershipsWith,omitempty"`
}

type Webhook struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the webhook
	Name string `json:"name"`
	// a description of the webhook
	Description *string `json:"description,omitempty"`
	// the url to send the webhook to
	DestinationURL string `json:"destinationURL"`
	// indicates if the webhook is active and enabled
	Enabled bool `json:"enabled"`
	// the number of failures
	Failures *int64 `json:"failures,omitempty"`
	// the last error message
	LastError *string `json:"lastError,omitempty"`
	// the last response
	LastResponse *string        `json:"lastResponse,omitempty"`
	Owner        *Organization  `json:"owner,omitempty"`
	Events       []*Event       `json:"events,omitempty"`
	Integrations []*Integration `json:"integrations,omitempty"`
}

func (Webhook) IsNode() {}

// Return response for createBulkWebhook mutation
type WebhookBulkCreatePayload struct {
	// Created webhooks
	Webhooks []*Webhook `json:"webhooks,omitempty"`
}

// A connection to a list of items.
type WebhookConnection struct {
	// A list of edges.
	Edges []*WebhookEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createWebhook mutation
type WebhookCreatePayload struct {
	// Created webhook
	Webhook *Webhook `json:"webhook"`
}

// Return response for deleteWebhook mutation
type WebhookDeletePayload struct {
	// Deleted webhook ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type WebhookEdge struct {
	// The item at the end of the edge.
	Node *Webhook `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type WebhookHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the webhook
	Name string `json:"name"`
	// a description of the webhook
	Description *string `json:"description,omitempty"`
	// the url to send the webhook to
	DestinationURL string `json:"destinationURL"`
	// indicates if the webhook is active and enabled
	Enabled bool `json:"enabled"`
	// the number of failures
	Failures *int64 `json:"failures,omitempty"`
	// the last error message
	LastError *string `json:"lastError,omitempty"`
	// the last response
	LastResponse *string `json:"lastResponse,omitempty"`
}

func (WebhookHistory) IsNode() {}

// A connection to a list of items.
type WebhookHistoryConnection struct {
	// A list of edges.
	Edges []*WebhookHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type WebhookHistoryEdge struct {
	// The item at the end of the edge.
	Node *WebhookHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for WebhookHistory connections
type WebhookHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order WebhookHistories.
	Field WebhookHistoryOrderField `json:"field"`
}

// WebhookHistoryWhereInput is used for filtering WebhookHistory objects.
// Input was generated by ent.
type WebhookHistoryWhereInput struct {
	Not *WebhookHistoryWhereInput   `json:"not,omitempty"`
	And []*WebhookHistoryWhereInput `json:"and,omitempty"`
	Or  []*WebhookHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// destination_url field predicates
	DestinationURL             *string  `json:"destinationURL,omitempty"`
	DestinationURLNeq          *string  `json:"destinationURLNEQ,omitempty"`
	DestinationURLIn           []string `json:"destinationURLIn,omitempty"`
	DestinationURLNotIn        []string `json:"destinationURLNotIn,omitempty"`
	DestinationURLGt           *string  `json:"destinationURLGT,omitempty"`
	DestinationURLGte          *string  `json:"destinationURLGTE,omitempty"`
	DestinationURLLt           *string  `json:"destinationURLLT,omitempty"`
	DestinationURLLte          *string  `json:"destinationURLLTE,omitempty"`
	DestinationURLContains     *string  `json:"destinationURLContains,omitempty"`
	DestinationURLHasPrefix    *string  `json:"destinationURLHasPrefix,omitempty"`
	DestinationURLHasSuffix    *string  `json:"destinationURLHasSuffix,omitempty"`
	DestinationURLEqualFold    *string  `json:"destinationURLEqualFold,omitempty"`
	DestinationURLContainsFold *string  `json:"destinationURLContainsFold,omitempty"`
	// enabled field predicates
	Enabled    *bool `json:"enabled,omitempty"`
	EnabledNeq *bool `json:"enabledNEQ,omitempty"`
	// failures field predicates
	Failures       *int64  `json:"failures,omitempty"`
	FailuresNeq    *int64  `json:"failuresNEQ,omitempty"`
	FailuresIn     []int64 `json:"failuresIn,omitempty"`
	FailuresNotIn  []int64 `json:"failuresNotIn,omitempty"`
	FailuresGt     *int64  `json:"failuresGT,omitempty"`
	FailuresGte    *int64  `json:"failuresGTE,omitempty"`
	FailuresLt     *int64  `json:"failuresLT,omitempty"`
	FailuresLte    *int64  `json:"failuresLTE,omitempty"`
	FailuresIsNil  *bool   `json:"failuresIsNil,omitempty"`
	FailuresNotNil *bool   `json:"failuresNotNil,omitempty"`
	// last_error field predicates
	LastError             *string  `json:"lastError,omitempty"`
	LastErrorNeq          *string  `json:"lastErrorNEQ,omitempty"`
	LastErrorIn           []string `json:"lastErrorIn,omitempty"`
	LastErrorNotIn        []string `json:"lastErrorNotIn,omitempty"`
	LastErrorGt           *string  `json:"lastErrorGT,omitempty"`
	LastErrorGte          *string  `json:"lastErrorGTE,omitempty"`
	LastErrorLt           *string  `json:"lastErrorLT,omitempty"`
	LastErrorLte          *string  `json:"lastErrorLTE,omitempty"`
	LastErrorContains     *string  `json:"lastErrorContains,omitempty"`
	LastErrorHasPrefix    *string  `json:"lastErrorHasPrefix,omitempty"`
	LastErrorHasSuffix    *string  `json:"lastErrorHasSuffix,omitempty"`
	LastErrorIsNil        *bool    `json:"lastErrorIsNil,omitempty"`
	LastErrorNotNil       *bool    `json:"lastErrorNotNil,omitempty"`
	LastErrorEqualFold    *string  `json:"lastErrorEqualFold,omitempty"`
	LastErrorContainsFold *string  `json:"lastErrorContainsFold,omitempty"`
	// last_response field predicates
	LastResponse             *string  `json:"lastResponse,omitempty"`
	LastResponseNeq          *string  `json:"lastResponseNEQ,omitempty"`
	LastResponseIn           []string `json:"lastResponseIn,omitempty"`
	LastResponseNotIn        []string `json:"lastResponseNotIn,omitempty"`
	LastResponseGt           *string  `json:"lastResponseGT,omitempty"`
	LastResponseGte          *string  `json:"lastResponseGTE,omitempty"`
	LastResponseLt           *string  `json:"lastResponseLT,omitempty"`
	LastResponseLte          *string  `json:"lastResponseLTE,omitempty"`
	LastResponseContains     *string  `json:"lastResponseContains,omitempty"`
	LastResponseHasPrefix    *string  `json:"lastResponseHasPrefix,omitempty"`
	LastResponseHasSuffix    *string  `json:"lastResponseHasSuffix,omitempty"`
	LastResponseIsNil        *bool    `json:"lastResponseIsNil,omitempty"`
	LastResponseNotNil       *bool    `json:"lastResponseNotNil,omitempty"`
	LastResponseEqualFold    *string  `json:"lastResponseEqualFold,omitempty"`
	LastResponseContainsFold *string  `json:"lastResponseContainsFold,omitempty"`
}

// Ordering options for Webhook connections
type WebhookOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Webhooks.
	Field WebhookOrderField `json:"field"`
}

type WebhookSearchResult struct {
	Webhooks []*Webhook `json:"webhooks,omitempty"`
}

func (WebhookSearchResult) IsSearchResult() {}

// Return response for updateWebhook mutation
type WebhookUpdatePayload struct {
	// Updated webhook
	Webhook *Webhook `json:"webhook"`
}

// WebhookWhereInput is used for filtering Webhook objects.
// Input was generated by ent.
type WebhookWhereInput struct {
	Not *WebhookWhereInput   `json:"not,omitempty"`
	And []*WebhookWhereInput `json:"and,omitempty"`
	Or  []*WebhookWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// destination_url field predicates
	DestinationURL             *string  `json:"destinationURL,omitempty"`
	DestinationURLNeq          *string  `json:"destinationURLNEQ,omitempty"`
	DestinationURLIn           []string `json:"destinationURLIn,omitempty"`
	DestinationURLNotIn        []string `json:"destinationURLNotIn,omitempty"`
	DestinationURLGt           *string  `json:"destinationURLGT,omitempty"`
	DestinationURLGte          *string  `json:"destinationURLGTE,omitempty"`
	DestinationURLLt           *string  `json:"destinationURLLT,omitempty"`
	DestinationURLLte          *string  `json:"destinationURLLTE,omitempty"`
	DestinationURLContains     *string  `json:"destinationURLContains,omitempty"`
	DestinationURLHasPrefix    *string  `json:"destinationURLHasPrefix,omitempty"`
	DestinationURLHasSuffix    *string  `json:"destinationURLHasSuffix,omitempty"`
	DestinationURLEqualFold    *string  `json:"destinationURLEqualFold,omitempty"`
	DestinationURLContainsFold *string  `json:"destinationURLContainsFold,omitempty"`
	// enabled field predicates
	Enabled    *bool `json:"enabled,omitempty"`
	EnabledNeq *bool `json:"enabledNEQ,omitempty"`
	// failures field predicates
	Failures       *int64  `json:"failures,omitempty"`
	FailuresNeq    *int64  `json:"failuresNEQ,omitempty"`
	FailuresIn     []int64 `json:"failuresIn,omitempty"`
	FailuresNotIn  []int64 `json:"failuresNotIn,omitempty"`
	FailuresGt     *int64  `json:"failuresGT,omitempty"`
	FailuresGte    *int64  `json:"failuresGTE,omitempty"`
	FailuresLt     *int64  `json:"failuresLT,omitempty"`
	FailuresLte    *int64  `json:"failuresLTE,omitempty"`
	FailuresIsNil  *bool   `json:"failuresIsNil,omitempty"`
	FailuresNotNil *bool   `json:"failuresNotNil,omitempty"`
	// last_error field predicates
	LastError             *string  `json:"lastError,omitempty"`
	LastErrorNeq          *string  `json:"lastErrorNEQ,omitempty"`
	LastErrorIn           []string `json:"lastErrorIn,omitempty"`
	LastErrorNotIn        []string `json:"lastErrorNotIn,omitempty"`
	LastErrorGt           *string  `json:"lastErrorGT,omitempty"`
	LastErrorGte          *string  `json:"lastErrorGTE,omitempty"`
	LastErrorLt           *string  `json:"lastErrorLT,omitempty"`
	LastErrorLte          *string  `json:"lastErrorLTE,omitempty"`
	LastErrorContains     *string  `json:"lastErrorContains,omitempty"`
	LastErrorHasPrefix    *string  `json:"lastErrorHasPrefix,omitempty"`
	LastErrorHasSuffix    *string  `json:"lastErrorHasSuffix,omitempty"`
	LastErrorIsNil        *bool    `json:"lastErrorIsNil,omitempty"`
	LastErrorNotNil       *bool    `json:"lastErrorNotNil,omitempty"`
	LastErrorEqualFold    *string  `json:"lastErrorEqualFold,omitempty"`
	LastErrorContainsFold *string  `json:"lastErrorContainsFold,omitempty"`
	// last_response field predicates
	LastResponse             *string  `json:"lastResponse,omitempty"`
	LastResponseNeq          *string  `json:"lastResponseNEQ,omitempty"`
	LastResponseIn           []string `json:"lastResponseIn,omitempty"`
	LastResponseNotIn        []string `json:"lastResponseNotIn,omitempty"`
	LastResponseGt           *string  `json:"lastResponseGT,omitempty"`
	LastResponseGte          *string  `json:"lastResponseGTE,omitempty"`
	LastResponseLt           *string  `json:"lastResponseLT,omitempty"`
	LastResponseLte          *string  `json:"lastResponseLTE,omitempty"`
	LastResponseContains     *string  `json:"lastResponseContains,omitempty"`
	LastResponseHasPrefix    *string  `json:"lastResponseHasPrefix,omitempty"`
	LastResponseHasSuffix    *string  `json:"lastResponseHasSuffix,omitempty"`
	LastResponseIsNil        *bool    `json:"lastResponseIsNil,omitempty"`
	LastResponseNotNil       *bool    `json:"lastResponseNotNil,omitempty"`
	LastResponseEqualFold    *string  `json:"lastResponseEqualFold,omitempty"`
	LastResponseContainsFold *string  `json:"lastResponseContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
}

// Properties by which EntityHistory connections can be ordered.
type EntityHistoryOrderField string

const (
	EntityHistoryOrderFieldName        EntityHistoryOrderField = "name"
	EntityHistoryOrderFieldDisplayName EntityHistoryOrderField = "display_name"
)

var AllEntityHistoryOrderField = []EntityHistoryOrderField{
	EntityHistoryOrderFieldName,
	EntityHistoryOrderFieldDisplayName,
}

func (e EntityHistoryOrderField) IsValid() bool {
	switch e {
	case EntityHistoryOrderFieldName, EntityHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e EntityHistoryOrderField) String() string {
	return string(e)
}

func (e *EntityHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityHistoryOrderField", str)
	}
	return nil
}

func (e EntityHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Entity connections can be ordered.
type EntityOrderField string

const (
	EntityOrderFieldName        EntityOrderField = "name"
	EntityOrderFieldDisplayName EntityOrderField = "display_name"
)

var AllEntityOrderField = []EntityOrderField{
	EntityOrderFieldName,
	EntityOrderFieldDisplayName,
}

func (e EntityOrderField) IsValid() bool {
	switch e {
	case EntityOrderFieldName, EntityOrderFieldDisplayName:
		return true
	}
	return false
}

func (e EntityOrderField) String() string {
	return string(e)
}

func (e *EntityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityOrderField", str)
	}
	return nil
}

func (e EntityOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which EntityTypeHistory connections can be ordered.
type EntityTypeHistoryOrderField string

const (
	EntityTypeHistoryOrderFieldName EntityTypeHistoryOrderField = "name"
)

var AllEntityTypeHistoryOrderField = []EntityTypeHistoryOrderField{
	EntityTypeHistoryOrderFieldName,
}

func (e EntityTypeHistoryOrderField) IsValid() bool {
	switch e {
	case EntityTypeHistoryOrderFieldName:
		return true
	}
	return false
}

func (e EntityTypeHistoryOrderField) String() string {
	return string(e)
}

func (e *EntityTypeHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityTypeHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityTypeHistoryOrderField", str)
	}
	return nil
}

func (e EntityTypeHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which EntityType connections can be ordered.
type EntityTypeOrderField string

const (
	EntityTypeOrderFieldName EntityTypeOrderField = "name"
)

var AllEntityTypeOrderField = []EntityTypeOrderField{
	EntityTypeOrderFieldName,
}

func (e EntityTypeOrderField) IsValid() bool {
	switch e {
	case EntityTypeOrderFieldName:
		return true
	}
	return false
}

func (e EntityTypeOrderField) String() string {
	return string(e)
}

func (e *EntityTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityTypeOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityTypeOrderField", str)
	}
	return nil
}

func (e EntityTypeOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which GroupHistory connections can be ordered.
type GroupHistoryOrderField string

const (
	GroupHistoryOrderFieldName        GroupHistoryOrderField = "name"
	GroupHistoryOrderFieldDisplayName GroupHistoryOrderField = "display_name"
)

var AllGroupHistoryOrderField = []GroupHistoryOrderField{
	GroupHistoryOrderFieldName,
	GroupHistoryOrderFieldDisplayName,
}

func (e GroupHistoryOrderField) IsValid() bool {
	switch e {
	case GroupHistoryOrderFieldName, GroupHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e GroupHistoryOrderField) String() string {
	return string(e)
}

func (e *GroupHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupHistoryOrderField", str)
	}
	return nil
}

func (e GroupHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Group connections can be ordered.
type GroupOrderField string

const (
	GroupOrderFieldName        GroupOrderField = "name"
	GroupOrderFieldDisplayName GroupOrderField = "display_name"
)

var AllGroupOrderField = []GroupOrderField{
	GroupOrderFieldName,
	GroupOrderFieldDisplayName,
}

func (e GroupOrderField) IsValid() bool {
	switch e {
	case GroupOrderFieldName, GroupOrderFieldDisplayName:
		return true
	}
	return false
}

func (e GroupOrderField) String() string {
	return string(e)
}

func (e *GroupOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupOrderField", str)
	}
	return nil
}

func (e GroupOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which HushHistory connections can be ordered.
type HushHistoryOrderField string

const (
	HushHistoryOrderFieldName HushHistoryOrderField = "name"
	HushHistoryOrderFieldKind HushHistoryOrderField = "kind"
)

var AllHushHistoryOrderField = []HushHistoryOrderField{
	HushHistoryOrderFieldName,
	HushHistoryOrderFieldKind,
}

func (e HushHistoryOrderField) IsValid() bool {
	switch e {
	case HushHistoryOrderFieldName, HushHistoryOrderFieldKind:
		return true
	}
	return false
}

func (e HushHistoryOrderField) String() string {
	return string(e)
}

func (e *HushHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HushHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HushHistoryOrderField", str)
	}
	return nil
}

func (e HushHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Hush connections can be ordered.
type HushOrderField string

const (
	HushOrderFieldName HushOrderField = "name"
	HushOrderFieldKind HushOrderField = "kind"
)

var AllHushOrderField = []HushOrderField{
	HushOrderFieldName,
	HushOrderFieldKind,
}

func (e HushOrderField) IsValid() bool {
	switch e {
	case HushOrderFieldName, HushOrderFieldKind:
		return true
	}
	return false
}

func (e HushOrderField) String() string {
	return string(e)
}

func (e *HushOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HushOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HushOrderField", str)
	}
	return nil
}

func (e HushOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which IntegrationHistory connections can be ordered.
type IntegrationHistoryOrderField string

const (
	IntegrationHistoryOrderFieldName IntegrationHistoryOrderField = "name"
	IntegrationHistoryOrderFieldKind IntegrationHistoryOrderField = "kind"
)

var AllIntegrationHistoryOrderField = []IntegrationHistoryOrderField{
	IntegrationHistoryOrderFieldName,
	IntegrationHistoryOrderFieldKind,
}

func (e IntegrationHistoryOrderField) IsValid() bool {
	switch e {
	case IntegrationHistoryOrderFieldName, IntegrationHistoryOrderFieldKind:
		return true
	}
	return false
}

func (e IntegrationHistoryOrderField) String() string {
	return string(e)
}

func (e *IntegrationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationHistoryOrderField", str)
	}
	return nil
}

func (e IntegrationHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Integration connections can be ordered.
type IntegrationOrderField string

const (
	IntegrationOrderFieldName IntegrationOrderField = "name"
	IntegrationOrderFieldKind IntegrationOrderField = "kind"
)

var AllIntegrationOrderField = []IntegrationOrderField{
	IntegrationOrderFieldName,
	IntegrationOrderFieldKind,
}

func (e IntegrationOrderField) IsValid() bool {
	switch e {
	case IntegrationOrderFieldName, IntegrationOrderFieldKind:
		return true
	}
	return false
}

func (e IntegrationOrderField) String() string {
	return string(e)
}

func (e *IntegrationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationOrderField", str)
	}
	return nil
}

func (e IntegrationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which OrganizationHistory connections can be ordered.
type OrganizationHistoryOrderField string

const (
	OrganizationHistoryOrderFieldName        OrganizationHistoryOrderField = "name"
	OrganizationHistoryOrderFieldDisplayName OrganizationHistoryOrderField = "display_name"
)

var AllOrganizationHistoryOrderField = []OrganizationHistoryOrderField{
	OrganizationHistoryOrderFieldName,
	OrganizationHistoryOrderFieldDisplayName,
}

func (e OrganizationHistoryOrderField) IsValid() bool {
	switch e {
	case OrganizationHistoryOrderFieldName, OrganizationHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e OrganizationHistoryOrderField) String() string {
	return string(e)
}

func (e *OrganizationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationHistoryOrderField", str)
	}
	return nil
}

func (e OrganizationHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Organization connections can be ordered.
type OrganizationOrderField string

const (
	OrganizationOrderFieldName        OrganizationOrderField = "name"
	OrganizationOrderFieldDisplayName OrganizationOrderField = "display_name"
)

var AllOrganizationOrderField = []OrganizationOrderField{
	OrganizationOrderFieldName,
	OrganizationOrderFieldDisplayName,
}

func (e OrganizationOrderField) IsValid() bool {
	switch e {
	case OrganizationOrderFieldName, OrganizationOrderFieldDisplayName:
		return true
	}
	return false
}

func (e OrganizationOrderField) String() string {
	return string(e)
}

func (e *OrganizationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

func (e OrganizationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which TemplateHistory connections can be ordered.
type TemplateHistoryOrderField string

const (
	TemplateHistoryOrderFieldName TemplateHistoryOrderField = "name"
)

var AllTemplateHistoryOrderField = []TemplateHistoryOrderField{
	TemplateHistoryOrderFieldName,
}

func (e TemplateHistoryOrderField) IsValid() bool {
	switch e {
	case TemplateHistoryOrderFieldName:
		return true
	}
	return false
}

func (e TemplateHistoryOrderField) String() string {
	return string(e)
}

func (e *TemplateHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateHistoryOrderField", str)
	}
	return nil
}

func (e TemplateHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Template connections can be ordered.
type TemplateOrderField string

const (
	TemplateOrderFieldName TemplateOrderField = "name"
)

var AllTemplateOrderField = []TemplateOrderField{
	TemplateOrderFieldName,
}

func (e TemplateOrderField) IsValid() bool {
	switch e {
	case TemplateOrderFieldName:
		return true
	}
	return false
}

func (e TemplateOrderField) String() string {
	return string(e)
}

func (e *TemplateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateOrderField", str)
	}
	return nil
}

func (e TemplateOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which UserHistory connections can be ordered.
type UserHistoryOrderField string

const (
	UserHistoryOrderFieldFirstName   UserHistoryOrderField = "first_name"
	UserHistoryOrderFieldLastName    UserHistoryOrderField = "last_name"
	UserHistoryOrderFieldDisplayName UserHistoryOrderField = "display_name"
)

var AllUserHistoryOrderField = []UserHistoryOrderField{
	UserHistoryOrderFieldFirstName,
	UserHistoryOrderFieldLastName,
	UserHistoryOrderFieldDisplayName,
}

func (e UserHistoryOrderField) IsValid() bool {
	switch e {
	case UserHistoryOrderFieldFirstName, UserHistoryOrderFieldLastName, UserHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e UserHistoryOrderField) String() string {
	return string(e)
}

func (e *UserHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserHistoryOrderField", str)
	}
	return nil
}

func (e UserHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which User connections can be ordered.
type UserOrderField string

const (
	UserOrderFieldFirstName   UserOrderField = "first_name"
	UserOrderFieldLastName    UserOrderField = "last_name"
	UserOrderFieldDisplayName UserOrderField = "display_name"
)

var AllUserOrderField = []UserOrderField{
	UserOrderFieldFirstName,
	UserOrderFieldLastName,
	UserOrderFieldDisplayName,
}

func (e UserOrderField) IsValid() bool {
	switch e {
	case UserOrderFieldFirstName, UserOrderFieldLastName, UserOrderFieldDisplayName:
		return true
	}
	return false
}

func (e UserOrderField) String() string {
	return string(e)
}

func (e *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

func (e UserOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which WebhookHistory connections can be ordered.
type WebhookHistoryOrderField string

const (
	WebhookHistoryOrderFieldName WebhookHistoryOrderField = "name"
	WebhookHistoryOrderFieldURL  WebhookHistoryOrderField = "url"
)

var AllWebhookHistoryOrderField = []WebhookHistoryOrderField{
	WebhookHistoryOrderFieldName,
	WebhookHistoryOrderFieldURL,
}

func (e WebhookHistoryOrderField) IsValid() bool {
	switch e {
	case WebhookHistoryOrderFieldName, WebhookHistoryOrderFieldURL:
		return true
	}
	return false
}

func (e WebhookHistoryOrderField) String() string {
	return string(e)
}

func (e *WebhookHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookHistoryOrderField", str)
	}
	return nil
}

func (e WebhookHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Webhook connections can be ordered.
type WebhookOrderField string

const (
	WebhookOrderFieldName WebhookOrderField = "name"
	WebhookOrderFieldURL  WebhookOrderField = "url"
)

var AllWebhookOrderField = []WebhookOrderField{
	WebhookOrderFieldName,
	WebhookOrderFieldURL,
}

func (e WebhookOrderField) IsValid() bool {
	switch e {
	case WebhookOrderFieldName, WebhookOrderFieldURL:
		return true
	}
	return false
}

func (e WebhookOrderField) String() string {
	return string(e)
}

func (e *WebhookOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookOrderField", str)
	}
	return nil
}

func (e WebhookOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
