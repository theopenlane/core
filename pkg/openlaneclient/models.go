// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package openlaneclient

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/theopenlane/core/pkg/enums"
	"github.com/theopenlane/core/pkg/models"
	"github.com/theopenlane/entx/history"
)

type SearchResult interface {
	IsSearchResult()
}

type APIToken struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name associated with the token
	Name  string `json:"name"`
	Token string `json:"token"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string    `json:"description,omitempty"`
	Scopes      []string   `json:"scopes,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	// whether the token is active
	IsActive *bool `json:"isActive,omitempty"`
	// the reason the token was revoked
	RevokedReason *string `json:"revokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy *string `json:"revokedBy,omitempty"`
	// when the token was revoked
	RevokedAt *time.Time    `json:"revokedAt,omitempty"`
	Owner     *Organization `json:"owner,omitempty"`
}

func (APIToken) IsNode() {}

// Return response for createBulkAPIToken mutation
type APITokenBulkCreatePayload struct {
	// Created apiTokens
	APITokens []*APIToken `json:"apiTokens,omitempty"`
}

// A connection to a list of items.
type APITokenConnection struct {
	// A list of edges.
	Edges []*APITokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createAPIToken mutation
type APITokenCreatePayload struct {
	// Created apiToken
	APIToken *APIToken `json:"apiToken"`
}

// Return response for deleteAPIToken mutation
type APITokenDeletePayload struct {
	// Deleted apiToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type APITokenEdge struct {
	// The item at the end of the edge.
	Node *APIToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type APITokenSearchResult struct {
	APITokens []*APIToken `json:"apiTokens,omitempty"`
}

func (APITokenSearchResult) IsSearchResult() {}

// Return response for updateAPIToken mutation
type APITokenUpdatePayload struct {
	// Updated apiToken
	APIToken *APIToken `json:"apiToken"`
}

// APITokenWhereInput is used for filtering APIToken objects.
// Input was generated by ent.
type APITokenWhereInput struct {
	Not *APITokenWhereInput   `json:"not,omitempty"`
	And []*APITokenWhereInput `json:"and,omitempty"`
	Or  []*APITokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// is_active field predicates
	IsActive       *bool `json:"isActive,omitempty"`
	IsActiveNeq    *bool `json:"isActiveNEQ,omitempty"`
	IsActiveIsNil  *bool `json:"isActiveIsNil,omitempty"`
	IsActiveNotNil *bool `json:"isActiveNotNil,omitempty"`
	// revoked_reason field predicates
	RevokedReason             *string  `json:"revokedReason,omitempty"`
	RevokedReasonNeq          *string  `json:"revokedReasonNEQ,omitempty"`
	RevokedReasonIn           []string `json:"revokedReasonIn,omitempty"`
	RevokedReasonNotIn        []string `json:"revokedReasonNotIn,omitempty"`
	RevokedReasonGt           *string  `json:"revokedReasonGT,omitempty"`
	RevokedReasonGte          *string  `json:"revokedReasonGTE,omitempty"`
	RevokedReasonLt           *string  `json:"revokedReasonLT,omitempty"`
	RevokedReasonLte          *string  `json:"revokedReasonLTE,omitempty"`
	RevokedReasonContains     *string  `json:"revokedReasonContains,omitempty"`
	RevokedReasonHasPrefix    *string  `json:"revokedReasonHasPrefix,omitempty"`
	RevokedReasonHasSuffix    *string  `json:"revokedReasonHasSuffix,omitempty"`
	RevokedReasonIsNil        *bool    `json:"revokedReasonIsNil,omitempty"`
	RevokedReasonNotNil       *bool    `json:"revokedReasonNotNil,omitempty"`
	RevokedReasonEqualFold    *string  `json:"revokedReasonEqualFold,omitempty"`
	RevokedReasonContainsFold *string  `json:"revokedReasonContainsFold,omitempty"`
	// revoked_by field predicates
	RevokedBy             *string  `json:"revokedBy,omitempty"`
	RevokedByNeq          *string  `json:"revokedByNEQ,omitempty"`
	RevokedByIn           []string `json:"revokedByIn,omitempty"`
	RevokedByNotIn        []string `json:"revokedByNotIn,omitempty"`
	RevokedByGt           *string  `json:"revokedByGT,omitempty"`
	RevokedByGte          *string  `json:"revokedByGTE,omitempty"`
	RevokedByLt           *string  `json:"revokedByLT,omitempty"`
	RevokedByLte          *string  `json:"revokedByLTE,omitempty"`
	RevokedByContains     *string  `json:"revokedByContains,omitempty"`
	RevokedByHasPrefix    *string  `json:"revokedByHasPrefix,omitempty"`
	RevokedByHasSuffix    *string  `json:"revokedByHasSuffix,omitempty"`
	RevokedByIsNil        *bool    `json:"revokedByIsNil,omitempty"`
	RevokedByNotNil       *bool    `json:"revokedByNotNil,omitempty"`
	RevokedByEqualFold    *string  `json:"revokedByEqualFold,omitempty"`
	RevokedByContainsFold *string  `json:"revokedByContainsFold,omitempty"`
	// revoked_at field predicates
	RevokedAt       *time.Time   `json:"revokedAt,omitempty"`
	RevokedAtNeq    *time.Time   `json:"revokedAtNEQ,omitempty"`
	RevokedAtIn     []*time.Time `json:"revokedAtIn,omitempty"`
	RevokedAtNotIn  []*time.Time `json:"revokedAtNotIn,omitempty"`
	RevokedAtGt     *time.Time   `json:"revokedAtGT,omitempty"`
	RevokedAtGte    *time.Time   `json:"revokedAtGTE,omitempty"`
	RevokedAtLt     *time.Time   `json:"revokedAtLT,omitempty"`
	RevokedAtLte    *time.Time   `json:"revokedAtLTE,omitempty"`
	RevokedAtIsNil  *bool        `json:"revokedAtIsNil,omitempty"`
	RevokedAtNotNil *bool        `json:"revokedAtNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type ActionPlan struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the action plan
	Name string `json:"name"`
	// description of the action plan
	Description *string `json:"description,omitempty"`
	// status of the action plan
	Status *string `json:"status,omitempty"`
	// due date of the action plan
	DueDate *time.Time `json:"dueDate,omitempty"`
	// priority of the action plan
	Priority *string `json:"priority,omitempty"`
	// source of the action plan
	Source *string `json:"source,omitempty"`
	// json data including details of the action plan
	Details map[string]any `json:"details,omitempty"`
	Risk    []*Risk        `json:"risk,omitempty"`
	Control []*Control     `json:"control,omitempty"`
	User    []*User        `json:"user,omitempty"`
	Program []*Program     `json:"program,omitempty"`
}

func (ActionPlan) IsNode() {}

// Return response for createBulkActionPlan mutation
type ActionPlanBulkCreatePayload struct {
	// Created actionPlans
	ActionPlans []*ActionPlan `json:"actionPlans,omitempty"`
}

// A connection to a list of items.
type ActionPlanConnection struct {
	// A list of edges.
	Edges []*ActionPlanEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createActionPlan mutation
type ActionPlanCreatePayload struct {
	// Created actionPlan
	ActionPlan *ActionPlan `json:"actionPlan"`
}

// Return response for deleteActionPlan mutation
type ActionPlanDeletePayload struct {
	// Deleted actionPlan ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ActionPlanEdge struct {
	// The item at the end of the edge.
	Node *ActionPlan `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ActionPlanHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the action plan
	Name string `json:"name"`
	// description of the action plan
	Description *string `json:"description,omitempty"`
	// status of the action plan
	Status *string `json:"status,omitempty"`
	// due date of the action plan
	DueDate *time.Time `json:"dueDate,omitempty"`
	// priority of the action plan
	Priority *string `json:"priority,omitempty"`
	// source of the action plan
	Source *string `json:"source,omitempty"`
	// json data including details of the action plan
	Details map[string]any `json:"details,omitempty"`
}

func (ActionPlanHistory) IsNode() {}

// A connection to a list of items.
type ActionPlanHistoryConnection struct {
	// A list of edges.
	Edges []*ActionPlanHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ActionPlanHistoryEdge struct {
	// The item at the end of the edge.
	Node *ActionPlanHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ActionPlanHistoryWhereInput is used for filtering ActionPlanHistory objects.
// Input was generated by ent.
type ActionPlanHistoryWhereInput struct {
	Not *ActionPlanHistoryWhereInput   `json:"not,omitempty"`
	And []*ActionPlanHistoryWhereInput `json:"and,omitempty"`
	Or  []*ActionPlanHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// due_date field predicates
	DueDate       *time.Time   `json:"dueDate,omitempty"`
	DueDateNeq    *time.Time   `json:"dueDateNEQ,omitempty"`
	DueDateIn     []*time.Time `json:"dueDateIn,omitempty"`
	DueDateNotIn  []*time.Time `json:"dueDateNotIn,omitempty"`
	DueDateGt     *time.Time   `json:"dueDateGT,omitempty"`
	DueDateGte    *time.Time   `json:"dueDateGTE,omitempty"`
	DueDateLt     *time.Time   `json:"dueDateLT,omitempty"`
	DueDateLte    *time.Time   `json:"dueDateLTE,omitempty"`
	DueDateIsNil  *bool        `json:"dueDateIsNil,omitempty"`
	DueDateNotNil *bool        `json:"dueDateNotNil,omitempty"`
	// priority field predicates
	Priority             *string  `json:"priority,omitempty"`
	PriorityNeq          *string  `json:"priorityNEQ,omitempty"`
	PriorityIn           []string `json:"priorityIn,omitempty"`
	PriorityNotIn        []string `json:"priorityNotIn,omitempty"`
	PriorityGt           *string  `json:"priorityGT,omitempty"`
	PriorityGte          *string  `json:"priorityGTE,omitempty"`
	PriorityLt           *string  `json:"priorityLT,omitempty"`
	PriorityLte          *string  `json:"priorityLTE,omitempty"`
	PriorityContains     *string  `json:"priorityContains,omitempty"`
	PriorityHasPrefix    *string  `json:"priorityHasPrefix,omitempty"`
	PriorityHasSuffix    *string  `json:"priorityHasSuffix,omitempty"`
	PriorityIsNil        *bool    `json:"priorityIsNil,omitempty"`
	PriorityNotNil       *bool    `json:"priorityNotNil,omitempty"`
	PriorityEqualFold    *string  `json:"priorityEqualFold,omitempty"`
	PriorityContainsFold *string  `json:"priorityContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
}

type ActionPlanSearchResult struct {
	ActionPlans []*ActionPlan `json:"actionPlans,omitempty"`
}

func (ActionPlanSearchResult) IsSearchResult() {}

// Return response for updateActionPlan mutation
type ActionPlanUpdatePayload struct {
	// Updated actionPlan
	ActionPlan *ActionPlan `json:"actionPlan"`
}

// ActionPlanWhereInput is used for filtering ActionPlan objects.
// Input was generated by ent.
type ActionPlanWhereInput struct {
	Not *ActionPlanWhereInput   `json:"not,omitempty"`
	And []*ActionPlanWhereInput `json:"and,omitempty"`
	Or  []*ActionPlanWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// due_date field predicates
	DueDate       *time.Time   `json:"dueDate,omitempty"`
	DueDateNeq    *time.Time   `json:"dueDateNEQ,omitempty"`
	DueDateIn     []*time.Time `json:"dueDateIn,omitempty"`
	DueDateNotIn  []*time.Time `json:"dueDateNotIn,omitempty"`
	DueDateGt     *time.Time   `json:"dueDateGT,omitempty"`
	DueDateGte    *time.Time   `json:"dueDateGTE,omitempty"`
	DueDateLt     *time.Time   `json:"dueDateLT,omitempty"`
	DueDateLte    *time.Time   `json:"dueDateLTE,omitempty"`
	DueDateIsNil  *bool        `json:"dueDateIsNil,omitempty"`
	DueDateNotNil *bool        `json:"dueDateNotNil,omitempty"`
	// priority field predicates
	Priority             *string  `json:"priority,omitempty"`
	PriorityNeq          *string  `json:"priorityNEQ,omitempty"`
	PriorityIn           []string `json:"priorityIn,omitempty"`
	PriorityNotIn        []string `json:"priorityNotIn,omitempty"`
	PriorityGt           *string  `json:"priorityGT,omitempty"`
	PriorityGte          *string  `json:"priorityGTE,omitempty"`
	PriorityLt           *string  `json:"priorityLT,omitempty"`
	PriorityLte          *string  `json:"priorityLTE,omitempty"`
	PriorityContains     *string  `json:"priorityContains,omitempty"`
	PriorityHasPrefix    *string  `json:"priorityHasPrefix,omitempty"`
	PriorityHasSuffix    *string  `json:"priorityHasSuffix,omitempty"`
	PriorityIsNil        *bool    `json:"priorityIsNil,omitempty"`
	PriorityNotNil       *bool    `json:"priorityNotNil,omitempty"`
	PriorityEqualFold    *string  `json:"priorityEqualFold,omitempty"`
	PriorityContainsFold *string  `json:"priorityContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// risk edge predicates
	HasRisk     *bool             `json:"hasRisk,omitempty"`
	HasRiskWith []*RiskWhereInput `json:"hasRiskWith,omitempty"`
	// control edge predicates
	HasControl     *bool                `json:"hasControl,omitempty"`
	HasControlWith []*ControlWhereInput `json:"hasControlWith,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// program edge predicates
	HasProgram     *bool                `json:"hasProgram,omitempty"`
	HasProgramWith []*ProgramWhereInput `json:"hasProgramWith,omitempty"`
}

type AuditLog struct {
	Table     *string    `json:"table,omitempty"`
	Time      *time.Time `json:"time,omitempty"`
	ID        string     `json:"id"`
	Operation *string    `json:"operation,omitempty"`
	Changes   []string   `json:"changes,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
}

func (AuditLog) IsNode() {}

// A connection to a list of items.
type AuditLogConnection struct {
	// A list of edges.
	Edges []*AuditLogEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type AuditLogEdge struct {
	// The item at the end of the edge.
	Node *AuditLog `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type AuditLogWhereInput struct {
	RefID     *string    `json:"refID,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	Operation *string    `json:"operation,omitempty"`
	Table     *string    `json:"table,omitempty"`
	Before    *time.Time `json:"before,omitempty"`
	After     *time.Time `json:"after,omitempty"`
}

type Contact struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the full name of the contact
	FullName string `json:"fullName"`
	// the title of the contact
	Title *string `json:"title,omitempty"`
	// the company of the contact
	Company *string `json:"company,omitempty"`
	// the email of the contact
	Email *string `json:"email,omitempty"`
	// the phone number of the contact
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// the address of the contact
	Address *string `json:"address,omitempty"`
	// status of the contact
	Status   enums.UserStatus `json:"status"`
	Owner    *Organization    `json:"owner,omitempty"`
	Entities []*Entity        `json:"entities,omitempty"`
	Files    []*File          `json:"files,omitempty"`
}

func (Contact) IsNode() {}

// Return response for createBulkContact mutation
type ContactBulkCreatePayload struct {
	// Created contacts
	Contacts []*Contact `json:"contacts,omitempty"`
}

// A connection to a list of items.
type ContactConnection struct {
	// A list of edges.
	Edges []*ContactEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createContact mutation
type ContactCreatePayload struct {
	// Created contact
	Contact *Contact `json:"contact"`
}

// Return response for deleteContact mutation
type ContactDeletePayload struct {
	// Deleted contact ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ContactEdge struct {
	// The item at the end of the edge.
	Node *Contact `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ContactHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the full name of the contact
	FullName string `json:"fullName"`
	// the title of the contact
	Title *string `json:"title,omitempty"`
	// the company of the contact
	Company *string `json:"company,omitempty"`
	// the email of the contact
	Email *string `json:"email,omitempty"`
	// the phone number of the contact
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// the address of the contact
	Address *string `json:"address,omitempty"`
	// status of the contact
	Status enums.UserStatus `json:"status"`
}

func (ContactHistory) IsNode() {}

// A connection to a list of items.
type ContactHistoryConnection struct {
	// A list of edges.
	Edges []*ContactHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ContactHistoryEdge struct {
	// The item at the end of the edge.
	Node *ContactHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ContactHistoryWhereInput is used for filtering ContactHistory objects.
// Input was generated by ent.
type ContactHistoryWhereInput struct {
	Not *ContactHistoryWhereInput   `json:"not,omitempty"`
	And []*ContactHistoryWhereInput `json:"and,omitempty"`
	Or  []*ContactHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// full_name field predicates
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNeq          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGt           *string  `json:"fullNameGT,omitempty"`
	FullNameGte          *string  `json:"fullNameGTE,omitempty"`
	FullNameLt           *string  `json:"fullNameLT,omitempty"`
	FullNameLte          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// company field predicates
	Company             *string  `json:"company,omitempty"`
	CompanyNeq          *string  `json:"companyNEQ,omitempty"`
	CompanyIn           []string `json:"companyIn,omitempty"`
	CompanyNotIn        []string `json:"companyNotIn,omitempty"`
	CompanyGt           *string  `json:"companyGT,omitempty"`
	CompanyGte          *string  `json:"companyGTE,omitempty"`
	CompanyLt           *string  `json:"companyLT,omitempty"`
	CompanyLte          *string  `json:"companyLTE,omitempty"`
	CompanyContains     *string  `json:"companyContains,omitempty"`
	CompanyHasPrefix    *string  `json:"companyHasPrefix,omitempty"`
	CompanyHasSuffix    *string  `json:"companyHasSuffix,omitempty"`
	CompanyIsNil        *bool    `json:"companyIsNil,omitempty"`
	CompanyNotNil       *bool    `json:"companyNotNil,omitempty"`
	CompanyEqualFold    *string  `json:"companyEqualFold,omitempty"`
	CompanyContainsFold *string  `json:"companyContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        *bool    `json:"emailIsNil,omitempty"`
	EmailNotNil       *bool    `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// phone_number field predicates
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNeq          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGt           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGte          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLt           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLte          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        *bool    `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       *bool    `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`
	// address field predicates
	Address             *string  `json:"address,omitempty"`
	AddressNeq          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGt           *string  `json:"addressGT,omitempty"`
	AddressGte          *string  `json:"addressGTE,omitempty"`
	AddressLt           *string  `json:"addressLT,omitempty"`
	AddressLte          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        *bool    `json:"addressIsNil,omitempty"`
	AddressNotNil       *bool    `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
}

type ContactSearchResult struct {
	Contacts []*Contact `json:"contacts,omitempty"`
}

func (ContactSearchResult) IsSearchResult() {}

// Return response for updateContact mutation
type ContactUpdatePayload struct {
	// Updated contact
	Contact *Contact `json:"contact"`
}

// ContactWhereInput is used for filtering Contact objects.
// Input was generated by ent.
type ContactWhereInput struct {
	Not *ContactWhereInput   `json:"not,omitempty"`
	And []*ContactWhereInput `json:"and,omitempty"`
	Or  []*ContactWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// full_name field predicates
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNeq          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGt           *string  `json:"fullNameGT,omitempty"`
	FullNameGte          *string  `json:"fullNameGTE,omitempty"`
	FullNameLt           *string  `json:"fullNameLT,omitempty"`
	FullNameLte          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// company field predicates
	Company             *string  `json:"company,omitempty"`
	CompanyNeq          *string  `json:"companyNEQ,omitempty"`
	CompanyIn           []string `json:"companyIn,omitempty"`
	CompanyNotIn        []string `json:"companyNotIn,omitempty"`
	CompanyGt           *string  `json:"companyGT,omitempty"`
	CompanyGte          *string  `json:"companyGTE,omitempty"`
	CompanyLt           *string  `json:"companyLT,omitempty"`
	CompanyLte          *string  `json:"companyLTE,omitempty"`
	CompanyContains     *string  `json:"companyContains,omitempty"`
	CompanyHasPrefix    *string  `json:"companyHasPrefix,omitempty"`
	CompanyHasSuffix    *string  `json:"companyHasSuffix,omitempty"`
	CompanyIsNil        *bool    `json:"companyIsNil,omitempty"`
	CompanyNotNil       *bool    `json:"companyNotNil,omitempty"`
	CompanyEqualFold    *string  `json:"companyEqualFold,omitempty"`
	CompanyContainsFold *string  `json:"companyContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        *bool    `json:"emailIsNil,omitempty"`
	EmailNotNil       *bool    `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// phone_number field predicates
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNeq          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGt           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGte          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLt           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLte          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        *bool    `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       *bool    `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`
	// address field predicates
	Address             *string  `json:"address,omitempty"`
	AddressNeq          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGt           *string  `json:"addressGT,omitempty"`
	AddressGte          *string  `json:"addressGTE,omitempty"`
	AddressLt           *string  `json:"addressLT,omitempty"`
	AddressLte          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        *bool    `json:"addressIsNil,omitempty"`
	AddressNotNil       *bool    `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

type Control struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// status of the control
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the unique reference code for the control
	RefCode string `json:"refCode"`
	// the id of the standard that the control belongs to, if applicable
	StandardID *string       `json:"standardID,omitempty"`
	Owner      *Organization `json:"owner,omitempty"`
	// groups that are blocked from viewing or editing the risk
	BlockedGroups []*Group `json:"blockedGroups,omitempty"`
	// provides edit access to the risk to members of the group
	Editors []*Group `json:"editors,omitempty"`
	// provides view access to the risk to members of the group
	Viewers  []*Group    `json:"viewers,omitempty"`
	Standard *Standard   `json:"standard,omitempty"`
	Programs []*Program  `json:"programs,omitempty"`
	Evidence []*Evidence `json:"evidence,omitempty"`
	// the implementation(s) of the control
	ControlImplementations []*ControlImplementation `json:"controlImplementations,omitempty"`
	// mapped subcontrols that have a relation to another control or subcontrol
	MappedControls    []*MappedControl    `json:"mappedControls,omitempty"`
	ControlObjectives []*ControlObjective `json:"controlObjectives,omitempty"`
	Subcontrols       []*Subcontrol       `json:"subcontrols,omitempty"`
	Tasks             []*Task             `json:"tasks,omitempty"`
	Narratives        []*Narrative        `json:"narratives,omitempty"`
	Risks             []*Risk             `json:"risks,omitempty"`
	ActionPlans       []*ActionPlan       `json:"actionPlans,omitempty"`
	Procedures        []*Procedure        `json:"procedures,omitempty"`
	InternalPolicies  []*InternalPolicy   `json:"internalPolicies,omitempty"`
	// the group of users who are responsible for the control, will be assigned tasks, approval, etc.
	ControlOwner *Group `json:"controlOwner,omitempty"`
	// temporary delegate for the control, used for temporary control ownership
	Delegate *Group `json:"delegate,omitempty"`
}

func (Control) IsNode() {}

// Return response for createBulkControl mutation
type ControlBulkCreatePayload struct {
	// Created controls
	Controls []*Control `json:"controls,omitempty"`
}

// A connection to a list of items.
type ControlConnection struct {
	// A list of edges.
	Edges []*ControlEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createControl mutation
type ControlCreatePayload struct {
	// Created control
	Control *Control `json:"control"`
}

// Return response for deleteControl mutation
type ControlDeletePayload struct {
	// Deleted control ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ControlEdge struct {
	// The item at the end of the edge.
	Node *Control `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ControlHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// status of the control
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the unique reference code for the control
	RefCode string `json:"refCode"`
	// the id of the standard that the control belongs to, if applicable
	StandardID *string `json:"standardID,omitempty"`
}

func (ControlHistory) IsNode() {}

// A connection to a list of items.
type ControlHistoryConnection struct {
	// A list of edges.
	Edges []*ControlHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ControlHistoryEdge struct {
	// The item at the end of the edge.
	Node *ControlHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ControlHistoryWhereInput is used for filtering ControlHistory objects.
// Input was generated by ent.
type ControlHistoryWhereInput struct {
	Not *ControlHistoryWhereInput   `json:"not,omitempty"`
	And []*ControlHistoryWhereInput `json:"and,omitempty"`
	Or  []*ControlHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// control_type field predicates
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNeq    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  *bool               `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil *bool               `json:"controlTypeNotNil,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// category_id field predicates
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIdneq          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIdgt           *string  `json:"categoryIDGT,omitempty"`
	CategoryIdgte          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIdlt           *string  `json:"categoryIDLT,omitempty"`
	CategoryIdlte          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        *bool    `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       *bool    `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
	// ref_code field predicates
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNeq          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGt           *string  `json:"refCodeGT,omitempty"`
	RefCodeGte          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLt           *string  `json:"refCodeLT,omitempty"`
	RefCodeLte          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`
	// standard_id field predicates
	StandardID             *string  `json:"standardID,omitempty"`
	StandardIdneq          *string  `json:"standardIDNEQ,omitempty"`
	StandardIDIn           []string `json:"standardIDIn,omitempty"`
	StandardIDNotIn        []string `json:"standardIDNotIn,omitempty"`
	StandardIdgt           *string  `json:"standardIDGT,omitempty"`
	StandardIdgte          *string  `json:"standardIDGTE,omitempty"`
	StandardIdlt           *string  `json:"standardIDLT,omitempty"`
	StandardIdlte          *string  `json:"standardIDLTE,omitempty"`
	StandardIDContains     *string  `json:"standardIDContains,omitempty"`
	StandardIDHasPrefix    *string  `json:"standardIDHasPrefix,omitempty"`
	StandardIDHasSuffix    *string  `json:"standardIDHasSuffix,omitempty"`
	StandardIDIsNil        *bool    `json:"standardIDIsNil,omitempty"`
	StandardIDNotNil       *bool    `json:"standardIDNotNil,omitempty"`
	StandardIDEqualFold    *string  `json:"standardIDEqualFold,omitempty"`
	StandardIDContainsFold *string  `json:"standardIDContainsFold,omitempty"`
}

type ControlImplementation struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// status of the control implementation
	Status *string `json:"status,omitempty"`
	// date the control was implemented
	ImplementationDate *time.Time `json:"implementationDate,omitempty"`
	// set to true if the control implementation has been verified
	Verified *bool `json:"verified,omitempty"`
	// date the control implementation was verified
	VerificationDate *time.Time `json:"verificationDate,omitempty"`
	// details of the control implementation
	Details  *string    `json:"details,omitempty"`
	Controls []*Control `json:"controls,omitempty"`
}

func (ControlImplementation) IsNode() {}

// Return response for createBulkControlImplementation mutation
type ControlImplementationBulkCreatePayload struct {
	// Created controlImplementations
	ControlImplementations []*ControlImplementation `json:"controlImplementations,omitempty"`
}

// A connection to a list of items.
type ControlImplementationConnection struct {
	// A list of edges.
	Edges []*ControlImplementationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createControlImplementation mutation
type ControlImplementationCreatePayload struct {
	// Created controlImplementation
	ControlImplementation *ControlImplementation `json:"controlImplementation"`
}

// Return response for deleteControlImplementation mutation
type ControlImplementationDeletePayload struct {
	// Deleted controlImplementation ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ControlImplementationEdge struct {
	// The item at the end of the edge.
	Node *ControlImplementation `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ControlImplementationHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// status of the control implementation
	Status *string `json:"status,omitempty"`
	// date the control was implemented
	ImplementationDate *time.Time `json:"implementationDate,omitempty"`
	// set to true if the control implementation has been verified
	Verified *bool `json:"verified,omitempty"`
	// date the control implementation was verified
	VerificationDate *time.Time `json:"verificationDate,omitempty"`
	// details of the control implementation
	Details *string `json:"details,omitempty"`
}

func (ControlImplementationHistory) IsNode() {}

// A connection to a list of items.
type ControlImplementationHistoryConnection struct {
	// A list of edges.
	Edges []*ControlImplementationHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ControlImplementationHistoryEdge struct {
	// The item at the end of the edge.
	Node *ControlImplementationHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ControlImplementationHistoryWhereInput is used for filtering ControlImplementationHistory objects.
// Input was generated by ent.
type ControlImplementationHistoryWhereInput struct {
	Not *ControlImplementationHistoryWhereInput   `json:"not,omitempty"`
	And []*ControlImplementationHistoryWhereInput `json:"and,omitempty"`
	Or  []*ControlImplementationHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// implementation_date field predicates
	ImplementationDate       *time.Time   `json:"implementationDate,omitempty"`
	ImplementationDateNeq    *time.Time   `json:"implementationDateNEQ,omitempty"`
	ImplementationDateIn     []*time.Time `json:"implementationDateIn,omitempty"`
	ImplementationDateNotIn  []*time.Time `json:"implementationDateNotIn,omitempty"`
	ImplementationDateGt     *time.Time   `json:"implementationDateGT,omitempty"`
	ImplementationDateGte    *time.Time   `json:"implementationDateGTE,omitempty"`
	ImplementationDateLt     *time.Time   `json:"implementationDateLT,omitempty"`
	ImplementationDateLte    *time.Time   `json:"implementationDateLTE,omitempty"`
	ImplementationDateIsNil  *bool        `json:"implementationDateIsNil,omitempty"`
	ImplementationDateNotNil *bool        `json:"implementationDateNotNil,omitempty"`
	// verified field predicates
	Verified       *bool `json:"verified,omitempty"`
	VerifiedNeq    *bool `json:"verifiedNEQ,omitempty"`
	VerifiedIsNil  *bool `json:"verifiedIsNil,omitempty"`
	VerifiedNotNil *bool `json:"verifiedNotNil,omitempty"`
	// verification_date field predicates
	VerificationDate       *time.Time   `json:"verificationDate,omitempty"`
	VerificationDateNeq    *time.Time   `json:"verificationDateNEQ,omitempty"`
	VerificationDateIn     []*time.Time `json:"verificationDateIn,omitempty"`
	VerificationDateNotIn  []*time.Time `json:"verificationDateNotIn,omitempty"`
	VerificationDateGt     *time.Time   `json:"verificationDateGT,omitempty"`
	VerificationDateGte    *time.Time   `json:"verificationDateGTE,omitempty"`
	VerificationDateLt     *time.Time   `json:"verificationDateLT,omitempty"`
	VerificationDateLte    *time.Time   `json:"verificationDateLTE,omitempty"`
	VerificationDateIsNil  *bool        `json:"verificationDateIsNil,omitempty"`
	VerificationDateNotNil *bool        `json:"verificationDateNotNil,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
}

type ControlImplementationSearchResult struct {
	ControlImplementations []*ControlImplementation `json:"controlImplementations,omitempty"`
}

func (ControlImplementationSearchResult) IsSearchResult() {}

// Return response for updateControlImplementation mutation
type ControlImplementationUpdatePayload struct {
	// Updated controlImplementation
	ControlImplementation *ControlImplementation `json:"controlImplementation"`
}

// ControlImplementationWhereInput is used for filtering ControlImplementation objects.
// Input was generated by ent.
type ControlImplementationWhereInput struct {
	Not *ControlImplementationWhereInput   `json:"not,omitempty"`
	And []*ControlImplementationWhereInput `json:"and,omitempty"`
	Or  []*ControlImplementationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// implementation_date field predicates
	ImplementationDate       *time.Time   `json:"implementationDate,omitempty"`
	ImplementationDateNeq    *time.Time   `json:"implementationDateNEQ,omitempty"`
	ImplementationDateIn     []*time.Time `json:"implementationDateIn,omitempty"`
	ImplementationDateNotIn  []*time.Time `json:"implementationDateNotIn,omitempty"`
	ImplementationDateGt     *time.Time   `json:"implementationDateGT,omitempty"`
	ImplementationDateGte    *time.Time   `json:"implementationDateGTE,omitempty"`
	ImplementationDateLt     *time.Time   `json:"implementationDateLT,omitempty"`
	ImplementationDateLte    *time.Time   `json:"implementationDateLTE,omitempty"`
	ImplementationDateIsNil  *bool        `json:"implementationDateIsNil,omitempty"`
	ImplementationDateNotNil *bool        `json:"implementationDateNotNil,omitempty"`
	// verified field predicates
	Verified       *bool `json:"verified,omitempty"`
	VerifiedNeq    *bool `json:"verifiedNEQ,omitempty"`
	VerifiedIsNil  *bool `json:"verifiedIsNil,omitempty"`
	VerifiedNotNil *bool `json:"verifiedNotNil,omitempty"`
	// verification_date field predicates
	VerificationDate       *time.Time   `json:"verificationDate,omitempty"`
	VerificationDateNeq    *time.Time   `json:"verificationDateNEQ,omitempty"`
	VerificationDateIn     []*time.Time `json:"verificationDateIn,omitempty"`
	VerificationDateNotIn  []*time.Time `json:"verificationDateNotIn,omitempty"`
	VerificationDateGt     *time.Time   `json:"verificationDateGT,omitempty"`
	VerificationDateGte    *time.Time   `json:"verificationDateGTE,omitempty"`
	VerificationDateLt     *time.Time   `json:"verificationDateLT,omitempty"`
	VerificationDateLte    *time.Time   `json:"verificationDateLTE,omitempty"`
	VerificationDateIsNil  *bool        `json:"verificationDateIsNil,omitempty"`
	VerificationDateNotNil *bool        `json:"verificationDateNotNil,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
}

type ControlObjective struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the control objective
	Name string `json:"name"`
	// the desired outcome or target of the control objective
	DesiredOutcome *string `json:"desiredOutcome,omitempty"`
	// status of the control objective
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control objective e.g. compliance, financial, operational, etc.
	ControlObjectiveType *string `json:"controlObjectiveType,omitempty"`
	// version of the control objective
	Version *string `json:"version,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// subcategory of the control
	Subcategory *string       `json:"subcategory,omitempty"`
	Owner       *Organization `json:"owner,omitempty"`
	// groups that are blocked from viewing or editing the risk
	BlockedGroups []*Group `json:"blockedGroups,omitempty"`
	// provides edit access to the risk to members of the group
	Editors []*Group `json:"editors,omitempty"`
	// provides view access to the risk to members of the group
	Viewers          []*Group          `json:"viewers,omitempty"`
	Programs         []*Program        `json:"programs,omitempty"`
	Evidence         []*Evidence       `json:"evidence,omitempty"`
	Controls         []*Control        `json:"controls,omitempty"`
	Subcontrols      []*Subcontrol     `json:"subcontrols,omitempty"`
	InternalPolicies []*InternalPolicy `json:"internalPolicies,omitempty"`
	Procedures       []*Procedure      `json:"procedures,omitempty"`
	Risks            []*Risk           `json:"risks,omitempty"`
	Narratives       []*Narrative      `json:"narratives,omitempty"`
	Tasks            []*Task           `json:"tasks,omitempty"`
}

func (ControlObjective) IsNode() {}

// Return response for createBulkControlObjective mutation
type ControlObjectiveBulkCreatePayload struct {
	// Created controlObjectives
	ControlObjectives []*ControlObjective `json:"controlObjectives,omitempty"`
}

// A connection to a list of items.
type ControlObjectiveConnection struct {
	// A list of edges.
	Edges []*ControlObjectiveEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createControlObjective mutation
type ControlObjectiveCreatePayload struct {
	// Created controlObjective
	ControlObjective *ControlObjective `json:"controlObjective"`
}

// Return response for deleteControlObjective mutation
type ControlObjectiveDeletePayload struct {
	// Deleted controlObjective ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ControlObjectiveEdge struct {
	// The item at the end of the edge.
	Node *ControlObjective `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ControlObjectiveHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the control objective
	Name string `json:"name"`
	// the desired outcome or target of the control objective
	DesiredOutcome *string `json:"desiredOutcome,omitempty"`
	// status of the control objective
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control objective e.g. compliance, financial, operational, etc.
	ControlObjectiveType *string `json:"controlObjectiveType,omitempty"`
	// version of the control objective
	Version *string `json:"version,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
}

func (ControlObjectiveHistory) IsNode() {}

// A connection to a list of items.
type ControlObjectiveHistoryConnection struct {
	// A list of edges.
	Edges []*ControlObjectiveHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ControlObjectiveHistoryEdge struct {
	// The item at the end of the edge.
	Node *ControlObjectiveHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ControlObjectiveHistoryWhereInput is used for filtering ControlObjectiveHistory objects.
// Input was generated by ent.
type ControlObjectiveHistoryWhereInput struct {
	Not *ControlObjectiveHistoryWhereInput   `json:"not,omitempty"`
	And []*ControlObjectiveHistoryWhereInput `json:"and,omitempty"`
	Or  []*ControlObjectiveHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// desired_outcome field predicates
	DesiredOutcome             *string  `json:"desiredOutcome,omitempty"`
	DesiredOutcomeNeq          *string  `json:"desiredOutcomeNEQ,omitempty"`
	DesiredOutcomeIn           []string `json:"desiredOutcomeIn,omitempty"`
	DesiredOutcomeNotIn        []string `json:"desiredOutcomeNotIn,omitempty"`
	DesiredOutcomeGt           *string  `json:"desiredOutcomeGT,omitempty"`
	DesiredOutcomeGte          *string  `json:"desiredOutcomeGTE,omitempty"`
	DesiredOutcomeLt           *string  `json:"desiredOutcomeLT,omitempty"`
	DesiredOutcomeLte          *string  `json:"desiredOutcomeLTE,omitempty"`
	DesiredOutcomeContains     *string  `json:"desiredOutcomeContains,omitempty"`
	DesiredOutcomeHasPrefix    *string  `json:"desiredOutcomeHasPrefix,omitempty"`
	DesiredOutcomeHasSuffix    *string  `json:"desiredOutcomeHasSuffix,omitempty"`
	DesiredOutcomeIsNil        *bool    `json:"desiredOutcomeIsNil,omitempty"`
	DesiredOutcomeNotNil       *bool    `json:"desiredOutcomeNotNil,omitempty"`
	DesiredOutcomeEqualFold    *string  `json:"desiredOutcomeEqualFold,omitempty"`
	DesiredOutcomeContainsFold *string  `json:"desiredOutcomeContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// control_objective_type field predicates
	ControlObjectiveType             *string  `json:"controlObjectiveType,omitempty"`
	ControlObjectiveTypeNeq          *string  `json:"controlObjectiveTypeNEQ,omitempty"`
	ControlObjectiveTypeIn           []string `json:"controlObjectiveTypeIn,omitempty"`
	ControlObjectiveTypeNotIn        []string `json:"controlObjectiveTypeNotIn,omitempty"`
	ControlObjectiveTypeGt           *string  `json:"controlObjectiveTypeGT,omitempty"`
	ControlObjectiveTypeGte          *string  `json:"controlObjectiveTypeGTE,omitempty"`
	ControlObjectiveTypeLt           *string  `json:"controlObjectiveTypeLT,omitempty"`
	ControlObjectiveTypeLte          *string  `json:"controlObjectiveTypeLTE,omitempty"`
	ControlObjectiveTypeContains     *string  `json:"controlObjectiveTypeContains,omitempty"`
	ControlObjectiveTypeHasPrefix    *string  `json:"controlObjectiveTypeHasPrefix,omitempty"`
	ControlObjectiveTypeHasSuffix    *string  `json:"controlObjectiveTypeHasSuffix,omitempty"`
	ControlObjectiveTypeIsNil        *bool    `json:"controlObjectiveTypeIsNil,omitempty"`
	ControlObjectiveTypeNotNil       *bool    `json:"controlObjectiveTypeNotNil,omitempty"`
	ControlObjectiveTypeEqualFold    *string  `json:"controlObjectiveTypeEqualFold,omitempty"`
	ControlObjectiveTypeContainsFold *string  `json:"controlObjectiveTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
}

type ControlObjectiveSearchResult struct {
	ControlObjectives []*ControlObjective `json:"controlObjectives,omitempty"`
}

func (ControlObjectiveSearchResult) IsSearchResult() {}

// Return response for updateControlObjective mutation
type ControlObjectiveUpdatePayload struct {
	// Updated controlObjective
	ControlObjective *ControlObjective `json:"controlObjective"`
}

// ControlObjectiveWhereInput is used for filtering ControlObjective objects.
// Input was generated by ent.
type ControlObjectiveWhereInput struct {
	Not *ControlObjectiveWhereInput   `json:"not,omitempty"`
	And []*ControlObjectiveWhereInput `json:"and,omitempty"`
	Or  []*ControlObjectiveWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// desired_outcome field predicates
	DesiredOutcome             *string  `json:"desiredOutcome,omitempty"`
	DesiredOutcomeNeq          *string  `json:"desiredOutcomeNEQ,omitempty"`
	DesiredOutcomeIn           []string `json:"desiredOutcomeIn,omitempty"`
	DesiredOutcomeNotIn        []string `json:"desiredOutcomeNotIn,omitempty"`
	DesiredOutcomeGt           *string  `json:"desiredOutcomeGT,omitempty"`
	DesiredOutcomeGte          *string  `json:"desiredOutcomeGTE,omitempty"`
	DesiredOutcomeLt           *string  `json:"desiredOutcomeLT,omitempty"`
	DesiredOutcomeLte          *string  `json:"desiredOutcomeLTE,omitempty"`
	DesiredOutcomeContains     *string  `json:"desiredOutcomeContains,omitempty"`
	DesiredOutcomeHasPrefix    *string  `json:"desiredOutcomeHasPrefix,omitempty"`
	DesiredOutcomeHasSuffix    *string  `json:"desiredOutcomeHasSuffix,omitempty"`
	DesiredOutcomeIsNil        *bool    `json:"desiredOutcomeIsNil,omitempty"`
	DesiredOutcomeNotNil       *bool    `json:"desiredOutcomeNotNil,omitempty"`
	DesiredOutcomeEqualFold    *string  `json:"desiredOutcomeEqualFold,omitempty"`
	DesiredOutcomeContainsFold *string  `json:"desiredOutcomeContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// control_objective_type field predicates
	ControlObjectiveType             *string  `json:"controlObjectiveType,omitempty"`
	ControlObjectiveTypeNeq          *string  `json:"controlObjectiveTypeNEQ,omitempty"`
	ControlObjectiveTypeIn           []string `json:"controlObjectiveTypeIn,omitempty"`
	ControlObjectiveTypeNotIn        []string `json:"controlObjectiveTypeNotIn,omitempty"`
	ControlObjectiveTypeGt           *string  `json:"controlObjectiveTypeGT,omitempty"`
	ControlObjectiveTypeGte          *string  `json:"controlObjectiveTypeGTE,omitempty"`
	ControlObjectiveTypeLt           *string  `json:"controlObjectiveTypeLT,omitempty"`
	ControlObjectiveTypeLte          *string  `json:"controlObjectiveTypeLTE,omitempty"`
	ControlObjectiveTypeContains     *string  `json:"controlObjectiveTypeContains,omitempty"`
	ControlObjectiveTypeHasPrefix    *string  `json:"controlObjectiveTypeHasPrefix,omitempty"`
	ControlObjectiveTypeHasSuffix    *string  `json:"controlObjectiveTypeHasSuffix,omitempty"`
	ControlObjectiveTypeIsNil        *bool    `json:"controlObjectiveTypeIsNil,omitempty"`
	ControlObjectiveTypeNotNil       *bool    `json:"controlObjectiveTypeNotNil,omitempty"`
	ControlObjectiveTypeEqualFold    *string  `json:"controlObjectiveTypeEqualFold,omitempty"`
	ControlObjectiveTypeContainsFold *string  `json:"controlObjectiveTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
}

type ControlSearchResult struct {
	Controls []*Control `json:"controls,omitempty"`
}

func (ControlSearchResult) IsSearchResult() {}

// Return response for updateControl mutation
type ControlUpdatePayload struct {
	// Updated control
	Control *Control `json:"control"`
}

// ControlWhereInput is used for filtering Control objects.
// Input was generated by ent.
type ControlWhereInput struct {
	Not *ControlWhereInput   `json:"not,omitempty"`
	And []*ControlWhereInput `json:"and,omitempty"`
	Or  []*ControlWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// control_type field predicates
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNeq    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  *bool               `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil *bool               `json:"controlTypeNotNil,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// category_id field predicates
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIdneq          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIdgt           *string  `json:"categoryIDGT,omitempty"`
	CategoryIdgte          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIdlt           *string  `json:"categoryIDLT,omitempty"`
	CategoryIdlte          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        *bool    `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       *bool    `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
	// ref_code field predicates
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNeq          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGt           *string  `json:"refCodeGT,omitempty"`
	RefCodeGte          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLt           *string  `json:"refCodeLT,omitempty"`
	RefCodeLte          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`
	// standard_id field predicates
	StandardID             *string  `json:"standardID,omitempty"`
	StandardIdneq          *string  `json:"standardIDNEQ,omitempty"`
	StandardIDIn           []string `json:"standardIDIn,omitempty"`
	StandardIDNotIn        []string `json:"standardIDNotIn,omitempty"`
	StandardIdgt           *string  `json:"standardIDGT,omitempty"`
	StandardIdgte          *string  `json:"standardIDGTE,omitempty"`
	StandardIdlt           *string  `json:"standardIDLT,omitempty"`
	StandardIdlte          *string  `json:"standardIDLTE,omitempty"`
	StandardIDContains     *string  `json:"standardIDContains,omitempty"`
	StandardIDHasPrefix    *string  `json:"standardIDHasPrefix,omitempty"`
	StandardIDHasSuffix    *string  `json:"standardIDHasSuffix,omitempty"`
	StandardIDIsNil        *bool    `json:"standardIDIsNil,omitempty"`
	StandardIDNotNil       *bool    `json:"standardIDNotNil,omitempty"`
	StandardIDEqualFold    *string  `json:"standardIDEqualFold,omitempty"`
	StandardIDContainsFold *string  `json:"standardIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// standard edge predicates
	HasStandard     *bool                 `json:"hasStandard,omitempty"`
	HasStandardWith []*StandardWhereInput `json:"hasStandardWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// control_implementations edge predicates
	HasControlImplementations     *bool                              `json:"hasControlImplementations,omitempty"`
	HasControlImplementationsWith []*ControlImplementationWhereInput `json:"hasControlImplementationsWith,omitempty"`
	// mapped_controls edge predicates
	HasMappedControls     *bool                      `json:"hasMappedControls,omitempty"`
	HasMappedControlsWith []*MappedControlWhereInput `json:"hasMappedControlsWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// control_owner edge predicates
	HasControlOwner     *bool              `json:"hasControlOwner,omitempty"`
	HasControlOwnerWith []*GroupWhereInput `json:"hasControlOwnerWith,omitempty"`
	// delegate edge predicates
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`
}

// CreateAPITokenInput is used for create APIToken object.
// Input was generated by ent.
type CreateAPITokenInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name associated with the token
	Name string `json:"name"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string    `json:"description,omitempty"`
	Scopes      []string   `json:"scopes,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	// whether the token is active
	IsActive *bool `json:"isActive,omitempty"`
	// the reason the token was revoked
	RevokedReason *string `json:"revokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy *string `json:"revokedBy,omitempty"`
	// when the token was revoked
	RevokedAt *time.Time `json:"revokedAt,omitempty"`
	OwnerID   *string    `json:"ownerID,omitempty"`
}

// CreateActionPlanInput is used for create ActionPlan object.
// Input was generated by ent.
type CreateActionPlanInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the action plan
	Name string `json:"name"`
	// description of the action plan
	Description *string `json:"description,omitempty"`
	// status of the action plan
	Status *string `json:"status,omitempty"`
	// due date of the action plan
	DueDate *time.Time `json:"dueDate,omitempty"`
	// priority of the action plan
	Priority *string `json:"priority,omitempty"`
	// source of the action plan
	Source *string `json:"source,omitempty"`
	// json data including details of the action plan
	Details    map[string]any `json:"details,omitempty"`
	RiskIDs    []string       `json:"riskIDs,omitempty"`
	ControlIDs []string       `json:"controlIDs,omitempty"`
	UserIDs    []string       `json:"userIDs,omitempty"`
	ProgramIDs []string       `json:"programIDs,omitempty"`
}

// CreateContactInput is used for create Contact object.
// Input was generated by ent.
type CreateContactInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the full name of the contact
	FullName string `json:"fullName"`
	// the title of the contact
	Title *string `json:"title,omitempty"`
	// the company of the contact
	Company *string `json:"company,omitempty"`
	// the email of the contact
	Email *string `json:"email,omitempty"`
	// the phone number of the contact
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// the address of the contact
	Address *string `json:"address,omitempty"`
	// status of the contact
	Status    *enums.UserStatus `json:"status,omitempty"`
	OwnerID   *string           `json:"ownerID,omitempty"`
	EntityIDs []string          `json:"entityIDs,omitempty"`
	FileIDs   []string          `json:"fileIDs,omitempty"`
}

// CreateControlImplementationInput is used for create ControlImplementation object.
// Input was generated by ent.
type CreateControlImplementationInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// status of the control implementation
	Status *string `json:"status,omitempty"`
	// date the control was implemented
	ImplementationDate *time.Time `json:"implementationDate,omitempty"`
	// set to true if the control implementation has been verified
	Verified *bool `json:"verified,omitempty"`
	// date the control implementation was verified
	VerificationDate *time.Time `json:"verificationDate,omitempty"`
	// details of the control implementation
	Details    *string  `json:"details,omitempty"`
	ControlIDs []string `json:"controlIDs,omitempty"`
}

// CreateControlInput is used for create Control object.
// Input was generated by ent.
type CreateControlInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// status of the control
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the unique reference code for the control
	RefCode                  string   `json:"refCode"`
	OwnerID                  *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs          []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs                []string `json:"editorIDs,omitempty"`
	ViewerIDs                []string `json:"viewerIDs,omitempty"`
	StandardID               *string  `json:"standardID,omitempty"`
	ProgramIDs               []string `json:"programIDs,omitempty"`
	EvidenceIDs              []string `json:"evidenceIDs,omitempty"`
	ControlImplementationIDs []string `json:"controlImplementationIDs,omitempty"`
	MappedControlIDs         []string `json:"mappedControlIDs,omitempty"`
	ControlObjectiveIDs      []string `json:"controlObjectiveIDs,omitempty"`
	SubcontrolIDs            []string `json:"subcontrolIDs,omitempty"`
	TaskIDs                  []string `json:"taskIDs,omitempty"`
	NarrativeIDs             []string `json:"narrativeIDs,omitempty"`
	RiskIDs                  []string `json:"riskIDs,omitempty"`
	ActionPlanIDs            []string `json:"actionPlanIDs,omitempty"`
	ProcedureIDs             []string `json:"procedureIDs,omitempty"`
	InternalPolicyIDs        []string `json:"internalPolicyIDs,omitempty"`
	ControlOwnerID           *string  `json:"controlOwnerID,omitempty"`
	DelegateID               *string  `json:"delegateID,omitempty"`
}

// CreateControlObjectiveInput is used for create ControlObjective object.
// Input was generated by ent.
type CreateControlObjectiveInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the control objective
	Name string `json:"name"`
	// the desired outcome or target of the control objective
	DesiredOutcome *string `json:"desiredOutcome,omitempty"`
	// status of the control objective
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control objective e.g. compliance, financial, operational, etc.
	ControlObjectiveType *string `json:"controlObjectiveType,omitempty"`
	// version of the control objective
	Version *string `json:"version,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// subcategory of the control
	Subcategory       *string  `json:"subcategory,omitempty"`
	OwnerID           *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs   []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs         []string `json:"editorIDs,omitempty"`
	ViewerIDs         []string `json:"viewerIDs,omitempty"`
	ProgramIDs        []string `json:"programIDs,omitempty"`
	EvidenceIDs       []string `json:"evidenceIDs,omitempty"`
	ControlIDs        []string `json:"controlIDs,omitempty"`
	SubcontrolIDs     []string `json:"subcontrolIDs,omitempty"`
	InternalPolicyIDs []string `json:"internalPolicyIDs,omitempty"`
	ProcedureIDs      []string `json:"procedureIDs,omitempty"`
	RiskIDs           []string `json:"riskIDs,omitempty"`
	NarrativeIDs      []string `json:"narrativeIDs,omitempty"`
	TaskIDs           []string `json:"taskIDs,omitempty"`
}

type CreateControlWithSubcontrolsInput struct {
	Control     *CreateControlInput      `json:"control,omitempty"`
	Subcontrols []*CreateSubcontrolInput `json:"subcontrols,omitempty"`
}

// CreateDocumentDataInput is used for create DocumentData object.
// Input was generated by ent.
type CreateDocumentDataInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the json data of the document
	Data       map[string]any `json:"data"`
	OwnerID    *string        `json:"ownerID,omitempty"`
	TemplateID string         `json:"templateID"`
	EntityIDs  []string       `json:"entityIDs,omitempty"`
	FileIDs    []string       `json:"fileIDs,omitempty"`
}

// CreateEntityInput is used for create Entity object.
// Input was generated by ent.
type CreateEntityInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the entity
	Name *string `json:"name,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the entity
	Description *string `json:"description,omitempty"`
	// domains associated with the entity
	Domains []string `json:"domains,omitempty"`
	// status of the entity
	Status       *string          `json:"status,omitempty"`
	OwnerID      *string          `json:"ownerID,omitempty"`
	ContactIDs   []string         `json:"contactIDs,omitempty"`
	DocumentIDs  []string         `json:"documentIDs,omitempty"`
	NoteIDs      []string         `json:"noteIDs,omitempty"`
	FileIDs      []string         `json:"fileIDs,omitempty"`
	EntityTypeID *string          `json:"entityTypeID,omitempty"`
	Note         *CreateNoteInput `json:"note,omitempty"`
}

// CreateEntityTypeInput is used for create EntityType object.
// Input was generated by ent.
type CreateEntityTypeInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the entity
	Name      string   `json:"name"`
	OwnerID   *string  `json:"ownerID,omitempty"`
	EntityIDs []string `json:"entityIDs,omitempty"`
}

// CreateEventInput is used for create Event object.
// Input was generated by ent.
type CreateEventInput struct {
	// tags associated with the object
	Tags                   []string       `json:"tags,omitempty"`
	EventID                *string        `json:"eventID,omitempty"`
	CorrelationID          *string        `json:"correlationID,omitempty"`
	EventType              string         `json:"eventType"`
	Metadata               map[string]any `json:"metadata,omitempty"`
	UserIDs                []string       `json:"userIDs,omitempty"`
	GroupIDs               []string       `json:"groupIDs,omitempty"`
	IntegrationIDs         []string       `json:"integrationIDs,omitempty"`
	OrganizationIDs        []string       `json:"organizationIDs,omitempty"`
	InviteIDs              []string       `json:"inviteIDs,omitempty"`
	PersonalAccessTokenIDs []string       `json:"personalAccessTokenIDs,omitempty"`
	HushIDs                []string       `json:"hushIDs,omitempty"`
	SubscriberIDs          []string       `json:"subscriberIDs,omitempty"`
	FileIDs                []string       `json:"fileIDs,omitempty"`
	OrgsubscriptionIDs     []string       `json:"orgsubscriptionIDs,omitempty"`
}

// CreateEvidenceInput is used for create Evidence object.
// Input was generated by ent.
type CreateEvidenceInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the evidence
	Name string `json:"name"`
	// the description of the evidence, what is contained in the uploaded file(s) or url(s)
	Description *string `json:"description,omitempty"`
	// description of how the evidence was collected
	CollectionProcedure *string `json:"collectionProcedure,omitempty"`
	// the date the evidence was retrieved
	CreationDate *time.Time `json:"creationDate,omitempty"`
	// the date the evidence should be renewed, defaults to a year from entry date
	RenewalDate *time.Time `json:"renewalDate,omitempty"`
	// the source of the evidence, e.g. system the evidence was retrieved from (splunk, github, etc)
	Source *string `json:"source,omitempty"`
	// whether the evidence was automatically generated
	IsAutomated *bool `json:"isAutomated,omitempty"`
	// the url of the evidence if not uploaded directly to the system
	URL                 *string  `json:"url,omitempty"`
	OwnerID             *string  `json:"ownerID,omitempty"`
	ControlObjectiveIDs []string `json:"controlObjectiveIDs,omitempty"`
	ControlIDs          []string `json:"controlIDs,omitempty"`
	SubcontrolIDs       []string `json:"subcontrolIDs,omitempty"`
	FileIDs             []string `json:"fileIDs,omitempty"`
	ProgramIDs          []string `json:"programIDs,omitempty"`
	TaskIDs             []string `json:"taskIDs,omitempty"`
}

// CreateFileInput is used for create File object.
// Input was generated by ent.
type CreateFileInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName string `json:"providedFileName"`
	// the extension of the file provided
	ProvidedFileExtension string `json:"providedFileExtension"`
	// the computed size of the file in the original http request
	ProvidedFileSize  *int64 `json:"providedFileSize,omitempty"`
	PersistedFileSize *int64 `json:"persistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType *string `json:"detectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash *string `json:"md5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType string `json:"detectedContentType"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey *string `json:"storeKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType *string `json:"categoryType,omitempty"`
	// the full URI of the file
	URI *string `json:"uri,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme *string `json:"storageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume *string `json:"storageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath            *string  `json:"storagePath,omitempty"`
	UserIDs                []string `json:"userIDs,omitempty"`
	OrganizationIDs        []string `json:"organizationIDs,omitempty"`
	GroupIDs               []string `json:"groupIDs,omitempty"`
	ContactIDs             []string `json:"contactIDs,omitempty"`
	EntityIDs              []string `json:"entityIDs,omitempty"`
	UserSettingIDs         []string `json:"userSettingIDs,omitempty"`
	OrganizationSettingIDs []string `json:"organizationSettingIDs,omitempty"`
	TemplateIDs            []string `json:"templateIDs,omitempty"`
	DocumentDatumIDs       []string `json:"documentDatumIDs,omitempty"`
	EventIDs               []string `json:"eventIDs,omitempty"`
	ProgramIDs             []string `json:"programIDs,omitempty"`
	EvidenceIDs            []string `json:"evidenceIDs,omitempty"`
}

type CreateFullProgramInput struct {
	Program          *CreateProgramInput                  `json:"program"`
	Controls         []*CreateControlWithSubcontrolsInput `json:"controls,omitempty"`
	Risks            []*CreateRiskInput                   `json:"risks,omitempty"`
	InternalPolicies []*CreateInternalPolicyInput         `json:"internalPolicies,omitempty"`
	Procedures       []*CreateProcedureInput              `json:"procedures,omitempty"`
	Members          []*CreateMemberWithProgramInput      `json:"members,omitempty"`
}

// CreateGroupInput is used for create Group object.
// Input was generated by ent.
type CreateGroupInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the group - must be unique within the organization
	Name string `json:"name"`
	// the groups description
	Description *string `json:"description,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL *string `json:"gravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL *string `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName                     *string                  `json:"displayName,omitempty"`
	OwnerID                         *string                  `json:"ownerID,omitempty"`
	ProcedureEditorIDs              []string                 `json:"procedureEditorIDs,omitempty"`
	ProcedureBlockedGroupIDs        []string                 `json:"procedureBlockedGroupIDs,omitempty"`
	InternalPolicyEditorIDs         []string                 `json:"internalPolicyEditorIDs,omitempty"`
	InternalPolicyBlockedGroupIDs   []string                 `json:"internalPolicyBlockedGroupIDs,omitempty"`
	ProgramEditorIDs                []string                 `json:"programEditorIDs,omitempty"`
	ProgramBlockedGroupIDs          []string                 `json:"programBlockedGroupIDs,omitempty"`
	ProgramViewerIDs                []string                 `json:"programViewerIDs,omitempty"`
	RiskEditorIDs                   []string                 `json:"riskEditorIDs,omitempty"`
	RiskBlockedGroupIDs             []string                 `json:"riskBlockedGroupIDs,omitempty"`
	RiskViewerIDs                   []string                 `json:"riskViewerIDs,omitempty"`
	ControlObjectiveEditorIDs       []string                 `json:"controlObjectiveEditorIDs,omitempty"`
	ControlObjectiveBlockedGroupIDs []string                 `json:"controlObjectiveBlockedGroupIDs,omitempty"`
	ControlObjectiveViewerIDs       []string                 `json:"controlObjectiveViewerIDs,omitempty"`
	ControlEditorIDs                []string                 `json:"controlEditorIDs,omitempty"`
	ControlBlockedGroupIDs          []string                 `json:"controlBlockedGroupIDs,omitempty"`
	ControlViewerIDs                []string                 `json:"controlViewerIDs,omitempty"`
	NarrativeEditorIDs              []string                 `json:"narrativeEditorIDs,omitempty"`
	NarrativeBlockedGroupIDs        []string                 `json:"narrativeBlockedGroupIDs,omitempty"`
	NarrativeViewerIDs              []string                 `json:"narrativeViewerIDs,omitempty"`
	SettingID                       *string                  `json:"settingID,omitempty"`
	EventIDs                        []string                 `json:"eventIDs,omitempty"`
	IntegrationIDs                  []string                 `json:"integrationIDs,omitempty"`
	FileIDs                         []string                 `json:"fileIDs,omitempty"`
	TaskIDs                         []string                 `json:"taskIDs,omitempty"`
	CreateGroupSettings             *CreateGroupSettingInput `json:"createGroupSettings,omitempty"`
}

// CreateGroupMembershipInput is used for create GroupMembership object.
// Input was generated by ent.
type CreateGroupMembershipInput struct {
	Role     *enums.Role `json:"role,omitempty"`
	GroupID  string      `json:"groupID"`
	UserID   string      `json:"userID"`
	EventIDs []string    `json:"eventIDs,omitempty"`
}

// CreateGroupSettingInput is used for create GroupSetting object.
// Input was generated by ent.
type CreateGroupSettingInput struct {
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility *enums.Visibility `json:"visibility,omitempty"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy *enums.JoinPolicy `json:"joinPolicy,omitempty"`
	// whether to sync group members to slack groups
	SyncToSlack *bool `json:"syncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub *bool   `json:"syncToGithub,omitempty"`
	GroupID      *string `json:"groupID,omitempty"`
}

// CreateHushInput is used for create Hush object.
// Input was generated by ent.
type CreateHushInput struct {
	// the logical name of the corresponding hush secret or it's general grouping
	Name string `json:"name"`
	// a description of the hush value or purpose, such as github PAT
	Description *string `json:"description,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind *string `json:"kind,omitempty"`
	// the generic name of a secret associated with the organization
	SecretName *string `json:"secretName,omitempty"`
	// the secret value
	SecretValue     *string  `json:"secretValue,omitempty"`
	IntegrationIDs  []string `json:"integrationIDs,omitempty"`
	OrganizationIDs []string `json:"organizationIDs,omitempty"`
	EventIDs        []string `json:"eventIDs,omitempty"`
}

// CreateIntegrationInput is used for create Integration object.
// Input was generated by ent.
type CreateIntegrationInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the integration - must be unique within the organization
	Name string `json:"name"`
	// a description of the integration
	Description *string  `json:"description,omitempty"`
	Kind        *string  `json:"kind,omitempty"`
	OwnerID     *string  `json:"ownerID,omitempty"`
	SecretIDs   []string `json:"secretIDs,omitempty"`
	EventIDs    []string `json:"eventIDs,omitempty"`
}

// CreateInternalPolicyInput is used for create InternalPolicy object.
// Input was generated by ent.
type CreateInternalPolicyInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the policy
	Name string `json:"name"`
	// description of the policy
	Description *string `json:"description,omitempty"`
	// status of the policy
	Status *string `json:"status,omitempty"`
	// the date the policy should be reviewed, defaults to a year from creation date
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// type of the policy
	PolicyType *string `json:"policyType,omitempty"`
	// version of the policy
	Version *string `json:"version,omitempty"`
	// purpose and scope
	PurposeAndScope *string `json:"purposeAndScope,omitempty"`
	// background of the policy
	Background *string `json:"background,omitempty"`
	// json data for the policy document
	Details             map[string]any `json:"details,omitempty"`
	OwnerID             *string        `json:"ownerID,omitempty"`
	BlockedGroupIDs     []string       `json:"blockedGroupIDs,omitempty"`
	EditorIDs           []string       `json:"editorIDs,omitempty"`
	ControlObjectiveIDs []string       `json:"controlObjectiveIDs,omitempty"`
	ControlIDs          []string       `json:"controlIDs,omitempty"`
	ProcedureIDs        []string       `json:"procedureIDs,omitempty"`
	NarrativeIDs        []string       `json:"narrativeIDs,omitempty"`
	TaskIDs             []string       `json:"taskIDs,omitempty"`
	ProgramIDs          []string       `json:"programIDs,omitempty"`
}

// CreateInviteInput is used for create Invite object.
// Input was generated by ent.
type CreateInviteInput struct {
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires *time.Time `json:"expires,omitempty"`
	// the email used as input to generate the invitation token and is the destination person the invitation is sent to who is required to accept to join the organization
	Recipient string `json:"recipient"`
	// the status of the invitation
	Status *enums.InviteStatus `json:"status,omitempty"`
	Role   *enums.Role         `json:"role,omitempty"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts *int64 `json:"sendAttempts,omitempty"`
	// the user who initiated the invitation
	RequestorID *string  `json:"requestorID,omitempty"`
	OwnerID     *string  `json:"ownerID,omitempty"`
	EventIDs    []string `json:"eventIDs,omitempty"`
}

// CreateMappedControlInput is used for create MappedControl object.
// Input was generated by ent.
type CreateMappedControlInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the type of mapping between the two controls, e.g. subset, intersect, equal, superset
	MappingType *string `json:"mappingType,omitempty"`
	// description of how the two controls are related
	Relation      *string  `json:"relation,omitempty"`
	ControlIDs    []string `json:"controlIDs,omitempty"`
	SubcontrolIDs []string `json:"subcontrolIDs,omitempty"`
}

type CreateMemberWithProgramInput struct {
	Role   *enums.Role `json:"role,omitempty"`
	UserID string      `json:"userID"`
}

// CreateNarrativeInput is used for create Narrative object.
// Input was generated by ent.
type CreateNarrativeInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the narrative
	Name string `json:"name"`
	// the description of the narrative
	Description *string `json:"description,omitempty"`
	// text data for the narrative document
	Details         *string  `json:"details,omitempty"`
	OwnerID         *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs       []string `json:"editorIDs,omitempty"`
	ViewerIDs       []string `json:"viewerIDs,omitempty"`
	SatisfyIDs      []string `json:"satisfyIDs,omitempty"`
	ProgramIDs      []string `json:"programIDs,omitempty"`
}

// CreateNoteInput is used for create Note object.
// Input was generated by ent.
type CreateNoteInput struct {
	// the text of the note
	Text    string  `json:"text"`
	OwnerID *string `json:"ownerID,omitempty"`
	TaskID  *string `json:"taskID,omitempty"`
}

// CreateOnboardingInput is used for create Onboarding object.
// Input was generated by ent.
type CreateOnboardingInput struct {
	// name of the company
	CompanyName string `json:"companyName"`
	// domains associated with the company
	Domains []string `json:"domains,omitempty"`
	// details given about the company during the onboarding process, including things such as company size, sector, etc
	CompanyDetails map[string]any `json:"companyDetails,omitempty"`
	// details given about the user during the onboarding process, including things such as name, job title, department, etc
	UserDetails map[string]any `json:"userDetails,omitempty"`
	// details given about the compliance requirements during the onboarding process, such as coming with existing policies, controls, risk assessments, etc
	Compliance     map[string]any `json:"compliance,omitempty"`
	OrganizationID *string        `json:"organizationID,omitempty"`
}

// CreateOrgMembershipInput is used for create OrgMembership object.
// Input was generated by ent.
type CreateOrgMembershipInput struct {
	Role           *enums.Role `json:"role,omitempty"`
	OrganizationID string      `json:"organizationID"`
	UserID         string      `json:"userID"`
	EventIDs       []string    `json:"eventIDs,omitempty"`
}

// CreateOrganizationInput is used for create Organization object.
// Input was generated by ent.
type CreateOrganizationInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the organization
	Name string `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the organization
	Description *string `json:"description,omitempty"`
	// orgs directly associated with a user
	PersonalOrg *bool `json:"personalOrg,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// Whether the organization has a dedicated database
	DedicatedDb                *bool                           `json:"dedicatedDb,omitempty"`
	ControlCreatorIDs          []string                        `json:"controlCreatorIDs,omitempty"`
	ControlObjectiveCreatorIDs []string                        `json:"controlObjectiveCreatorIDs,omitempty"`
	GroupCreatorIDs            []string                        `json:"groupCreatorIDs,omitempty"`
	InternalPolicyCreatorIDs   []string                        `json:"internalPolicyCreatorIDs,omitempty"`
	NarrativeCreatorIDs        []string                        `json:"narrativeCreatorIDs,omitempty"`
	ProcedureCreatorIDs        []string                        `json:"procedureCreatorIDs,omitempty"`
	ProgramCreatorIDs          []string                        `json:"programCreatorIDs,omitempty"`
	RiskCreatorIDs             []string                        `json:"riskCreatorIDs,omitempty"`
	TemplateCreatorIDs         []string                        `json:"templateCreatorIDs,omitempty"`
	ParentID                   *string                         `json:"parentID,omitempty"`
	SettingID                  *string                         `json:"settingID,omitempty"`
	PersonalAccessTokenIDs     []string                        `json:"personalAccessTokenIDs,omitempty"`
	APITokenIDs                []string                        `json:"apiTokenIDs,omitempty"`
	FileIDs                    []string                        `json:"fileIDs,omitempty"`
	EventIDs                   []string                        `json:"eventIDs,omitempty"`
	SecretIDs                  []string                        `json:"secretIDs,omitempty"`
	AvatarFileID               *string                         `json:"avatarFileID,omitempty"`
	GroupIDs                   []string                        `json:"groupIDs,omitempty"`
	TemplateIDs                []string                        `json:"templateIDs,omitempty"`
	IntegrationIDs             []string                        `json:"integrationIDs,omitempty"`
	DocumentDatumIDs           []string                        `json:"documentDatumIDs,omitempty"`
	OrgSubscriptionIDs         []string                        `json:"orgSubscriptionIDs,omitempty"`
	InviteIDs                  []string                        `json:"inviteIDs,omitempty"`
	SubscriberIDs              []string                        `json:"subscriberIDs,omitempty"`
	EntityIDs                  []string                        `json:"entityIDs,omitempty"`
	EntityTypeIDs              []string                        `json:"entityTypeIDs,omitempty"`
	ContactIDs                 []string                        `json:"contactIDs,omitempty"`
	NoteIDs                    []string                        `json:"noteIDs,omitempty"`
	TaskIDs                    []string                        `json:"taskIDs,omitempty"`
	ProgramIDs                 []string                        `json:"programIDs,omitempty"`
	ProcedureIDs               []string                        `json:"procedureIDs,omitempty"`
	InternalPolicyIDs          []string                        `json:"internalPolicyIDs,omitempty"`
	RiskIDs                    []string                        `json:"riskIDs,omitempty"`
	ControlObjectiveIDs        []string                        `json:"controlObjectiveIDs,omitempty"`
	NarrativeIDs               []string                        `json:"narrativeIDs,omitempty"`
	ControlIDs                 []string                        `json:"controlIDs,omitempty"`
	SubcontrolIDs              []string                        `json:"subcontrolIDs,omitempty"`
	EvidenceIDs                []string                        `json:"evidenceIDs,omitempty"`
	StandardIDs                []string                        `json:"standardIDs,omitempty"`
	CreateOrgSettings          *CreateOrganizationSettingInput `json:"createOrgSettings,omitempty"`
}

// CreateOrganizationSettingInput is used for create OrganizationSetting object.
// Input was generated by ent.
type CreateOrganizationSettingInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// domains associated with the organization
	Domains []string `json:"domains,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone *string `json:"billingPhone,omitempty"`
	// the billing address to send billing information to
	BillingAddress *models.Address `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation *enums.Region `json:"geoLocation,omitempty"`
	// should we send email notifications related to billing
	BillingNotificationsEnabled *bool `json:"billingNotificationsEnabled,omitempty"`
	// domains allowed to access the organization, if empty all domains are allowed
	AllowedEmailDomains []string `json:"allowedEmailDomains,omitempty"`
	OrganizationID      *string  `json:"organizationID,omitempty"`
	FileIDs             []string `json:"fileIDs,omitempty"`
}

// CreatePersonalAccessTokenInput is used for create PersonalAccessToken object.
// Input was generated by ent.
type CreatePersonalAccessTokenInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name associated with the token
	Name string `json:"name"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string    `json:"description,omitempty"`
	Scopes      []string   `json:"scopes,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	// whether the token is active
	IsActive *bool `json:"isActive,omitempty"`
	// the reason the token was revoked
	RevokedReason *string `json:"revokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy *string `json:"revokedBy,omitempty"`
	// when the token was revoked
	RevokedAt       *time.Time `json:"revokedAt,omitempty"`
	OwnerID         string     `json:"ownerID"`
	OrganizationIDs []string   `json:"organizationIDs,omitempty"`
	EventIDs        []string   `json:"eventIDs,omitempty"`
}

// CreateProcedureInput is used for create Procedure object.
// Input was generated by ent.
type CreateProcedureInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the procedure
	Name string `json:"name"`
	// description of the procedure
	Description *string `json:"description,omitempty"`
	// status of the procedure
	Status *string `json:"status,omitempty"`
	// type of the procedure
	ProcedureType *string `json:"procedureType,omitempty"`
	// the date the procedure should be reviewed, defaults to a year from creation date
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// version of the procedure
	Version *string `json:"version,omitempty"`
	// purpose and scope
	PurposeAndScope *string `json:"purposeAndScope,omitempty"`
	// background of the procedure
	Background *string `json:"background,omitempty"`
	// which controls are satisfied by the procedure
	Satisfies *string `json:"satisfies,omitempty"`
	// json data for the procedure document
	Details           map[string]any `json:"details,omitempty"`
	OwnerID           *string        `json:"ownerID,omitempty"`
	BlockedGroupIDs   []string       `json:"blockedGroupIDs,omitempty"`
	EditorIDs         []string       `json:"editorIDs,omitempty"`
	ControlIDs        []string       `json:"controlIDs,omitempty"`
	InternalPolicyIDs []string       `json:"internalPolicyIDs,omitempty"`
	NarrativeIDs      []string       `json:"narrativeIDs,omitempty"`
	RiskIDs           []string       `json:"riskIDs,omitempty"`
	TaskIDs           []string       `json:"taskIDs,omitempty"`
	ProgramIDs        []string       `json:"programIDs,omitempty"`
}

// CreateProgramInput is used for create Program object.
// Input was generated by ent.
type CreateProgramInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the program
	Name string `json:"name"`
	// the description of the program
	Description *string `json:"description,omitempty"`
	// the status of the program
	Status *enums.ProgramStatus `json:"status,omitempty"`
	// the start date of the period
	StartDate *time.Time `json:"startDate,omitempty"`
	// the end date of the period
	EndDate *time.Time `json:"endDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady *bool `json:"auditorReady,omitempty"`
	// can the auditor write comments
	AuditorWriteComments *bool `json:"auditorWriteComments,omitempty"`
	// can the auditor read comments
	AuditorReadComments *bool    `json:"auditorReadComments,omitempty"`
	OwnerID             *string  `json:"ownerID,omitempty"`
	BlockedGroupIDs     []string `json:"blockedGroupIDs,omitempty"`
	EditorIDs           []string `json:"editorIDs,omitempty"`
	ViewerIDs           []string `json:"viewerIDs,omitempty"`
	ControlIDs          []string `json:"controlIDs,omitempty"`
	SubcontrolIDs       []string `json:"subcontrolIDs,omitempty"`
	ControlObjectiveIDs []string `json:"controlObjectiveIDs,omitempty"`
	InternalPolicyIDs   []string `json:"internalPolicyIDs,omitempty"`
	ProcedureIDs        []string `json:"procedureIDs,omitempty"`
	RiskIDs             []string `json:"riskIDs,omitempty"`
	TaskIDs             []string `json:"taskIDs,omitempty"`
	NoteIDs             []string `json:"noteIDs,omitempty"`
	FileIDs             []string `json:"fileIDs,omitempty"`
	EvidenceIDs         []string `json:"evidenceIDs,omitempty"`
	NarrativeIDs        []string `json:"narrativeIDs,omitempty"`
	ActionPlanIDs       []string `json:"actionPlanIDs,omitempty"`
}

// CreateProgramMembershipInput is used for create ProgramMembership object.
// Input was generated by ent.
type CreateProgramMembershipInput struct {
	Role      *enums.Role `json:"role,omitempty"`
	ProgramID string      `json:"programID"`
	UserID    string      `json:"userID"`
}

type CreateProgramWithMembersInput struct {
	Program *CreateProgramInput             `json:"program"`
	Members []*CreateMemberWithProgramInput `json:"members,omitempty"`
}

// CreateRiskInput is used for create Risk object.
// Input was generated by ent.
type CreateRiskInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the risk
	Name string `json:"name"`
	// description of the risk
	Description *string `json:"description,omitempty"`
	// status of the risk - mitigated or not, inflight, etc.
	Status *string `json:"status,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType *string `json:"riskType,omitempty"`
	// business costs associated with the risk
	BusinessCosts *string `json:"businessCosts,omitempty"`
	// impact of the risk - high, medium, low
	Impact *enums.RiskImpact `json:"impact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood *enums.RiskLikelihood `json:"likelihood,omitempty"`
	// mitigation for the risk
	Mitigation *string `json:"mitigation,omitempty"`
	// which controls are satisfied by the risk
	Satisfies *string `json:"satisfies,omitempty"`
	// json data for the risk document
	Details         map[string]any `json:"details,omitempty"`
	OwnerID         *string        `json:"ownerID,omitempty"`
	BlockedGroupIDs []string       `json:"blockedGroupIDs,omitempty"`
	EditorIDs       []string       `json:"editorIDs,omitempty"`
	ViewerIDs       []string       `json:"viewerIDs,omitempty"`
	ControlIDs      []string       `json:"controlIDs,omitempty"`
	ProcedureIDs    []string       `json:"procedureIDs,omitempty"`
	ActionPlanIDs   []string       `json:"actionPlanIDs,omitempty"`
	ProgramIDs      []string       `json:"programIDs,omitempty"`
}

// CreateStandardInput is used for create Standard object.
// Input was generated by ent.
type CreateStandardInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the long name of the standard body
	Name string `json:"name"`
	// short name of the standard, e.g. SOC 2, ISO 27001, etc.
	ShortName *string `json:"shortName,omitempty"`
	// unique identifier of the standard with version
	Framework *string `json:"framework,omitempty"`
	// description of the standard
	Description *string `json:"description,omitempty"`
	// governing body of the standard, e.g. AICPA, etc.
	GoverningBody *string `json:"governingBody,omitempty"`
	// domains the standard covers, e.g. availability, confidentiality, etc.
	Domains []string `json:"domains,omitempty"`
	// link to the official standard documentation
	Link *string `json:"link,omitempty"`
	// status of the standard - active, deprecated, etc.
	Status *string `json:"status,omitempty"`
	// indicates if the standard should be made available to all users, only for public standards
	IsPublic *bool `json:"isPublic,omitempty"`
	// indicates if the standard is freely distributable under a trial license, only for public standards
	FreeToUse *bool `json:"freeToUse,omitempty"`
	// indicates if the standard is owned by the the openlane system
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// type of the standard - security, privacy, etc.
	StandardType *string `json:"standardType,omitempty"`
	// version of the standard
	Version *string `json:"version,omitempty"`
	// internal revision of the standard
	Revision   *string  `json:"revision,omitempty"`
	OwnerID    *string  `json:"ownerID,omitempty"`
	ControlIDs []string `json:"controlIDs,omitempty"`
}

// CreateSubcontrolInput is used for create Subcontrol object.
// Input was generated by ent.
type CreateSubcontrolInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// status of the control
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the unique reference code for the control
	RefCode             string   `json:"refCode"`
	OwnerID             *string  `json:"ownerID,omitempty"`
	ControlID           string   `json:"controlID"`
	MappedControlIDs    []string `json:"mappedControlIDs,omitempty"`
	EvidenceIDs         []string `json:"evidenceIDs,omitempty"`
	ControlObjectiveIDs []string `json:"controlObjectiveIDs,omitempty"`
	TaskIDs             []string `json:"taskIDs,omitempty"`
	NarrativeIDs        []string `json:"narrativeIDs,omitempty"`
	RiskIDs             []string `json:"riskIDs,omitempty"`
	ActionPlanIDs       []string `json:"actionPlanIDs,omitempty"`
	ProcedureIDs        []string `json:"procedureIDs,omitempty"`
	InternalPolicyIDs   []string `json:"internalPolicyIDs,omitempty"`
	ControlOwnerID      *string  `json:"controlOwnerID,omitempty"`
	DelegateID          *string  `json:"delegateID,omitempty"`
}

// CreateSubscriberInput is used for create Subscriber object.
// Input was generated by ent.
type CreateSubscriberInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// email address of the subscriber
	Email string `json:"email"`
	// phone number of the subscriber
	PhoneNumber *string  `json:"phoneNumber,omitempty"`
	OwnerID     *string  `json:"ownerID,omitempty"`
	EventIDs    []string `json:"eventIDs,omitempty"`
}

// CreateTFASettingInput is used for create TFASetting object.
// Input was generated by ent.
type CreateTFASettingInput struct {
	// specifies a user may complete authentication by verifying a TOTP code delivered through an authenticator app
	TotpAllowed *bool   `json:"totpAllowed,omitempty"`
	OwnerID     *string `json:"ownerID,omitempty"`
}

// CreateTaskInput is used for create Task object.
// Input was generated by ent.
type CreateTaskInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the title of the task
	Title string `json:"title"`
	// the description of the task
	Description *string `json:"description,omitempty"`
	// the details of the task
	Details *string `json:"details,omitempty"`
	// the status of the task
	Status *enums.TaskStatus `json:"status,omitempty"`
	// the category of the task, e.g. evidence upload, risk review, policy review, etc.
	Category *string `json:"category,omitempty"`
	// the due date of the task
	Due *time.Time `json:"due,omitempty"`
	// the completion date of the task
	Completed           *time.Time `json:"completed,omitempty"`
	OwnerID             *string    `json:"ownerID,omitempty"`
	AssignerID          *string    `json:"assignerID,omitempty"`
	AssigneeID          *string    `json:"assigneeID,omitempty"`
	CommentIDs          []string   `json:"commentIDs,omitempty"`
	GroupIDs            []string   `json:"groupIDs,omitempty"`
	InternalPolicyIDs   []string   `json:"internalPolicyIDs,omitempty"`
	ProcedureIDs        []string   `json:"procedureIDs,omitempty"`
	ControlIDs          []string   `json:"controlIDs,omitempty"`
	ControlObjectiveIDs []string   `json:"controlObjectiveIDs,omitempty"`
	SubcontrolIDs       []string   `json:"subcontrolIDs,omitempty"`
	ProgramIDs          []string   `json:"programIDs,omitempty"`
	EvidenceIDs         []string   `json:"evidenceIDs,omitempty"`
}

// CreateTemplateInput is used for create Template object.
// Input was generated by ent.
type CreateTemplateInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the template
	Name string `json:"name"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType *enums.DocumentType `json:"templateType,omitempty"`
	// the description of the template
	Description *string `json:"description,omitempty"`
	// the jsonschema object of the template
	Jsonconfig map[string]any `json:"jsonconfig"`
	// the uischema for the template to render in the UI
	Uischema    map[string]any `json:"uischema,omitempty"`
	OwnerID     *string        `json:"ownerID,omitempty"`
	DocumentIDs []string       `json:"documentIDs,omitempty"`
	FileIDs     []string       `json:"fileIDs,omitempty"`
}

// CreateUserInput is used for create User object.
// Input was generated by ent.
type CreateUserInput struct {
	// tags associated with the object
	Tags      []string `json:"tags,omitempty"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName,omitempty"`
	LastName  *string  `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// user password hash
	Password *string `json:"password,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// auth provider used to register the account
	AuthProvider *enums.AuthProvider `json:"authProvider,omitempty"`
	// the user's role
	Role                      *enums.Role `json:"role,omitempty"`
	PersonalAccessTokenIDs    []string    `json:"personalAccessTokenIDs,omitempty"`
	TfaSettingIDs             []string    `json:"tfaSettingIDs,omitempty"`
	SettingID                 string      `json:"settingID"`
	EmailVerificationTokenIDs []string    `json:"emailVerificationTokenIDs,omitempty"`
	PasswordResetTokenIDs     []string    `json:"passwordResetTokenIDs,omitempty"`
	GroupIDs                  []string    `json:"groupIDs,omitempty"`
	OrganizationIDs           []string    `json:"organizationIDs,omitempty"`
	WebauthnIDs               []string    `json:"webauthnIDs,omitempty"`
	FileIDs                   []string    `json:"fileIDs,omitempty"`
	AvatarFileID              *string     `json:"avatarFileID,omitempty"`
	EventIDs                  []string    `json:"eventIDs,omitempty"`
	ActionPlanIDs             []string    `json:"actionPlanIDs,omitempty"`
	SubcontrolIDs             []string    `json:"subcontrolIDs,omitempty"`
	AssignerTaskIDs           []string    `json:"assignerTaskIDs,omitempty"`
	AssigneeTaskIDs           []string    `json:"assigneeTaskIDs,omitempty"`
	ProgramIDs                []string    `json:"programIDs,omitempty"`
}

// CreateUserSettingInput is used for create UserSetting object.
// Input was generated by ent.
type CreateUserSettingInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// status of the user account
	Status *enums.UserStatus `json:"status,omitempty"`
	// whether the user has confirmed their email address
	EmailConfirmed *bool `json:"emailConfirmed,omitempty"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed *bool `json:"isWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled *bool    `json:"isTfaEnabled,omitempty"`
	UserID       *string  `json:"userID,omitempty"`
	DefaultOrgID *string  `json:"defaultOrgID,omitempty"`
	FileIDs      []string `json:"fileIDs,omitempty"`
}

type DocumentData struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the template id of the document
	TemplateID string `json:"templateID"`
	// the json data of the document
	Data     map[string]any `json:"data"`
	Owner    *Organization  `json:"owner,omitempty"`
	Template *Template      `json:"template"`
	Entity   []*Entity      `json:"entity,omitempty"`
	Files    []*File        `json:"files,omitempty"`
}

func (DocumentData) IsNode() {}

// Return response for createBulkDocumentData mutation
type DocumentDataBulkCreatePayload struct {
	// Created documentData
	DocumentData []*DocumentData `json:"documentData,omitempty"`
}

// A connection to a list of items.
type DocumentDataConnection struct {
	// A list of edges.
	Edges []*DocumentDataEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createDocumentData mutation
type DocumentDataCreatePayload struct {
	// Created documentData
	DocumentData *DocumentData `json:"documentData"`
}

// Return response for deleteDocumentData mutation
type DocumentDataDeletePayload struct {
	// Deleted documentData ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type DocumentDataEdge struct {
	// The item at the end of the edge.
	Node *DocumentData `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type DocumentDataHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the template id of the document
	TemplateID string `json:"templateID"`
	// the json data of the document
	Data map[string]any `json:"data"`
}

func (DocumentDataHistory) IsNode() {}

// A connection to a list of items.
type DocumentDataHistoryConnection struct {
	// A list of edges.
	Edges []*DocumentDataHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type DocumentDataHistoryEdge struct {
	// The item at the end of the edge.
	Node *DocumentDataHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// DocumentDataHistoryWhereInput is used for filtering DocumentDataHistory objects.
// Input was generated by ent.
type DocumentDataHistoryWhereInput struct {
	Not *DocumentDataHistoryWhereInput   `json:"not,omitempty"`
	And []*DocumentDataHistoryWhereInput `json:"and,omitempty"`
	Or  []*DocumentDataHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// template_id field predicates
	TemplateID             *string  `json:"templateID,omitempty"`
	TemplateIdneq          *string  `json:"templateIDNEQ,omitempty"`
	TemplateIDIn           []string `json:"templateIDIn,omitempty"`
	TemplateIDNotIn        []string `json:"templateIDNotIn,omitempty"`
	TemplateIdgt           *string  `json:"templateIDGT,omitempty"`
	TemplateIdgte          *string  `json:"templateIDGTE,omitempty"`
	TemplateIdlt           *string  `json:"templateIDLT,omitempty"`
	TemplateIdlte          *string  `json:"templateIDLTE,omitempty"`
	TemplateIDContains     *string  `json:"templateIDContains,omitempty"`
	TemplateIDHasPrefix    *string  `json:"templateIDHasPrefix,omitempty"`
	TemplateIDHasSuffix    *string  `json:"templateIDHasSuffix,omitempty"`
	TemplateIDEqualFold    *string  `json:"templateIDEqualFold,omitempty"`
	TemplateIDContainsFold *string  `json:"templateIDContainsFold,omitempty"`
}

type DocumentDataSearchResult struct {
	DocumentData []*DocumentData `json:"documentData,omitempty"`
}

func (DocumentDataSearchResult) IsSearchResult() {}

// Return response for updateDocumentData mutation
type DocumentDataUpdatePayload struct {
	// Updated documentData
	DocumentData *DocumentData `json:"documentData"`
}

// DocumentDataWhereInput is used for filtering DocumentData objects.
// Input was generated by ent.
type DocumentDataWhereInput struct {
	Not *DocumentDataWhereInput   `json:"not,omitempty"`
	And []*DocumentDataWhereInput `json:"and,omitempty"`
	Or  []*DocumentDataWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// template_id field predicates
	TemplateID             *string  `json:"templateID,omitempty"`
	TemplateIdneq          *string  `json:"templateIDNEQ,omitempty"`
	TemplateIDIn           []string `json:"templateIDIn,omitempty"`
	TemplateIDNotIn        []string `json:"templateIDNotIn,omitempty"`
	TemplateIdgt           *string  `json:"templateIDGT,omitempty"`
	TemplateIdgte          *string  `json:"templateIDGTE,omitempty"`
	TemplateIdlt           *string  `json:"templateIDLT,omitempty"`
	TemplateIdlte          *string  `json:"templateIDLTE,omitempty"`
	TemplateIDContains     *string  `json:"templateIDContains,omitempty"`
	TemplateIDHasPrefix    *string  `json:"templateIDHasPrefix,omitempty"`
	TemplateIDHasSuffix    *string  `json:"templateIDHasSuffix,omitempty"`
	TemplateIDEqualFold    *string  `json:"templateIDEqualFold,omitempty"`
	TemplateIDContainsFold *string  `json:"templateIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// template edge predicates
	HasTemplate     *bool                 `json:"hasTemplate,omitempty"`
	HasTemplateWith []*TemplateWhereInput `json:"hasTemplateWith,omitempty"`
	// entity edge predicates
	HasEntity     *bool               `json:"hasEntity,omitempty"`
	HasEntityWith []*EntityWhereInput `json:"hasEntityWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

type Entity struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name *string `json:"name,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the entity
	Description *string `json:"description,omitempty"`
	// domains associated with the entity
	Domains []string `json:"domains,omitempty"`
	// The type of the entity
	EntityTypeID *string `json:"entityTypeID,omitempty"`
	// status of the entity
	Status     *string         `json:"status,omitempty"`
	Owner      *Organization   `json:"owner,omitempty"`
	Contacts   []*Contact      `json:"contacts,omitempty"`
	Documents  []*DocumentData `json:"documents,omitempty"`
	Notes      []*Note         `json:"notes,omitempty"`
	Files      []*File         `json:"files,omitempty"`
	EntityType *EntityType     `json:"entityType,omitempty"`
}

func (Entity) IsNode() {}

// Return response for createBulkEntity mutation
type EntityBulkCreatePayload struct {
	// Created entities
	Entities []*Entity `json:"entities,omitempty"`
}

// A connection to a list of items.
type EntityConnection struct {
	// A list of edges.
	Edges []*EntityEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntity mutation
type EntityCreatePayload struct {
	// Created entity
	Entity *Entity `json:"entity"`
}

// Return response for deleteEntity mutation
type EntityDeletePayload struct {
	// Deleted entity ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntityEdge struct {
	// The item at the end of the edge.
	Node *Entity `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntityHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name *string `json:"name,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the entity
	Description *string `json:"description,omitempty"`
	// domains associated with the entity
	Domains []string `json:"domains,omitempty"`
	// The type of the entity
	EntityTypeID *string `json:"entityTypeID,omitempty"`
	// status of the entity
	Status *string `json:"status,omitempty"`
}

func (EntityHistory) IsNode() {}

// A connection to a list of items.
type EntityHistoryConnection struct {
	// A list of edges.
	Edges []*EntityHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntityHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntityHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for EntityHistory connections
type EntityHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EntityHistories.
	Field EntityHistoryOrderField `json:"field"`
}

// EntityHistoryWhereInput is used for filtering EntityHistory objects.
// Input was generated by ent.
type EntityHistoryWhereInput struct {
	Not *EntityHistoryWhereInput   `json:"not,omitempty"`
	And []*EntityHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntityHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        *bool    `json:"nameIsNil,omitempty"`
	NameNotNil       *bool    `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// entity_type_id field predicates
	EntityTypeID             *string  `json:"entityTypeID,omitempty"`
	EntityTypeIdneq          *string  `json:"entityTypeIDNEQ,omitempty"`
	EntityTypeIDIn           []string `json:"entityTypeIDIn,omitempty"`
	EntityTypeIDNotIn        []string `json:"entityTypeIDNotIn,omitempty"`
	EntityTypeIdgt           *string  `json:"entityTypeIDGT,omitempty"`
	EntityTypeIdgte          *string  `json:"entityTypeIDGTE,omitempty"`
	EntityTypeIdlt           *string  `json:"entityTypeIDLT,omitempty"`
	EntityTypeIdlte          *string  `json:"entityTypeIDLTE,omitempty"`
	EntityTypeIDContains     *string  `json:"entityTypeIDContains,omitempty"`
	EntityTypeIDHasPrefix    *string  `json:"entityTypeIDHasPrefix,omitempty"`
	EntityTypeIDHasSuffix    *string  `json:"entityTypeIDHasSuffix,omitempty"`
	EntityTypeIDIsNil        *bool    `json:"entityTypeIDIsNil,omitempty"`
	EntityTypeIDNotNil       *bool    `json:"entityTypeIDNotNil,omitempty"`
	EntityTypeIDEqualFold    *string  `json:"entityTypeIDEqualFold,omitempty"`
	EntityTypeIDContainsFold *string  `json:"entityTypeIDContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
}

// Ordering options for Entity connections
type EntityOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Entities.
	Field EntityOrderField `json:"field"`
}

type EntitySearchResult struct {
	Entities []*Entity `json:"entities,omitempty"`
}

func (EntitySearchResult) IsSearchResult() {}

type EntityType struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name     string        `json:"name"`
	Owner    *Organization `json:"owner,omitempty"`
	Entities []*Entity     `json:"entities,omitempty"`
}

func (EntityType) IsNode() {}

// Return response for createBulkEntityType mutation
type EntityTypeBulkCreatePayload struct {
	// Created entityTypes
	EntityTypes []*EntityType `json:"entityTypes,omitempty"`
}

// A connection to a list of items.
type EntityTypeConnection struct {
	// A list of edges.
	Edges []*EntityTypeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntityType mutation
type EntityTypeCreatePayload struct {
	// Created entityType
	EntityType *EntityType `json:"entityType"`
}

// Return response for deleteEntityType mutation
type EntityTypeDeletePayload struct {
	// Deleted entityType ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntityTypeEdge struct {
	// The item at the end of the edge.
	Node *EntityType `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntityTypeHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name string `json:"name"`
}

func (EntityTypeHistory) IsNode() {}

// A connection to a list of items.
type EntityTypeHistoryConnection struct {
	// A list of edges.
	Edges []*EntityTypeHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntityTypeHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntityTypeHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for EntityTypeHistory connections
type EntityTypeHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EntityTypeHistories.
	Field EntityTypeHistoryOrderField `json:"field"`
}

// EntityTypeHistoryWhereInput is used for filtering EntityTypeHistory objects.
// Input was generated by ent.
type EntityTypeHistoryWhereInput struct {
	Not *EntityTypeHistoryWhereInput   `json:"not,omitempty"`
	And []*EntityTypeHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntityTypeHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// Ordering options for EntityType connections
type EntityTypeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EntityTypes.
	Field EntityTypeOrderField `json:"field"`
}

type EntityTypeSearchResult struct {
	EntityTypes []*EntityType `json:"entityTypes,omitempty"`
}

func (EntityTypeSearchResult) IsSearchResult() {}

// Return response for updateEntityType mutation
type EntityTypeUpdatePayload struct {
	// Updated entityType
	EntityType *EntityType `json:"entityType"`
}

// EntityTypeWhereInput is used for filtering EntityType objects.
// Input was generated by ent.
type EntityTypeWhereInput struct {
	Not *EntityTypeWhereInput   `json:"not,omitempty"`
	And []*EntityTypeWhereInput `json:"and,omitempty"`
	Or  []*EntityTypeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
}

// Return response for updateEntity mutation
type EntityUpdatePayload struct {
	// Updated entity
	Entity *Entity `json:"entity"`
}

// EntityWhereInput is used for filtering Entity objects.
// Input was generated by ent.
type EntityWhereInput struct {
	Not *EntityWhereInput   `json:"not,omitempty"`
	And []*EntityWhereInput `json:"and,omitempty"`
	Or  []*EntityWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        *bool    `json:"nameIsNil,omitempty"`
	NameNotNil       *bool    `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// entity_type_id field predicates
	EntityTypeID             *string  `json:"entityTypeID,omitempty"`
	EntityTypeIdneq          *string  `json:"entityTypeIDNEQ,omitempty"`
	EntityTypeIDIn           []string `json:"entityTypeIDIn,omitempty"`
	EntityTypeIDNotIn        []string `json:"entityTypeIDNotIn,omitempty"`
	EntityTypeIdgt           *string  `json:"entityTypeIDGT,omitempty"`
	EntityTypeIdgte          *string  `json:"entityTypeIDGTE,omitempty"`
	EntityTypeIdlt           *string  `json:"entityTypeIDLT,omitempty"`
	EntityTypeIdlte          *string  `json:"entityTypeIDLTE,omitempty"`
	EntityTypeIDContains     *string  `json:"entityTypeIDContains,omitempty"`
	EntityTypeIDHasPrefix    *string  `json:"entityTypeIDHasPrefix,omitempty"`
	EntityTypeIDHasSuffix    *string  `json:"entityTypeIDHasSuffix,omitempty"`
	EntityTypeIDIsNil        *bool    `json:"entityTypeIDIsNil,omitempty"`
	EntityTypeIDNotNil       *bool    `json:"entityTypeIDNotNil,omitempty"`
	EntityTypeIDEqualFold    *string  `json:"entityTypeIDEqualFold,omitempty"`
	EntityTypeIDContainsFold *string  `json:"entityTypeIDContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// contacts edge predicates
	HasContacts     *bool                `json:"hasContacts,omitempty"`
	HasContactsWith []*ContactWhereInput `json:"hasContactsWith,omitempty"`
	// documents edge predicates
	HasDocuments     *bool                     `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentDataWhereInput `json:"hasDocumentsWith,omitempty"`
	// notes edge predicates
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// entity_type edge predicates
	HasEntityType     *bool                   `json:"hasEntityType,omitempty"`
	HasEntityTypeWith []*EntityTypeWhereInput `json:"hasEntityTypeWith,omitempty"`
}

type Event struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the unique identifier of the event as it relates to the source or outside system
	EventID string `json:"eventID"`
	// an identifier to correleate the event to another object or source, if needed
	CorrelationID *string `json:"correlationID,omitempty"`
	// the type of event
	EventType *string `json:"eventType,omitempty"`
	// event metadata
	Metadata map[string]any `json:"metadata,omitempty"`
	// the source of the event
	Source *string `json:"source,omitempty"`
	// indicates if additional processing is required for the event
	AdditionalProcessingRequired *bool `json:"additionalProcessingRequired,omitempty"`
	// details about the additional processing required
	AdditionalProcessingDetails *string `json:"additionalProcessingDetails,omitempty"`
	// the listener ID who processed the event
	ProcessedBy *string `json:"processedBy,omitempty"`
	// the time the event was processed
	ProcessedAt         *time.Time             `json:"processedAt,omitempty"`
	User                []*User                `json:"user,omitempty"`
	Group               []*Group               `json:"group,omitempty"`
	Integration         []*Integration         `json:"integration,omitempty"`
	Organization        []*Organization        `json:"organization,omitempty"`
	Invite              []*Invite              `json:"invite,omitempty"`
	PersonalAccessToken []*PersonalAccessToken `json:"personalAccessToken,omitempty"`
	Hush                []*Hush                `json:"hush,omitempty"`
	Orgmembership       []*OrgMembership       `json:"orgmembership,omitempty"`
	Groupmembership     []*GroupMembership     `json:"groupmembership,omitempty"`
	Subscriber          []*Subscriber          `json:"subscriber,omitempty"`
	File                []*File                `json:"file,omitempty"`
	Orgsubscription     []*OrgSubscription     `json:"orgsubscription,omitempty"`
}

func (Event) IsNode() {}

// Return response for createBulkEvent mutation
type EventBulkCreatePayload struct {
	// Created events
	Events []*Event `json:"events,omitempty"`
}

// A connection to a list of items.
type EventConnection struct {
	// A list of edges.
	Edges []*EventEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEvent mutation
type EventCreatePayload struct {
	// Created event
	Event *Event `json:"event"`
}

// Return response for deleteEvent mutation
type EventDeletePayload struct {
	// Deleted event ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EventEdge struct {
	// The item at the end of the edge.
	Node *Event `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EventHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the unique identifier of the event as it relates to the source or outside system
	EventID string `json:"eventID"`
	// an identifier to correleate the event to another object or source, if needed
	CorrelationID *string `json:"correlationID,omitempty"`
	// the type of event
	EventType *string `json:"eventType,omitempty"`
	// event metadata
	Metadata map[string]any `json:"metadata,omitempty"`
	// the source of the event
	Source *string `json:"source,omitempty"`
	// indicates if additional processing is required for the event
	AdditionalProcessingRequired *bool `json:"additionalProcessingRequired,omitempty"`
	// details about the additional processing required
	AdditionalProcessingDetails *string `json:"additionalProcessingDetails,omitempty"`
	// the listener ID who processed the event
	ProcessedBy *string `json:"processedBy,omitempty"`
	// the time the event was processed
	ProcessedAt *time.Time `json:"processedAt,omitempty"`
}

func (EventHistory) IsNode() {}

// A connection to a list of items.
type EventHistoryConnection struct {
	// A list of edges.
	Edges []*EventHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EventHistoryEdge struct {
	// The item at the end of the edge.
	Node *EventHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// EventHistoryWhereInput is used for filtering EventHistory objects.
// Input was generated by ent.
type EventHistoryWhereInput struct {
	Not *EventHistoryWhereInput   `json:"not,omitempty"`
	And []*EventHistoryWhereInput `json:"and,omitempty"`
	Or  []*EventHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// event_id field predicates
	EventID             *string  `json:"eventID,omitempty"`
	EventIdneq          *string  `json:"eventIDNEQ,omitempty"`
	EventIDIn           []string `json:"eventIDIn,omitempty"`
	EventIDNotIn        []string `json:"eventIDNotIn,omitempty"`
	EventIdgt           *string  `json:"eventIDGT,omitempty"`
	EventIdgte          *string  `json:"eventIDGTE,omitempty"`
	EventIdlt           *string  `json:"eventIDLT,omitempty"`
	EventIdlte          *string  `json:"eventIDLTE,omitempty"`
	EventIDContains     *string  `json:"eventIDContains,omitempty"`
	EventIDHasPrefix    *string  `json:"eventIDHasPrefix,omitempty"`
	EventIDHasSuffix    *string  `json:"eventIDHasSuffix,omitempty"`
	EventIDEqualFold    *string  `json:"eventIDEqualFold,omitempty"`
	EventIDContainsFold *string  `json:"eventIDContainsFold,omitempty"`
	// correlation_id field predicates
	CorrelationID             *string  `json:"correlationID,omitempty"`
	CorrelationIdneq          *string  `json:"correlationIDNEQ,omitempty"`
	CorrelationIDIn           []string `json:"correlationIDIn,omitempty"`
	CorrelationIDNotIn        []string `json:"correlationIDNotIn,omitempty"`
	CorrelationIdgt           *string  `json:"correlationIDGT,omitempty"`
	CorrelationIdgte          *string  `json:"correlationIDGTE,omitempty"`
	CorrelationIdlt           *string  `json:"correlationIDLT,omitempty"`
	CorrelationIdlte          *string  `json:"correlationIDLTE,omitempty"`
	CorrelationIDContains     *string  `json:"correlationIDContains,omitempty"`
	CorrelationIDHasPrefix    *string  `json:"correlationIDHasPrefix,omitempty"`
	CorrelationIDHasSuffix    *string  `json:"correlationIDHasSuffix,omitempty"`
	CorrelationIDIsNil        *bool    `json:"correlationIDIsNil,omitempty"`
	CorrelationIDNotNil       *bool    `json:"correlationIDNotNil,omitempty"`
	CorrelationIDEqualFold    *string  `json:"correlationIDEqualFold,omitempty"`
	CorrelationIDContainsFold *string  `json:"correlationIDContainsFold,omitempty"`
	// event_type field predicates
	EventType             *string  `json:"eventType,omitempty"`
	EventTypeNeq          *string  `json:"eventTypeNEQ,omitempty"`
	EventTypeIn           []string `json:"eventTypeIn,omitempty"`
	EventTypeNotIn        []string `json:"eventTypeNotIn,omitempty"`
	EventTypeGt           *string  `json:"eventTypeGT,omitempty"`
	EventTypeGte          *string  `json:"eventTypeGTE,omitempty"`
	EventTypeLt           *string  `json:"eventTypeLT,omitempty"`
	EventTypeLte          *string  `json:"eventTypeLTE,omitempty"`
	EventTypeContains     *string  `json:"eventTypeContains,omitempty"`
	EventTypeHasPrefix    *string  `json:"eventTypeHasPrefix,omitempty"`
	EventTypeHasSuffix    *string  `json:"eventTypeHasSuffix,omitempty"`
	EventTypeIsNil        *bool    `json:"eventTypeIsNil,omitempty"`
	EventTypeNotNil       *bool    `json:"eventTypeNotNil,omitempty"`
	EventTypeEqualFold    *string  `json:"eventTypeEqualFold,omitempty"`
	EventTypeContainsFold *string  `json:"eventTypeContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// additional_processing_required field predicates
	AdditionalProcessingRequired       *bool `json:"additionalProcessingRequired,omitempty"`
	AdditionalProcessingRequiredNeq    *bool `json:"additionalProcessingRequiredNEQ,omitempty"`
	AdditionalProcessingRequiredIsNil  *bool `json:"additionalProcessingRequiredIsNil,omitempty"`
	AdditionalProcessingRequiredNotNil *bool `json:"additionalProcessingRequiredNotNil,omitempty"`
	// additional_processing_details field predicates
	AdditionalProcessingDetails             *string  `json:"additionalProcessingDetails,omitempty"`
	AdditionalProcessingDetailsNeq          *string  `json:"additionalProcessingDetailsNEQ,omitempty"`
	AdditionalProcessingDetailsIn           []string `json:"additionalProcessingDetailsIn,omitempty"`
	AdditionalProcessingDetailsNotIn        []string `json:"additionalProcessingDetailsNotIn,omitempty"`
	AdditionalProcessingDetailsGt           *string  `json:"additionalProcessingDetailsGT,omitempty"`
	AdditionalProcessingDetailsGte          *string  `json:"additionalProcessingDetailsGTE,omitempty"`
	AdditionalProcessingDetailsLt           *string  `json:"additionalProcessingDetailsLT,omitempty"`
	AdditionalProcessingDetailsLte          *string  `json:"additionalProcessingDetailsLTE,omitempty"`
	AdditionalProcessingDetailsContains     *string  `json:"additionalProcessingDetailsContains,omitempty"`
	AdditionalProcessingDetailsHasPrefix    *string  `json:"additionalProcessingDetailsHasPrefix,omitempty"`
	AdditionalProcessingDetailsHasSuffix    *string  `json:"additionalProcessingDetailsHasSuffix,omitempty"`
	AdditionalProcessingDetailsIsNil        *bool    `json:"additionalProcessingDetailsIsNil,omitempty"`
	AdditionalProcessingDetailsNotNil       *bool    `json:"additionalProcessingDetailsNotNil,omitempty"`
	AdditionalProcessingDetailsEqualFold    *string  `json:"additionalProcessingDetailsEqualFold,omitempty"`
	AdditionalProcessingDetailsContainsFold *string  `json:"additionalProcessingDetailsContainsFold,omitempty"`
	// processed_by field predicates
	ProcessedBy             *string  `json:"processedBy,omitempty"`
	ProcessedByNeq          *string  `json:"processedByNEQ,omitempty"`
	ProcessedByIn           []string `json:"processedByIn,omitempty"`
	ProcessedByNotIn        []string `json:"processedByNotIn,omitempty"`
	ProcessedByGt           *string  `json:"processedByGT,omitempty"`
	ProcessedByGte          *string  `json:"processedByGTE,omitempty"`
	ProcessedByLt           *string  `json:"processedByLT,omitempty"`
	ProcessedByLte          *string  `json:"processedByLTE,omitempty"`
	ProcessedByContains     *string  `json:"processedByContains,omitempty"`
	ProcessedByHasPrefix    *string  `json:"processedByHasPrefix,omitempty"`
	ProcessedByHasSuffix    *string  `json:"processedByHasSuffix,omitempty"`
	ProcessedByIsNil        *bool    `json:"processedByIsNil,omitempty"`
	ProcessedByNotNil       *bool    `json:"processedByNotNil,omitempty"`
	ProcessedByEqualFold    *string  `json:"processedByEqualFold,omitempty"`
	ProcessedByContainsFold *string  `json:"processedByContainsFold,omitempty"`
	// processed_at field predicates
	ProcessedAt       *time.Time   `json:"processedAt,omitempty"`
	ProcessedAtNeq    *time.Time   `json:"processedAtNEQ,omitempty"`
	ProcessedAtIn     []*time.Time `json:"processedAtIn,omitempty"`
	ProcessedAtNotIn  []*time.Time `json:"processedAtNotIn,omitempty"`
	ProcessedAtGt     *time.Time   `json:"processedAtGT,omitempty"`
	ProcessedAtGte    *time.Time   `json:"processedAtGTE,omitempty"`
	ProcessedAtLt     *time.Time   `json:"processedAtLT,omitempty"`
	ProcessedAtLte    *time.Time   `json:"processedAtLTE,omitempty"`
	ProcessedAtIsNil  *bool        `json:"processedAtIsNil,omitempty"`
	ProcessedAtNotNil *bool        `json:"processedAtNotNil,omitempty"`
}

type EventSearchResult struct {
	Events []*Event `json:"events,omitempty"`
}

func (EventSearchResult) IsSearchResult() {}

// Return response for updateEvent mutation
type EventUpdatePayload struct {
	// Updated event
	Event *Event `json:"event"`
}

// EventWhereInput is used for filtering Event objects.
// Input was generated by ent.
type EventWhereInput struct {
	Not *EventWhereInput   `json:"not,omitempty"`
	And []*EventWhereInput `json:"and,omitempty"`
	Or  []*EventWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// event_id field predicates
	EventID             *string  `json:"eventID,omitempty"`
	EventIdneq          *string  `json:"eventIDNEQ,omitempty"`
	EventIDIn           []string `json:"eventIDIn,omitempty"`
	EventIDNotIn        []string `json:"eventIDNotIn,omitempty"`
	EventIdgt           *string  `json:"eventIDGT,omitempty"`
	EventIdgte          *string  `json:"eventIDGTE,omitempty"`
	EventIdlt           *string  `json:"eventIDLT,omitempty"`
	EventIdlte          *string  `json:"eventIDLTE,omitempty"`
	EventIDContains     *string  `json:"eventIDContains,omitempty"`
	EventIDHasPrefix    *string  `json:"eventIDHasPrefix,omitempty"`
	EventIDHasSuffix    *string  `json:"eventIDHasSuffix,omitempty"`
	EventIDEqualFold    *string  `json:"eventIDEqualFold,omitempty"`
	EventIDContainsFold *string  `json:"eventIDContainsFold,omitempty"`
	// correlation_id field predicates
	CorrelationID             *string  `json:"correlationID,omitempty"`
	CorrelationIdneq          *string  `json:"correlationIDNEQ,omitempty"`
	CorrelationIDIn           []string `json:"correlationIDIn,omitempty"`
	CorrelationIDNotIn        []string `json:"correlationIDNotIn,omitempty"`
	CorrelationIdgt           *string  `json:"correlationIDGT,omitempty"`
	CorrelationIdgte          *string  `json:"correlationIDGTE,omitempty"`
	CorrelationIdlt           *string  `json:"correlationIDLT,omitempty"`
	CorrelationIdlte          *string  `json:"correlationIDLTE,omitempty"`
	CorrelationIDContains     *string  `json:"correlationIDContains,omitempty"`
	CorrelationIDHasPrefix    *string  `json:"correlationIDHasPrefix,omitempty"`
	CorrelationIDHasSuffix    *string  `json:"correlationIDHasSuffix,omitempty"`
	CorrelationIDIsNil        *bool    `json:"correlationIDIsNil,omitempty"`
	CorrelationIDNotNil       *bool    `json:"correlationIDNotNil,omitempty"`
	CorrelationIDEqualFold    *string  `json:"correlationIDEqualFold,omitempty"`
	CorrelationIDContainsFold *string  `json:"correlationIDContainsFold,omitempty"`
	// event_type field predicates
	EventType             *string  `json:"eventType,omitempty"`
	EventTypeNeq          *string  `json:"eventTypeNEQ,omitempty"`
	EventTypeIn           []string `json:"eventTypeIn,omitempty"`
	EventTypeNotIn        []string `json:"eventTypeNotIn,omitempty"`
	EventTypeGt           *string  `json:"eventTypeGT,omitempty"`
	EventTypeGte          *string  `json:"eventTypeGTE,omitempty"`
	EventTypeLt           *string  `json:"eventTypeLT,omitempty"`
	EventTypeLte          *string  `json:"eventTypeLTE,omitempty"`
	EventTypeContains     *string  `json:"eventTypeContains,omitempty"`
	EventTypeHasPrefix    *string  `json:"eventTypeHasPrefix,omitempty"`
	EventTypeHasSuffix    *string  `json:"eventTypeHasSuffix,omitempty"`
	EventTypeIsNil        *bool    `json:"eventTypeIsNil,omitempty"`
	EventTypeNotNil       *bool    `json:"eventTypeNotNil,omitempty"`
	EventTypeEqualFold    *string  `json:"eventTypeEqualFold,omitempty"`
	EventTypeContainsFold *string  `json:"eventTypeContainsFold,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// additional_processing_required field predicates
	AdditionalProcessingRequired       *bool `json:"additionalProcessingRequired,omitempty"`
	AdditionalProcessingRequiredNeq    *bool `json:"additionalProcessingRequiredNEQ,omitempty"`
	AdditionalProcessingRequiredIsNil  *bool `json:"additionalProcessingRequiredIsNil,omitempty"`
	AdditionalProcessingRequiredNotNil *bool `json:"additionalProcessingRequiredNotNil,omitempty"`
	// additional_processing_details field predicates
	AdditionalProcessingDetails             *string  `json:"additionalProcessingDetails,omitempty"`
	AdditionalProcessingDetailsNeq          *string  `json:"additionalProcessingDetailsNEQ,omitempty"`
	AdditionalProcessingDetailsIn           []string `json:"additionalProcessingDetailsIn,omitempty"`
	AdditionalProcessingDetailsNotIn        []string `json:"additionalProcessingDetailsNotIn,omitempty"`
	AdditionalProcessingDetailsGt           *string  `json:"additionalProcessingDetailsGT,omitempty"`
	AdditionalProcessingDetailsGte          *string  `json:"additionalProcessingDetailsGTE,omitempty"`
	AdditionalProcessingDetailsLt           *string  `json:"additionalProcessingDetailsLT,omitempty"`
	AdditionalProcessingDetailsLte          *string  `json:"additionalProcessingDetailsLTE,omitempty"`
	AdditionalProcessingDetailsContains     *string  `json:"additionalProcessingDetailsContains,omitempty"`
	AdditionalProcessingDetailsHasPrefix    *string  `json:"additionalProcessingDetailsHasPrefix,omitempty"`
	AdditionalProcessingDetailsHasSuffix    *string  `json:"additionalProcessingDetailsHasSuffix,omitempty"`
	AdditionalProcessingDetailsIsNil        *bool    `json:"additionalProcessingDetailsIsNil,omitempty"`
	AdditionalProcessingDetailsNotNil       *bool    `json:"additionalProcessingDetailsNotNil,omitempty"`
	AdditionalProcessingDetailsEqualFold    *string  `json:"additionalProcessingDetailsEqualFold,omitempty"`
	AdditionalProcessingDetailsContainsFold *string  `json:"additionalProcessingDetailsContainsFold,omitempty"`
	// processed_by field predicates
	ProcessedBy             *string  `json:"processedBy,omitempty"`
	ProcessedByNeq          *string  `json:"processedByNEQ,omitempty"`
	ProcessedByIn           []string `json:"processedByIn,omitempty"`
	ProcessedByNotIn        []string `json:"processedByNotIn,omitempty"`
	ProcessedByGt           *string  `json:"processedByGT,omitempty"`
	ProcessedByGte          *string  `json:"processedByGTE,omitempty"`
	ProcessedByLt           *string  `json:"processedByLT,omitempty"`
	ProcessedByLte          *string  `json:"processedByLTE,omitempty"`
	ProcessedByContains     *string  `json:"processedByContains,omitempty"`
	ProcessedByHasPrefix    *string  `json:"processedByHasPrefix,omitempty"`
	ProcessedByHasSuffix    *string  `json:"processedByHasSuffix,omitempty"`
	ProcessedByIsNil        *bool    `json:"processedByIsNil,omitempty"`
	ProcessedByNotNil       *bool    `json:"processedByNotNil,omitempty"`
	ProcessedByEqualFold    *string  `json:"processedByEqualFold,omitempty"`
	ProcessedByContainsFold *string  `json:"processedByContainsFold,omitempty"`
	// processed_at field predicates
	ProcessedAt       *time.Time   `json:"processedAt,omitempty"`
	ProcessedAtNeq    *time.Time   `json:"processedAtNEQ,omitempty"`
	ProcessedAtIn     []*time.Time `json:"processedAtIn,omitempty"`
	ProcessedAtNotIn  []*time.Time `json:"processedAtNotIn,omitempty"`
	ProcessedAtGt     *time.Time   `json:"processedAtGT,omitempty"`
	ProcessedAtGte    *time.Time   `json:"processedAtGTE,omitempty"`
	ProcessedAtLt     *time.Time   `json:"processedAtLT,omitempty"`
	ProcessedAtLte    *time.Time   `json:"processedAtLTE,omitempty"`
	ProcessedAtIsNil  *bool        `json:"processedAtIsNil,omitempty"`
	ProcessedAtNotNil *bool        `json:"processedAtNotNil,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
	// integration edge predicates
	HasIntegration     *bool                    `json:"hasIntegration,omitempty"`
	HasIntegrationWith []*IntegrationWhereInput `json:"hasIntegrationWith,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// invite edge predicates
	HasInvite     *bool               `json:"hasInvite,omitempty"`
	HasInviteWith []*InviteWhereInput `json:"hasInviteWith,omitempty"`
	// personal_access_token edge predicates
	HasPersonalAccessToken     *bool                            `json:"hasPersonalAccessToken,omitempty"`
	HasPersonalAccessTokenWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokenWith,omitempty"`
	// hush edge predicates
	HasHush     *bool             `json:"hasHush,omitempty"`
	HasHushWith []*HushWhereInput `json:"hasHushWith,omitempty"`
	// orgmembership edge predicates
	HasOrgmembership     *bool                      `json:"hasOrgmembership,omitempty"`
	HasOrgmembershipWith []*OrgMembershipWhereInput `json:"hasOrgmembershipWith,omitempty"`
	// groupmembership edge predicates
	HasGroupmembership     *bool                        `json:"hasGroupmembership,omitempty"`
	HasGroupmembershipWith []*GroupMembershipWhereInput `json:"hasGroupmembershipWith,omitempty"`
	// subscriber edge predicates
	HasSubscriber     *bool                   `json:"hasSubscriber,omitempty"`
	HasSubscriberWith []*SubscriberWhereInput `json:"hasSubscriberWith,omitempty"`
	// file edge predicates
	HasFile     *bool             `json:"hasFile,omitempty"`
	HasFileWith []*FileWhereInput `json:"hasFileWith,omitempty"`
	// orgsubscription edge predicates
	HasOrgsubscription     *bool                        `json:"hasOrgsubscription,omitempty"`
	HasOrgsubscriptionWith []*OrgSubscriptionWhereInput `json:"hasOrgsubscriptionWith,omitempty"`
}

type Evidence struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string     `json:"displayID"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the evidence
	Name string `json:"name"`
	// the description of the evidence, what is contained in the uploaded file(s) or url(s)
	Description *string `json:"description,omitempty"`
	// description of how the evidence was collected
	CollectionProcedure *string `json:"collectionProcedure,omitempty"`
	// the date the evidence was retrieved
	CreationDate time.Time `json:"creationDate"`
	// the date the evidence should be renewed, defaults to a year from entry date
	RenewalDate *time.Time `json:"renewalDate,omitempty"`
	// the source of the evidence, e.g. system the evidence was retrieved from (splunk, github, etc)
	Source *string `json:"source,omitempty"`
	// whether the evidence was automatically generated
	IsAutomated *bool `json:"isAutomated,omitempty"`
	// the url of the evidence if not uploaded directly to the system
	URL               *string             `json:"url,omitempty"`
	Owner             *Organization       `json:"owner,omitempty"`
	ControlObjectives []*ControlObjective `json:"controlObjectives,omitempty"`
	Controls          []*Control          `json:"controls,omitempty"`
	Subcontrols       []*Subcontrol       `json:"subcontrols,omitempty"`
	Files             []*File             `json:"files,omitempty"`
	Programs          []*Program          `json:"programs,omitempty"`
	Tasks             []*Task             `json:"tasks,omitempty"`
}

func (Evidence) IsNode() {}

// Return response for createBulkEvidence mutation
type EvidenceBulkCreatePayload struct {
	// Created evidences
	Evidences []*Evidence `json:"evidences,omitempty"`
}

// A connection to a list of items.
type EvidenceConnection struct {
	// A list of edges.
	Edges []*EvidenceEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEvidence mutation
type EvidenceCreatePayload struct {
	// Created evidence
	Evidence *Evidence `json:"evidence"`
}

// Return response for deleteEvidence mutation
type EvidenceDeletePayload struct {
	// Deleted evidence ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EvidenceEdge struct {
	// The item at the end of the edge.
	Node *Evidence `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EvidenceHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string     `json:"displayID"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the evidence
	Name string `json:"name"`
	// the description of the evidence, what is contained in the uploaded file(s) or url(s)
	Description *string `json:"description,omitempty"`
	// description of how the evidence was collected
	CollectionProcedure *string `json:"collectionProcedure,omitempty"`
	// the date the evidence was retrieved
	CreationDate time.Time `json:"creationDate"`
	// the date the evidence should be renewed, defaults to a year from entry date
	RenewalDate *time.Time `json:"renewalDate,omitempty"`
	// the source of the evidence, e.g. system the evidence was retrieved from (splunk, github, etc)
	Source *string `json:"source,omitempty"`
	// whether the evidence was automatically generated
	IsAutomated *bool `json:"isAutomated,omitempty"`
	// the url of the evidence if not uploaded directly to the system
	URL *string `json:"url,omitempty"`
}

func (EvidenceHistory) IsNode() {}

// A connection to a list of items.
type EvidenceHistoryConnection struct {
	// A list of edges.
	Edges []*EvidenceHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EvidenceHistoryEdge struct {
	// The item at the end of the edge.
	Node *EvidenceHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// EvidenceHistoryWhereInput is used for filtering EvidenceHistory objects.
// Input was generated by ent.
type EvidenceHistoryWhereInput struct {
	Not *EvidenceHistoryWhereInput   `json:"not,omitempty"`
	And []*EvidenceHistoryWhereInput `json:"and,omitempty"`
	Or  []*EvidenceHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// collection_procedure field predicates
	CollectionProcedure             *string  `json:"collectionProcedure,omitempty"`
	CollectionProcedureNeq          *string  `json:"collectionProcedureNEQ,omitempty"`
	CollectionProcedureIn           []string `json:"collectionProcedureIn,omitempty"`
	CollectionProcedureNotIn        []string `json:"collectionProcedureNotIn,omitempty"`
	CollectionProcedureGt           *string  `json:"collectionProcedureGT,omitempty"`
	CollectionProcedureGte          *string  `json:"collectionProcedureGTE,omitempty"`
	CollectionProcedureLt           *string  `json:"collectionProcedureLT,omitempty"`
	CollectionProcedureLte          *string  `json:"collectionProcedureLTE,omitempty"`
	CollectionProcedureContains     *string  `json:"collectionProcedureContains,omitempty"`
	CollectionProcedureHasPrefix    *string  `json:"collectionProcedureHasPrefix,omitempty"`
	CollectionProcedureHasSuffix    *string  `json:"collectionProcedureHasSuffix,omitempty"`
	CollectionProcedureIsNil        *bool    `json:"collectionProcedureIsNil,omitempty"`
	CollectionProcedureNotNil       *bool    `json:"collectionProcedureNotNil,omitempty"`
	CollectionProcedureEqualFold    *string  `json:"collectionProcedureEqualFold,omitempty"`
	CollectionProcedureContainsFold *string  `json:"collectionProcedureContainsFold,omitempty"`
	// creation_date field predicates
	CreationDate      *time.Time   `json:"creationDate,omitempty"`
	CreationDateNeq   *time.Time   `json:"creationDateNEQ,omitempty"`
	CreationDateIn    []*time.Time `json:"creationDateIn,omitempty"`
	CreationDateNotIn []*time.Time `json:"creationDateNotIn,omitempty"`
	CreationDateGt    *time.Time   `json:"creationDateGT,omitempty"`
	CreationDateGte   *time.Time   `json:"creationDateGTE,omitempty"`
	CreationDateLt    *time.Time   `json:"creationDateLT,omitempty"`
	CreationDateLte   *time.Time   `json:"creationDateLTE,omitempty"`
	// renewal_date field predicates
	RenewalDate       *time.Time   `json:"renewalDate,omitempty"`
	RenewalDateNeq    *time.Time   `json:"renewalDateNEQ,omitempty"`
	RenewalDateIn     []*time.Time `json:"renewalDateIn,omitempty"`
	RenewalDateNotIn  []*time.Time `json:"renewalDateNotIn,omitempty"`
	RenewalDateGt     *time.Time   `json:"renewalDateGT,omitempty"`
	RenewalDateGte    *time.Time   `json:"renewalDateGTE,omitempty"`
	RenewalDateLt     *time.Time   `json:"renewalDateLT,omitempty"`
	RenewalDateLte    *time.Time   `json:"renewalDateLTE,omitempty"`
	RenewalDateIsNil  *bool        `json:"renewalDateIsNil,omitempty"`
	RenewalDateNotNil *bool        `json:"renewalDateNotNil,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// is_automated field predicates
	IsAutomated       *bool `json:"isAutomated,omitempty"`
	IsAutomatedNeq    *bool `json:"isAutomatedNEQ,omitempty"`
	IsAutomatedIsNil  *bool `json:"isAutomatedIsNil,omitempty"`
	IsAutomatedNotNil *bool `json:"isAutomatedNotNil,omitempty"`
	// url field predicates
	URL             *string  `json:"url,omitempty"`
	URLNeq          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGt           *string  `json:"urlGT,omitempty"`
	URLGte          *string  `json:"urlGTE,omitempty"`
	URLLt           *string  `json:"urlLT,omitempty"`
	URLLte          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        *bool    `json:"urlIsNil,omitempty"`
	URLNotNil       *bool    `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`
}

type EvidenceSearchResult struct {
	Evidences []*Evidence `json:"evidences,omitempty"`
}

func (EvidenceSearchResult) IsSearchResult() {}

// Return response for updateEvidence mutation
type EvidenceUpdatePayload struct {
	// Updated evidence
	Evidence *Evidence `json:"evidence"`
}

// EvidenceWhereInput is used for filtering Evidence objects.
// Input was generated by ent.
type EvidenceWhereInput struct {
	Not *EvidenceWhereInput   `json:"not,omitempty"`
	And []*EvidenceWhereInput `json:"and,omitempty"`
	Or  []*EvidenceWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// collection_procedure field predicates
	CollectionProcedure             *string  `json:"collectionProcedure,omitempty"`
	CollectionProcedureNeq          *string  `json:"collectionProcedureNEQ,omitempty"`
	CollectionProcedureIn           []string `json:"collectionProcedureIn,omitempty"`
	CollectionProcedureNotIn        []string `json:"collectionProcedureNotIn,omitempty"`
	CollectionProcedureGt           *string  `json:"collectionProcedureGT,omitempty"`
	CollectionProcedureGte          *string  `json:"collectionProcedureGTE,omitempty"`
	CollectionProcedureLt           *string  `json:"collectionProcedureLT,omitempty"`
	CollectionProcedureLte          *string  `json:"collectionProcedureLTE,omitempty"`
	CollectionProcedureContains     *string  `json:"collectionProcedureContains,omitempty"`
	CollectionProcedureHasPrefix    *string  `json:"collectionProcedureHasPrefix,omitempty"`
	CollectionProcedureHasSuffix    *string  `json:"collectionProcedureHasSuffix,omitempty"`
	CollectionProcedureIsNil        *bool    `json:"collectionProcedureIsNil,omitempty"`
	CollectionProcedureNotNil       *bool    `json:"collectionProcedureNotNil,omitempty"`
	CollectionProcedureEqualFold    *string  `json:"collectionProcedureEqualFold,omitempty"`
	CollectionProcedureContainsFold *string  `json:"collectionProcedureContainsFold,omitempty"`
	// creation_date field predicates
	CreationDate      *time.Time   `json:"creationDate,omitempty"`
	CreationDateNeq   *time.Time   `json:"creationDateNEQ,omitempty"`
	CreationDateIn    []*time.Time `json:"creationDateIn,omitempty"`
	CreationDateNotIn []*time.Time `json:"creationDateNotIn,omitempty"`
	CreationDateGt    *time.Time   `json:"creationDateGT,omitempty"`
	CreationDateGte   *time.Time   `json:"creationDateGTE,omitempty"`
	CreationDateLt    *time.Time   `json:"creationDateLT,omitempty"`
	CreationDateLte   *time.Time   `json:"creationDateLTE,omitempty"`
	// renewal_date field predicates
	RenewalDate       *time.Time   `json:"renewalDate,omitempty"`
	RenewalDateNeq    *time.Time   `json:"renewalDateNEQ,omitempty"`
	RenewalDateIn     []*time.Time `json:"renewalDateIn,omitempty"`
	RenewalDateNotIn  []*time.Time `json:"renewalDateNotIn,omitempty"`
	RenewalDateGt     *time.Time   `json:"renewalDateGT,omitempty"`
	RenewalDateGte    *time.Time   `json:"renewalDateGTE,omitempty"`
	RenewalDateLt     *time.Time   `json:"renewalDateLT,omitempty"`
	RenewalDateLte    *time.Time   `json:"renewalDateLTE,omitempty"`
	RenewalDateIsNil  *bool        `json:"renewalDateIsNil,omitempty"`
	RenewalDateNotNil *bool        `json:"renewalDateNotNil,omitempty"`
	// source field predicates
	Source             *string  `json:"source,omitempty"`
	SourceNeq          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGt           *string  `json:"sourceGT,omitempty"`
	SourceGte          *string  `json:"sourceGTE,omitempty"`
	SourceLt           *string  `json:"sourceLT,omitempty"`
	SourceLte          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        *bool    `json:"sourceIsNil,omitempty"`
	SourceNotNil       *bool    `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`
	// is_automated field predicates
	IsAutomated       *bool `json:"isAutomated,omitempty"`
	IsAutomatedNeq    *bool `json:"isAutomatedNEQ,omitempty"`
	IsAutomatedIsNil  *bool `json:"isAutomatedIsNil,omitempty"`
	IsAutomatedNotNil *bool `json:"isAutomatedNotNil,omitempty"`
	// url field predicates
	URL             *string  `json:"url,omitempty"`
	URLNeq          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGt           *string  `json:"urlGT,omitempty"`
	URLGte          *string  `json:"urlGTE,omitempty"`
	URLLt           *string  `json:"urlLT,omitempty"`
	URLLte          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        *bool    `json:"urlIsNil,omitempty"`
	URLNotNil       *bool    `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
}

type File struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName string `json:"providedFileName"`
	// the extension of the file provided
	ProvidedFileExtension string `json:"providedFileExtension"`
	// the computed size of the file in the original http request
	ProvidedFileSize  *int64 `json:"providedFileSize,omitempty"`
	PersistedFileSize *int64 `json:"persistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType *string `json:"detectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash *string `json:"md5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType string `json:"detectedContentType"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey *string `json:"storeKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType *string `json:"categoryType,omitempty"`
	// the full URI of the file
	URI *string `json:"uri,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme *string `json:"storageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume *string `json:"storageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath         *string                `json:"storagePath,omitempty"`
	User                []*User                `json:"user,omitempty"`
	Organization        []*Organization        `json:"organization,omitempty"`
	Group               []*Group               `json:"group,omitempty"`
	Contact             []*Contact             `json:"contact,omitempty"`
	Entity              []*Entity              `json:"entity,omitempty"`
	UserSetting         []*UserSetting         `json:"userSetting,omitempty"`
	OrganizationSetting []*OrganizationSetting `json:"organizationSetting,omitempty"`
	Template            []*Template            `json:"template,omitempty"`
	DocumentData        []*DocumentData        `json:"documentData,omitempty"`
	Events              []*Event               `json:"events,omitempty"`
	Program             []*Program             `json:"program,omitempty"`
	Evidence            []*Evidence            `json:"evidence,omitempty"`
	PresignedURL        *string                `json:"presignedURL,omitempty"`
}

func (File) IsNode() {}

// A connection to a list of items.
type FileConnection struct {
	// A list of edges.
	Edges []*FileEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for deleteFile mutation
type FileDeletePayload struct {
	// Deleted file ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type FileEdge struct {
	// The item at the end of the edge.
	Node *File `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type FileHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName string `json:"providedFileName"`
	// the extension of the file provided
	ProvidedFileExtension string `json:"providedFileExtension"`
	// the computed size of the file in the original http request
	ProvidedFileSize  *int64 `json:"providedFileSize,omitempty"`
	PersistedFileSize *int64 `json:"persistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType *string `json:"detectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash *string `json:"md5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType string `json:"detectedContentType"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey *string `json:"storeKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType *string `json:"categoryType,omitempty"`
	// the full URI of the file
	URI *string `json:"uri,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme *string `json:"storageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume *string `json:"storageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath *string `json:"storagePath,omitempty"`
}

func (FileHistory) IsNode() {}

// A connection to a list of items.
type FileHistoryConnection struct {
	// A list of edges.
	Edges []*FileHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type FileHistoryEdge struct {
	// The item at the end of the edge.
	Node *FileHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// FileHistoryWhereInput is used for filtering FileHistory objects.
// Input was generated by ent.
type FileHistoryWhereInput struct {
	Not *FileHistoryWhereInput   `json:"not,omitempty"`
	And []*FileHistoryWhereInput `json:"and,omitempty"`
	Or  []*FileHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// provided_file_name field predicates
	ProvidedFileName             *string  `json:"providedFileName,omitempty"`
	ProvidedFileNameNeq          *string  `json:"providedFileNameNEQ,omitempty"`
	ProvidedFileNameIn           []string `json:"providedFileNameIn,omitempty"`
	ProvidedFileNameNotIn        []string `json:"providedFileNameNotIn,omitempty"`
	ProvidedFileNameGt           *string  `json:"providedFileNameGT,omitempty"`
	ProvidedFileNameGte          *string  `json:"providedFileNameGTE,omitempty"`
	ProvidedFileNameLt           *string  `json:"providedFileNameLT,omitempty"`
	ProvidedFileNameLte          *string  `json:"providedFileNameLTE,omitempty"`
	ProvidedFileNameContains     *string  `json:"providedFileNameContains,omitempty"`
	ProvidedFileNameHasPrefix    *string  `json:"providedFileNameHasPrefix,omitempty"`
	ProvidedFileNameHasSuffix    *string  `json:"providedFileNameHasSuffix,omitempty"`
	ProvidedFileNameEqualFold    *string  `json:"providedFileNameEqualFold,omitempty"`
	ProvidedFileNameContainsFold *string  `json:"providedFileNameContainsFold,omitempty"`
	// provided_file_extension field predicates
	ProvidedFileExtension             *string  `json:"providedFileExtension,omitempty"`
	ProvidedFileExtensionNeq          *string  `json:"providedFileExtensionNEQ,omitempty"`
	ProvidedFileExtensionIn           []string `json:"providedFileExtensionIn,omitempty"`
	ProvidedFileExtensionNotIn        []string `json:"providedFileExtensionNotIn,omitempty"`
	ProvidedFileExtensionGt           *string  `json:"providedFileExtensionGT,omitempty"`
	ProvidedFileExtensionGte          *string  `json:"providedFileExtensionGTE,omitempty"`
	ProvidedFileExtensionLt           *string  `json:"providedFileExtensionLT,omitempty"`
	ProvidedFileExtensionLte          *string  `json:"providedFileExtensionLTE,omitempty"`
	ProvidedFileExtensionContains     *string  `json:"providedFileExtensionContains,omitempty"`
	ProvidedFileExtensionHasPrefix    *string  `json:"providedFileExtensionHasPrefix,omitempty"`
	ProvidedFileExtensionHasSuffix    *string  `json:"providedFileExtensionHasSuffix,omitempty"`
	ProvidedFileExtensionEqualFold    *string  `json:"providedFileExtensionEqualFold,omitempty"`
	ProvidedFileExtensionContainsFold *string  `json:"providedFileExtensionContainsFold,omitempty"`
	// provided_file_size field predicates
	ProvidedFileSize       *int64  `json:"providedFileSize,omitempty"`
	ProvidedFileSizeNeq    *int64  `json:"providedFileSizeNEQ,omitempty"`
	ProvidedFileSizeIn     []int64 `json:"providedFileSizeIn,omitempty"`
	ProvidedFileSizeNotIn  []int64 `json:"providedFileSizeNotIn,omitempty"`
	ProvidedFileSizeGt     *int64  `json:"providedFileSizeGT,omitempty"`
	ProvidedFileSizeGte    *int64  `json:"providedFileSizeGTE,omitempty"`
	ProvidedFileSizeLt     *int64  `json:"providedFileSizeLT,omitempty"`
	ProvidedFileSizeLte    *int64  `json:"providedFileSizeLTE,omitempty"`
	ProvidedFileSizeIsNil  *bool   `json:"providedFileSizeIsNil,omitempty"`
	ProvidedFileSizeNotNil *bool   `json:"providedFileSizeNotNil,omitempty"`
	// persisted_file_size field predicates
	PersistedFileSize       *int64  `json:"persistedFileSize,omitempty"`
	PersistedFileSizeNeq    *int64  `json:"persistedFileSizeNEQ,omitempty"`
	PersistedFileSizeIn     []int64 `json:"persistedFileSizeIn,omitempty"`
	PersistedFileSizeNotIn  []int64 `json:"persistedFileSizeNotIn,omitempty"`
	PersistedFileSizeGt     *int64  `json:"persistedFileSizeGT,omitempty"`
	PersistedFileSizeGte    *int64  `json:"persistedFileSizeGTE,omitempty"`
	PersistedFileSizeLt     *int64  `json:"persistedFileSizeLT,omitempty"`
	PersistedFileSizeLte    *int64  `json:"persistedFileSizeLTE,omitempty"`
	PersistedFileSizeIsNil  *bool   `json:"persistedFileSizeIsNil,omitempty"`
	PersistedFileSizeNotNil *bool   `json:"persistedFileSizeNotNil,omitempty"`
	// detected_mime_type field predicates
	DetectedMimeType             *string  `json:"detectedMimeType,omitempty"`
	DetectedMimeTypeNeq          *string  `json:"detectedMimeTypeNEQ,omitempty"`
	DetectedMimeTypeIn           []string `json:"detectedMimeTypeIn,omitempty"`
	DetectedMimeTypeNotIn        []string `json:"detectedMimeTypeNotIn,omitempty"`
	DetectedMimeTypeGt           *string  `json:"detectedMimeTypeGT,omitempty"`
	DetectedMimeTypeGte          *string  `json:"detectedMimeTypeGTE,omitempty"`
	DetectedMimeTypeLt           *string  `json:"detectedMimeTypeLT,omitempty"`
	DetectedMimeTypeLte          *string  `json:"detectedMimeTypeLTE,omitempty"`
	DetectedMimeTypeContains     *string  `json:"detectedMimeTypeContains,omitempty"`
	DetectedMimeTypeHasPrefix    *string  `json:"detectedMimeTypeHasPrefix,omitempty"`
	DetectedMimeTypeHasSuffix    *string  `json:"detectedMimeTypeHasSuffix,omitempty"`
	DetectedMimeTypeIsNil        *bool    `json:"detectedMimeTypeIsNil,omitempty"`
	DetectedMimeTypeNotNil       *bool    `json:"detectedMimeTypeNotNil,omitempty"`
	DetectedMimeTypeEqualFold    *string  `json:"detectedMimeTypeEqualFold,omitempty"`
	DetectedMimeTypeContainsFold *string  `json:"detectedMimeTypeContainsFold,omitempty"`
	// md5_hash field predicates
	Md5Hash             *string  `json:"md5Hash,omitempty"`
	Md5HashNeq          *string  `json:"md5HashNEQ,omitempty"`
	Md5HashIn           []string `json:"md5HashIn,omitempty"`
	Md5HashNotIn        []string `json:"md5HashNotIn,omitempty"`
	Md5HashGt           *string  `json:"md5HashGT,omitempty"`
	Md5HashGte          *string  `json:"md5HashGTE,omitempty"`
	Md5HashLt           *string  `json:"md5HashLT,omitempty"`
	Md5HashLte          *string  `json:"md5HashLTE,omitempty"`
	Md5HashContains     *string  `json:"md5HashContains,omitempty"`
	Md5HashHasPrefix    *string  `json:"md5HashHasPrefix,omitempty"`
	Md5HashHasSuffix    *string  `json:"md5HashHasSuffix,omitempty"`
	Md5HashIsNil        *bool    `json:"md5HashIsNil,omitempty"`
	Md5HashNotNil       *bool    `json:"md5HashNotNil,omitempty"`
	Md5HashEqualFold    *string  `json:"md5HashEqualFold,omitempty"`
	Md5HashContainsFold *string  `json:"md5HashContainsFold,omitempty"`
	// detected_content_type field predicates
	DetectedContentType             *string  `json:"detectedContentType,omitempty"`
	DetectedContentTypeNeq          *string  `json:"detectedContentTypeNEQ,omitempty"`
	DetectedContentTypeIn           []string `json:"detectedContentTypeIn,omitempty"`
	DetectedContentTypeNotIn        []string `json:"detectedContentTypeNotIn,omitempty"`
	DetectedContentTypeGt           *string  `json:"detectedContentTypeGT,omitempty"`
	DetectedContentTypeGte          *string  `json:"detectedContentTypeGTE,omitempty"`
	DetectedContentTypeLt           *string  `json:"detectedContentTypeLT,omitempty"`
	DetectedContentTypeLte          *string  `json:"detectedContentTypeLTE,omitempty"`
	DetectedContentTypeContains     *string  `json:"detectedContentTypeContains,omitempty"`
	DetectedContentTypeHasPrefix    *string  `json:"detectedContentTypeHasPrefix,omitempty"`
	DetectedContentTypeHasSuffix    *string  `json:"detectedContentTypeHasSuffix,omitempty"`
	DetectedContentTypeEqualFold    *string  `json:"detectedContentTypeEqualFold,omitempty"`
	DetectedContentTypeContainsFold *string  `json:"detectedContentTypeContainsFold,omitempty"`
	// store_key field predicates
	StoreKey             *string  `json:"storeKey,omitempty"`
	StoreKeyNeq          *string  `json:"storeKeyNEQ,omitempty"`
	StoreKeyIn           []string `json:"storeKeyIn,omitempty"`
	StoreKeyNotIn        []string `json:"storeKeyNotIn,omitempty"`
	StoreKeyGt           *string  `json:"storeKeyGT,omitempty"`
	StoreKeyGte          *string  `json:"storeKeyGTE,omitempty"`
	StoreKeyLt           *string  `json:"storeKeyLT,omitempty"`
	StoreKeyLte          *string  `json:"storeKeyLTE,omitempty"`
	StoreKeyContains     *string  `json:"storeKeyContains,omitempty"`
	StoreKeyHasPrefix    *string  `json:"storeKeyHasPrefix,omitempty"`
	StoreKeyHasSuffix    *string  `json:"storeKeyHasSuffix,omitempty"`
	StoreKeyIsNil        *bool    `json:"storeKeyIsNil,omitempty"`
	StoreKeyNotNil       *bool    `json:"storeKeyNotNil,omitempty"`
	StoreKeyEqualFold    *string  `json:"storeKeyEqualFold,omitempty"`
	StoreKeyContainsFold *string  `json:"storeKeyContainsFold,omitempty"`
	// category_type field predicates
	CategoryType             *string  `json:"categoryType,omitempty"`
	CategoryTypeNeq          *string  `json:"categoryTypeNEQ,omitempty"`
	CategoryTypeIn           []string `json:"categoryTypeIn,omitempty"`
	CategoryTypeNotIn        []string `json:"categoryTypeNotIn,omitempty"`
	CategoryTypeGt           *string  `json:"categoryTypeGT,omitempty"`
	CategoryTypeGte          *string  `json:"categoryTypeGTE,omitempty"`
	CategoryTypeLt           *string  `json:"categoryTypeLT,omitempty"`
	CategoryTypeLte          *string  `json:"categoryTypeLTE,omitempty"`
	CategoryTypeContains     *string  `json:"categoryTypeContains,omitempty"`
	CategoryTypeHasPrefix    *string  `json:"categoryTypeHasPrefix,omitempty"`
	CategoryTypeHasSuffix    *string  `json:"categoryTypeHasSuffix,omitempty"`
	CategoryTypeIsNil        *bool    `json:"categoryTypeIsNil,omitempty"`
	CategoryTypeNotNil       *bool    `json:"categoryTypeNotNil,omitempty"`
	CategoryTypeEqualFold    *string  `json:"categoryTypeEqualFold,omitempty"`
	CategoryTypeContainsFold *string  `json:"categoryTypeContainsFold,omitempty"`
	// uri field predicates
	URI             *string  `json:"uri,omitempty"`
	URINeq          *string  `json:"uriNEQ,omitempty"`
	URIIn           []string `json:"uriIn,omitempty"`
	URINotIn        []string `json:"uriNotIn,omitempty"`
	URIGt           *string  `json:"uriGT,omitempty"`
	URIGte          *string  `json:"uriGTE,omitempty"`
	URILt           *string  `json:"uriLT,omitempty"`
	URILte          *string  `json:"uriLTE,omitempty"`
	URIContains     *string  `json:"uriContains,omitempty"`
	URIHasPrefix    *string  `json:"uriHasPrefix,omitempty"`
	URIHasSuffix    *string  `json:"uriHasSuffix,omitempty"`
	URIIsNil        *bool    `json:"uriIsNil,omitempty"`
	URINotNil       *bool    `json:"uriNotNil,omitempty"`
	URIEqualFold    *string  `json:"uriEqualFold,omitempty"`
	URIContainsFold *string  `json:"uriContainsFold,omitempty"`
	// storage_scheme field predicates
	StorageScheme             *string  `json:"storageScheme,omitempty"`
	StorageSchemeNeq          *string  `json:"storageSchemeNEQ,omitempty"`
	StorageSchemeIn           []string `json:"storageSchemeIn,omitempty"`
	StorageSchemeNotIn        []string `json:"storageSchemeNotIn,omitempty"`
	StorageSchemeGt           *string  `json:"storageSchemeGT,omitempty"`
	StorageSchemeGte          *string  `json:"storageSchemeGTE,omitempty"`
	StorageSchemeLt           *string  `json:"storageSchemeLT,omitempty"`
	StorageSchemeLte          *string  `json:"storageSchemeLTE,omitempty"`
	StorageSchemeContains     *string  `json:"storageSchemeContains,omitempty"`
	StorageSchemeHasPrefix    *string  `json:"storageSchemeHasPrefix,omitempty"`
	StorageSchemeHasSuffix    *string  `json:"storageSchemeHasSuffix,omitempty"`
	StorageSchemeIsNil        *bool    `json:"storageSchemeIsNil,omitempty"`
	StorageSchemeNotNil       *bool    `json:"storageSchemeNotNil,omitempty"`
	StorageSchemeEqualFold    *string  `json:"storageSchemeEqualFold,omitempty"`
	StorageSchemeContainsFold *string  `json:"storageSchemeContainsFold,omitempty"`
	// storage_volume field predicates
	StorageVolume             *string  `json:"storageVolume,omitempty"`
	StorageVolumeNeq          *string  `json:"storageVolumeNEQ,omitempty"`
	StorageVolumeIn           []string `json:"storageVolumeIn,omitempty"`
	StorageVolumeNotIn        []string `json:"storageVolumeNotIn,omitempty"`
	StorageVolumeGt           *string  `json:"storageVolumeGT,omitempty"`
	StorageVolumeGte          *string  `json:"storageVolumeGTE,omitempty"`
	StorageVolumeLt           *string  `json:"storageVolumeLT,omitempty"`
	StorageVolumeLte          *string  `json:"storageVolumeLTE,omitempty"`
	StorageVolumeContains     *string  `json:"storageVolumeContains,omitempty"`
	StorageVolumeHasPrefix    *string  `json:"storageVolumeHasPrefix,omitempty"`
	StorageVolumeHasSuffix    *string  `json:"storageVolumeHasSuffix,omitempty"`
	StorageVolumeIsNil        *bool    `json:"storageVolumeIsNil,omitempty"`
	StorageVolumeNotNil       *bool    `json:"storageVolumeNotNil,omitempty"`
	StorageVolumeEqualFold    *string  `json:"storageVolumeEqualFold,omitempty"`
	StorageVolumeContainsFold *string  `json:"storageVolumeContainsFold,omitempty"`
	// storage_path field predicates
	StoragePath             *string  `json:"storagePath,omitempty"`
	StoragePathNeq          *string  `json:"storagePathNEQ,omitempty"`
	StoragePathIn           []string `json:"storagePathIn,omitempty"`
	StoragePathNotIn        []string `json:"storagePathNotIn,omitempty"`
	StoragePathGt           *string  `json:"storagePathGT,omitempty"`
	StoragePathGte          *string  `json:"storagePathGTE,omitempty"`
	StoragePathLt           *string  `json:"storagePathLT,omitempty"`
	StoragePathLte          *string  `json:"storagePathLTE,omitempty"`
	StoragePathContains     *string  `json:"storagePathContains,omitempty"`
	StoragePathHasPrefix    *string  `json:"storagePathHasPrefix,omitempty"`
	StoragePathHasSuffix    *string  `json:"storagePathHasSuffix,omitempty"`
	StoragePathIsNil        *bool    `json:"storagePathIsNil,omitempty"`
	StoragePathNotNil       *bool    `json:"storagePathNotNil,omitempty"`
	StoragePathEqualFold    *string  `json:"storagePathEqualFold,omitempty"`
	StoragePathContainsFold *string  `json:"storagePathContainsFold,omitempty"`
}

type FileSearchResult struct {
	Files []*File `json:"files,omitempty"`
}

func (FileSearchResult) IsSearchResult() {}

// FileWhereInput is used for filtering File objects.
// Input was generated by ent.
type FileWhereInput struct {
	Not *FileWhereInput   `json:"not,omitempty"`
	And []*FileWhereInput `json:"and,omitempty"`
	Or  []*FileWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// provided_file_name field predicates
	ProvidedFileName             *string  `json:"providedFileName,omitempty"`
	ProvidedFileNameNeq          *string  `json:"providedFileNameNEQ,omitempty"`
	ProvidedFileNameIn           []string `json:"providedFileNameIn,omitempty"`
	ProvidedFileNameNotIn        []string `json:"providedFileNameNotIn,omitempty"`
	ProvidedFileNameGt           *string  `json:"providedFileNameGT,omitempty"`
	ProvidedFileNameGte          *string  `json:"providedFileNameGTE,omitempty"`
	ProvidedFileNameLt           *string  `json:"providedFileNameLT,omitempty"`
	ProvidedFileNameLte          *string  `json:"providedFileNameLTE,omitempty"`
	ProvidedFileNameContains     *string  `json:"providedFileNameContains,omitempty"`
	ProvidedFileNameHasPrefix    *string  `json:"providedFileNameHasPrefix,omitempty"`
	ProvidedFileNameHasSuffix    *string  `json:"providedFileNameHasSuffix,omitempty"`
	ProvidedFileNameEqualFold    *string  `json:"providedFileNameEqualFold,omitempty"`
	ProvidedFileNameContainsFold *string  `json:"providedFileNameContainsFold,omitempty"`
	// provided_file_extension field predicates
	ProvidedFileExtension             *string  `json:"providedFileExtension,omitempty"`
	ProvidedFileExtensionNeq          *string  `json:"providedFileExtensionNEQ,omitempty"`
	ProvidedFileExtensionIn           []string `json:"providedFileExtensionIn,omitempty"`
	ProvidedFileExtensionNotIn        []string `json:"providedFileExtensionNotIn,omitempty"`
	ProvidedFileExtensionGt           *string  `json:"providedFileExtensionGT,omitempty"`
	ProvidedFileExtensionGte          *string  `json:"providedFileExtensionGTE,omitempty"`
	ProvidedFileExtensionLt           *string  `json:"providedFileExtensionLT,omitempty"`
	ProvidedFileExtensionLte          *string  `json:"providedFileExtensionLTE,omitempty"`
	ProvidedFileExtensionContains     *string  `json:"providedFileExtensionContains,omitempty"`
	ProvidedFileExtensionHasPrefix    *string  `json:"providedFileExtensionHasPrefix,omitempty"`
	ProvidedFileExtensionHasSuffix    *string  `json:"providedFileExtensionHasSuffix,omitempty"`
	ProvidedFileExtensionEqualFold    *string  `json:"providedFileExtensionEqualFold,omitempty"`
	ProvidedFileExtensionContainsFold *string  `json:"providedFileExtensionContainsFold,omitempty"`
	// provided_file_size field predicates
	ProvidedFileSize       *int64  `json:"providedFileSize,omitempty"`
	ProvidedFileSizeNeq    *int64  `json:"providedFileSizeNEQ,omitempty"`
	ProvidedFileSizeIn     []int64 `json:"providedFileSizeIn,omitempty"`
	ProvidedFileSizeNotIn  []int64 `json:"providedFileSizeNotIn,omitempty"`
	ProvidedFileSizeGt     *int64  `json:"providedFileSizeGT,omitempty"`
	ProvidedFileSizeGte    *int64  `json:"providedFileSizeGTE,omitempty"`
	ProvidedFileSizeLt     *int64  `json:"providedFileSizeLT,omitempty"`
	ProvidedFileSizeLte    *int64  `json:"providedFileSizeLTE,omitempty"`
	ProvidedFileSizeIsNil  *bool   `json:"providedFileSizeIsNil,omitempty"`
	ProvidedFileSizeNotNil *bool   `json:"providedFileSizeNotNil,omitempty"`
	// persisted_file_size field predicates
	PersistedFileSize       *int64  `json:"persistedFileSize,omitempty"`
	PersistedFileSizeNeq    *int64  `json:"persistedFileSizeNEQ,omitempty"`
	PersistedFileSizeIn     []int64 `json:"persistedFileSizeIn,omitempty"`
	PersistedFileSizeNotIn  []int64 `json:"persistedFileSizeNotIn,omitempty"`
	PersistedFileSizeGt     *int64  `json:"persistedFileSizeGT,omitempty"`
	PersistedFileSizeGte    *int64  `json:"persistedFileSizeGTE,omitempty"`
	PersistedFileSizeLt     *int64  `json:"persistedFileSizeLT,omitempty"`
	PersistedFileSizeLte    *int64  `json:"persistedFileSizeLTE,omitempty"`
	PersistedFileSizeIsNil  *bool   `json:"persistedFileSizeIsNil,omitempty"`
	PersistedFileSizeNotNil *bool   `json:"persistedFileSizeNotNil,omitempty"`
	// detected_mime_type field predicates
	DetectedMimeType             *string  `json:"detectedMimeType,omitempty"`
	DetectedMimeTypeNeq          *string  `json:"detectedMimeTypeNEQ,omitempty"`
	DetectedMimeTypeIn           []string `json:"detectedMimeTypeIn,omitempty"`
	DetectedMimeTypeNotIn        []string `json:"detectedMimeTypeNotIn,omitempty"`
	DetectedMimeTypeGt           *string  `json:"detectedMimeTypeGT,omitempty"`
	DetectedMimeTypeGte          *string  `json:"detectedMimeTypeGTE,omitempty"`
	DetectedMimeTypeLt           *string  `json:"detectedMimeTypeLT,omitempty"`
	DetectedMimeTypeLte          *string  `json:"detectedMimeTypeLTE,omitempty"`
	DetectedMimeTypeContains     *string  `json:"detectedMimeTypeContains,omitempty"`
	DetectedMimeTypeHasPrefix    *string  `json:"detectedMimeTypeHasPrefix,omitempty"`
	DetectedMimeTypeHasSuffix    *string  `json:"detectedMimeTypeHasSuffix,omitempty"`
	DetectedMimeTypeIsNil        *bool    `json:"detectedMimeTypeIsNil,omitempty"`
	DetectedMimeTypeNotNil       *bool    `json:"detectedMimeTypeNotNil,omitempty"`
	DetectedMimeTypeEqualFold    *string  `json:"detectedMimeTypeEqualFold,omitempty"`
	DetectedMimeTypeContainsFold *string  `json:"detectedMimeTypeContainsFold,omitempty"`
	// md5_hash field predicates
	Md5Hash             *string  `json:"md5Hash,omitempty"`
	Md5HashNeq          *string  `json:"md5HashNEQ,omitempty"`
	Md5HashIn           []string `json:"md5HashIn,omitempty"`
	Md5HashNotIn        []string `json:"md5HashNotIn,omitempty"`
	Md5HashGt           *string  `json:"md5HashGT,omitempty"`
	Md5HashGte          *string  `json:"md5HashGTE,omitempty"`
	Md5HashLt           *string  `json:"md5HashLT,omitempty"`
	Md5HashLte          *string  `json:"md5HashLTE,omitempty"`
	Md5HashContains     *string  `json:"md5HashContains,omitempty"`
	Md5HashHasPrefix    *string  `json:"md5HashHasPrefix,omitempty"`
	Md5HashHasSuffix    *string  `json:"md5HashHasSuffix,omitempty"`
	Md5HashIsNil        *bool    `json:"md5HashIsNil,omitempty"`
	Md5HashNotNil       *bool    `json:"md5HashNotNil,omitempty"`
	Md5HashEqualFold    *string  `json:"md5HashEqualFold,omitempty"`
	Md5HashContainsFold *string  `json:"md5HashContainsFold,omitempty"`
	// detected_content_type field predicates
	DetectedContentType             *string  `json:"detectedContentType,omitempty"`
	DetectedContentTypeNeq          *string  `json:"detectedContentTypeNEQ,omitempty"`
	DetectedContentTypeIn           []string `json:"detectedContentTypeIn,omitempty"`
	DetectedContentTypeNotIn        []string `json:"detectedContentTypeNotIn,omitempty"`
	DetectedContentTypeGt           *string  `json:"detectedContentTypeGT,omitempty"`
	DetectedContentTypeGte          *string  `json:"detectedContentTypeGTE,omitempty"`
	DetectedContentTypeLt           *string  `json:"detectedContentTypeLT,omitempty"`
	DetectedContentTypeLte          *string  `json:"detectedContentTypeLTE,omitempty"`
	DetectedContentTypeContains     *string  `json:"detectedContentTypeContains,omitempty"`
	DetectedContentTypeHasPrefix    *string  `json:"detectedContentTypeHasPrefix,omitempty"`
	DetectedContentTypeHasSuffix    *string  `json:"detectedContentTypeHasSuffix,omitempty"`
	DetectedContentTypeEqualFold    *string  `json:"detectedContentTypeEqualFold,omitempty"`
	DetectedContentTypeContainsFold *string  `json:"detectedContentTypeContainsFold,omitempty"`
	// store_key field predicates
	StoreKey             *string  `json:"storeKey,omitempty"`
	StoreKeyNeq          *string  `json:"storeKeyNEQ,omitempty"`
	StoreKeyIn           []string `json:"storeKeyIn,omitempty"`
	StoreKeyNotIn        []string `json:"storeKeyNotIn,omitempty"`
	StoreKeyGt           *string  `json:"storeKeyGT,omitempty"`
	StoreKeyGte          *string  `json:"storeKeyGTE,omitempty"`
	StoreKeyLt           *string  `json:"storeKeyLT,omitempty"`
	StoreKeyLte          *string  `json:"storeKeyLTE,omitempty"`
	StoreKeyContains     *string  `json:"storeKeyContains,omitempty"`
	StoreKeyHasPrefix    *string  `json:"storeKeyHasPrefix,omitempty"`
	StoreKeyHasSuffix    *string  `json:"storeKeyHasSuffix,omitempty"`
	StoreKeyIsNil        *bool    `json:"storeKeyIsNil,omitempty"`
	StoreKeyNotNil       *bool    `json:"storeKeyNotNil,omitempty"`
	StoreKeyEqualFold    *string  `json:"storeKeyEqualFold,omitempty"`
	StoreKeyContainsFold *string  `json:"storeKeyContainsFold,omitempty"`
	// category_type field predicates
	CategoryType             *string  `json:"categoryType,omitempty"`
	CategoryTypeNeq          *string  `json:"categoryTypeNEQ,omitempty"`
	CategoryTypeIn           []string `json:"categoryTypeIn,omitempty"`
	CategoryTypeNotIn        []string `json:"categoryTypeNotIn,omitempty"`
	CategoryTypeGt           *string  `json:"categoryTypeGT,omitempty"`
	CategoryTypeGte          *string  `json:"categoryTypeGTE,omitempty"`
	CategoryTypeLt           *string  `json:"categoryTypeLT,omitempty"`
	CategoryTypeLte          *string  `json:"categoryTypeLTE,omitempty"`
	CategoryTypeContains     *string  `json:"categoryTypeContains,omitempty"`
	CategoryTypeHasPrefix    *string  `json:"categoryTypeHasPrefix,omitempty"`
	CategoryTypeHasSuffix    *string  `json:"categoryTypeHasSuffix,omitempty"`
	CategoryTypeIsNil        *bool    `json:"categoryTypeIsNil,omitempty"`
	CategoryTypeNotNil       *bool    `json:"categoryTypeNotNil,omitempty"`
	CategoryTypeEqualFold    *string  `json:"categoryTypeEqualFold,omitempty"`
	CategoryTypeContainsFold *string  `json:"categoryTypeContainsFold,omitempty"`
	// uri field predicates
	URI             *string  `json:"uri,omitempty"`
	URINeq          *string  `json:"uriNEQ,omitempty"`
	URIIn           []string `json:"uriIn,omitempty"`
	URINotIn        []string `json:"uriNotIn,omitempty"`
	URIGt           *string  `json:"uriGT,omitempty"`
	URIGte          *string  `json:"uriGTE,omitempty"`
	URILt           *string  `json:"uriLT,omitempty"`
	URILte          *string  `json:"uriLTE,omitempty"`
	URIContains     *string  `json:"uriContains,omitempty"`
	URIHasPrefix    *string  `json:"uriHasPrefix,omitempty"`
	URIHasSuffix    *string  `json:"uriHasSuffix,omitempty"`
	URIIsNil        *bool    `json:"uriIsNil,omitempty"`
	URINotNil       *bool    `json:"uriNotNil,omitempty"`
	URIEqualFold    *string  `json:"uriEqualFold,omitempty"`
	URIContainsFold *string  `json:"uriContainsFold,omitempty"`
	// storage_scheme field predicates
	StorageScheme             *string  `json:"storageScheme,omitempty"`
	StorageSchemeNeq          *string  `json:"storageSchemeNEQ,omitempty"`
	StorageSchemeIn           []string `json:"storageSchemeIn,omitempty"`
	StorageSchemeNotIn        []string `json:"storageSchemeNotIn,omitempty"`
	StorageSchemeGt           *string  `json:"storageSchemeGT,omitempty"`
	StorageSchemeGte          *string  `json:"storageSchemeGTE,omitempty"`
	StorageSchemeLt           *string  `json:"storageSchemeLT,omitempty"`
	StorageSchemeLte          *string  `json:"storageSchemeLTE,omitempty"`
	StorageSchemeContains     *string  `json:"storageSchemeContains,omitempty"`
	StorageSchemeHasPrefix    *string  `json:"storageSchemeHasPrefix,omitempty"`
	StorageSchemeHasSuffix    *string  `json:"storageSchemeHasSuffix,omitempty"`
	StorageSchemeIsNil        *bool    `json:"storageSchemeIsNil,omitempty"`
	StorageSchemeNotNil       *bool    `json:"storageSchemeNotNil,omitempty"`
	StorageSchemeEqualFold    *string  `json:"storageSchemeEqualFold,omitempty"`
	StorageSchemeContainsFold *string  `json:"storageSchemeContainsFold,omitempty"`
	// storage_volume field predicates
	StorageVolume             *string  `json:"storageVolume,omitempty"`
	StorageVolumeNeq          *string  `json:"storageVolumeNEQ,omitempty"`
	StorageVolumeIn           []string `json:"storageVolumeIn,omitempty"`
	StorageVolumeNotIn        []string `json:"storageVolumeNotIn,omitempty"`
	StorageVolumeGt           *string  `json:"storageVolumeGT,omitempty"`
	StorageVolumeGte          *string  `json:"storageVolumeGTE,omitempty"`
	StorageVolumeLt           *string  `json:"storageVolumeLT,omitempty"`
	StorageVolumeLte          *string  `json:"storageVolumeLTE,omitempty"`
	StorageVolumeContains     *string  `json:"storageVolumeContains,omitempty"`
	StorageVolumeHasPrefix    *string  `json:"storageVolumeHasPrefix,omitempty"`
	StorageVolumeHasSuffix    *string  `json:"storageVolumeHasSuffix,omitempty"`
	StorageVolumeIsNil        *bool    `json:"storageVolumeIsNil,omitempty"`
	StorageVolumeNotNil       *bool    `json:"storageVolumeNotNil,omitempty"`
	StorageVolumeEqualFold    *string  `json:"storageVolumeEqualFold,omitempty"`
	StorageVolumeContainsFold *string  `json:"storageVolumeContainsFold,omitempty"`
	// storage_path field predicates
	StoragePath             *string  `json:"storagePath,omitempty"`
	StoragePathNeq          *string  `json:"storagePathNEQ,omitempty"`
	StoragePathIn           []string `json:"storagePathIn,omitempty"`
	StoragePathNotIn        []string `json:"storagePathNotIn,omitempty"`
	StoragePathGt           *string  `json:"storagePathGT,omitempty"`
	StoragePathGte          *string  `json:"storagePathGTE,omitempty"`
	StoragePathLt           *string  `json:"storagePathLT,omitempty"`
	StoragePathLte          *string  `json:"storagePathLTE,omitempty"`
	StoragePathContains     *string  `json:"storagePathContains,omitempty"`
	StoragePathHasPrefix    *string  `json:"storagePathHasPrefix,omitempty"`
	StoragePathHasSuffix    *string  `json:"storagePathHasSuffix,omitempty"`
	StoragePathIsNil        *bool    `json:"storagePathIsNil,omitempty"`
	StoragePathNotNil       *bool    `json:"storagePathNotNil,omitempty"`
	StoragePathEqualFold    *string  `json:"storagePathEqualFold,omitempty"`
	StoragePathContainsFold *string  `json:"storagePathContainsFold,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
	// contact edge predicates
	HasContact     *bool                `json:"hasContact,omitempty"`
	HasContactWith []*ContactWhereInput `json:"hasContactWith,omitempty"`
	// entity edge predicates
	HasEntity     *bool               `json:"hasEntity,omitempty"`
	HasEntityWith []*EntityWhereInput `json:"hasEntityWith,omitempty"`
	// user_setting edge predicates
	HasUserSetting     *bool                    `json:"hasUserSetting,omitempty"`
	HasUserSettingWith []*UserSettingWhereInput `json:"hasUserSettingWith,omitempty"`
	// organization_setting edge predicates
	HasOrganizationSetting     *bool                            `json:"hasOrganizationSetting,omitempty"`
	HasOrganizationSettingWith []*OrganizationSettingWhereInput `json:"hasOrganizationSettingWith,omitempty"`
	// template edge predicates
	HasTemplate     *bool                 `json:"hasTemplate,omitempty"`
	HasTemplateWith []*TemplateWhereInput `json:"hasTemplateWith,omitempty"`
	// document_data edge predicates
	HasDocumentData     *bool                     `json:"hasDocumentData,omitempty"`
	HasDocumentDataWith []*DocumentDataWhereInput `json:"hasDocumentDataWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// program edge predicates
	HasProgram     *bool                `json:"hasProgram,omitempty"`
	HasProgramWith []*ProgramWhereInput `json:"hasProgramWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
}

type Group struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the group - must be unique within the organization
	Name string `json:"name"`
	// the groups description
	Description *string `json:"description,omitempty"`
	// whether the group is managed by the system
	IsManaged *bool `json:"isManaged,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL *string `json:"gravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL *string `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName                   string              `json:"displayName"`
	Owner                         *Organization       `json:"owner,omitempty"`
	ProcedureEditors              []*Procedure        `json:"procedureEditors,omitempty"`
	ProcedureBlockedGroups        []*Procedure        `json:"procedureBlockedGroups,omitempty"`
	InternalPolicyEditors         []*InternalPolicy   `json:"internalPolicyEditors,omitempty"`
	InternalPolicyBlockedGroups   []*InternalPolicy   `json:"internalPolicyBlockedGroups,omitempty"`
	ProgramEditors                []*Program          `json:"programEditors,omitempty"`
	ProgramBlockedGroups          []*Program          `json:"programBlockedGroups,omitempty"`
	ProgramViewers                []*Program          `json:"programViewers,omitempty"`
	RiskEditors                   []*Risk             `json:"riskEditors,omitempty"`
	RiskBlockedGroups             []*Risk             `json:"riskBlockedGroups,omitempty"`
	RiskViewers                   []*Risk             `json:"riskViewers,omitempty"`
	ControlObjectiveEditors       []*ControlObjective `json:"controlObjectiveEditors,omitempty"`
	ControlObjectiveBlockedGroups []*ControlObjective `json:"controlObjectiveBlockedGroups,omitempty"`
	ControlObjectiveViewers       []*ControlObjective `json:"controlObjectiveViewers,omitempty"`
	ControlEditors                []*Control          `json:"controlEditors,omitempty"`
	ControlBlockedGroups          []*Control          `json:"controlBlockedGroups,omitempty"`
	ControlViewers                []*Control          `json:"controlViewers,omitempty"`
	NarrativeEditors              []*Narrative        `json:"narrativeEditors,omitempty"`
	NarrativeBlockedGroups        []*Narrative        `json:"narrativeBlockedGroups,omitempty"`
	NarrativeViewers              []*Narrative        `json:"narrativeViewers,omitempty"`
	Setting                       *GroupSetting       `json:"setting,omitempty"`
	Users                         []*User             `json:"users,omitempty"`
	Events                        []*Event            `json:"events,omitempty"`
	Integrations                  []*Integration      `json:"integrations,omitempty"`
	Files                         []*File             `json:"files,omitempty"`
	Tasks                         []*Task             `json:"tasks,omitempty"`
	Members                       []*GroupMembership  `json:"members,omitempty"`
	// permissions the group provides
	Permissions []*GroupPermissions `json:"permissions,omitempty"`
}

func (Group) IsNode() {}

// Return response for createBulkGroup mutation
type GroupBulkCreatePayload struct {
	// Created groups
	Groups []*Group `json:"groups,omitempty"`
}

// A connection to a list of items.
type GroupConnection struct {
	// A list of edges.
	Edges []*GroupEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroup mutation
type GroupCreatePayload struct {
	// Created group
	Group *Group `json:"group"`
}

// Return response for deleteGroup mutation
type GroupDeletePayload struct {
	// Deleted group ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupEdge struct {
	// The item at the end of the edge.
	Node *Group `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type GroupHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the group - must be unique within the organization
	Name string `json:"name"`
	// the groups description
	Description *string `json:"description,omitempty"`
	// whether the group is managed by the system
	IsManaged *bool `json:"isManaged,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL *string `json:"gravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL *string `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName string `json:"displayName"`
}

func (GroupHistory) IsNode() {}

// A connection to a list of items.
type GroupHistoryConnection struct {
	// A list of edges.
	Edges []*GroupHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupHistoryEdge struct {
	// The item at the end of the edge.
	Node *GroupHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for GroupHistory connections
type GroupHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order GroupHistories.
	Field GroupHistoryOrderField `json:"field"`
}

// GroupHistoryWhereInput is used for filtering GroupHistory objects.
// Input was generated by ent.
type GroupHistoryWhereInput struct {
	Not *GroupHistoryWhereInput   `json:"not,omitempty"`
	And []*GroupHistoryWhereInput `json:"and,omitempty"`
	Or  []*GroupHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// is_managed field predicates
	IsManaged       *bool `json:"isManaged,omitempty"`
	IsManagedNeq    *bool `json:"isManagedNEQ,omitempty"`
	IsManagedIsNil  *bool `json:"isManagedIsNil,omitempty"`
	IsManagedNotNil *bool `json:"isManagedNotNil,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
}

// GroupMembersInput is used to create members for a group
// along with the group creation
type GroupMembersInput struct {
	Role   *enums.Role `json:"role,omitempty"`
	UserID string      `json:"userID"`
}

type GroupMembership struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	Role      enums.Role `json:"role"`
	GroupID   string     `json:"groupID"`
	UserID    string     `json:"userID"`
	Group     *Group     `json:"group"`
	User      *User      `json:"user"`
	Events    []*Event   `json:"events,omitempty"`
}

func (GroupMembership) IsNode() {}

// Return response for createBulkGroupMembership mutation
type GroupMembershipBulkCreatePayload struct {
	// Created groupMemberships
	GroupMemberships []*GroupMembership `json:"groupMemberships,omitempty"`
}

// A connection to a list of items.
type GroupMembershipConnection struct {
	// A list of edges.
	Edges []*GroupMembershipEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroupMembership mutation
type GroupMembershipCreatePayload struct {
	// Created groupMembership
	GroupMembership *GroupMembership `json:"groupMembership"`
}

// Return response for deleteGroupMembership mutation
type GroupMembershipDeletePayload struct {
	// Deleted groupMembership ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupMembershipEdge struct {
	// The item at the end of the edge.
	Node *GroupMembership `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type GroupMembershipHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	Role        enums.Role     `json:"role"`
	GroupID     string         `json:"groupID"`
	UserID      string         `json:"userID"`
}

func (GroupMembershipHistory) IsNode() {}

// A connection to a list of items.
type GroupMembershipHistoryConnection struct {
	// A list of edges.
	Edges []*GroupMembershipHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupMembershipHistoryEdge struct {
	// The item at the end of the edge.
	Node *GroupMembershipHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// GroupMembershipHistoryWhereInput is used for filtering GroupMembershipHistory objects.
// Input was generated by ent.
type GroupMembershipHistoryWhereInput struct {
	Not *GroupMembershipHistoryWhereInput   `json:"not,omitempty"`
	And []*GroupMembershipHistoryWhereInput `json:"and,omitempty"`
	Or  []*GroupMembershipHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// group_id field predicates
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIdneq          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIdgt           *string  `json:"groupIDGT,omitempty"`
	GroupIdgte          *string  `json:"groupIDGTE,omitempty"`
	GroupIdlt           *string  `json:"groupIDLT,omitempty"`
	GroupIdlte          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// Return response for updateGroupMembership mutation
type GroupMembershipUpdatePayload struct {
	// Updated groupMembership
	GroupMembership *GroupMembership `json:"groupMembership"`
}

// GroupMembershipWhereInput is used for filtering GroupMembership objects.
// Input was generated by ent.
type GroupMembershipWhereInput struct {
	Not *GroupMembershipWhereInput   `json:"not,omitempty"`
	And []*GroupMembershipWhereInput `json:"and,omitempty"`
	Or  []*GroupMembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	GroupID   *string      `json:"groupID,omitempty"`
	UserID    *string      `json:"userID,omitempty"`
}

// Ordering options for Group connections
type GroupOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Groups.
	Field GroupOrderField `json:"field"`
}

// GroupPermissions contains details for the related object and the permissions
// the group provides (or removes in the case of blocked) to the object within the
// organization
type GroupPermissions struct {
	ObjectType  string           `json:"objectType"`
	Permissions enums.Permission `json:"permissions"`
	ID          *string          `json:"id,omitempty"`
	DisplayID   *string          `json:"displayID,omitempty"`
	Name        *string          `json:"name,omitempty"`
}

type GroupSearchResult struct {
	Groups []*Group `json:"groups,omitempty"`
}

func (GroupSearchResult) IsSearchResult() {}

type GroupSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility enums.Visibility `json:"visibility"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy enums.JoinPolicy `json:"joinPolicy"`
	// whether to sync group members to slack groups
	SyncToSlack *bool `json:"syncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub *bool `json:"syncToGithub,omitempty"`
	// the group id associated with the settings
	GroupID *string `json:"groupID,omitempty"`
	Group   *Group  `json:"group,omitempty"`
}

func (GroupSetting) IsNode() {}

// Return response for createBulkGroupSetting mutation
type GroupSettingBulkCreatePayload struct {
	// Created groupSettings
	GroupSettings []*GroupSetting `json:"groupSettings,omitempty"`
}

// A connection to a list of items.
type GroupSettingConnection struct {
	// A list of edges.
	Edges []*GroupSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroupSetting mutation
type GroupSettingCreatePayload struct {
	// Created groupSetting
	GroupSetting *GroupSetting `json:"groupSetting"`
}

// Return response for deleteGroupSetting mutation
type GroupSettingDeletePayload struct {
	// Deleted groupSetting ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupSettingEdge struct {
	// The item at the end of the edge.
	Node *GroupSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type GroupSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility enums.Visibility `json:"visibility"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy enums.JoinPolicy `json:"joinPolicy"`
	// whether to sync group members to slack groups
	SyncToSlack *bool `json:"syncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub *bool `json:"syncToGithub,omitempty"`
	// the group id associated with the settings
	GroupID *string `json:"groupID,omitempty"`
}

func (GroupSettingHistory) IsNode() {}

// A connection to a list of items.
type GroupSettingHistoryConnection struct {
	// A list of edges.
	Edges []*GroupSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *GroupSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// GroupSettingHistoryWhereInput is used for filtering GroupSettingHistory objects.
// Input was generated by ent.
type GroupSettingHistoryWhereInput struct {
	Not *GroupSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*GroupSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*GroupSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// visibility field predicates
	Visibility      *enums.Visibility  `json:"visibility,omitempty"`
	VisibilityNeq   *enums.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []enums.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []enums.Visibility `json:"visibilityNotIn,omitempty"`
	// join_policy field predicates
	JoinPolicy      *enums.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNeq   *enums.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []enums.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []enums.JoinPolicy `json:"joinPolicyNotIn,omitempty"`
	// sync_to_slack field predicates
	SyncToSlack       *bool `json:"syncToSlack,omitempty"`
	SyncToSlackNeq    *bool `json:"syncToSlackNEQ,omitempty"`
	SyncToSlackIsNil  *bool `json:"syncToSlackIsNil,omitempty"`
	SyncToSlackNotNil *bool `json:"syncToSlackNotNil,omitempty"`
	// sync_to_github field predicates
	SyncToGithub       *bool `json:"syncToGithub,omitempty"`
	SyncToGithubNeq    *bool `json:"syncToGithubNEQ,omitempty"`
	SyncToGithubIsNil  *bool `json:"syncToGithubIsNil,omitempty"`
	SyncToGithubNotNil *bool `json:"syncToGithubNotNil,omitempty"`
	// group_id field predicates
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIdneq          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIdgt           *string  `json:"groupIDGT,omitempty"`
	GroupIdgte          *string  `json:"groupIDGTE,omitempty"`
	GroupIdlt           *string  `json:"groupIDLT,omitempty"`
	GroupIdlte          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDIsNil        *bool    `json:"groupIDIsNil,omitempty"`
	GroupIDNotNil       *bool    `json:"groupIDNotNil,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
}

// Return response for updateGroupSetting mutation
type GroupSettingUpdatePayload struct {
	// Updated groupSetting
	GroupSetting *GroupSetting `json:"groupSetting"`
}

// GroupSettingWhereInput is used for filtering GroupSetting objects.
// Input was generated by ent.
type GroupSettingWhereInput struct {
	Not *GroupSettingWhereInput   `json:"not,omitempty"`
	And []*GroupSettingWhereInput `json:"and,omitempty"`
	Or  []*GroupSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// visibility field predicates
	Visibility      *enums.Visibility  `json:"visibility,omitempty"`
	VisibilityNeq   *enums.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []enums.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []enums.Visibility `json:"visibilityNotIn,omitempty"`
	// join_policy field predicates
	JoinPolicy      *enums.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNeq   *enums.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []enums.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []enums.JoinPolicy `json:"joinPolicyNotIn,omitempty"`
	// sync_to_slack field predicates
	SyncToSlack       *bool `json:"syncToSlack,omitempty"`
	SyncToSlackNeq    *bool `json:"syncToSlackNEQ,omitempty"`
	SyncToSlackIsNil  *bool `json:"syncToSlackIsNil,omitempty"`
	SyncToSlackNotNil *bool `json:"syncToSlackNotNil,omitempty"`
	// sync_to_github field predicates
	SyncToGithub       *bool `json:"syncToGithub,omitempty"`
	SyncToGithubNeq    *bool `json:"syncToGithubNEQ,omitempty"`
	SyncToGithubIsNil  *bool `json:"syncToGithubIsNil,omitempty"`
	SyncToGithubNotNil *bool `json:"syncToGithubNotNil,omitempty"`
	// group_id field predicates
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIdneq          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIdgt           *string  `json:"groupIDGT,omitempty"`
	GroupIdgte          *string  `json:"groupIDGTE,omitempty"`
	GroupIdlt           *string  `json:"groupIDLT,omitempty"`
	GroupIdlte          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDIsNil        *bool    `json:"groupIDIsNil,omitempty"`
	GroupIDNotNil       *bool    `json:"groupIDNotNil,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
}

// Return response for updateGroup mutation
type GroupUpdatePayload struct {
	// Updated group
	Group *Group `json:"group"`
}

// GroupWhereInput is used for filtering Group objects.
// Input was generated by ent.
type GroupWhereInput struct {
	Not *GroupWhereInput   `json:"not,omitempty"`
	And []*GroupWhereInput `json:"and,omitempty"`
	Or  []*GroupWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// is_managed field predicates
	IsManaged       *bool `json:"isManaged,omitempty"`
	IsManagedNeq    *bool `json:"isManagedNEQ,omitempty"`
	IsManagedIsNil  *bool `json:"isManagedIsNil,omitempty"`
	IsManagedNotNil *bool `json:"isManagedNotNil,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// procedure_editors edge predicates
	HasProcedureEditors     *bool                  `json:"hasProcedureEditors,omitempty"`
	HasProcedureEditorsWith []*ProcedureWhereInput `json:"hasProcedureEditorsWith,omitempty"`
	// procedure_blocked_groups edge predicates
	HasProcedureBlockedGroups     *bool                  `json:"hasProcedureBlockedGroups,omitempty"`
	HasProcedureBlockedGroupsWith []*ProcedureWhereInput `json:"hasProcedureBlockedGroupsWith,omitempty"`
	// internal_policy_editors edge predicates
	HasInternalPolicyEditors     *bool                       `json:"hasInternalPolicyEditors,omitempty"`
	HasInternalPolicyEditorsWith []*InternalPolicyWhereInput `json:"hasInternalPolicyEditorsWith,omitempty"`
	// internal_policy_blocked_groups edge predicates
	HasInternalPolicyBlockedGroups     *bool                       `json:"hasInternalPolicyBlockedGroups,omitempty"`
	HasInternalPolicyBlockedGroupsWith []*InternalPolicyWhereInput `json:"hasInternalPolicyBlockedGroupsWith,omitempty"`
	// program_editors edge predicates
	HasProgramEditors     *bool                `json:"hasProgramEditors,omitempty"`
	HasProgramEditorsWith []*ProgramWhereInput `json:"hasProgramEditorsWith,omitempty"`
	// program_blocked_groups edge predicates
	HasProgramBlockedGroups     *bool                `json:"hasProgramBlockedGroups,omitempty"`
	HasProgramBlockedGroupsWith []*ProgramWhereInput `json:"hasProgramBlockedGroupsWith,omitempty"`
	// program_viewers edge predicates
	HasProgramViewers     *bool                `json:"hasProgramViewers,omitempty"`
	HasProgramViewersWith []*ProgramWhereInput `json:"hasProgramViewersWith,omitempty"`
	// risk_editors edge predicates
	HasRiskEditors     *bool             `json:"hasRiskEditors,omitempty"`
	HasRiskEditorsWith []*RiskWhereInput `json:"hasRiskEditorsWith,omitempty"`
	// risk_blocked_groups edge predicates
	HasRiskBlockedGroups     *bool             `json:"hasRiskBlockedGroups,omitempty"`
	HasRiskBlockedGroupsWith []*RiskWhereInput `json:"hasRiskBlockedGroupsWith,omitempty"`
	// risk_viewers edge predicates
	HasRiskViewers     *bool             `json:"hasRiskViewers,omitempty"`
	HasRiskViewersWith []*RiskWhereInput `json:"hasRiskViewersWith,omitempty"`
	// control_objective_editors edge predicates
	HasControlObjectiveEditors     *bool                         `json:"hasControlObjectiveEditors,omitempty"`
	HasControlObjectiveEditorsWith []*ControlObjectiveWhereInput `json:"hasControlObjectiveEditorsWith,omitempty"`
	// control_objective_blocked_groups edge predicates
	HasControlObjectiveBlockedGroups     *bool                         `json:"hasControlObjectiveBlockedGroups,omitempty"`
	HasControlObjectiveBlockedGroupsWith []*ControlObjectiveWhereInput `json:"hasControlObjectiveBlockedGroupsWith,omitempty"`
	// control_objective_viewers edge predicates
	HasControlObjectiveViewers     *bool                         `json:"hasControlObjectiveViewers,omitempty"`
	HasControlObjectiveViewersWith []*ControlObjectiveWhereInput `json:"hasControlObjectiveViewersWith,omitempty"`
	// control_editors edge predicates
	HasControlEditors     *bool                `json:"hasControlEditors,omitempty"`
	HasControlEditorsWith []*ControlWhereInput `json:"hasControlEditorsWith,omitempty"`
	// control_blocked_groups edge predicates
	HasControlBlockedGroups     *bool                `json:"hasControlBlockedGroups,omitempty"`
	HasControlBlockedGroupsWith []*ControlWhereInput `json:"hasControlBlockedGroupsWith,omitempty"`
	// control_viewers edge predicates
	HasControlViewers     *bool                `json:"hasControlViewers,omitempty"`
	HasControlViewersWith []*ControlWhereInput `json:"hasControlViewersWith,omitempty"`
	// narrative_editors edge predicates
	HasNarrativeEditors     *bool                  `json:"hasNarrativeEditors,omitempty"`
	HasNarrativeEditorsWith []*NarrativeWhereInput `json:"hasNarrativeEditorsWith,omitempty"`
	// narrative_blocked_groups edge predicates
	HasNarrativeBlockedGroups     *bool                  `json:"hasNarrativeBlockedGroups,omitempty"`
	HasNarrativeBlockedGroupsWith []*NarrativeWhereInput `json:"hasNarrativeBlockedGroupsWith,omitempty"`
	// narrative_viewers edge predicates
	HasNarrativeViewers     *bool                  `json:"hasNarrativeViewers,omitempty"`
	HasNarrativeViewersWith []*NarrativeWhereInput `json:"hasNarrativeViewersWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                     `json:"hasSetting,omitempty"`
	HasSettingWith []*GroupSettingWhereInput `json:"hasSettingWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// members edge predicates
	HasMembers     *bool                        `json:"hasMembers,omitempty"`
	HasMembersWith []*GroupMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

type Hush struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the logical name of the corresponding hush secret or it's general grouping
	Name string `json:"name"`
	// a description of the hush value or purpose, such as github PAT
	Description *string `json:"description,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind *string `json:"kind,omitempty"`
	// the generic name of a secret associated with the organization
	SecretName *string `json:"secretName,omitempty"`
	// the integration associated with the secret
	Integrations []*Integration  `json:"integrations,omitempty"`
	Organization []*Organization `json:"organization,omitempty"`
	Events       []*Event        `json:"events,omitempty"`
}

func (Hush) IsNode() {}

// Return response for createBulkHush mutation
type HushBulkCreatePayload struct {
	// Created hushs
	Hushes []*Hush `json:"hushes,omitempty"`
}

// A connection to a list of items.
type HushConnection struct {
	// A list of edges.
	Edges []*HushEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createHush mutation
type HushCreatePayload struct {
	// Created hush
	Hush *Hush `json:"hush"`
}

// Return response for deleteHush mutation
type HushDeletePayload struct {
	// Deleted hush ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type HushEdge struct {
	// The item at the end of the edge.
	Node *Hush `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type HushHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// the logical name of the corresponding hush secret or it's general grouping
	Name string `json:"name"`
	// a description of the hush value or purpose, such as github PAT
	Description *string `json:"description,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind *string `json:"kind,omitempty"`
	// the generic name of a secret associated with the organization
	SecretName *string `json:"secretName,omitempty"`
}

func (HushHistory) IsNode() {}

// A connection to a list of items.
type HushHistoryConnection struct {
	// A list of edges.
	Edges []*HushHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type HushHistoryEdge struct {
	// The item at the end of the edge.
	Node *HushHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for HushHistory connections
type HushHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order HushHistories.
	Field HushHistoryOrderField `json:"field"`
}

// HushHistoryWhereInput is used for filtering HushHistory objects.
// Input was generated by ent.
type HushHistoryWhereInput struct {
	Not *HushHistoryWhereInput   `json:"not,omitempty"`
	And []*HushHistoryWhereInput `json:"and,omitempty"`
	Or  []*HushHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// secret_name field predicates
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNeq          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGt           *string  `json:"secretNameGT,omitempty"`
	SecretNameGte          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLt           *string  `json:"secretNameLT,omitempty"`
	SecretNameLte          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameIsNil        *bool    `json:"secretNameIsNil,omitempty"`
	SecretNameNotNil       *bool    `json:"secretNameNotNil,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`
}

// Ordering options for Hush connections
type HushOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Hushes.
	Field HushOrderField `json:"field"`
}

// Return response for updateHush mutation
type HushUpdatePayload struct {
	// Updated hush
	Hush *Hush `json:"hush"`
}

// HushWhereInput is used for filtering Hush objects.
// Input was generated by ent.
type HushWhereInput struct {
	Not *HushWhereInput   `json:"not,omitempty"`
	And []*HushWhereInput `json:"and,omitempty"`
	Or  []*HushWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// secret_name field predicates
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNeq          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGt           *string  `json:"secretNameGT,omitempty"`
	SecretNameGte          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLt           *string  `json:"secretNameLT,omitempty"`
	SecretNameLte          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameIsNil        *bool    `json:"secretNameIsNil,omitempty"`
	SecretNameNotNil       *bool    `json:"secretNameNotNil,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Integration struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the integration - must be unique within the organization
	Name string `json:"name"`
	// a description of the integration
	Description *string       `json:"description,omitempty"`
	Kind        *string       `json:"kind,omitempty"`
	Owner       *Organization `json:"owner,omitempty"`
	// the secrets associated with the integration
	Secrets []*Hush  `json:"secrets,omitempty"`
	Events  []*Event `json:"events,omitempty"`
}

func (Integration) IsNode() {}

// Return response for createBulkIntegration mutation
type IntegrationBulkCreatePayload struct {
	// Created integrations
	Integrations []*Integration `json:"integrations,omitempty"`
}

// A connection to a list of items.
type IntegrationConnection struct {
	// A list of edges.
	Edges []*IntegrationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createIntegration mutation
type IntegrationCreatePayload struct {
	// Created integration
	Integration *Integration `json:"integration"`
}

// Return response for deleteIntegration mutation
type IntegrationDeletePayload struct {
	// Deleted integration ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type IntegrationEdge struct {
	// The item at the end of the edge.
	Node *Integration `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type IntegrationHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the integration - must be unique within the organization
	Name string `json:"name"`
	// a description of the integration
	Description *string `json:"description,omitempty"`
	Kind        *string `json:"kind,omitempty"`
}

func (IntegrationHistory) IsNode() {}

// A connection to a list of items.
type IntegrationHistoryConnection struct {
	// A list of edges.
	Edges []*IntegrationHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type IntegrationHistoryEdge struct {
	// The item at the end of the edge.
	Node *IntegrationHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for IntegrationHistory connections
type IntegrationHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order IntegrationHistories.
	Field IntegrationHistoryOrderField `json:"field"`
}

// IntegrationHistoryWhereInput is used for filtering IntegrationHistory objects.
// Input was generated by ent.
type IntegrationHistoryWhereInput struct {
	Not *IntegrationHistoryWhereInput   `json:"not,omitempty"`
	And []*IntegrationHistoryWhereInput `json:"and,omitempty"`
	Or  []*IntegrationHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
}

// Ordering options for Integration connections
type IntegrationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Integrations.
	Field IntegrationOrderField `json:"field"`
}

type IntegrationSearchResult struct {
	Integrations []*Integration `json:"integrations,omitempty"`
}

func (IntegrationSearchResult) IsSearchResult() {}

// Return response for updateIntegration mutation
type IntegrationUpdatePayload struct {
	// Updated integration
	Integration *Integration `json:"integration"`
}

// IntegrationWhereInput is used for filtering Integration objects.
// Input was generated by ent.
type IntegrationWhereInput struct {
	Not *IntegrationWhereInput   `json:"not,omitempty"`
	And []*IntegrationWhereInput `json:"and,omitempty"`
	Or  []*IntegrationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// secrets edge predicates
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type InternalPolicy struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the policy
	Name string `json:"name"`
	// description of the policy
	Description *string `json:"description,omitempty"`
	// status of the policy
	Status *string `json:"status,omitempty"`
	// the date the policy should be reviewed, defaults to a year from creation date
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// type of the policy
	PolicyType *string `json:"policyType,omitempty"`
	// version of the policy
	Version *string `json:"version,omitempty"`
	// purpose and scope
	PurposeAndScope *string `json:"purposeAndScope,omitempty"`
	// background of the policy
	Background *string `json:"background,omitempty"`
	// json data for the policy document
	Details map[string]any `json:"details,omitempty"`
	Owner   *Organization  `json:"owner,omitempty"`
	// groups that are blocked from viewing or editing the risk
	BlockedGroups []*Group `json:"blockedGroups,omitempty"`
	// provides edit access to the risk to members of the group
	Editors           []*Group            `json:"editors,omitempty"`
	ControlObjectives []*ControlObjective `json:"controlObjectives,omitempty"`
	Controls          []*Control          `json:"controls,omitempty"`
	Procedures        []*Procedure        `json:"procedures,omitempty"`
	Narratives        []*Narrative        `json:"narratives,omitempty"`
	Tasks             []*Task             `json:"tasks,omitempty"`
	Programs          []*Program          `json:"programs,omitempty"`
}

func (InternalPolicy) IsNode() {}

// Return response for createBulkInternalPolicy mutation
type InternalPolicyBulkCreatePayload struct {
	// Created internalPolicys
	InternalPolicies []*InternalPolicy `json:"internalPolicies,omitempty"`
}

// A connection to a list of items.
type InternalPolicyConnection struct {
	// A list of edges.
	Edges []*InternalPolicyEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createInternalPolicy mutation
type InternalPolicyCreatePayload struct {
	// Created internalPolicy
	InternalPolicy *InternalPolicy `json:"internalPolicy"`
}

// Return response for deleteInternalPolicy mutation
type InternalPolicyDeletePayload struct {
	// Deleted internalPolicy ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type InternalPolicyEdge struct {
	// The item at the end of the edge.
	Node *InternalPolicy `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type InternalPolicyHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the policy
	Name string `json:"name"`
	// description of the policy
	Description *string `json:"description,omitempty"`
	// status of the policy
	Status *string `json:"status,omitempty"`
	// the date the policy should be reviewed, defaults to a year from creation date
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// type of the policy
	PolicyType *string `json:"policyType,omitempty"`
	// version of the policy
	Version *string `json:"version,omitempty"`
	// purpose and scope
	PurposeAndScope *string `json:"purposeAndScope,omitempty"`
	// background of the policy
	Background *string `json:"background,omitempty"`
	// json data for the policy document
	Details map[string]any `json:"details,omitempty"`
}

func (InternalPolicyHistory) IsNode() {}

// A connection to a list of items.
type InternalPolicyHistoryConnection struct {
	// A list of edges.
	Edges []*InternalPolicyHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type InternalPolicyHistoryEdge struct {
	// The item at the end of the edge.
	Node *InternalPolicyHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// InternalPolicyHistoryWhereInput is used for filtering InternalPolicyHistory objects.
// Input was generated by ent.
type InternalPolicyHistoryWhereInput struct {
	Not *InternalPolicyHistoryWhereInput   `json:"not,omitempty"`
	And []*InternalPolicyHistoryWhereInput `json:"and,omitempty"`
	Or  []*InternalPolicyHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// policy_type field predicates
	PolicyType             *string  `json:"policyType,omitempty"`
	PolicyTypeNeq          *string  `json:"policyTypeNEQ,omitempty"`
	PolicyTypeIn           []string `json:"policyTypeIn,omitempty"`
	PolicyTypeNotIn        []string `json:"policyTypeNotIn,omitempty"`
	PolicyTypeGt           *string  `json:"policyTypeGT,omitempty"`
	PolicyTypeGte          *string  `json:"policyTypeGTE,omitempty"`
	PolicyTypeLt           *string  `json:"policyTypeLT,omitempty"`
	PolicyTypeLte          *string  `json:"policyTypeLTE,omitempty"`
	PolicyTypeContains     *string  `json:"policyTypeContains,omitempty"`
	PolicyTypeHasPrefix    *string  `json:"policyTypeHasPrefix,omitempty"`
	PolicyTypeHasSuffix    *string  `json:"policyTypeHasSuffix,omitempty"`
	PolicyTypeIsNil        *bool    `json:"policyTypeIsNil,omitempty"`
	PolicyTypeNotNil       *bool    `json:"policyTypeNotNil,omitempty"`
	PolicyTypeEqualFold    *string  `json:"policyTypeEqualFold,omitempty"`
	PolicyTypeContainsFold *string  `json:"policyTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// purpose_and_scope field predicates
	PurposeAndScope             *string  `json:"purposeAndScope,omitempty"`
	PurposeAndScopeNeq          *string  `json:"purposeAndScopeNEQ,omitempty"`
	PurposeAndScopeIn           []string `json:"purposeAndScopeIn,omitempty"`
	PurposeAndScopeNotIn        []string `json:"purposeAndScopeNotIn,omitempty"`
	PurposeAndScopeGt           *string  `json:"purposeAndScopeGT,omitempty"`
	PurposeAndScopeGte          *string  `json:"purposeAndScopeGTE,omitempty"`
	PurposeAndScopeLt           *string  `json:"purposeAndScopeLT,omitempty"`
	PurposeAndScopeLte          *string  `json:"purposeAndScopeLTE,omitempty"`
	PurposeAndScopeContains     *string  `json:"purposeAndScopeContains,omitempty"`
	PurposeAndScopeHasPrefix    *string  `json:"purposeAndScopeHasPrefix,omitempty"`
	PurposeAndScopeHasSuffix    *string  `json:"purposeAndScopeHasSuffix,omitempty"`
	PurposeAndScopeIsNil        *bool    `json:"purposeAndScopeIsNil,omitempty"`
	PurposeAndScopeNotNil       *bool    `json:"purposeAndScopeNotNil,omitempty"`
	PurposeAndScopeEqualFold    *string  `json:"purposeAndScopeEqualFold,omitempty"`
	PurposeAndScopeContainsFold *string  `json:"purposeAndScopeContainsFold,omitempty"`
	// background field predicates
	Background             *string  `json:"background,omitempty"`
	BackgroundNeq          *string  `json:"backgroundNEQ,omitempty"`
	BackgroundIn           []string `json:"backgroundIn,omitempty"`
	BackgroundNotIn        []string `json:"backgroundNotIn,omitempty"`
	BackgroundGt           *string  `json:"backgroundGT,omitempty"`
	BackgroundGte          *string  `json:"backgroundGTE,omitempty"`
	BackgroundLt           *string  `json:"backgroundLT,omitempty"`
	BackgroundLte          *string  `json:"backgroundLTE,omitempty"`
	BackgroundContains     *string  `json:"backgroundContains,omitempty"`
	BackgroundHasPrefix    *string  `json:"backgroundHasPrefix,omitempty"`
	BackgroundHasSuffix    *string  `json:"backgroundHasSuffix,omitempty"`
	BackgroundIsNil        *bool    `json:"backgroundIsNil,omitempty"`
	BackgroundNotNil       *bool    `json:"backgroundNotNil,omitempty"`
	BackgroundEqualFold    *string  `json:"backgroundEqualFold,omitempty"`
	BackgroundContainsFold *string  `json:"backgroundContainsFold,omitempty"`
}

type InternalPolicySearchResult struct {
	InternalPolicies []*InternalPolicy `json:"internalPolicies,omitempty"`
}

func (InternalPolicySearchResult) IsSearchResult() {}

// Return response for updateInternalPolicy mutation
type InternalPolicyUpdatePayload struct {
	// Updated internalPolicy
	InternalPolicy *InternalPolicy `json:"internalPolicy"`
}

// InternalPolicyWhereInput is used for filtering InternalPolicy objects.
// Input was generated by ent.
type InternalPolicyWhereInput struct {
	Not *InternalPolicyWhereInput   `json:"not,omitempty"`
	And []*InternalPolicyWhereInput `json:"and,omitempty"`
	Or  []*InternalPolicyWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// policy_type field predicates
	PolicyType             *string  `json:"policyType,omitempty"`
	PolicyTypeNeq          *string  `json:"policyTypeNEQ,omitempty"`
	PolicyTypeIn           []string `json:"policyTypeIn,omitempty"`
	PolicyTypeNotIn        []string `json:"policyTypeNotIn,omitempty"`
	PolicyTypeGt           *string  `json:"policyTypeGT,omitempty"`
	PolicyTypeGte          *string  `json:"policyTypeGTE,omitempty"`
	PolicyTypeLt           *string  `json:"policyTypeLT,omitempty"`
	PolicyTypeLte          *string  `json:"policyTypeLTE,omitempty"`
	PolicyTypeContains     *string  `json:"policyTypeContains,omitempty"`
	PolicyTypeHasPrefix    *string  `json:"policyTypeHasPrefix,omitempty"`
	PolicyTypeHasSuffix    *string  `json:"policyTypeHasSuffix,omitempty"`
	PolicyTypeIsNil        *bool    `json:"policyTypeIsNil,omitempty"`
	PolicyTypeNotNil       *bool    `json:"policyTypeNotNil,omitempty"`
	PolicyTypeEqualFold    *string  `json:"policyTypeEqualFold,omitempty"`
	PolicyTypeContainsFold *string  `json:"policyTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// purpose_and_scope field predicates
	PurposeAndScope             *string  `json:"purposeAndScope,omitempty"`
	PurposeAndScopeNeq          *string  `json:"purposeAndScopeNEQ,omitempty"`
	PurposeAndScopeIn           []string `json:"purposeAndScopeIn,omitempty"`
	PurposeAndScopeNotIn        []string `json:"purposeAndScopeNotIn,omitempty"`
	PurposeAndScopeGt           *string  `json:"purposeAndScopeGT,omitempty"`
	PurposeAndScopeGte          *string  `json:"purposeAndScopeGTE,omitempty"`
	PurposeAndScopeLt           *string  `json:"purposeAndScopeLT,omitempty"`
	PurposeAndScopeLte          *string  `json:"purposeAndScopeLTE,omitempty"`
	PurposeAndScopeContains     *string  `json:"purposeAndScopeContains,omitempty"`
	PurposeAndScopeHasPrefix    *string  `json:"purposeAndScopeHasPrefix,omitempty"`
	PurposeAndScopeHasSuffix    *string  `json:"purposeAndScopeHasSuffix,omitempty"`
	PurposeAndScopeIsNil        *bool    `json:"purposeAndScopeIsNil,omitempty"`
	PurposeAndScopeNotNil       *bool    `json:"purposeAndScopeNotNil,omitempty"`
	PurposeAndScopeEqualFold    *string  `json:"purposeAndScopeEqualFold,omitempty"`
	PurposeAndScopeContainsFold *string  `json:"purposeAndScopeContainsFold,omitempty"`
	// background field predicates
	Background             *string  `json:"background,omitempty"`
	BackgroundNeq          *string  `json:"backgroundNEQ,omitempty"`
	BackgroundIn           []string `json:"backgroundIn,omitempty"`
	BackgroundNotIn        []string `json:"backgroundNotIn,omitempty"`
	BackgroundGt           *string  `json:"backgroundGT,omitempty"`
	BackgroundGte          *string  `json:"backgroundGTE,omitempty"`
	BackgroundLt           *string  `json:"backgroundLT,omitempty"`
	BackgroundLte          *string  `json:"backgroundLTE,omitempty"`
	BackgroundContains     *string  `json:"backgroundContains,omitempty"`
	BackgroundHasPrefix    *string  `json:"backgroundHasPrefix,omitempty"`
	BackgroundHasSuffix    *string  `json:"backgroundHasSuffix,omitempty"`
	BackgroundIsNil        *bool    `json:"backgroundIsNil,omitempty"`
	BackgroundNotNil       *bool    `json:"backgroundNotNil,omitempty"`
	BackgroundEqualFold    *string  `json:"backgroundEqualFold,omitempty"`
	BackgroundContainsFold *string  `json:"backgroundContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

type Invite struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires *time.Time `json:"expires,omitempty"`
	// the email used as input to generate the invitation token and is the destination person the invitation is sent to who is required to accept to join the organization
	Recipient string `json:"recipient"`
	// the status of the invitation
	Status enums.InviteStatus `json:"status"`
	Role   enums.Role         `json:"role"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts int64 `json:"sendAttempts"`
	// the user who initiated the invitation
	RequestorID *string       `json:"requestorID,omitempty"`
	Owner       *Organization `json:"owner,omitempty"`
	Events      []*Event      `json:"events,omitempty"`
}

func (Invite) IsNode() {}

// Return response for createBulkInvite mutation
type InviteBulkCreatePayload struct {
	// Created invites
	Invites []*Invite `json:"invites,omitempty"`
}

// A connection to a list of items.
type InviteConnection struct {
	// A list of edges.
	Edges []*InviteEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createInvite mutation
type InviteCreatePayload struct {
	// Created invite
	Invite *Invite `json:"invite"`
}

// Return response for deleteInvite mutation
type InviteDeletePayload struct {
	// Deleted invite ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type InviteEdge struct {
	// The item at the end of the edge.
	Node *Invite `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateInvite mutation
type InviteUpdatePayload struct {
	// Updated invite
	Invite *Invite `json:"invite"`
}

// InviteWhereInput is used for filtering Invite objects.
// Input was generated by ent.
type InviteWhereInput struct {
	Not *InviteWhereInput   `json:"not,omitempty"`
	And []*InviteWhereInput `json:"and,omitempty"`
	Or  []*InviteWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// expires field predicates
	Expires       *time.Time   `json:"expires,omitempty"`
	ExpiresNeq    *time.Time   `json:"expiresNEQ,omitempty"`
	ExpiresIn     []*time.Time `json:"expiresIn,omitempty"`
	ExpiresNotIn  []*time.Time `json:"expiresNotIn,omitempty"`
	ExpiresGt     *time.Time   `json:"expiresGT,omitempty"`
	ExpiresGte    *time.Time   `json:"expiresGTE,omitempty"`
	ExpiresLt     *time.Time   `json:"expiresLT,omitempty"`
	ExpiresLte    *time.Time   `json:"expiresLTE,omitempty"`
	ExpiresIsNil  *bool        `json:"expiresIsNil,omitempty"`
	ExpiresNotNil *bool        `json:"expiresNotNil,omitempty"`
	// recipient field predicates
	Recipient             *string  `json:"recipient,omitempty"`
	RecipientNeq          *string  `json:"recipientNEQ,omitempty"`
	RecipientIn           []string `json:"recipientIn,omitempty"`
	RecipientNotIn        []string `json:"recipientNotIn,omitempty"`
	RecipientGt           *string  `json:"recipientGT,omitempty"`
	RecipientGte          *string  `json:"recipientGTE,omitempty"`
	RecipientLt           *string  `json:"recipientLT,omitempty"`
	RecipientLte          *string  `json:"recipientLTE,omitempty"`
	RecipientContains     *string  `json:"recipientContains,omitempty"`
	RecipientHasPrefix    *string  `json:"recipientHasPrefix,omitempty"`
	RecipientHasSuffix    *string  `json:"recipientHasSuffix,omitempty"`
	RecipientEqualFold    *string  `json:"recipientEqualFold,omitempty"`
	RecipientContainsFold *string  `json:"recipientContainsFold,omitempty"`
	// status field predicates
	Status      *enums.InviteStatus  `json:"status,omitempty"`
	StatusNeq   *enums.InviteStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.InviteStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.InviteStatus `json:"statusNotIn,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// send_attempts field predicates
	SendAttempts      *int64  `json:"sendAttempts,omitempty"`
	SendAttemptsNeq   *int64  `json:"sendAttemptsNEQ,omitempty"`
	SendAttemptsIn    []int64 `json:"sendAttemptsIn,omitempty"`
	SendAttemptsNotIn []int64 `json:"sendAttemptsNotIn,omitempty"`
	SendAttemptsGt    *int64  `json:"sendAttemptsGT,omitempty"`
	SendAttemptsGte   *int64  `json:"sendAttemptsGTE,omitempty"`
	SendAttemptsLt    *int64  `json:"sendAttemptsLT,omitempty"`
	SendAttemptsLte   *int64  `json:"sendAttemptsLTE,omitempty"`
	// requestor_id field predicates
	RequestorID             *string  `json:"requestorID,omitempty"`
	RequestorIdneq          *string  `json:"requestorIDNEQ,omitempty"`
	RequestorIDIn           []string `json:"requestorIDIn,omitempty"`
	RequestorIDNotIn        []string `json:"requestorIDNotIn,omitempty"`
	RequestorIdgt           *string  `json:"requestorIDGT,omitempty"`
	RequestorIdgte          *string  `json:"requestorIDGTE,omitempty"`
	RequestorIdlt           *string  `json:"requestorIDLT,omitempty"`
	RequestorIdlte          *string  `json:"requestorIDLTE,omitempty"`
	RequestorIDContains     *string  `json:"requestorIDContains,omitempty"`
	RequestorIDHasPrefix    *string  `json:"requestorIDHasPrefix,omitempty"`
	RequestorIDHasSuffix    *string  `json:"requestorIDHasSuffix,omitempty"`
	RequestorIDIsNil        *bool    `json:"requestorIDIsNil,omitempty"`
	RequestorIDNotNil       *bool    `json:"requestorIDNotNil,omitempty"`
	RequestorIDEqualFold    *string  `json:"requestorIDEqualFold,omitempty"`
	RequestorIDContainsFold *string  `json:"requestorIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type MappedControl struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the type of mapping between the two controls, e.g. subset, intersect, equal, superset
	MappingType *string `json:"mappingType,omitempty"`
	// description of how the two controls are related
	Relation *string `json:"relation,omitempty"`
	// mapped controls that have a relation to each other
	Controls []*Control `json:"controls,omitempty"`
	// mapped subcontrols that have a relation to each other
	Subcontrols []*Subcontrol `json:"subcontrols,omitempty"`
}

func (MappedControl) IsNode() {}

// Return response for createBulkMappedControl mutation
type MappedControlBulkCreatePayload struct {
	// Created mappedControls
	MappedControls []*MappedControl `json:"mappedControls,omitempty"`
}

// A connection to a list of items.
type MappedControlConnection struct {
	// A list of edges.
	Edges []*MappedControlEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createMappedControl mutation
type MappedControlCreatePayload struct {
	// Created mappedControl
	MappedControl *MappedControl `json:"mappedControl"`
}

// Return response for deleteMappedControl mutation
type MappedControlDeletePayload struct {
	// Deleted mappedControl ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type MappedControlEdge struct {
	// The item at the end of the edge.
	Node *MappedControl `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type MappedControlHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the type of mapping between the two controls, e.g. subset, intersect, equal, superset
	MappingType *string `json:"mappingType,omitempty"`
	// description of how the two controls are related
	Relation *string `json:"relation,omitempty"`
}

func (MappedControlHistory) IsNode() {}

// A connection to a list of items.
type MappedControlHistoryConnection struct {
	// A list of edges.
	Edges []*MappedControlHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type MappedControlHistoryEdge struct {
	// The item at the end of the edge.
	Node *MappedControlHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// MappedControlHistoryWhereInput is used for filtering MappedControlHistory objects.
// Input was generated by ent.
type MappedControlHistoryWhereInput struct {
	Not *MappedControlHistoryWhereInput   `json:"not,omitempty"`
	And []*MappedControlHistoryWhereInput `json:"and,omitempty"`
	Or  []*MappedControlHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// mapping_type field predicates
	MappingType             *string  `json:"mappingType,omitempty"`
	MappingTypeNeq          *string  `json:"mappingTypeNEQ,omitempty"`
	MappingTypeIn           []string `json:"mappingTypeIn,omitempty"`
	MappingTypeNotIn        []string `json:"mappingTypeNotIn,omitempty"`
	MappingTypeGt           *string  `json:"mappingTypeGT,omitempty"`
	MappingTypeGte          *string  `json:"mappingTypeGTE,omitempty"`
	MappingTypeLt           *string  `json:"mappingTypeLT,omitempty"`
	MappingTypeLte          *string  `json:"mappingTypeLTE,omitempty"`
	MappingTypeContains     *string  `json:"mappingTypeContains,omitempty"`
	MappingTypeHasPrefix    *string  `json:"mappingTypeHasPrefix,omitempty"`
	MappingTypeHasSuffix    *string  `json:"mappingTypeHasSuffix,omitempty"`
	MappingTypeIsNil        *bool    `json:"mappingTypeIsNil,omitempty"`
	MappingTypeNotNil       *bool    `json:"mappingTypeNotNil,omitempty"`
	MappingTypeEqualFold    *string  `json:"mappingTypeEqualFold,omitempty"`
	MappingTypeContainsFold *string  `json:"mappingTypeContainsFold,omitempty"`
	// relation field predicates
	Relation             *string  `json:"relation,omitempty"`
	RelationNeq          *string  `json:"relationNEQ,omitempty"`
	RelationIn           []string `json:"relationIn,omitempty"`
	RelationNotIn        []string `json:"relationNotIn,omitempty"`
	RelationGt           *string  `json:"relationGT,omitempty"`
	RelationGte          *string  `json:"relationGTE,omitempty"`
	RelationLt           *string  `json:"relationLT,omitempty"`
	RelationLte          *string  `json:"relationLTE,omitempty"`
	RelationContains     *string  `json:"relationContains,omitempty"`
	RelationHasPrefix    *string  `json:"relationHasPrefix,omitempty"`
	RelationHasSuffix    *string  `json:"relationHasSuffix,omitempty"`
	RelationIsNil        *bool    `json:"relationIsNil,omitempty"`
	RelationNotNil       *bool    `json:"relationNotNil,omitempty"`
	RelationEqualFold    *string  `json:"relationEqualFold,omitempty"`
	RelationContainsFold *string  `json:"relationContainsFold,omitempty"`
}

type MappedControlSearchResult struct {
	MappedControls []*MappedControl `json:"mappedControls,omitempty"`
}

func (MappedControlSearchResult) IsSearchResult() {}

// Return response for updateMappedControl mutation
type MappedControlUpdatePayload struct {
	// Updated mappedControl
	MappedControl *MappedControl `json:"mappedControl"`
}

// MappedControlWhereInput is used for filtering MappedControl objects.
// Input was generated by ent.
type MappedControlWhereInput struct {
	Not *MappedControlWhereInput   `json:"not,omitempty"`
	And []*MappedControlWhereInput `json:"and,omitempty"`
	Or  []*MappedControlWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// mapping_type field predicates
	MappingType             *string  `json:"mappingType,omitempty"`
	MappingTypeNeq          *string  `json:"mappingTypeNEQ,omitempty"`
	MappingTypeIn           []string `json:"mappingTypeIn,omitempty"`
	MappingTypeNotIn        []string `json:"mappingTypeNotIn,omitempty"`
	MappingTypeGt           *string  `json:"mappingTypeGT,omitempty"`
	MappingTypeGte          *string  `json:"mappingTypeGTE,omitempty"`
	MappingTypeLt           *string  `json:"mappingTypeLT,omitempty"`
	MappingTypeLte          *string  `json:"mappingTypeLTE,omitempty"`
	MappingTypeContains     *string  `json:"mappingTypeContains,omitempty"`
	MappingTypeHasPrefix    *string  `json:"mappingTypeHasPrefix,omitempty"`
	MappingTypeHasSuffix    *string  `json:"mappingTypeHasSuffix,omitempty"`
	MappingTypeIsNil        *bool    `json:"mappingTypeIsNil,omitempty"`
	MappingTypeNotNil       *bool    `json:"mappingTypeNotNil,omitempty"`
	MappingTypeEqualFold    *string  `json:"mappingTypeEqualFold,omitempty"`
	MappingTypeContainsFold *string  `json:"mappingTypeContainsFold,omitempty"`
	// relation field predicates
	Relation             *string  `json:"relation,omitempty"`
	RelationNeq          *string  `json:"relationNEQ,omitempty"`
	RelationIn           []string `json:"relationIn,omitempty"`
	RelationNotIn        []string `json:"relationNotIn,omitempty"`
	RelationGt           *string  `json:"relationGT,omitempty"`
	RelationGte          *string  `json:"relationGTE,omitempty"`
	RelationLt           *string  `json:"relationLT,omitempty"`
	RelationLte          *string  `json:"relationLTE,omitempty"`
	RelationContains     *string  `json:"relationContains,omitempty"`
	RelationHasPrefix    *string  `json:"relationHasPrefix,omitempty"`
	RelationHasSuffix    *string  `json:"relationHasSuffix,omitempty"`
	RelationIsNil        *bool    `json:"relationIsNil,omitempty"`
	RelationNotNil       *bool    `json:"relationNotNil,omitempty"`
	RelationEqualFold    *string  `json:"relationEqualFold,omitempty"`
	RelationContainsFold *string  `json:"relationContainsFold,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
}

type Mutation struct {
}

type Narrative struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the narrative
	Name string `json:"name"`
	// the description of the narrative
	Description *string `json:"description,omitempty"`
	// text data for the narrative document
	Details *string       `json:"details,omitempty"`
	Owner   *Organization `json:"owner,omitempty"`
	// groups that are blocked from viewing or editing the risk
	BlockedGroups []*Group `json:"blockedGroups,omitempty"`
	// provides edit access to the risk to members of the group
	Editors []*Group `json:"editors,omitempty"`
	// provides view access to the risk to members of the group
	Viewers []*Group `json:"viewers,omitempty"`
	// which controls are satisfied by the narrative
	Satisfies []*Control `json:"satisfies,omitempty"`
	Programs  []*Program `json:"programs,omitempty"`
}

func (Narrative) IsNode() {}

// Return response for createBulkNarrative mutation
type NarrativeBulkCreatePayload struct {
	// Created narratives
	Narratives []*Narrative `json:"narratives,omitempty"`
}

// A connection to a list of items.
type NarrativeConnection struct {
	// A list of edges.
	Edges []*NarrativeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createNarrative mutation
type NarrativeCreatePayload struct {
	// Created narrative
	Narrative *Narrative `json:"narrative"`
}

// Return response for deleteNarrative mutation
type NarrativeDeletePayload struct {
	// Deleted narrative ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type NarrativeEdge struct {
	// The item at the end of the edge.
	Node *Narrative `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type NarrativeHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the narrative
	Name string `json:"name"`
	// the description of the narrative
	Description *string `json:"description,omitempty"`
	// text data for the narrative document
	Details *string `json:"details,omitempty"`
}

func (NarrativeHistory) IsNode() {}

// A connection to a list of items.
type NarrativeHistoryConnection struct {
	// A list of edges.
	Edges []*NarrativeHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type NarrativeHistoryEdge struct {
	// The item at the end of the edge.
	Node *NarrativeHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// NarrativeHistoryWhereInput is used for filtering NarrativeHistory objects.
// Input was generated by ent.
type NarrativeHistoryWhereInput struct {
	Not *NarrativeHistoryWhereInput   `json:"not,omitempty"`
	And []*NarrativeHistoryWhereInput `json:"and,omitempty"`
	Or  []*NarrativeHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
}

type NarrativeSearchResult struct {
	Narratives []*Narrative `json:"narratives,omitempty"`
}

func (NarrativeSearchResult) IsSearchResult() {}

// Return response for updateNarrative mutation
type NarrativeUpdatePayload struct {
	// Updated narrative
	Narrative *Narrative `json:"narrative"`
}

// NarrativeWhereInput is used for filtering Narrative objects.
// Input was generated by ent.
type NarrativeWhereInput struct {
	Not *NarrativeWhereInput   `json:"not,omitempty"`
	And []*NarrativeWhereInput `json:"and,omitempty"`
	Or  []*NarrativeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// satisfies edge predicates
	HasSatisfies     *bool                `json:"hasSatisfies,omitempty"`
	HasSatisfiesWith []*ControlWhereInput `json:"hasSatisfiesWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

type Note struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string     `json:"displayID"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the text of the note
	Text  string        `json:"text"`
	Owner *Organization `json:"owner,omitempty"`
	Task  *Task         `json:"task,omitempty"`
}

func (Note) IsNode() {}

// A connection to a list of items.
type NoteConnection struct {
	// A list of edges.
	Edges []*NoteEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type NoteEdge struct {
	// The item at the end of the edge.
	Node *Note `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type NoteHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string     `json:"displayID"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the text of the note
	Text string `json:"text"`
}

func (NoteHistory) IsNode() {}

// A connection to a list of items.
type NoteHistoryConnection struct {
	// A list of edges.
	Edges []*NoteHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type NoteHistoryEdge struct {
	// The item at the end of the edge.
	Node *NoteHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// NoteHistoryWhereInput is used for filtering NoteHistory objects.
// Input was generated by ent.
type NoteHistoryWhereInput struct {
	Not *NoteHistoryWhereInput   `json:"not,omitempty"`
	And []*NoteHistoryWhereInput `json:"and,omitempty"`
	Or  []*NoteHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// text field predicates
	Text             *string  `json:"text,omitempty"`
	TextNeq          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGt           *string  `json:"textGT,omitempty"`
	TextGte          *string  `json:"textGTE,omitempty"`
	TextLt           *string  `json:"textLT,omitempty"`
	TextLte          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`
}

// NoteWhereInput is used for filtering Note objects.
// Input was generated by ent.
type NoteWhereInput struct {
	Not *NoteWhereInput   `json:"not,omitempty"`
	And []*NoteWhereInput `json:"and,omitempty"`
	Or  []*NoteWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// text field predicates
	Text             *string  `json:"text,omitempty"`
	TextNeq          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGt           *string  `json:"textGT,omitempty"`
	TextGte          *string  `json:"textGTE,omitempty"`
	TextLt           *string  `json:"textLT,omitempty"`
	TextLte          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// task edge predicates
	HasTask     *bool             `json:"hasTask,omitempty"`
	HasTaskWith []*TaskWhereInput `json:"hasTaskWith,omitempty"`
}

type Onboarding struct {
	ID             string     `json:"id"`
	DeletedAt      *time.Time `json:"deletedAt,omitempty"`
	DeletedBy      *string    `json:"deletedBy,omitempty"`
	OrganizationID *string    `json:"organizationID,omitempty"`
	// name of the company
	CompanyName string `json:"companyName"`
	// domains associated with the company
	Domains []string `json:"domains,omitempty"`
	// details given about the company during the onboarding process, including things such as company size, sector, etc
	CompanyDetails map[string]any `json:"companyDetails,omitempty"`
	// details given about the user during the onboarding process, including things such as name, job title, department, etc
	UserDetails map[string]any `json:"userDetails,omitempty"`
	// details given about the compliance requirements during the onboarding process, such as coming with existing policies, controls, risk assessments, etc
	Compliance   map[string]any `json:"compliance,omitempty"`
	Organization *Organization  `json:"organization,omitempty"`
}

func (Onboarding) IsNode() {}

// Return response for createOnboarding mutation
type OnboardingCreatePayload struct {
	// Created onboarding
	Onboarding *Onboarding `json:"onboarding"`
}

// OnboardingWhereInput is used for filtering Onboarding objects.
// Input was generated by ent.
type OnboardingWhereInput struct {
	Not *OnboardingWhereInput   `json:"not,omitempty"`
	And []*OnboardingWhereInput `json:"and,omitempty"`
	Or  []*OnboardingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        *bool    `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       *bool    `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// company_name field predicates
	CompanyName             *string  `json:"companyName,omitempty"`
	CompanyNameNeq          *string  `json:"companyNameNEQ,omitempty"`
	CompanyNameIn           []string `json:"companyNameIn,omitempty"`
	CompanyNameNotIn        []string `json:"companyNameNotIn,omitempty"`
	CompanyNameGt           *string  `json:"companyNameGT,omitempty"`
	CompanyNameGte          *string  `json:"companyNameGTE,omitempty"`
	CompanyNameLt           *string  `json:"companyNameLT,omitempty"`
	CompanyNameLte          *string  `json:"companyNameLTE,omitempty"`
	CompanyNameContains     *string  `json:"companyNameContains,omitempty"`
	CompanyNameHasPrefix    *string  `json:"companyNameHasPrefix,omitempty"`
	CompanyNameHasSuffix    *string  `json:"companyNameHasSuffix,omitempty"`
	CompanyNameEqualFold    *string  `json:"companyNameEqualFold,omitempty"`
	CompanyNameContainsFold *string  `json:"companyNameContainsFold,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
}

// OrgMembersInput is used to create members for a organization
// along with the org creation
type OrgMembersInput struct {
	Role   *enums.Role `json:"role,omitempty"`
	UserID string      `json:"userID"`
}

type OrgMembership struct {
	ID             string        `json:"id"`
	CreatedAt      *time.Time    `json:"createdAt,omitempty"`
	UpdatedAt      *time.Time    `json:"updatedAt,omitempty"`
	CreatedBy      *string       `json:"createdBy,omitempty"`
	UpdatedBy      *string       `json:"updatedBy,omitempty"`
	DeletedAt      *time.Time    `json:"deletedAt,omitempty"`
	DeletedBy      *string       `json:"deletedBy,omitempty"`
	Role           enums.Role    `json:"role"`
	OrganizationID string        `json:"organizationID"`
	UserID         string        `json:"userID"`
	Organization   *Organization `json:"organization"`
	User           *User         `json:"user"`
	Events         []*Event      `json:"events,omitempty"`
}

func (OrgMembership) IsNode() {}

// Return response for createBulkOrgMembership mutation
type OrgMembershipBulkCreatePayload struct {
	// Created orgMemberships
	OrgMemberships []*OrgMembership `json:"orgMemberships,omitempty"`
}

// A connection to a list of items.
type OrgMembershipConnection struct {
	// A list of edges.
	Edges []*OrgMembershipEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrgMembership mutation
type OrgMembershipCreatePayload struct {
	// Created orgMembership
	OrgMembership *OrgMembership `json:"orgMembership"`
}

// Return response for deleteOrgMembership mutation
type OrgMembershipDeletePayload struct {
	// Deleted orgMembership ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrgMembershipEdge struct {
	// The item at the end of the edge.
	Node *OrgMembership `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrgMembershipHistory struct {
	ID             string         `json:"id"`
	HistoryTime    time.Time      `json:"historyTime"`
	Ref            *string        `json:"ref,omitempty"`
	Operation      history.OpType `json:"operation"`
	CreatedAt      *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt      *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy      *string        `json:"createdBy,omitempty"`
	UpdatedBy      *string        `json:"updatedBy,omitempty"`
	DeletedAt      *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy      *string        `json:"deletedBy,omitempty"`
	Role           enums.Role     `json:"role"`
	OrganizationID string         `json:"organizationID"`
	UserID         string         `json:"userID"`
}

func (OrgMembershipHistory) IsNode() {}

// A connection to a list of items.
type OrgMembershipHistoryConnection struct {
	// A list of edges.
	Edges []*OrgMembershipHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrgMembershipHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrgMembershipHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// OrgMembershipHistoryWhereInput is used for filtering OrgMembershipHistory objects.
// Input was generated by ent.
type OrgMembershipHistoryWhereInput struct {
	Not *OrgMembershipHistoryWhereInput   `json:"not,omitempty"`
	And []*OrgMembershipHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrgMembershipHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// Return response for updateOrgMembership mutation
type OrgMembershipUpdatePayload struct {
	// Updated orgMembership
	OrgMembership *OrgMembership `json:"orgMembership"`
}

// OrgMembershipWhereInput is used for filtering OrgMembership objects.
// Input was generated by ent.
type OrgMembershipWhereInput struct {
	Not *OrgMembershipWhereInput   `json:"not,omitempty"`
	And []*OrgMembershipWhereInput `json:"and,omitempty"`
	Or  []*OrgMembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role           *enums.Role  `json:"role,omitempty"`
	RoleNeq        *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn         []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn      []enums.Role `json:"roleNotIn,omitempty"`
	OrganizationID *string      `json:"organizationID,omitempty"`
	UserID         *string      `json:"userID,omitempty"`
}

type OrgSubscription struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the stripe subscription id
	StripeSubscriptionID *string `json:"stripeSubscriptionID,omitempty"`
	// the common name of the product tier the subscription is associated with, e.g. starter tier
	ProductTier *string `json:"productTier,omitempty"`
	// the price of the product tier
	ProductPrice *models.Price `json:"productPrice,omitempty"`
	// the product id that represents the tier in stripe
	StripeProductTierID *string `json:"stripeProductTierID,omitempty"`
	// the status of the subscription in stripe -- see https://docs.stripe.com/api/subscriptions/object#subscription_object-status
	StripeSubscriptionStatus *string `json:"stripeSubscriptionStatus,omitempty"`
	// indicates if the subscription is active
	Active bool `json:"active"`
	// the customer ID the subscription is associated to
	StripeCustomerID *string `json:"stripeCustomerID,omitempty"`
	// the time the subscription is set to expire; only populated if subscription is cancelled
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// the time the trial is set to expire
	TrialExpiresAt *time.Time `json:"trialExpiresAt,omitempty"`
	// number of days until there is a due payment
	DaysUntilDue *string `json:"daysUntilDue,omitempty"`
	// whether or not a payment method has been added to the account
	PaymentMethodAdded *bool `json:"paymentMethodAdded,omitempty"`
	// the features associated with the subscription
	Features []string `json:"features,omitempty"`
	// the feature lookup keys associated with the subscription
	FeatureLookupKeys    []string      `json:"featureLookupKeys,omitempty"`
	Owner                *Organization `json:"owner,omitempty"`
	Events               []*Event      `json:"events,omitempty"`
	SubscriptionURL      *string       `json:"subscriptionURL,omitempty"`
	ManagePaymentMethods *string       `json:"managePaymentMethods,omitempty"`
	Cancellation         *string       `json:"cancellation,omitempty"`
}

func (OrgSubscription) IsNode() {}

// A connection to a list of items.
type OrgSubscriptionConnection struct {
	// A list of edges.
	Edges []*OrgSubscriptionEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrgSubscriptionEdge struct {
	// The item at the end of the edge.
	Node *OrgSubscription `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrgSubscriptionHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the stripe subscription id
	StripeSubscriptionID *string `json:"stripeSubscriptionID,omitempty"`
	// the common name of the product tier the subscription is associated with, e.g. starter tier
	ProductTier *string `json:"productTier,omitempty"`
	// the price of the product tier
	ProductPrice *models.Price `json:"productPrice,omitempty"`
	// the product id that represents the tier in stripe
	StripeProductTierID *string `json:"stripeProductTierID,omitempty"`
	// the status of the subscription in stripe -- see https://docs.stripe.com/api/subscriptions/object#subscription_object-status
	StripeSubscriptionStatus *string `json:"stripeSubscriptionStatus,omitempty"`
	// indicates if the subscription is active
	Active bool `json:"active"`
	// the customer ID the subscription is associated to
	StripeCustomerID *string `json:"stripeCustomerID,omitempty"`
	// the time the subscription is set to expire; only populated if subscription is cancelled
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// the time the trial is set to expire
	TrialExpiresAt *time.Time `json:"trialExpiresAt,omitempty"`
	// number of days until there is a due payment
	DaysUntilDue *string `json:"daysUntilDue,omitempty"`
	// whether or not a payment method has been added to the account
	PaymentMethodAdded *bool `json:"paymentMethodAdded,omitempty"`
	// the features associated with the subscription
	Features []string `json:"features,omitempty"`
	// the feature lookup keys associated with the subscription
	FeatureLookupKeys []string `json:"featureLookupKeys,omitempty"`
}

func (OrgSubscriptionHistory) IsNode() {}

// A connection to a list of items.
type OrgSubscriptionHistoryConnection struct {
	// A list of edges.
	Edges []*OrgSubscriptionHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrgSubscriptionHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrgSubscriptionHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// OrgSubscriptionHistoryWhereInput is used for filtering OrgSubscriptionHistory objects.
// Input was generated by ent.
type OrgSubscriptionHistoryWhereInput struct {
	Not *OrgSubscriptionHistoryWhereInput   `json:"not,omitempty"`
	And []*OrgSubscriptionHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrgSubscriptionHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// stripe_subscription_id field predicates
	StripeSubscriptionID             *string  `json:"stripeSubscriptionID,omitempty"`
	StripeSubscriptionIdneq          *string  `json:"stripeSubscriptionIDNEQ,omitempty"`
	StripeSubscriptionIDIn           []string `json:"stripeSubscriptionIDIn,omitempty"`
	StripeSubscriptionIDNotIn        []string `json:"stripeSubscriptionIDNotIn,omitempty"`
	StripeSubscriptionIdgt           *string  `json:"stripeSubscriptionIDGT,omitempty"`
	StripeSubscriptionIdgte          *string  `json:"stripeSubscriptionIDGTE,omitempty"`
	StripeSubscriptionIdlt           *string  `json:"stripeSubscriptionIDLT,omitempty"`
	StripeSubscriptionIdlte          *string  `json:"stripeSubscriptionIDLTE,omitempty"`
	StripeSubscriptionIDContains     *string  `json:"stripeSubscriptionIDContains,omitempty"`
	StripeSubscriptionIDHasPrefix    *string  `json:"stripeSubscriptionIDHasPrefix,omitempty"`
	StripeSubscriptionIDHasSuffix    *string  `json:"stripeSubscriptionIDHasSuffix,omitempty"`
	StripeSubscriptionIDIsNil        *bool    `json:"stripeSubscriptionIDIsNil,omitempty"`
	StripeSubscriptionIDNotNil       *bool    `json:"stripeSubscriptionIDNotNil,omitempty"`
	StripeSubscriptionIDEqualFold    *string  `json:"stripeSubscriptionIDEqualFold,omitempty"`
	StripeSubscriptionIDContainsFold *string  `json:"stripeSubscriptionIDContainsFold,omitempty"`
	// product_tier field predicates
	ProductTier             *string  `json:"productTier,omitempty"`
	ProductTierNeq          *string  `json:"productTierNEQ,omitempty"`
	ProductTierIn           []string `json:"productTierIn,omitempty"`
	ProductTierNotIn        []string `json:"productTierNotIn,omitempty"`
	ProductTierGt           *string  `json:"productTierGT,omitempty"`
	ProductTierGte          *string  `json:"productTierGTE,omitempty"`
	ProductTierLt           *string  `json:"productTierLT,omitempty"`
	ProductTierLte          *string  `json:"productTierLTE,omitempty"`
	ProductTierContains     *string  `json:"productTierContains,omitempty"`
	ProductTierHasPrefix    *string  `json:"productTierHasPrefix,omitempty"`
	ProductTierHasSuffix    *string  `json:"productTierHasSuffix,omitempty"`
	ProductTierIsNil        *bool    `json:"productTierIsNil,omitempty"`
	ProductTierNotNil       *bool    `json:"productTierNotNil,omitempty"`
	ProductTierEqualFold    *string  `json:"productTierEqualFold,omitempty"`
	ProductTierContainsFold *string  `json:"productTierContainsFold,omitempty"`
	// stripe_product_tier_id field predicates
	StripeProductTierID             *string  `json:"stripeProductTierID,omitempty"`
	StripeProductTierIdneq          *string  `json:"stripeProductTierIDNEQ,omitempty"`
	StripeProductTierIDIn           []string `json:"stripeProductTierIDIn,omitempty"`
	StripeProductTierIDNotIn        []string `json:"stripeProductTierIDNotIn,omitempty"`
	StripeProductTierIdgt           *string  `json:"stripeProductTierIDGT,omitempty"`
	StripeProductTierIdgte          *string  `json:"stripeProductTierIDGTE,omitempty"`
	StripeProductTierIdlt           *string  `json:"stripeProductTierIDLT,omitempty"`
	StripeProductTierIdlte          *string  `json:"stripeProductTierIDLTE,omitempty"`
	StripeProductTierIDContains     *string  `json:"stripeProductTierIDContains,omitempty"`
	StripeProductTierIDHasPrefix    *string  `json:"stripeProductTierIDHasPrefix,omitempty"`
	StripeProductTierIDHasSuffix    *string  `json:"stripeProductTierIDHasSuffix,omitempty"`
	StripeProductTierIDIsNil        *bool    `json:"stripeProductTierIDIsNil,omitempty"`
	StripeProductTierIDNotNil       *bool    `json:"stripeProductTierIDNotNil,omitempty"`
	StripeProductTierIDEqualFold    *string  `json:"stripeProductTierIDEqualFold,omitempty"`
	StripeProductTierIDContainsFold *string  `json:"stripeProductTierIDContainsFold,omitempty"`
	// stripe_subscription_status field predicates
	StripeSubscriptionStatus             *string  `json:"stripeSubscriptionStatus,omitempty"`
	StripeSubscriptionStatusNeq          *string  `json:"stripeSubscriptionStatusNEQ,omitempty"`
	StripeSubscriptionStatusIn           []string `json:"stripeSubscriptionStatusIn,omitempty"`
	StripeSubscriptionStatusNotIn        []string `json:"stripeSubscriptionStatusNotIn,omitempty"`
	StripeSubscriptionStatusGt           *string  `json:"stripeSubscriptionStatusGT,omitempty"`
	StripeSubscriptionStatusGte          *string  `json:"stripeSubscriptionStatusGTE,omitempty"`
	StripeSubscriptionStatusLt           *string  `json:"stripeSubscriptionStatusLT,omitempty"`
	StripeSubscriptionStatusLte          *string  `json:"stripeSubscriptionStatusLTE,omitempty"`
	StripeSubscriptionStatusContains     *string  `json:"stripeSubscriptionStatusContains,omitempty"`
	StripeSubscriptionStatusHasPrefix    *string  `json:"stripeSubscriptionStatusHasPrefix,omitempty"`
	StripeSubscriptionStatusHasSuffix    *string  `json:"stripeSubscriptionStatusHasSuffix,omitempty"`
	StripeSubscriptionStatusIsNil        *bool    `json:"stripeSubscriptionStatusIsNil,omitempty"`
	StripeSubscriptionStatusNotNil       *bool    `json:"stripeSubscriptionStatusNotNil,omitempty"`
	StripeSubscriptionStatusEqualFold    *string  `json:"stripeSubscriptionStatusEqualFold,omitempty"`
	StripeSubscriptionStatusContainsFold *string  `json:"stripeSubscriptionStatusContainsFold,omitempty"`
	// active field predicates
	Active    *bool `json:"active,omitempty"`
	ActiveNeq *bool `json:"activeNEQ,omitempty"`
	// stripe_customer_id field predicates
	StripeCustomerID             *string  `json:"stripeCustomerID,omitempty"`
	StripeCustomerIdneq          *string  `json:"stripeCustomerIDNEQ,omitempty"`
	StripeCustomerIDIn           []string `json:"stripeCustomerIDIn,omitempty"`
	StripeCustomerIDNotIn        []string `json:"stripeCustomerIDNotIn,omitempty"`
	StripeCustomerIdgt           *string  `json:"stripeCustomerIDGT,omitempty"`
	StripeCustomerIdgte          *string  `json:"stripeCustomerIDGTE,omitempty"`
	StripeCustomerIdlt           *string  `json:"stripeCustomerIDLT,omitempty"`
	StripeCustomerIdlte          *string  `json:"stripeCustomerIDLTE,omitempty"`
	StripeCustomerIDContains     *string  `json:"stripeCustomerIDContains,omitempty"`
	StripeCustomerIDHasPrefix    *string  `json:"stripeCustomerIDHasPrefix,omitempty"`
	StripeCustomerIDHasSuffix    *string  `json:"stripeCustomerIDHasSuffix,omitempty"`
	StripeCustomerIDIsNil        *bool    `json:"stripeCustomerIDIsNil,omitempty"`
	StripeCustomerIDNotNil       *bool    `json:"stripeCustomerIDNotNil,omitempty"`
	StripeCustomerIDEqualFold    *string  `json:"stripeCustomerIDEqualFold,omitempty"`
	StripeCustomerIDContainsFold *string  `json:"stripeCustomerIDContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// trial_expires_at field predicates
	TrialExpiresAt       *time.Time   `json:"trialExpiresAt,omitempty"`
	TrialExpiresAtNeq    *time.Time   `json:"trialExpiresAtNEQ,omitempty"`
	TrialExpiresAtIn     []*time.Time `json:"trialExpiresAtIn,omitempty"`
	TrialExpiresAtNotIn  []*time.Time `json:"trialExpiresAtNotIn,omitempty"`
	TrialExpiresAtGt     *time.Time   `json:"trialExpiresAtGT,omitempty"`
	TrialExpiresAtGte    *time.Time   `json:"trialExpiresAtGTE,omitempty"`
	TrialExpiresAtLt     *time.Time   `json:"trialExpiresAtLT,omitempty"`
	TrialExpiresAtLte    *time.Time   `json:"trialExpiresAtLTE,omitempty"`
	TrialExpiresAtIsNil  *bool        `json:"trialExpiresAtIsNil,omitempty"`
	TrialExpiresAtNotNil *bool        `json:"trialExpiresAtNotNil,omitempty"`
	// days_until_due field predicates
	DaysUntilDue             *string  `json:"daysUntilDue,omitempty"`
	DaysUntilDueNeq          *string  `json:"daysUntilDueNEQ,omitempty"`
	DaysUntilDueIn           []string `json:"daysUntilDueIn,omitempty"`
	DaysUntilDueNotIn        []string `json:"daysUntilDueNotIn,omitempty"`
	DaysUntilDueGt           *string  `json:"daysUntilDueGT,omitempty"`
	DaysUntilDueGte          *string  `json:"daysUntilDueGTE,omitempty"`
	DaysUntilDueLt           *string  `json:"daysUntilDueLT,omitempty"`
	DaysUntilDueLte          *string  `json:"daysUntilDueLTE,omitempty"`
	DaysUntilDueContains     *string  `json:"daysUntilDueContains,omitempty"`
	DaysUntilDueHasPrefix    *string  `json:"daysUntilDueHasPrefix,omitempty"`
	DaysUntilDueHasSuffix    *string  `json:"daysUntilDueHasSuffix,omitempty"`
	DaysUntilDueIsNil        *bool    `json:"daysUntilDueIsNil,omitempty"`
	DaysUntilDueNotNil       *bool    `json:"daysUntilDueNotNil,omitempty"`
	DaysUntilDueEqualFold    *string  `json:"daysUntilDueEqualFold,omitempty"`
	DaysUntilDueContainsFold *string  `json:"daysUntilDueContainsFold,omitempty"`
	// payment_method_added field predicates
	PaymentMethodAdded       *bool `json:"paymentMethodAdded,omitempty"`
	PaymentMethodAddedNeq    *bool `json:"paymentMethodAddedNEQ,omitempty"`
	PaymentMethodAddedIsNil  *bool `json:"paymentMethodAddedIsNil,omitempty"`
	PaymentMethodAddedNotNil *bool `json:"paymentMethodAddedNotNil,omitempty"`
}

type OrgSubscriptionSearchResult struct {
	OrgSubscriptions []*OrgSubscription `json:"orgSubscriptions,omitempty"`
}

func (OrgSubscriptionSearchResult) IsSearchResult() {}

// OrgSubscriptionWhereInput is used for filtering OrgSubscription objects.
// Input was generated by ent.
type OrgSubscriptionWhereInput struct {
	Not *OrgSubscriptionWhereInput   `json:"not,omitempty"`
	And []*OrgSubscriptionWhereInput `json:"and,omitempty"`
	Or  []*OrgSubscriptionWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// stripe_subscription_id field predicates
	StripeSubscriptionID             *string  `json:"stripeSubscriptionID,omitempty"`
	StripeSubscriptionIdneq          *string  `json:"stripeSubscriptionIDNEQ,omitempty"`
	StripeSubscriptionIDIn           []string `json:"stripeSubscriptionIDIn,omitempty"`
	StripeSubscriptionIDNotIn        []string `json:"stripeSubscriptionIDNotIn,omitempty"`
	StripeSubscriptionIdgt           *string  `json:"stripeSubscriptionIDGT,omitempty"`
	StripeSubscriptionIdgte          *string  `json:"stripeSubscriptionIDGTE,omitempty"`
	StripeSubscriptionIdlt           *string  `json:"stripeSubscriptionIDLT,omitempty"`
	StripeSubscriptionIdlte          *string  `json:"stripeSubscriptionIDLTE,omitempty"`
	StripeSubscriptionIDContains     *string  `json:"stripeSubscriptionIDContains,omitempty"`
	StripeSubscriptionIDHasPrefix    *string  `json:"stripeSubscriptionIDHasPrefix,omitempty"`
	StripeSubscriptionIDHasSuffix    *string  `json:"stripeSubscriptionIDHasSuffix,omitempty"`
	StripeSubscriptionIDIsNil        *bool    `json:"stripeSubscriptionIDIsNil,omitempty"`
	StripeSubscriptionIDNotNil       *bool    `json:"stripeSubscriptionIDNotNil,omitempty"`
	StripeSubscriptionIDEqualFold    *string  `json:"stripeSubscriptionIDEqualFold,omitempty"`
	StripeSubscriptionIDContainsFold *string  `json:"stripeSubscriptionIDContainsFold,omitempty"`
	// product_tier field predicates
	ProductTier             *string  `json:"productTier,omitempty"`
	ProductTierNeq          *string  `json:"productTierNEQ,omitempty"`
	ProductTierIn           []string `json:"productTierIn,omitempty"`
	ProductTierNotIn        []string `json:"productTierNotIn,omitempty"`
	ProductTierGt           *string  `json:"productTierGT,omitempty"`
	ProductTierGte          *string  `json:"productTierGTE,omitempty"`
	ProductTierLt           *string  `json:"productTierLT,omitempty"`
	ProductTierLte          *string  `json:"productTierLTE,omitempty"`
	ProductTierContains     *string  `json:"productTierContains,omitempty"`
	ProductTierHasPrefix    *string  `json:"productTierHasPrefix,omitempty"`
	ProductTierHasSuffix    *string  `json:"productTierHasSuffix,omitempty"`
	ProductTierIsNil        *bool    `json:"productTierIsNil,omitempty"`
	ProductTierNotNil       *bool    `json:"productTierNotNil,omitempty"`
	ProductTierEqualFold    *string  `json:"productTierEqualFold,omitempty"`
	ProductTierContainsFold *string  `json:"productTierContainsFold,omitempty"`
	// stripe_product_tier_id field predicates
	StripeProductTierID             *string  `json:"stripeProductTierID,omitempty"`
	StripeProductTierIdneq          *string  `json:"stripeProductTierIDNEQ,omitempty"`
	StripeProductTierIDIn           []string `json:"stripeProductTierIDIn,omitempty"`
	StripeProductTierIDNotIn        []string `json:"stripeProductTierIDNotIn,omitempty"`
	StripeProductTierIdgt           *string  `json:"stripeProductTierIDGT,omitempty"`
	StripeProductTierIdgte          *string  `json:"stripeProductTierIDGTE,omitempty"`
	StripeProductTierIdlt           *string  `json:"stripeProductTierIDLT,omitempty"`
	StripeProductTierIdlte          *string  `json:"stripeProductTierIDLTE,omitempty"`
	StripeProductTierIDContains     *string  `json:"stripeProductTierIDContains,omitempty"`
	StripeProductTierIDHasPrefix    *string  `json:"stripeProductTierIDHasPrefix,omitempty"`
	StripeProductTierIDHasSuffix    *string  `json:"stripeProductTierIDHasSuffix,omitempty"`
	StripeProductTierIDIsNil        *bool    `json:"stripeProductTierIDIsNil,omitempty"`
	StripeProductTierIDNotNil       *bool    `json:"stripeProductTierIDNotNil,omitempty"`
	StripeProductTierIDEqualFold    *string  `json:"stripeProductTierIDEqualFold,omitempty"`
	StripeProductTierIDContainsFold *string  `json:"stripeProductTierIDContainsFold,omitempty"`
	// stripe_subscription_status field predicates
	StripeSubscriptionStatus             *string  `json:"stripeSubscriptionStatus,omitempty"`
	StripeSubscriptionStatusNeq          *string  `json:"stripeSubscriptionStatusNEQ,omitempty"`
	StripeSubscriptionStatusIn           []string `json:"stripeSubscriptionStatusIn,omitempty"`
	StripeSubscriptionStatusNotIn        []string `json:"stripeSubscriptionStatusNotIn,omitempty"`
	StripeSubscriptionStatusGt           *string  `json:"stripeSubscriptionStatusGT,omitempty"`
	StripeSubscriptionStatusGte          *string  `json:"stripeSubscriptionStatusGTE,omitempty"`
	StripeSubscriptionStatusLt           *string  `json:"stripeSubscriptionStatusLT,omitempty"`
	StripeSubscriptionStatusLte          *string  `json:"stripeSubscriptionStatusLTE,omitempty"`
	StripeSubscriptionStatusContains     *string  `json:"stripeSubscriptionStatusContains,omitempty"`
	StripeSubscriptionStatusHasPrefix    *string  `json:"stripeSubscriptionStatusHasPrefix,omitempty"`
	StripeSubscriptionStatusHasSuffix    *string  `json:"stripeSubscriptionStatusHasSuffix,omitempty"`
	StripeSubscriptionStatusIsNil        *bool    `json:"stripeSubscriptionStatusIsNil,omitempty"`
	StripeSubscriptionStatusNotNil       *bool    `json:"stripeSubscriptionStatusNotNil,omitempty"`
	StripeSubscriptionStatusEqualFold    *string  `json:"stripeSubscriptionStatusEqualFold,omitempty"`
	StripeSubscriptionStatusContainsFold *string  `json:"stripeSubscriptionStatusContainsFold,omitempty"`
	// active field predicates
	Active    *bool `json:"active,omitempty"`
	ActiveNeq *bool `json:"activeNEQ,omitempty"`
	// stripe_customer_id field predicates
	StripeCustomerID             *string  `json:"stripeCustomerID,omitempty"`
	StripeCustomerIdneq          *string  `json:"stripeCustomerIDNEQ,omitempty"`
	StripeCustomerIDIn           []string `json:"stripeCustomerIDIn,omitempty"`
	StripeCustomerIDNotIn        []string `json:"stripeCustomerIDNotIn,omitempty"`
	StripeCustomerIdgt           *string  `json:"stripeCustomerIDGT,omitempty"`
	StripeCustomerIdgte          *string  `json:"stripeCustomerIDGTE,omitempty"`
	StripeCustomerIdlt           *string  `json:"stripeCustomerIDLT,omitempty"`
	StripeCustomerIdlte          *string  `json:"stripeCustomerIDLTE,omitempty"`
	StripeCustomerIDContains     *string  `json:"stripeCustomerIDContains,omitempty"`
	StripeCustomerIDHasPrefix    *string  `json:"stripeCustomerIDHasPrefix,omitempty"`
	StripeCustomerIDHasSuffix    *string  `json:"stripeCustomerIDHasSuffix,omitempty"`
	StripeCustomerIDIsNil        *bool    `json:"stripeCustomerIDIsNil,omitempty"`
	StripeCustomerIDNotNil       *bool    `json:"stripeCustomerIDNotNil,omitempty"`
	StripeCustomerIDEqualFold    *string  `json:"stripeCustomerIDEqualFold,omitempty"`
	StripeCustomerIDContainsFold *string  `json:"stripeCustomerIDContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// trial_expires_at field predicates
	TrialExpiresAt       *time.Time   `json:"trialExpiresAt,omitempty"`
	TrialExpiresAtNeq    *time.Time   `json:"trialExpiresAtNEQ,omitempty"`
	TrialExpiresAtIn     []*time.Time `json:"trialExpiresAtIn,omitempty"`
	TrialExpiresAtNotIn  []*time.Time `json:"trialExpiresAtNotIn,omitempty"`
	TrialExpiresAtGt     *time.Time   `json:"trialExpiresAtGT,omitempty"`
	TrialExpiresAtGte    *time.Time   `json:"trialExpiresAtGTE,omitempty"`
	TrialExpiresAtLt     *time.Time   `json:"trialExpiresAtLT,omitempty"`
	TrialExpiresAtLte    *time.Time   `json:"trialExpiresAtLTE,omitempty"`
	TrialExpiresAtIsNil  *bool        `json:"trialExpiresAtIsNil,omitempty"`
	TrialExpiresAtNotNil *bool        `json:"trialExpiresAtNotNil,omitempty"`
	// days_until_due field predicates
	DaysUntilDue             *string  `json:"daysUntilDue,omitempty"`
	DaysUntilDueNeq          *string  `json:"daysUntilDueNEQ,omitempty"`
	DaysUntilDueIn           []string `json:"daysUntilDueIn,omitempty"`
	DaysUntilDueNotIn        []string `json:"daysUntilDueNotIn,omitempty"`
	DaysUntilDueGt           *string  `json:"daysUntilDueGT,omitempty"`
	DaysUntilDueGte          *string  `json:"daysUntilDueGTE,omitempty"`
	DaysUntilDueLt           *string  `json:"daysUntilDueLT,omitempty"`
	DaysUntilDueLte          *string  `json:"daysUntilDueLTE,omitempty"`
	DaysUntilDueContains     *string  `json:"daysUntilDueContains,omitempty"`
	DaysUntilDueHasPrefix    *string  `json:"daysUntilDueHasPrefix,omitempty"`
	DaysUntilDueHasSuffix    *string  `json:"daysUntilDueHasSuffix,omitempty"`
	DaysUntilDueIsNil        *bool    `json:"daysUntilDueIsNil,omitempty"`
	DaysUntilDueNotNil       *bool    `json:"daysUntilDueNotNil,omitempty"`
	DaysUntilDueEqualFold    *string  `json:"daysUntilDueEqualFold,omitempty"`
	DaysUntilDueContainsFold *string  `json:"daysUntilDueContainsFold,omitempty"`
	// payment_method_added field predicates
	PaymentMethodAdded       *bool `json:"paymentMethodAdded,omitempty"`
	PaymentMethodAddedNeq    *bool `json:"paymentMethodAddedNEQ,omitempty"`
	PaymentMethodAddedIsNil  *bool `json:"paymentMethodAddedIsNil,omitempty"`
	PaymentMethodAddedNotNil *bool `json:"paymentMethodAddedNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Organization struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the name of the organization
	Name string `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// An optional description of the organization
	Description *string `json:"description,omitempty"`
	// orgs directly associated with a user
	PersonalOrg *bool `json:"personalOrg,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The organizations's local avatar file id, takes precedence over the avatar remote URL
	AvatarLocalFileID *string `json:"avatarLocalFileID,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// Whether the organization has a dedicated database
	DedicatedDb bool `json:"dedicatedDb"`
	// groups that are allowed to create controls
	ControlCreators []*Group `json:"controlCreators,omitempty"`
	// groups that are allowed to create control_objectives
	ControlObjectiveCreators []*Group `json:"controlObjectiveCreators,omitempty"`
	// groups that are allowed to create groups
	GroupCreators []*Group `json:"groupCreators,omitempty"`
	// groups that are allowed to create internal_policys
	InternalPolicyCreators []*Group `json:"internalPolicyCreators,omitempty"`
	// groups that are allowed to create narratives
	NarrativeCreators []*Group `json:"narrativeCreators,omitempty"`
	// groups that are allowed to create procedures
	ProcedureCreators []*Group `json:"procedureCreators,omitempty"`
	// groups that are allowed to create programs
	ProgramCreators []*Group `json:"programCreators,omitempty"`
	// groups that are allowed to create risks
	RiskCreators []*Group `json:"riskCreators,omitempty"`
	// groups that are allowed to create templates
	TemplateCreators     []*Group                `json:"templateCreators,omitempty"`
	Parent               *Organization           `json:"parent,omitempty"`
	Children             *OrganizationConnection `json:"children"`
	Setting              *OrganizationSetting    `json:"setting,omitempty"`
	PersonalAccessTokens []*PersonalAccessToken  `json:"personalAccessTokens,omitempty"`
	APITokens            []*APIToken             `json:"apiTokens,omitempty"`
	Users                []*User                 `json:"users,omitempty"`
	Files                []*File                 `json:"files,omitempty"`
	Events               []*Event                `json:"events,omitempty"`
	Secrets              []*Hush                 `json:"secrets,omitempty"`
	AvatarFile           *File                   `json:"avatarFile,omitempty"`
	Groups               []*Group                `json:"groups,omitempty"`
	Templates            []*Template             `json:"templates,omitempty"`
	Integrations         []*Integration          `json:"integrations,omitempty"`
	DocumentData         []*DocumentData         `json:"documentData,omitempty"`
	OrgSubscriptions     []*OrgSubscription      `json:"orgSubscriptions,omitempty"`
	Invites              []*Invite               `json:"invites,omitempty"`
	Subscribers          []*Subscriber           `json:"subscribers,omitempty"`
	Entities             []*Entity               `json:"entities,omitempty"`
	EntityTypes          []*EntityType           `json:"entityTypes,omitempty"`
	Contacts             []*Contact              `json:"contacts,omitempty"`
	Notes                []*Note                 `json:"notes,omitempty"`
	Tasks                []*Task                 `json:"tasks,omitempty"`
	Programs             []*Program              `json:"programs,omitempty"`
	Procedures           []*Procedure            `json:"procedures,omitempty"`
	InternalPolicies     []*InternalPolicy       `json:"internalPolicies,omitempty"`
	Risks                []*Risk                 `json:"risks,omitempty"`
	ControlObjectives    []*ControlObjective     `json:"controlObjectives,omitempty"`
	Narratives           []*Narrative            `json:"narratives,omitempty"`
	Controls             []*Control              `json:"controls,omitempty"`
	Subcontrols          []*Subcontrol           `json:"subcontrols,omitempty"`
	Evidence             []*Evidence             `json:"evidence,omitempty"`
	Standards            []*Standard             `json:"standards,omitempty"`
	Members              []*OrgMembership        `json:"members,omitempty"`
}

func (Organization) IsNode() {}

// Return response for createBulkOrganization mutation
type OrganizationBulkCreatePayload struct {
	// Created organizations
	Organizations []*Organization `json:"organizations,omitempty"`
}

// A connection to a list of items.
type OrganizationConnection struct {
	// A list of edges.
	Edges []*OrganizationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrganization mutation
type OrganizationCreatePayload struct {
	// Created organization
	Organization *Organization `json:"organization"`
}

// Return response for deleteOrganization mutation
type OrganizationDeletePayload struct {
	// Deleted organization ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrganizationEdge struct {
	// The item at the end of the edge.
	Node *Organization `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrganizationHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the name of the organization
	Name string `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// An optional description of the organization
	Description *string `json:"description,omitempty"`
	// orgs directly associated with a user
	PersonalOrg *bool `json:"personalOrg,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The organizations's local avatar file id, takes precedence over the avatar remote URL
	AvatarLocalFileID *string `json:"avatarLocalFileID,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// Whether the organization has a dedicated database
	DedicatedDb bool `json:"dedicatedDb"`
}

func (OrganizationHistory) IsNode() {}

// A connection to a list of items.
type OrganizationHistoryConnection struct {
	// A list of edges.
	Edges []*OrganizationHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrganizationHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrganizationHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for OrganizationHistory connections
type OrganizationHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrganizationHistories.
	Field OrganizationHistoryOrderField `json:"field"`
}

// OrganizationHistoryWhereInput is used for filtering OrganizationHistory objects.
// Input was generated by ent.
type OrganizationHistoryWhereInput struct {
	Not *OrganizationHistoryWhereInput   `json:"not,omitempty"`
	And []*OrganizationHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrganizationHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// parent_organization_id field predicates
	ParentOrganizationID             *string  `json:"parentOrganizationID,omitempty"`
	ParentOrganizationIdneq          *string  `json:"parentOrganizationIDNEQ,omitempty"`
	ParentOrganizationIDIn           []string `json:"parentOrganizationIDIn,omitempty"`
	ParentOrganizationIDNotIn        []string `json:"parentOrganizationIDNotIn,omitempty"`
	ParentOrganizationIdgt           *string  `json:"parentOrganizationIDGT,omitempty"`
	ParentOrganizationIdgte          *string  `json:"parentOrganizationIDGTE,omitempty"`
	ParentOrganizationIdlt           *string  `json:"parentOrganizationIDLT,omitempty"`
	ParentOrganizationIdlte          *string  `json:"parentOrganizationIDLTE,omitempty"`
	ParentOrganizationIDContains     *string  `json:"parentOrganizationIDContains,omitempty"`
	ParentOrganizationIDHasPrefix    *string  `json:"parentOrganizationIDHasPrefix,omitempty"`
	ParentOrganizationIDHasSuffix    *string  `json:"parentOrganizationIDHasSuffix,omitempty"`
	ParentOrganizationIDIsNil        *bool    `json:"parentOrganizationIDIsNil,omitempty"`
	ParentOrganizationIDNotNil       *bool    `json:"parentOrganizationIDNotNil,omitempty"`
	ParentOrganizationIDEqualFold    *string  `json:"parentOrganizationIDEqualFold,omitempty"`
	ParentOrganizationIDContainsFold *string  `json:"parentOrganizationIDContainsFold,omitempty"`
	// personal_org field predicates
	PersonalOrg       *bool `json:"personalOrg,omitempty"`
	PersonalOrgNeq    *bool `json:"personalOrgNEQ,omitempty"`
	PersonalOrgIsNil  *bool `json:"personalOrgIsNil,omitempty"`
	PersonalOrgNotNil *bool `json:"personalOrgNotNil,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file_id field predicates
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIdneq          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIdgt           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIdgte          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIdlt           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIdlte          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        *bool    `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       *bool    `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
}

// Ordering options for Organization connections
type OrganizationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Organizations.
	Field OrganizationOrderField `json:"field"`
}

type OrganizationSearchResult struct {
	Organizations []*Organization `json:"organizations,omitempty"`
}

func (OrganizationSearchResult) IsSearchResult() {}

type OrganizationSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// domains associated with the organization
	Domains []string `json:"domains,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone *string `json:"billingPhone,omitempty"`
	// the billing address to send billing information to
	BillingAddress *models.Address `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation *enums.Region `json:"geoLocation,omitempty"`
	// the ID of the organization the settings belong to
	OrganizationID *string `json:"organizationID,omitempty"`
	// should we send email notifications related to billing
	BillingNotificationsEnabled bool `json:"billingNotificationsEnabled"`
	// domains allowed to access the organization, if empty all domains are allowed
	AllowedEmailDomains []string      `json:"allowedEmailDomains,omitempty"`
	Organization        *Organization `json:"organization,omitempty"`
	Files               []*File       `json:"files,omitempty"`
}

func (OrganizationSetting) IsNode() {}

// Return response for createBulkOrganizationSetting mutation
type OrganizationSettingBulkCreatePayload struct {
	// Created organizationSettings
	OrganizationSettings []*OrganizationSetting `json:"organizationSettings,omitempty"`
}

// A connection to a list of items.
type OrganizationSettingConnection struct {
	// A list of edges.
	Edges []*OrganizationSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrganizationSetting mutation
type OrganizationSettingCreatePayload struct {
	// Created organizationSetting
	OrganizationSetting *OrganizationSetting `json:"organizationSetting"`
}

// Return response for deleteOrganizationSetting mutation
type OrganizationSettingDeletePayload struct {
	// Deleted organizationSetting ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrganizationSettingEdge struct {
	// The item at the end of the edge.
	Node *OrganizationSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrganizationSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// domains associated with the organization
	Domains []string `json:"domains,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone *string `json:"billingPhone,omitempty"`
	// the billing address to send billing information to
	BillingAddress *models.Address `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation *enums.Region `json:"geoLocation,omitempty"`
	// the ID of the organization the settings belong to
	OrganizationID *string `json:"organizationID,omitempty"`
	// should we send email notifications related to billing
	BillingNotificationsEnabled bool `json:"billingNotificationsEnabled"`
	// domains allowed to access the organization, if empty all domains are allowed
	AllowedEmailDomains []string `json:"allowedEmailDomains,omitempty"`
}

func (OrganizationSettingHistory) IsNode() {}

// A connection to a list of items.
type OrganizationSettingHistoryConnection struct {
	// A list of edges.
	Edges []*OrganizationSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrganizationSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrganizationSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// OrganizationSettingHistoryWhereInput is used for filtering OrganizationSettingHistory objects.
// Input was generated by ent.
type OrganizationSettingHistoryWhereInput struct {
	Not *OrganizationSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*OrganizationSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrganizationSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// billing_contact field predicates
	BillingContact             *string  `json:"billingContact,omitempty"`
	BillingContactNeq          *string  `json:"billingContactNEQ,omitempty"`
	BillingContactIn           []string `json:"billingContactIn,omitempty"`
	BillingContactNotIn        []string `json:"billingContactNotIn,omitempty"`
	BillingContactGt           *string  `json:"billingContactGT,omitempty"`
	BillingContactGte          *string  `json:"billingContactGTE,omitempty"`
	BillingContactLt           *string  `json:"billingContactLT,omitempty"`
	BillingContactLte          *string  `json:"billingContactLTE,omitempty"`
	BillingContactContains     *string  `json:"billingContactContains,omitempty"`
	BillingContactHasPrefix    *string  `json:"billingContactHasPrefix,omitempty"`
	BillingContactHasSuffix    *string  `json:"billingContactHasSuffix,omitempty"`
	BillingContactIsNil        *bool    `json:"billingContactIsNil,omitempty"`
	BillingContactNotNil       *bool    `json:"billingContactNotNil,omitempty"`
	BillingContactEqualFold    *string  `json:"billingContactEqualFold,omitempty"`
	BillingContactContainsFold *string  `json:"billingContactContainsFold,omitempty"`
	// billing_email field predicates
	BillingEmail             *string  `json:"billingEmail,omitempty"`
	BillingEmailNeq          *string  `json:"billingEmailNEQ,omitempty"`
	BillingEmailIn           []string `json:"billingEmailIn,omitempty"`
	BillingEmailNotIn        []string `json:"billingEmailNotIn,omitempty"`
	BillingEmailGt           *string  `json:"billingEmailGT,omitempty"`
	BillingEmailGte          *string  `json:"billingEmailGTE,omitempty"`
	BillingEmailLt           *string  `json:"billingEmailLT,omitempty"`
	BillingEmailLte          *string  `json:"billingEmailLTE,omitempty"`
	BillingEmailContains     *string  `json:"billingEmailContains,omitempty"`
	BillingEmailHasPrefix    *string  `json:"billingEmailHasPrefix,omitempty"`
	BillingEmailHasSuffix    *string  `json:"billingEmailHasSuffix,omitempty"`
	BillingEmailIsNil        *bool    `json:"billingEmailIsNil,omitempty"`
	BillingEmailNotNil       *bool    `json:"billingEmailNotNil,omitempty"`
	BillingEmailEqualFold    *string  `json:"billingEmailEqualFold,omitempty"`
	BillingEmailContainsFold *string  `json:"billingEmailContainsFold,omitempty"`
	// billing_phone field predicates
	BillingPhone             *string  `json:"billingPhone,omitempty"`
	BillingPhoneNeq          *string  `json:"billingPhoneNEQ,omitempty"`
	BillingPhoneIn           []string `json:"billingPhoneIn,omitempty"`
	BillingPhoneNotIn        []string `json:"billingPhoneNotIn,omitempty"`
	BillingPhoneGt           *string  `json:"billingPhoneGT,omitempty"`
	BillingPhoneGte          *string  `json:"billingPhoneGTE,omitempty"`
	BillingPhoneLt           *string  `json:"billingPhoneLT,omitempty"`
	BillingPhoneLte          *string  `json:"billingPhoneLTE,omitempty"`
	BillingPhoneContains     *string  `json:"billingPhoneContains,omitempty"`
	BillingPhoneHasPrefix    *string  `json:"billingPhoneHasPrefix,omitempty"`
	BillingPhoneHasSuffix    *string  `json:"billingPhoneHasSuffix,omitempty"`
	BillingPhoneIsNil        *bool    `json:"billingPhoneIsNil,omitempty"`
	BillingPhoneNotNil       *bool    `json:"billingPhoneNotNil,omitempty"`
	BillingPhoneEqualFold    *string  `json:"billingPhoneEqualFold,omitempty"`
	BillingPhoneContainsFold *string  `json:"billingPhoneContainsFold,omitempty"`
	// tax_identifier field predicates
	TaxIdentifier             *string  `json:"taxIdentifier,omitempty"`
	TaxIdentifierNeq          *string  `json:"taxIdentifierNEQ,omitempty"`
	TaxIdentifierIn           []string `json:"taxIdentifierIn,omitempty"`
	TaxIdentifierNotIn        []string `json:"taxIdentifierNotIn,omitempty"`
	TaxIdentifierGt           *string  `json:"taxIdentifierGT,omitempty"`
	TaxIdentifierGte          *string  `json:"taxIdentifierGTE,omitempty"`
	TaxIdentifierLt           *string  `json:"taxIdentifierLT,omitempty"`
	TaxIdentifierLte          *string  `json:"taxIdentifierLTE,omitempty"`
	TaxIdentifierContains     *string  `json:"taxIdentifierContains,omitempty"`
	TaxIdentifierHasPrefix    *string  `json:"taxIdentifierHasPrefix,omitempty"`
	TaxIdentifierHasSuffix    *string  `json:"taxIdentifierHasSuffix,omitempty"`
	TaxIdentifierIsNil        *bool    `json:"taxIdentifierIsNil,omitempty"`
	TaxIdentifierNotNil       *bool    `json:"taxIdentifierNotNil,omitempty"`
	TaxIdentifierEqualFold    *string  `json:"taxIdentifierEqualFold,omitempty"`
	TaxIdentifierContainsFold *string  `json:"taxIdentifierContainsFold,omitempty"`
	// geo_location field predicates
	GeoLocation       *enums.Region  `json:"geoLocation,omitempty"`
	GeoLocationNeq    *enums.Region  `json:"geoLocationNEQ,omitempty"`
	GeoLocationIn     []enums.Region `json:"geoLocationIn,omitempty"`
	GeoLocationNotIn  []enums.Region `json:"geoLocationNotIn,omitempty"`
	GeoLocationIsNil  *bool          `json:"geoLocationIsNil,omitempty"`
	GeoLocationNotNil *bool          `json:"geoLocationNotNil,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        *bool    `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       *bool    `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// billing_notifications_enabled field predicates
	BillingNotificationsEnabled    *bool `json:"billingNotificationsEnabled,omitempty"`
	BillingNotificationsEnabledNeq *bool `json:"billingNotificationsEnabledNEQ,omitempty"`
}

type OrganizationSettingSearchResult struct {
	OrganizationSettings []*OrganizationSetting `json:"organizationSettings,omitempty"`
}

func (OrganizationSettingSearchResult) IsSearchResult() {}

// Return response for updateOrganizationSetting mutation
type OrganizationSettingUpdatePayload struct {
	// Updated organizationSetting
	OrganizationSetting *OrganizationSetting `json:"organizationSetting"`
}

// OrganizationSettingWhereInput is used for filtering OrganizationSetting objects.
// Input was generated by ent.
type OrganizationSettingWhereInput struct {
	Not *OrganizationSettingWhereInput   `json:"not,omitempty"`
	And []*OrganizationSettingWhereInput `json:"and,omitempty"`
	Or  []*OrganizationSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// billing_contact field predicates
	BillingContact             *string  `json:"billingContact,omitempty"`
	BillingContactNeq          *string  `json:"billingContactNEQ,omitempty"`
	BillingContactIn           []string `json:"billingContactIn,omitempty"`
	BillingContactNotIn        []string `json:"billingContactNotIn,omitempty"`
	BillingContactGt           *string  `json:"billingContactGT,omitempty"`
	BillingContactGte          *string  `json:"billingContactGTE,omitempty"`
	BillingContactLt           *string  `json:"billingContactLT,omitempty"`
	BillingContactLte          *string  `json:"billingContactLTE,omitempty"`
	BillingContactContains     *string  `json:"billingContactContains,omitempty"`
	BillingContactHasPrefix    *string  `json:"billingContactHasPrefix,omitempty"`
	BillingContactHasSuffix    *string  `json:"billingContactHasSuffix,omitempty"`
	BillingContactIsNil        *bool    `json:"billingContactIsNil,omitempty"`
	BillingContactNotNil       *bool    `json:"billingContactNotNil,omitempty"`
	BillingContactEqualFold    *string  `json:"billingContactEqualFold,omitempty"`
	BillingContactContainsFold *string  `json:"billingContactContainsFold,omitempty"`
	// billing_email field predicates
	BillingEmail             *string  `json:"billingEmail,omitempty"`
	BillingEmailNeq          *string  `json:"billingEmailNEQ,omitempty"`
	BillingEmailIn           []string `json:"billingEmailIn,omitempty"`
	BillingEmailNotIn        []string `json:"billingEmailNotIn,omitempty"`
	BillingEmailGt           *string  `json:"billingEmailGT,omitempty"`
	BillingEmailGte          *string  `json:"billingEmailGTE,omitempty"`
	BillingEmailLt           *string  `json:"billingEmailLT,omitempty"`
	BillingEmailLte          *string  `json:"billingEmailLTE,omitempty"`
	BillingEmailContains     *string  `json:"billingEmailContains,omitempty"`
	BillingEmailHasPrefix    *string  `json:"billingEmailHasPrefix,omitempty"`
	BillingEmailHasSuffix    *string  `json:"billingEmailHasSuffix,omitempty"`
	BillingEmailIsNil        *bool    `json:"billingEmailIsNil,omitempty"`
	BillingEmailNotNil       *bool    `json:"billingEmailNotNil,omitempty"`
	BillingEmailEqualFold    *string  `json:"billingEmailEqualFold,omitempty"`
	BillingEmailContainsFold *string  `json:"billingEmailContainsFold,omitempty"`
	// billing_phone field predicates
	BillingPhone             *string  `json:"billingPhone,omitempty"`
	BillingPhoneNeq          *string  `json:"billingPhoneNEQ,omitempty"`
	BillingPhoneIn           []string `json:"billingPhoneIn,omitempty"`
	BillingPhoneNotIn        []string `json:"billingPhoneNotIn,omitempty"`
	BillingPhoneGt           *string  `json:"billingPhoneGT,omitempty"`
	BillingPhoneGte          *string  `json:"billingPhoneGTE,omitempty"`
	BillingPhoneLt           *string  `json:"billingPhoneLT,omitempty"`
	BillingPhoneLte          *string  `json:"billingPhoneLTE,omitempty"`
	BillingPhoneContains     *string  `json:"billingPhoneContains,omitempty"`
	BillingPhoneHasPrefix    *string  `json:"billingPhoneHasPrefix,omitempty"`
	BillingPhoneHasSuffix    *string  `json:"billingPhoneHasSuffix,omitempty"`
	BillingPhoneIsNil        *bool    `json:"billingPhoneIsNil,omitempty"`
	BillingPhoneNotNil       *bool    `json:"billingPhoneNotNil,omitempty"`
	BillingPhoneEqualFold    *string  `json:"billingPhoneEqualFold,omitempty"`
	BillingPhoneContainsFold *string  `json:"billingPhoneContainsFold,omitempty"`
	// tax_identifier field predicates
	TaxIdentifier             *string  `json:"taxIdentifier,omitempty"`
	TaxIdentifierNeq          *string  `json:"taxIdentifierNEQ,omitempty"`
	TaxIdentifierIn           []string `json:"taxIdentifierIn,omitempty"`
	TaxIdentifierNotIn        []string `json:"taxIdentifierNotIn,omitempty"`
	TaxIdentifierGt           *string  `json:"taxIdentifierGT,omitempty"`
	TaxIdentifierGte          *string  `json:"taxIdentifierGTE,omitempty"`
	TaxIdentifierLt           *string  `json:"taxIdentifierLT,omitempty"`
	TaxIdentifierLte          *string  `json:"taxIdentifierLTE,omitempty"`
	TaxIdentifierContains     *string  `json:"taxIdentifierContains,omitempty"`
	TaxIdentifierHasPrefix    *string  `json:"taxIdentifierHasPrefix,omitempty"`
	TaxIdentifierHasSuffix    *string  `json:"taxIdentifierHasSuffix,omitempty"`
	TaxIdentifierIsNil        *bool    `json:"taxIdentifierIsNil,omitempty"`
	TaxIdentifierNotNil       *bool    `json:"taxIdentifierNotNil,omitempty"`
	TaxIdentifierEqualFold    *string  `json:"taxIdentifierEqualFold,omitempty"`
	TaxIdentifierContainsFold *string  `json:"taxIdentifierContainsFold,omitempty"`
	// geo_location field predicates
	GeoLocation       *enums.Region  `json:"geoLocation,omitempty"`
	GeoLocationNeq    *enums.Region  `json:"geoLocationNEQ,omitempty"`
	GeoLocationIn     []enums.Region `json:"geoLocationIn,omitempty"`
	GeoLocationNotIn  []enums.Region `json:"geoLocationNotIn,omitempty"`
	GeoLocationIsNil  *bool          `json:"geoLocationIsNil,omitempty"`
	GeoLocationNotNil *bool          `json:"geoLocationNotNil,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIdneq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIdgt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIdgte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIdlt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIdlte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        *bool    `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       *bool    `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// billing_notifications_enabled field predicates
	BillingNotificationsEnabled    *bool `json:"billingNotificationsEnabled,omitempty"`
	BillingNotificationsEnabledNeq *bool `json:"billingNotificationsEnabledNEQ,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// Return response for updateOrganization mutation
type OrganizationUpdatePayload struct {
	// Updated organization
	Organization *Organization `json:"organization"`
}

// OrganizationWhereInput is used for filtering Organization objects.
// Input was generated by ent.
type OrganizationWhereInput struct {
	Not *OrganizationWhereInput   `json:"not,omitempty"`
	And []*OrganizationWhereInput `json:"and,omitempty"`
	Or  []*OrganizationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// parent_organization_id field predicates
	ParentOrganizationID             *string  `json:"parentOrganizationID,omitempty"`
	ParentOrganizationIdneq          *string  `json:"parentOrganizationIDNEQ,omitempty"`
	ParentOrganizationIDIn           []string `json:"parentOrganizationIDIn,omitempty"`
	ParentOrganizationIDNotIn        []string `json:"parentOrganizationIDNotIn,omitempty"`
	ParentOrganizationIdgt           *string  `json:"parentOrganizationIDGT,omitempty"`
	ParentOrganizationIdgte          *string  `json:"parentOrganizationIDGTE,omitempty"`
	ParentOrganizationIdlt           *string  `json:"parentOrganizationIDLT,omitempty"`
	ParentOrganizationIdlte          *string  `json:"parentOrganizationIDLTE,omitempty"`
	ParentOrganizationIDContains     *string  `json:"parentOrganizationIDContains,omitempty"`
	ParentOrganizationIDHasPrefix    *string  `json:"parentOrganizationIDHasPrefix,omitempty"`
	ParentOrganizationIDHasSuffix    *string  `json:"parentOrganizationIDHasSuffix,omitempty"`
	ParentOrganizationIDIsNil        *bool    `json:"parentOrganizationIDIsNil,omitempty"`
	ParentOrganizationIDNotNil       *bool    `json:"parentOrganizationIDNotNil,omitempty"`
	ParentOrganizationIDEqualFold    *string  `json:"parentOrganizationIDEqualFold,omitempty"`
	ParentOrganizationIDContainsFold *string  `json:"parentOrganizationIDContainsFold,omitempty"`
	// personal_org field predicates
	PersonalOrg       *bool `json:"personalOrg,omitempty"`
	PersonalOrgNeq    *bool `json:"personalOrgNEQ,omitempty"`
	PersonalOrgIsNil  *bool `json:"personalOrgIsNil,omitempty"`
	PersonalOrgNotNil *bool `json:"personalOrgNotNil,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file_id field predicates
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIdneq          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIdgt           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIdgte          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIdlt           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIdlte          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        *bool    `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       *bool    `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// control_creators edge predicates
	HasControlCreators     *bool              `json:"hasControlCreators,omitempty"`
	HasControlCreatorsWith []*GroupWhereInput `json:"hasControlCreatorsWith,omitempty"`
	// control_objective_creators edge predicates
	HasControlObjectiveCreators     *bool              `json:"hasControlObjectiveCreators,omitempty"`
	HasControlObjectiveCreatorsWith []*GroupWhereInput `json:"hasControlObjectiveCreatorsWith,omitempty"`
	// group_creators edge predicates
	HasGroupCreators     *bool              `json:"hasGroupCreators,omitempty"`
	HasGroupCreatorsWith []*GroupWhereInput `json:"hasGroupCreatorsWith,omitempty"`
	// internal_policy_creators edge predicates
	HasInternalPolicyCreators     *bool              `json:"hasInternalPolicyCreators,omitempty"`
	HasInternalPolicyCreatorsWith []*GroupWhereInput `json:"hasInternalPolicyCreatorsWith,omitempty"`
	// narrative_creators edge predicates
	HasNarrativeCreators     *bool              `json:"hasNarrativeCreators,omitempty"`
	HasNarrativeCreatorsWith []*GroupWhereInput `json:"hasNarrativeCreatorsWith,omitempty"`
	// procedure_creators edge predicates
	HasProcedureCreators     *bool              `json:"hasProcedureCreators,omitempty"`
	HasProcedureCreatorsWith []*GroupWhereInput `json:"hasProcedureCreatorsWith,omitempty"`
	// program_creators edge predicates
	HasProgramCreators     *bool              `json:"hasProgramCreators,omitempty"`
	HasProgramCreatorsWith []*GroupWhereInput `json:"hasProgramCreatorsWith,omitempty"`
	// risk_creators edge predicates
	HasRiskCreators     *bool              `json:"hasRiskCreators,omitempty"`
	HasRiskCreatorsWith []*GroupWhereInput `json:"hasRiskCreatorsWith,omitempty"`
	// template_creators edge predicates
	HasTemplateCreators     *bool              `json:"hasTemplateCreators,omitempty"`
	HasTemplateCreatorsWith []*GroupWhereInput `json:"hasTemplateCreatorsWith,omitempty"`
	// parent edge predicates
	HasParent     *bool                     `json:"hasParent,omitempty"`
	HasParentWith []*OrganizationWhereInput `json:"hasParentWith,omitempty"`
	// children edge predicates
	HasChildren     *bool                     `json:"hasChildren,omitempty"`
	HasChildrenWith []*OrganizationWhereInput `json:"hasChildrenWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                            `json:"hasSetting,omitempty"`
	HasSettingWith []*OrganizationSettingWhereInput `json:"hasSettingWith,omitempty"`
	// personal_access_tokens edge predicates
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`
	// api_tokens edge predicates
	HasAPITokens     *bool                 `json:"hasAPITokens,omitempty"`
	HasAPITokensWith []*APITokenWhereInput `json:"hasAPITokensWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// secrets edge predicates
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`
	// avatar_file edge predicates
	HasAvatarFile     *bool             `json:"hasAvatarFile,omitempty"`
	HasAvatarFileWith []*FileWhereInput `json:"hasAvatarFileWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// templates edge predicates
	HasTemplates     *bool                 `json:"hasTemplates,omitempty"`
	HasTemplatesWith []*TemplateWhereInput `json:"hasTemplatesWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// document_data edge predicates
	HasDocumentData     *bool                     `json:"hasDocumentData,omitempty"`
	HasDocumentDataWith []*DocumentDataWhereInput `json:"hasDocumentDataWith,omitempty"`
	// org_subscriptions edge predicates
	HasOrgSubscriptions     *bool                        `json:"hasOrgSubscriptions,omitempty"`
	HasOrgSubscriptionsWith []*OrgSubscriptionWhereInput `json:"hasOrgSubscriptionsWith,omitempty"`
	// invites edge predicates
	HasInvites     *bool               `json:"hasInvites,omitempty"`
	HasInvitesWith []*InviteWhereInput `json:"hasInvitesWith,omitempty"`
	// subscribers edge predicates
	HasSubscribers     *bool                   `json:"hasSubscribers,omitempty"`
	HasSubscribersWith []*SubscriberWhereInput `json:"hasSubscribersWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// entity_types edge predicates
	HasEntityTypes     *bool                   `json:"hasEntityTypes,omitempty"`
	HasEntityTypesWith []*EntityTypeWhereInput `json:"hasEntityTypesWith,omitempty"`
	// contacts edge predicates
	HasContacts     *bool                `json:"hasContacts,omitempty"`
	HasContactsWith []*ContactWhereInput `json:"hasContactsWith,omitempty"`
	// notes edge predicates
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// standards edge predicates
	HasStandards     *bool                 `json:"hasStandards,omitempty"`
	HasStandardsWith []*StandardWhereInput `json:"hasStandardsWith,omitempty"`
	// members edge predicates
	HasMembers     *bool                      `json:"hasMembers,omitempty"`
	HasMembersWith []*OrgMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

type PersonalAccessToken struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name associated with the token
	Name  string `json:"name"`
	Token string `json:"token"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string    `json:"description,omitempty"`
	Scopes      []string   `json:"scopes,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	// whether the token is active
	IsActive *bool `json:"isActive,omitempty"`
	// the reason the token was revoked
	RevokedReason *string `json:"revokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy *string `json:"revokedBy,omitempty"`
	// when the token was revoked
	RevokedAt *time.Time `json:"revokedAt,omitempty"`
	Owner     *User      `json:"owner"`
	// the organization(s) the token is associated with
	Organizations []*Organization `json:"organizations,omitempty"`
	Events        []*Event        `json:"events,omitempty"`
}

func (PersonalAccessToken) IsNode() {}

// Return response for createBulkPersonalAccessToken mutation
type PersonalAccessTokenBulkCreatePayload struct {
	// Created personalAccessTokens
	PersonalAccessTokens []*PersonalAccessToken `json:"personalAccessTokens,omitempty"`
}

// A connection to a list of items.
type PersonalAccessTokenConnection struct {
	// A list of edges.
	Edges []*PersonalAccessTokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createPersonalAccessToken mutation
type PersonalAccessTokenCreatePayload struct {
	// Created personalAccessToken
	PersonalAccessToken *PersonalAccessToken `json:"personalAccessToken"`
}

// Return response for deletePersonalAccessToken mutation
type PersonalAccessTokenDeletePayload struct {
	// Deleted personalAccessToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type PersonalAccessTokenEdge struct {
	// The item at the end of the edge.
	Node *PersonalAccessToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type PersonalAccessTokenSearchResult struct {
	PersonalAccessTokens []*PersonalAccessToken `json:"personalAccessTokens,omitempty"`
}

func (PersonalAccessTokenSearchResult) IsSearchResult() {}

// Return response for updatePersonalAccessToken mutation
type PersonalAccessTokenUpdatePayload struct {
	// Updated personalAccessToken
	PersonalAccessToken *PersonalAccessToken `json:"personalAccessToken"`
}

// PersonalAccessTokenWhereInput is used for filtering PersonalAccessToken objects.
// Input was generated by ent.
type PersonalAccessTokenWhereInput struct {
	Not *PersonalAccessTokenWhereInput   `json:"not,omitempty"`
	And []*PersonalAccessTokenWhereInput `json:"and,omitempty"`
	Or  []*PersonalAccessTokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// is_active field predicates
	IsActive       *bool `json:"isActive,omitempty"`
	IsActiveNeq    *bool `json:"isActiveNEQ,omitempty"`
	IsActiveIsNil  *bool `json:"isActiveIsNil,omitempty"`
	IsActiveNotNil *bool `json:"isActiveNotNil,omitempty"`
	// revoked_reason field predicates
	RevokedReason             *string  `json:"revokedReason,omitempty"`
	RevokedReasonNeq          *string  `json:"revokedReasonNEQ,omitempty"`
	RevokedReasonIn           []string `json:"revokedReasonIn,omitempty"`
	RevokedReasonNotIn        []string `json:"revokedReasonNotIn,omitempty"`
	RevokedReasonGt           *string  `json:"revokedReasonGT,omitempty"`
	RevokedReasonGte          *string  `json:"revokedReasonGTE,omitempty"`
	RevokedReasonLt           *string  `json:"revokedReasonLT,omitempty"`
	RevokedReasonLte          *string  `json:"revokedReasonLTE,omitempty"`
	RevokedReasonContains     *string  `json:"revokedReasonContains,omitempty"`
	RevokedReasonHasPrefix    *string  `json:"revokedReasonHasPrefix,omitempty"`
	RevokedReasonHasSuffix    *string  `json:"revokedReasonHasSuffix,omitempty"`
	RevokedReasonIsNil        *bool    `json:"revokedReasonIsNil,omitempty"`
	RevokedReasonNotNil       *bool    `json:"revokedReasonNotNil,omitempty"`
	RevokedReasonEqualFold    *string  `json:"revokedReasonEqualFold,omitempty"`
	RevokedReasonContainsFold *string  `json:"revokedReasonContainsFold,omitempty"`
	// revoked_by field predicates
	RevokedBy             *string  `json:"revokedBy,omitempty"`
	RevokedByNeq          *string  `json:"revokedByNEQ,omitempty"`
	RevokedByIn           []string `json:"revokedByIn,omitempty"`
	RevokedByNotIn        []string `json:"revokedByNotIn,omitempty"`
	RevokedByGt           *string  `json:"revokedByGT,omitempty"`
	RevokedByGte          *string  `json:"revokedByGTE,omitempty"`
	RevokedByLt           *string  `json:"revokedByLT,omitempty"`
	RevokedByLte          *string  `json:"revokedByLTE,omitempty"`
	RevokedByContains     *string  `json:"revokedByContains,omitempty"`
	RevokedByHasPrefix    *string  `json:"revokedByHasPrefix,omitempty"`
	RevokedByHasSuffix    *string  `json:"revokedByHasSuffix,omitempty"`
	RevokedByIsNil        *bool    `json:"revokedByIsNil,omitempty"`
	RevokedByNotNil       *bool    `json:"revokedByNotNil,omitempty"`
	RevokedByEqualFold    *string  `json:"revokedByEqualFold,omitempty"`
	RevokedByContainsFold *string  `json:"revokedByContainsFold,omitempty"`
	// revoked_at field predicates
	RevokedAt       *time.Time   `json:"revokedAt,omitempty"`
	RevokedAtNeq    *time.Time   `json:"revokedAtNEQ,omitempty"`
	RevokedAtIn     []*time.Time `json:"revokedAtIn,omitempty"`
	RevokedAtNotIn  []*time.Time `json:"revokedAtNotIn,omitempty"`
	RevokedAtGt     *time.Time   `json:"revokedAtGT,omitempty"`
	RevokedAtGte    *time.Time   `json:"revokedAtGTE,omitempty"`
	RevokedAtLt     *time.Time   `json:"revokedAtLT,omitempty"`
	RevokedAtLte    *time.Time   `json:"revokedAtLTE,omitempty"`
	RevokedAtIsNil  *bool        `json:"revokedAtIsNil,omitempty"`
	RevokedAtNotNil *bool        `json:"revokedAtNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
	// organizations edge predicates
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Procedure struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the procedure
	Name string `json:"name"`
	// description of the procedure
	Description *string `json:"description,omitempty"`
	// status of the procedure
	Status *string `json:"status,omitempty"`
	// type of the procedure
	ProcedureType *string `json:"procedureType,omitempty"`
	// the date the procedure should be reviewed, defaults to a year from creation date
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// version of the procedure
	Version *string `json:"version,omitempty"`
	// purpose and scope
	PurposeAndScope *string `json:"purposeAndScope,omitempty"`
	// background of the procedure
	Background *string `json:"background,omitempty"`
	// which controls are satisfied by the procedure
	Satisfies *string `json:"satisfies,omitempty"`
	// json data for the procedure document
	Details map[string]any `json:"details,omitempty"`
	Owner   *Organization  `json:"owner,omitempty"`
	// groups that are blocked from viewing or editing the risk
	BlockedGroups []*Group `json:"blockedGroups,omitempty"`
	// provides edit access to the risk to members of the group
	Editors          []*Group          `json:"editors,omitempty"`
	Controls         []*Control        `json:"controls,omitempty"`
	InternalPolicies []*InternalPolicy `json:"internalPolicies,omitempty"`
	Narratives       []*Narrative      `json:"narratives,omitempty"`
	Risks            []*Risk           `json:"risks,omitempty"`
	Tasks            []*Task           `json:"tasks,omitempty"`
	Programs         []*Program        `json:"programs,omitempty"`
}

func (Procedure) IsNode() {}

// Return response for createBulkProcedure mutation
type ProcedureBulkCreatePayload struct {
	// Created procedures
	Procedures []*Procedure `json:"procedures,omitempty"`
}

// A connection to a list of items.
type ProcedureConnection struct {
	// A list of edges.
	Edges []*ProcedureEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createProcedure mutation
type ProcedureCreatePayload struct {
	// Created procedure
	Procedure *Procedure `json:"procedure"`
}

// Return response for deleteProcedure mutation
type ProcedureDeletePayload struct {
	// Deleted procedure ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ProcedureEdge struct {
	// The item at the end of the edge.
	Node *Procedure `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ProcedureHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the procedure
	Name string `json:"name"`
	// description of the procedure
	Description *string `json:"description,omitempty"`
	// status of the procedure
	Status *string `json:"status,omitempty"`
	// type of the procedure
	ProcedureType *string `json:"procedureType,omitempty"`
	// the date the procedure should be reviewed, defaults to a year from creation date
	ReviewDue *time.Time `json:"reviewDue,omitempty"`
	// version of the procedure
	Version *string `json:"version,omitempty"`
	// purpose and scope
	PurposeAndScope *string `json:"purposeAndScope,omitempty"`
	// background of the procedure
	Background *string `json:"background,omitempty"`
	// which controls are satisfied by the procedure
	Satisfies *string `json:"satisfies,omitempty"`
	// json data for the procedure document
	Details map[string]any `json:"details,omitempty"`
}

func (ProcedureHistory) IsNode() {}

// A connection to a list of items.
type ProcedureHistoryConnection struct {
	// A list of edges.
	Edges []*ProcedureHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ProcedureHistoryEdge struct {
	// The item at the end of the edge.
	Node *ProcedureHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ProcedureHistoryWhereInput is used for filtering ProcedureHistory objects.
// Input was generated by ent.
type ProcedureHistoryWhereInput struct {
	Not *ProcedureHistoryWhereInput   `json:"not,omitempty"`
	And []*ProcedureHistoryWhereInput `json:"and,omitempty"`
	Or  []*ProcedureHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// procedure_type field predicates
	ProcedureType             *string  `json:"procedureType,omitempty"`
	ProcedureTypeNeq          *string  `json:"procedureTypeNEQ,omitempty"`
	ProcedureTypeIn           []string `json:"procedureTypeIn,omitempty"`
	ProcedureTypeNotIn        []string `json:"procedureTypeNotIn,omitempty"`
	ProcedureTypeGt           *string  `json:"procedureTypeGT,omitempty"`
	ProcedureTypeGte          *string  `json:"procedureTypeGTE,omitempty"`
	ProcedureTypeLt           *string  `json:"procedureTypeLT,omitempty"`
	ProcedureTypeLte          *string  `json:"procedureTypeLTE,omitempty"`
	ProcedureTypeContains     *string  `json:"procedureTypeContains,omitempty"`
	ProcedureTypeHasPrefix    *string  `json:"procedureTypeHasPrefix,omitempty"`
	ProcedureTypeHasSuffix    *string  `json:"procedureTypeHasSuffix,omitempty"`
	ProcedureTypeIsNil        *bool    `json:"procedureTypeIsNil,omitempty"`
	ProcedureTypeNotNil       *bool    `json:"procedureTypeNotNil,omitempty"`
	ProcedureTypeEqualFold    *string  `json:"procedureTypeEqualFold,omitempty"`
	ProcedureTypeContainsFold *string  `json:"procedureTypeContainsFold,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// purpose_and_scope field predicates
	PurposeAndScope             *string  `json:"purposeAndScope,omitempty"`
	PurposeAndScopeNeq          *string  `json:"purposeAndScopeNEQ,omitempty"`
	PurposeAndScopeIn           []string `json:"purposeAndScopeIn,omitempty"`
	PurposeAndScopeNotIn        []string `json:"purposeAndScopeNotIn,omitempty"`
	PurposeAndScopeGt           *string  `json:"purposeAndScopeGT,omitempty"`
	PurposeAndScopeGte          *string  `json:"purposeAndScopeGTE,omitempty"`
	PurposeAndScopeLt           *string  `json:"purposeAndScopeLT,omitempty"`
	PurposeAndScopeLte          *string  `json:"purposeAndScopeLTE,omitempty"`
	PurposeAndScopeContains     *string  `json:"purposeAndScopeContains,omitempty"`
	PurposeAndScopeHasPrefix    *string  `json:"purposeAndScopeHasPrefix,omitempty"`
	PurposeAndScopeHasSuffix    *string  `json:"purposeAndScopeHasSuffix,omitempty"`
	PurposeAndScopeIsNil        *bool    `json:"purposeAndScopeIsNil,omitempty"`
	PurposeAndScopeNotNil       *bool    `json:"purposeAndScopeNotNil,omitempty"`
	PurposeAndScopeEqualFold    *string  `json:"purposeAndScopeEqualFold,omitempty"`
	PurposeAndScopeContainsFold *string  `json:"purposeAndScopeContainsFold,omitempty"`
	// background field predicates
	Background             *string  `json:"background,omitempty"`
	BackgroundNeq          *string  `json:"backgroundNEQ,omitempty"`
	BackgroundIn           []string `json:"backgroundIn,omitempty"`
	BackgroundNotIn        []string `json:"backgroundNotIn,omitempty"`
	BackgroundGt           *string  `json:"backgroundGT,omitempty"`
	BackgroundGte          *string  `json:"backgroundGTE,omitempty"`
	BackgroundLt           *string  `json:"backgroundLT,omitempty"`
	BackgroundLte          *string  `json:"backgroundLTE,omitempty"`
	BackgroundContains     *string  `json:"backgroundContains,omitempty"`
	BackgroundHasPrefix    *string  `json:"backgroundHasPrefix,omitempty"`
	BackgroundHasSuffix    *string  `json:"backgroundHasSuffix,omitempty"`
	BackgroundIsNil        *bool    `json:"backgroundIsNil,omitempty"`
	BackgroundNotNil       *bool    `json:"backgroundNotNil,omitempty"`
	BackgroundEqualFold    *string  `json:"backgroundEqualFold,omitempty"`
	BackgroundContainsFold *string  `json:"backgroundContainsFold,omitempty"`
	// satisfies field predicates
	Satisfies             *string  `json:"satisfies,omitempty"`
	SatisfiesNeq          *string  `json:"satisfiesNEQ,omitempty"`
	SatisfiesIn           []string `json:"satisfiesIn,omitempty"`
	SatisfiesNotIn        []string `json:"satisfiesNotIn,omitempty"`
	SatisfiesGt           *string  `json:"satisfiesGT,omitempty"`
	SatisfiesGte          *string  `json:"satisfiesGTE,omitempty"`
	SatisfiesLt           *string  `json:"satisfiesLT,omitempty"`
	SatisfiesLte          *string  `json:"satisfiesLTE,omitempty"`
	SatisfiesContains     *string  `json:"satisfiesContains,omitempty"`
	SatisfiesHasPrefix    *string  `json:"satisfiesHasPrefix,omitempty"`
	SatisfiesHasSuffix    *string  `json:"satisfiesHasSuffix,omitempty"`
	SatisfiesIsNil        *bool    `json:"satisfiesIsNil,omitempty"`
	SatisfiesNotNil       *bool    `json:"satisfiesNotNil,omitempty"`
	SatisfiesEqualFold    *string  `json:"satisfiesEqualFold,omitempty"`
	SatisfiesContainsFold *string  `json:"satisfiesContainsFold,omitempty"`
}

type ProcedureSearchResult struct {
	Procedures []*Procedure `json:"procedures,omitempty"`
}

func (ProcedureSearchResult) IsSearchResult() {}

// Return response for updateProcedure mutation
type ProcedureUpdatePayload struct {
	// Updated procedure
	Procedure *Procedure `json:"procedure"`
}

// ProcedureWhereInput is used for filtering Procedure objects.
// Input was generated by ent.
type ProcedureWhereInput struct {
	Not *ProcedureWhereInput   `json:"not,omitempty"`
	And []*ProcedureWhereInput `json:"and,omitempty"`
	Or  []*ProcedureWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// procedure_type field predicates
	ProcedureType             *string  `json:"procedureType,omitempty"`
	ProcedureTypeNeq          *string  `json:"procedureTypeNEQ,omitempty"`
	ProcedureTypeIn           []string `json:"procedureTypeIn,omitempty"`
	ProcedureTypeNotIn        []string `json:"procedureTypeNotIn,omitempty"`
	ProcedureTypeGt           *string  `json:"procedureTypeGT,omitempty"`
	ProcedureTypeGte          *string  `json:"procedureTypeGTE,omitempty"`
	ProcedureTypeLt           *string  `json:"procedureTypeLT,omitempty"`
	ProcedureTypeLte          *string  `json:"procedureTypeLTE,omitempty"`
	ProcedureTypeContains     *string  `json:"procedureTypeContains,omitempty"`
	ProcedureTypeHasPrefix    *string  `json:"procedureTypeHasPrefix,omitempty"`
	ProcedureTypeHasSuffix    *string  `json:"procedureTypeHasSuffix,omitempty"`
	ProcedureTypeIsNil        *bool    `json:"procedureTypeIsNil,omitempty"`
	ProcedureTypeNotNil       *bool    `json:"procedureTypeNotNil,omitempty"`
	ProcedureTypeEqualFold    *string  `json:"procedureTypeEqualFold,omitempty"`
	ProcedureTypeContainsFold *string  `json:"procedureTypeContainsFold,omitempty"`
	// review_due field predicates
	ReviewDue       *time.Time   `json:"reviewDue,omitempty"`
	ReviewDueNeq    *time.Time   `json:"reviewDueNEQ,omitempty"`
	ReviewDueIn     []*time.Time `json:"reviewDueIn,omitempty"`
	ReviewDueNotIn  []*time.Time `json:"reviewDueNotIn,omitempty"`
	ReviewDueGt     *time.Time   `json:"reviewDueGT,omitempty"`
	ReviewDueGte    *time.Time   `json:"reviewDueGTE,omitempty"`
	ReviewDueLt     *time.Time   `json:"reviewDueLT,omitempty"`
	ReviewDueLte    *time.Time   `json:"reviewDueLTE,omitempty"`
	ReviewDueIsNil  *bool        `json:"reviewDueIsNil,omitempty"`
	ReviewDueNotNil *bool        `json:"reviewDueNotNil,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// purpose_and_scope field predicates
	PurposeAndScope             *string  `json:"purposeAndScope,omitempty"`
	PurposeAndScopeNeq          *string  `json:"purposeAndScopeNEQ,omitempty"`
	PurposeAndScopeIn           []string `json:"purposeAndScopeIn,omitempty"`
	PurposeAndScopeNotIn        []string `json:"purposeAndScopeNotIn,omitempty"`
	PurposeAndScopeGt           *string  `json:"purposeAndScopeGT,omitempty"`
	PurposeAndScopeGte          *string  `json:"purposeAndScopeGTE,omitempty"`
	PurposeAndScopeLt           *string  `json:"purposeAndScopeLT,omitempty"`
	PurposeAndScopeLte          *string  `json:"purposeAndScopeLTE,omitempty"`
	PurposeAndScopeContains     *string  `json:"purposeAndScopeContains,omitempty"`
	PurposeAndScopeHasPrefix    *string  `json:"purposeAndScopeHasPrefix,omitempty"`
	PurposeAndScopeHasSuffix    *string  `json:"purposeAndScopeHasSuffix,omitempty"`
	PurposeAndScopeIsNil        *bool    `json:"purposeAndScopeIsNil,omitempty"`
	PurposeAndScopeNotNil       *bool    `json:"purposeAndScopeNotNil,omitempty"`
	PurposeAndScopeEqualFold    *string  `json:"purposeAndScopeEqualFold,omitempty"`
	PurposeAndScopeContainsFold *string  `json:"purposeAndScopeContainsFold,omitempty"`
	// background field predicates
	Background             *string  `json:"background,omitempty"`
	BackgroundNeq          *string  `json:"backgroundNEQ,omitempty"`
	BackgroundIn           []string `json:"backgroundIn,omitempty"`
	BackgroundNotIn        []string `json:"backgroundNotIn,omitempty"`
	BackgroundGt           *string  `json:"backgroundGT,omitempty"`
	BackgroundGte          *string  `json:"backgroundGTE,omitempty"`
	BackgroundLt           *string  `json:"backgroundLT,omitempty"`
	BackgroundLte          *string  `json:"backgroundLTE,omitempty"`
	BackgroundContains     *string  `json:"backgroundContains,omitempty"`
	BackgroundHasPrefix    *string  `json:"backgroundHasPrefix,omitempty"`
	BackgroundHasSuffix    *string  `json:"backgroundHasSuffix,omitempty"`
	BackgroundIsNil        *bool    `json:"backgroundIsNil,omitempty"`
	BackgroundNotNil       *bool    `json:"backgroundNotNil,omitempty"`
	BackgroundEqualFold    *string  `json:"backgroundEqualFold,omitempty"`
	BackgroundContainsFold *string  `json:"backgroundContainsFold,omitempty"`
	// satisfies field predicates
	Satisfies             *string  `json:"satisfies,omitempty"`
	SatisfiesNeq          *string  `json:"satisfiesNEQ,omitempty"`
	SatisfiesIn           []string `json:"satisfiesIn,omitempty"`
	SatisfiesNotIn        []string `json:"satisfiesNotIn,omitempty"`
	SatisfiesGt           *string  `json:"satisfiesGT,omitempty"`
	SatisfiesGte          *string  `json:"satisfiesGTE,omitempty"`
	SatisfiesLt           *string  `json:"satisfiesLT,omitempty"`
	SatisfiesLte          *string  `json:"satisfiesLTE,omitempty"`
	SatisfiesContains     *string  `json:"satisfiesContains,omitempty"`
	SatisfiesHasPrefix    *string  `json:"satisfiesHasPrefix,omitempty"`
	SatisfiesHasSuffix    *string  `json:"satisfiesHasSuffix,omitempty"`
	SatisfiesIsNil        *bool    `json:"satisfiesIsNil,omitempty"`
	SatisfiesNotNil       *bool    `json:"satisfiesNotNil,omitempty"`
	SatisfiesEqualFold    *string  `json:"satisfiesEqualFold,omitempty"`
	SatisfiesContainsFold *string  `json:"satisfiesContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

type Program struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string     `json:"displayID"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the program
	Name string `json:"name"`
	// the description of the program
	Description *string `json:"description,omitempty"`
	// the status of the program
	Status enums.ProgramStatus `json:"status"`
	// the start date of the period
	StartDate *time.Time `json:"startDate,omitempty"`
	// the end date of the period
	EndDate *time.Time `json:"endDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady bool `json:"auditorReady"`
	// can the auditor write comments
	AuditorWriteComments bool `json:"auditorWriteComments"`
	// can the auditor read comments
	AuditorReadComments bool          `json:"auditorReadComments"`
	Owner               *Organization `json:"owner,omitempty"`
	// groups that are blocked from viewing or editing the risk
	BlockedGroups []*Group `json:"blockedGroups,omitempty"`
	// provides edit access to the risk to members of the group
	Editors []*Group `json:"editors,omitempty"`
	// provides view access to the risk to members of the group
	Viewers           []*Group             `json:"viewers,omitempty"`
	Controls          []*Control           `json:"controls,omitempty"`
	Subcontrols       []*Subcontrol        `json:"subcontrols,omitempty"`
	ControlObjectives []*ControlObjective  `json:"controlObjectives,omitempty"`
	InternalPolicies  []*InternalPolicy    `json:"internalPolicies,omitempty"`
	Procedures        []*Procedure         `json:"procedures,omitempty"`
	Risks             []*Risk              `json:"risks,omitempty"`
	Tasks             []*Task              `json:"tasks,omitempty"`
	Notes             []*Note              `json:"notes,omitempty"`
	Files             []*File              `json:"files,omitempty"`
	Evidence          []*Evidence          `json:"evidence,omitempty"`
	Narratives        []*Narrative         `json:"narratives,omitempty"`
	ActionPlans       []*ActionPlan        `json:"actionPlans,omitempty"`
	Users             []*User              `json:"users,omitempty"`
	Members           []*ProgramMembership `json:"members,omitempty"`
}

func (Program) IsNode() {}

// Return response for createBulkProgram mutation
type ProgramBulkCreatePayload struct {
	// Created programs
	Programs []*Program `json:"programs,omitempty"`
}

// A connection to a list of items.
type ProgramConnection struct {
	// A list of edges.
	Edges []*ProgramEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createProgram mutation
type ProgramCreatePayload struct {
	// Created program
	Program *Program `json:"program"`
}

// Return response for deleteProgram mutation
type ProgramDeletePayload struct {
	// Deleted program ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ProgramEdge struct {
	// The item at the end of the edge.
	Node *Program `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ProgramHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string     `json:"displayID"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the program
	Name string `json:"name"`
	// the description of the program
	Description *string `json:"description,omitempty"`
	// the status of the program
	Status enums.ProgramStatus `json:"status"`
	// the start date of the period
	StartDate *time.Time `json:"startDate,omitempty"`
	// the end date of the period
	EndDate *time.Time `json:"endDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady bool `json:"auditorReady"`
	// can the auditor write comments
	AuditorWriteComments bool `json:"auditorWriteComments"`
	// can the auditor read comments
	AuditorReadComments bool `json:"auditorReadComments"`
}

func (ProgramHistory) IsNode() {}

// A connection to a list of items.
type ProgramHistoryConnection struct {
	// A list of edges.
	Edges []*ProgramHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ProgramHistoryEdge struct {
	// The item at the end of the edge.
	Node *ProgramHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ProgramHistoryWhereInput is used for filtering ProgramHistory objects.
// Input was generated by ent.
type ProgramHistoryWhereInput struct {
	Not *ProgramHistoryWhereInput   `json:"not,omitempty"`
	And []*ProgramHistoryWhereInput `json:"and,omitempty"`
	Or  []*ProgramHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status      *enums.ProgramStatus  `json:"status,omitempty"`
	StatusNeq   *enums.ProgramStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ProgramStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ProgramStatus `json:"statusNotIn,omitempty"`
	// start_date field predicates
	StartDate       *time.Time   `json:"startDate,omitempty"`
	StartDateNeq    *time.Time   `json:"startDateNEQ,omitempty"`
	StartDateIn     []*time.Time `json:"startDateIn,omitempty"`
	StartDateNotIn  []*time.Time `json:"startDateNotIn,omitempty"`
	StartDateGt     *time.Time   `json:"startDateGT,omitempty"`
	StartDateGte    *time.Time   `json:"startDateGTE,omitempty"`
	StartDateLt     *time.Time   `json:"startDateLT,omitempty"`
	StartDateLte    *time.Time   `json:"startDateLTE,omitempty"`
	StartDateIsNil  *bool        `json:"startDateIsNil,omitempty"`
	StartDateNotNil *bool        `json:"startDateNotNil,omitempty"`
	// end_date field predicates
	EndDate       *time.Time   `json:"endDate,omitempty"`
	EndDateNeq    *time.Time   `json:"endDateNEQ,omitempty"`
	EndDateIn     []*time.Time `json:"endDateIn,omitempty"`
	EndDateNotIn  []*time.Time `json:"endDateNotIn,omitempty"`
	EndDateGt     *time.Time   `json:"endDateGT,omitempty"`
	EndDateGte    *time.Time   `json:"endDateGTE,omitempty"`
	EndDateLt     *time.Time   `json:"endDateLT,omitempty"`
	EndDateLte    *time.Time   `json:"endDateLTE,omitempty"`
	EndDateIsNil  *bool        `json:"endDateIsNil,omitempty"`
	EndDateNotNil *bool        `json:"endDateNotNil,omitempty"`
	// auditor_ready field predicates
	AuditorReady    *bool `json:"auditorReady,omitempty"`
	AuditorReadyNeq *bool `json:"auditorReadyNEQ,omitempty"`
	// auditor_write_comments field predicates
	AuditorWriteComments    *bool `json:"auditorWriteComments,omitempty"`
	AuditorWriteCommentsNeq *bool `json:"auditorWriteCommentsNEQ,omitempty"`
	// auditor_read_comments field predicates
	AuditorReadComments    *bool `json:"auditorReadComments,omitempty"`
	AuditorReadCommentsNeq *bool `json:"auditorReadCommentsNEQ,omitempty"`
}

type ProgramMembership struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	Role      enums.Role `json:"role"`
	ProgramID string     `json:"programID"`
	UserID    string     `json:"userID"`
	Program   *Program   `json:"program"`
	User      *User      `json:"user"`
}

func (ProgramMembership) IsNode() {}

// Return response for createBulkProgramMembership mutation
type ProgramMembershipBulkCreatePayload struct {
	// Created programMemberships
	ProgramMemberships []*ProgramMembership `json:"programMemberships,omitempty"`
}

// A connection to a list of items.
type ProgramMembershipConnection struct {
	// A list of edges.
	Edges []*ProgramMembershipEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createProgramMembership mutation
type ProgramMembershipCreatePayload struct {
	// Created programMembership
	ProgramMembership *ProgramMembership `json:"programMembership"`
}

// Return response for deleteProgramMembership mutation
type ProgramMembershipDeletePayload struct {
	// Deleted programMembership ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ProgramMembershipEdge struct {
	// The item at the end of the edge.
	Node *ProgramMembership `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ProgramMembershipHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	Role        enums.Role     `json:"role"`
	ProgramID   string         `json:"programID"`
	UserID      string         `json:"userID"`
}

func (ProgramMembershipHistory) IsNode() {}

// A connection to a list of items.
type ProgramMembershipHistoryConnection struct {
	// A list of edges.
	Edges []*ProgramMembershipHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ProgramMembershipHistoryEdge struct {
	// The item at the end of the edge.
	Node *ProgramMembershipHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ProgramMembershipHistoryWhereInput is used for filtering ProgramMembershipHistory objects.
// Input was generated by ent.
type ProgramMembershipHistoryWhereInput struct {
	Not *ProgramMembershipHistoryWhereInput   `json:"not,omitempty"`
	And []*ProgramMembershipHistoryWhereInput `json:"and,omitempty"`
	Or  []*ProgramMembershipHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// program_id field predicates
	ProgramID             *string  `json:"programID,omitempty"`
	ProgramIdneq          *string  `json:"programIDNEQ,omitempty"`
	ProgramIDIn           []string `json:"programIDIn,omitempty"`
	ProgramIDNotIn        []string `json:"programIDNotIn,omitempty"`
	ProgramIdgt           *string  `json:"programIDGT,omitempty"`
	ProgramIdgte          *string  `json:"programIDGTE,omitempty"`
	ProgramIdlt           *string  `json:"programIDLT,omitempty"`
	ProgramIdlte          *string  `json:"programIDLTE,omitempty"`
	ProgramIDContains     *string  `json:"programIDContains,omitempty"`
	ProgramIDHasPrefix    *string  `json:"programIDHasPrefix,omitempty"`
	ProgramIDHasSuffix    *string  `json:"programIDHasSuffix,omitempty"`
	ProgramIDEqualFold    *string  `json:"programIDEqualFold,omitempty"`
	ProgramIDContainsFold *string  `json:"programIDContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// Return response for updateProgramMembership mutation
type ProgramMembershipUpdatePayload struct {
	// Updated programMembership
	ProgramMembership *ProgramMembership `json:"programMembership"`
}

// ProgramMembershipWhereInput is used for filtering ProgramMembership objects.
// Input was generated by ent.
type ProgramMembershipWhereInput struct {
	Not *ProgramMembershipWhereInput   `json:"not,omitempty"`
	And []*ProgramMembershipWhereInput `json:"and,omitempty"`
	Or  []*ProgramMembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	ProgramID *string      `json:"programID,omitempty"`
	UserID    *string      `json:"userID,omitempty"`
}

type ProgramSearchResult struct {
	Programs []*Program `json:"programs,omitempty"`
}

func (ProgramSearchResult) IsSearchResult() {}

// Return response for updateProgram mutation
type ProgramUpdatePayload struct {
	// Updated program
	Program *Program `json:"program"`
}

// ProgramWhereInput is used for filtering Program objects.
// Input was generated by ent.
type ProgramWhereInput struct {
	Not *ProgramWhereInput   `json:"not,omitempty"`
	And []*ProgramWhereInput `json:"and,omitempty"`
	Or  []*ProgramWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status      *enums.ProgramStatus  `json:"status,omitempty"`
	StatusNeq   *enums.ProgramStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.ProgramStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.ProgramStatus `json:"statusNotIn,omitempty"`
	// start_date field predicates
	StartDate       *time.Time   `json:"startDate,omitempty"`
	StartDateNeq    *time.Time   `json:"startDateNEQ,omitempty"`
	StartDateIn     []*time.Time `json:"startDateIn,omitempty"`
	StartDateNotIn  []*time.Time `json:"startDateNotIn,omitempty"`
	StartDateGt     *time.Time   `json:"startDateGT,omitempty"`
	StartDateGte    *time.Time   `json:"startDateGTE,omitempty"`
	StartDateLt     *time.Time   `json:"startDateLT,omitempty"`
	StartDateLte    *time.Time   `json:"startDateLTE,omitempty"`
	StartDateIsNil  *bool        `json:"startDateIsNil,omitempty"`
	StartDateNotNil *bool        `json:"startDateNotNil,omitempty"`
	// end_date field predicates
	EndDate       *time.Time   `json:"endDate,omitempty"`
	EndDateNeq    *time.Time   `json:"endDateNEQ,omitempty"`
	EndDateIn     []*time.Time `json:"endDateIn,omitempty"`
	EndDateNotIn  []*time.Time `json:"endDateNotIn,omitempty"`
	EndDateGt     *time.Time   `json:"endDateGT,omitempty"`
	EndDateGte    *time.Time   `json:"endDateGTE,omitempty"`
	EndDateLt     *time.Time   `json:"endDateLT,omitempty"`
	EndDateLte    *time.Time   `json:"endDateLTE,omitempty"`
	EndDateIsNil  *bool        `json:"endDateIsNil,omitempty"`
	EndDateNotNil *bool        `json:"endDateNotNil,omitempty"`
	// auditor_ready field predicates
	AuditorReady    *bool `json:"auditorReady,omitempty"`
	AuditorReadyNeq *bool `json:"auditorReadyNEQ,omitempty"`
	// auditor_write_comments field predicates
	AuditorWriteComments    *bool `json:"auditorWriteComments,omitempty"`
	AuditorWriteCommentsNeq *bool `json:"auditorWriteCommentsNEQ,omitempty"`
	// auditor_read_comments field predicates
	AuditorReadComments    *bool `json:"auditorReadComments,omitempty"`
	AuditorReadCommentsNeq *bool `json:"auditorReadCommentsNEQ,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// notes edge predicates
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// members edge predicates
	HasMembers     *bool                          `json:"hasMembers,omitempty"`
	HasMembersWith []*ProgramMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

type Query struct {
}

type Risk struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the risk
	Name string `json:"name"`
	// description of the risk
	Description *string `json:"description,omitempty"`
	// status of the risk - mitigated or not, inflight, etc.
	Status *string `json:"status,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType *string `json:"riskType,omitempty"`
	// business costs associated with the risk
	BusinessCosts *string `json:"businessCosts,omitempty"`
	// impact of the risk - high, medium, low
	Impact *enums.RiskImpact `json:"impact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood *enums.RiskLikelihood `json:"likelihood,omitempty"`
	// mitigation for the risk
	Mitigation *string `json:"mitigation,omitempty"`
	// which controls are satisfied by the risk
	Satisfies *string `json:"satisfies,omitempty"`
	// json data for the risk document
	Details map[string]any `json:"details,omitempty"`
	Owner   *Organization  `json:"owner,omitempty"`
	// groups that are blocked from viewing or editing the risk
	BlockedGroups []*Group `json:"blockedGroups,omitempty"`
	// provides edit access to the risk to members of the group
	Editors []*Group `json:"editors,omitempty"`
	// provides view access to the risk to members of the group
	Viewers     []*Group      `json:"viewers,omitempty"`
	Control     []*Control    `json:"control,omitempty"`
	Procedure   []*Procedure  `json:"procedure,omitempty"`
	ActionPlans []*ActionPlan `json:"actionPlans,omitempty"`
	Programs    []*Program    `json:"programs,omitempty"`
}

func (Risk) IsNode() {}

// Return response for createBulkRisk mutation
type RiskBulkCreatePayload struct {
	// Created risks
	Risks []*Risk `json:"risks,omitempty"`
}

// A connection to a list of items.
type RiskConnection struct {
	// A list of edges.
	Edges []*RiskEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createRisk mutation
type RiskCreatePayload struct {
	// Created risk
	Risk *Risk `json:"risk"`
}

// Return response for deleteRisk mutation
type RiskDeletePayload struct {
	// Deleted risk ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type RiskEdge struct {
	// The item at the end of the edge.
	Node *Risk `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type RiskHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the risk
	Name string `json:"name"`
	// description of the risk
	Description *string `json:"description,omitempty"`
	// status of the risk - mitigated or not, inflight, etc.
	Status *string `json:"status,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType *string `json:"riskType,omitempty"`
	// business costs associated with the risk
	BusinessCosts *string `json:"businessCosts,omitempty"`
	// impact of the risk - high, medium, low
	Impact *enums.RiskImpact `json:"impact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood *enums.RiskLikelihood `json:"likelihood,omitempty"`
	// mitigation for the risk
	Mitigation *string `json:"mitigation,omitempty"`
	// which controls are satisfied by the risk
	Satisfies *string `json:"satisfies,omitempty"`
	// json data for the risk document
	Details map[string]any `json:"details,omitempty"`
}

func (RiskHistory) IsNode() {}

// A connection to a list of items.
type RiskHistoryConnection struct {
	// A list of edges.
	Edges []*RiskHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type RiskHistoryEdge struct {
	// The item at the end of the edge.
	Node *RiskHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// RiskHistoryWhereInput is used for filtering RiskHistory objects.
// Input was generated by ent.
type RiskHistoryWhereInput struct {
	Not *RiskHistoryWhereInput   `json:"not,omitempty"`
	And []*RiskHistoryWhereInput `json:"and,omitempty"`
	Or  []*RiskHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// risk_type field predicates
	RiskType             *string  `json:"riskType,omitempty"`
	RiskTypeNeq          *string  `json:"riskTypeNEQ,omitempty"`
	RiskTypeIn           []string `json:"riskTypeIn,omitempty"`
	RiskTypeNotIn        []string `json:"riskTypeNotIn,omitempty"`
	RiskTypeGt           *string  `json:"riskTypeGT,omitempty"`
	RiskTypeGte          *string  `json:"riskTypeGTE,omitempty"`
	RiskTypeLt           *string  `json:"riskTypeLT,omitempty"`
	RiskTypeLte          *string  `json:"riskTypeLTE,omitempty"`
	RiskTypeContains     *string  `json:"riskTypeContains,omitempty"`
	RiskTypeHasPrefix    *string  `json:"riskTypeHasPrefix,omitempty"`
	RiskTypeHasSuffix    *string  `json:"riskTypeHasSuffix,omitempty"`
	RiskTypeIsNil        *bool    `json:"riskTypeIsNil,omitempty"`
	RiskTypeNotNil       *bool    `json:"riskTypeNotNil,omitempty"`
	RiskTypeEqualFold    *string  `json:"riskTypeEqualFold,omitempty"`
	RiskTypeContainsFold *string  `json:"riskTypeContainsFold,omitempty"`
	// business_costs field predicates
	BusinessCosts             *string  `json:"businessCosts,omitempty"`
	BusinessCostsNeq          *string  `json:"businessCostsNEQ,omitempty"`
	BusinessCostsIn           []string `json:"businessCostsIn,omitempty"`
	BusinessCostsNotIn        []string `json:"businessCostsNotIn,omitempty"`
	BusinessCostsGt           *string  `json:"businessCostsGT,omitempty"`
	BusinessCostsGte          *string  `json:"businessCostsGTE,omitempty"`
	BusinessCostsLt           *string  `json:"businessCostsLT,omitempty"`
	BusinessCostsLte          *string  `json:"businessCostsLTE,omitempty"`
	BusinessCostsContains     *string  `json:"businessCostsContains,omitempty"`
	BusinessCostsHasPrefix    *string  `json:"businessCostsHasPrefix,omitempty"`
	BusinessCostsHasSuffix    *string  `json:"businessCostsHasSuffix,omitempty"`
	BusinessCostsIsNil        *bool    `json:"businessCostsIsNil,omitempty"`
	BusinessCostsNotNil       *bool    `json:"businessCostsNotNil,omitempty"`
	BusinessCostsEqualFold    *string  `json:"businessCostsEqualFold,omitempty"`
	BusinessCostsContainsFold *string  `json:"businessCostsContainsFold,omitempty"`
	// impact field predicates
	Impact       *enums.RiskImpact  `json:"impact,omitempty"`
	ImpactNeq    *enums.RiskImpact  `json:"impactNEQ,omitempty"`
	ImpactIn     []enums.RiskImpact `json:"impactIn,omitempty"`
	ImpactNotIn  []enums.RiskImpact `json:"impactNotIn,omitempty"`
	ImpactIsNil  *bool              `json:"impactIsNil,omitempty"`
	ImpactNotNil *bool              `json:"impactNotNil,omitempty"`
	// likelihood field predicates
	Likelihood       *enums.RiskLikelihood  `json:"likelihood,omitempty"`
	LikelihoodNeq    *enums.RiskLikelihood  `json:"likelihoodNEQ,omitempty"`
	LikelihoodIn     []enums.RiskLikelihood `json:"likelihoodIn,omitempty"`
	LikelihoodNotIn  []enums.RiskLikelihood `json:"likelihoodNotIn,omitempty"`
	LikelihoodIsNil  *bool                  `json:"likelihoodIsNil,omitempty"`
	LikelihoodNotNil *bool                  `json:"likelihoodNotNil,omitempty"`
	// mitigation field predicates
	Mitigation             *string  `json:"mitigation,omitempty"`
	MitigationNeq          *string  `json:"mitigationNEQ,omitempty"`
	MitigationIn           []string `json:"mitigationIn,omitempty"`
	MitigationNotIn        []string `json:"mitigationNotIn,omitempty"`
	MitigationGt           *string  `json:"mitigationGT,omitempty"`
	MitigationGte          *string  `json:"mitigationGTE,omitempty"`
	MitigationLt           *string  `json:"mitigationLT,omitempty"`
	MitigationLte          *string  `json:"mitigationLTE,omitempty"`
	MitigationContains     *string  `json:"mitigationContains,omitempty"`
	MitigationHasPrefix    *string  `json:"mitigationHasPrefix,omitempty"`
	MitigationHasSuffix    *string  `json:"mitigationHasSuffix,omitempty"`
	MitigationIsNil        *bool    `json:"mitigationIsNil,omitempty"`
	MitigationNotNil       *bool    `json:"mitigationNotNil,omitempty"`
	MitigationEqualFold    *string  `json:"mitigationEqualFold,omitempty"`
	MitigationContainsFold *string  `json:"mitigationContainsFold,omitempty"`
	// satisfies field predicates
	Satisfies             *string  `json:"satisfies,omitempty"`
	SatisfiesNeq          *string  `json:"satisfiesNEQ,omitempty"`
	SatisfiesIn           []string `json:"satisfiesIn,omitempty"`
	SatisfiesNotIn        []string `json:"satisfiesNotIn,omitempty"`
	SatisfiesGt           *string  `json:"satisfiesGT,omitempty"`
	SatisfiesGte          *string  `json:"satisfiesGTE,omitempty"`
	SatisfiesLt           *string  `json:"satisfiesLT,omitempty"`
	SatisfiesLte          *string  `json:"satisfiesLTE,omitempty"`
	SatisfiesContains     *string  `json:"satisfiesContains,omitempty"`
	SatisfiesHasPrefix    *string  `json:"satisfiesHasPrefix,omitempty"`
	SatisfiesHasSuffix    *string  `json:"satisfiesHasSuffix,omitempty"`
	SatisfiesIsNil        *bool    `json:"satisfiesIsNil,omitempty"`
	SatisfiesNotNil       *bool    `json:"satisfiesNotNil,omitempty"`
	SatisfiesEqualFold    *string  `json:"satisfiesEqualFold,omitempty"`
	SatisfiesContainsFold *string  `json:"satisfiesContainsFold,omitempty"`
}

type RiskSearchResult struct {
	Risks []*Risk `json:"risks,omitempty"`
}

func (RiskSearchResult) IsSearchResult() {}

// Return response for updateRisk mutation
type RiskUpdatePayload struct {
	// Updated risk
	Risk *Risk `json:"risk"`
}

// RiskWhereInput is used for filtering Risk objects.
// Input was generated by ent.
type RiskWhereInput struct {
	Not *RiskWhereInput   `json:"not,omitempty"`
	And []*RiskWhereInput `json:"and,omitempty"`
	Or  []*RiskWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// risk_type field predicates
	RiskType             *string  `json:"riskType,omitempty"`
	RiskTypeNeq          *string  `json:"riskTypeNEQ,omitempty"`
	RiskTypeIn           []string `json:"riskTypeIn,omitempty"`
	RiskTypeNotIn        []string `json:"riskTypeNotIn,omitempty"`
	RiskTypeGt           *string  `json:"riskTypeGT,omitempty"`
	RiskTypeGte          *string  `json:"riskTypeGTE,omitempty"`
	RiskTypeLt           *string  `json:"riskTypeLT,omitempty"`
	RiskTypeLte          *string  `json:"riskTypeLTE,omitempty"`
	RiskTypeContains     *string  `json:"riskTypeContains,omitempty"`
	RiskTypeHasPrefix    *string  `json:"riskTypeHasPrefix,omitempty"`
	RiskTypeHasSuffix    *string  `json:"riskTypeHasSuffix,omitempty"`
	RiskTypeIsNil        *bool    `json:"riskTypeIsNil,omitempty"`
	RiskTypeNotNil       *bool    `json:"riskTypeNotNil,omitempty"`
	RiskTypeEqualFold    *string  `json:"riskTypeEqualFold,omitempty"`
	RiskTypeContainsFold *string  `json:"riskTypeContainsFold,omitempty"`
	// business_costs field predicates
	BusinessCosts             *string  `json:"businessCosts,omitempty"`
	BusinessCostsNeq          *string  `json:"businessCostsNEQ,omitempty"`
	BusinessCostsIn           []string `json:"businessCostsIn,omitempty"`
	BusinessCostsNotIn        []string `json:"businessCostsNotIn,omitempty"`
	BusinessCostsGt           *string  `json:"businessCostsGT,omitempty"`
	BusinessCostsGte          *string  `json:"businessCostsGTE,omitempty"`
	BusinessCostsLt           *string  `json:"businessCostsLT,omitempty"`
	BusinessCostsLte          *string  `json:"businessCostsLTE,omitempty"`
	BusinessCostsContains     *string  `json:"businessCostsContains,omitempty"`
	BusinessCostsHasPrefix    *string  `json:"businessCostsHasPrefix,omitempty"`
	BusinessCostsHasSuffix    *string  `json:"businessCostsHasSuffix,omitempty"`
	BusinessCostsIsNil        *bool    `json:"businessCostsIsNil,omitempty"`
	BusinessCostsNotNil       *bool    `json:"businessCostsNotNil,omitempty"`
	BusinessCostsEqualFold    *string  `json:"businessCostsEqualFold,omitempty"`
	BusinessCostsContainsFold *string  `json:"businessCostsContainsFold,omitempty"`
	// impact field predicates
	Impact       *enums.RiskImpact  `json:"impact,omitempty"`
	ImpactNeq    *enums.RiskImpact  `json:"impactNEQ,omitempty"`
	ImpactIn     []enums.RiskImpact `json:"impactIn,omitempty"`
	ImpactNotIn  []enums.RiskImpact `json:"impactNotIn,omitempty"`
	ImpactIsNil  *bool              `json:"impactIsNil,omitempty"`
	ImpactNotNil *bool              `json:"impactNotNil,omitempty"`
	// likelihood field predicates
	Likelihood       *enums.RiskLikelihood  `json:"likelihood,omitempty"`
	LikelihoodNeq    *enums.RiskLikelihood  `json:"likelihoodNEQ,omitempty"`
	LikelihoodIn     []enums.RiskLikelihood `json:"likelihoodIn,omitempty"`
	LikelihoodNotIn  []enums.RiskLikelihood `json:"likelihoodNotIn,omitempty"`
	LikelihoodIsNil  *bool                  `json:"likelihoodIsNil,omitempty"`
	LikelihoodNotNil *bool                  `json:"likelihoodNotNil,omitempty"`
	// mitigation field predicates
	Mitigation             *string  `json:"mitigation,omitempty"`
	MitigationNeq          *string  `json:"mitigationNEQ,omitempty"`
	MitigationIn           []string `json:"mitigationIn,omitempty"`
	MitigationNotIn        []string `json:"mitigationNotIn,omitempty"`
	MitigationGt           *string  `json:"mitigationGT,omitempty"`
	MitigationGte          *string  `json:"mitigationGTE,omitempty"`
	MitigationLt           *string  `json:"mitigationLT,omitempty"`
	MitigationLte          *string  `json:"mitigationLTE,omitempty"`
	MitigationContains     *string  `json:"mitigationContains,omitempty"`
	MitigationHasPrefix    *string  `json:"mitigationHasPrefix,omitempty"`
	MitigationHasSuffix    *string  `json:"mitigationHasSuffix,omitempty"`
	MitigationIsNil        *bool    `json:"mitigationIsNil,omitempty"`
	MitigationNotNil       *bool    `json:"mitigationNotNil,omitempty"`
	MitigationEqualFold    *string  `json:"mitigationEqualFold,omitempty"`
	MitigationContainsFold *string  `json:"mitigationContainsFold,omitempty"`
	// satisfies field predicates
	Satisfies             *string  `json:"satisfies,omitempty"`
	SatisfiesNeq          *string  `json:"satisfiesNEQ,omitempty"`
	SatisfiesIn           []string `json:"satisfiesIn,omitempty"`
	SatisfiesNotIn        []string `json:"satisfiesNotIn,omitempty"`
	SatisfiesGt           *string  `json:"satisfiesGT,omitempty"`
	SatisfiesGte          *string  `json:"satisfiesGTE,omitempty"`
	SatisfiesLt           *string  `json:"satisfiesLT,omitempty"`
	SatisfiesLte          *string  `json:"satisfiesLTE,omitempty"`
	SatisfiesContains     *string  `json:"satisfiesContains,omitempty"`
	SatisfiesHasPrefix    *string  `json:"satisfiesHasPrefix,omitempty"`
	SatisfiesHasSuffix    *string  `json:"satisfiesHasSuffix,omitempty"`
	SatisfiesIsNil        *bool    `json:"satisfiesIsNil,omitempty"`
	SatisfiesNotNil       *bool    `json:"satisfiesNotNil,omitempty"`
	SatisfiesEqualFold    *string  `json:"satisfiesEqualFold,omitempty"`
	SatisfiesContainsFold *string  `json:"satisfiesContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// blocked_groups edge predicates
	HasBlockedGroups     *bool              `json:"hasBlockedGroups,omitempty"`
	HasBlockedGroupsWith []*GroupWhereInput `json:"hasBlockedGroupsWith,omitempty"`
	// editors edge predicates
	HasEditors     *bool              `json:"hasEditors,omitempty"`
	HasEditorsWith []*GroupWhereInput `json:"hasEditorsWith,omitempty"`
	// viewers edge predicates
	HasViewers     *bool              `json:"hasViewers,omitempty"`
	HasViewersWith []*GroupWhereInput `json:"hasViewersWith,omitempty"`
	// control edge predicates
	HasControl     *bool                `json:"hasControl,omitempty"`
	HasControlWith []*ControlWhereInput `json:"hasControlWith,omitempty"`
	// procedure edge predicates
	HasProcedure     *bool                  `json:"hasProcedure,omitempty"`
	HasProcedureWith []*ProcedureWhereInput `json:"hasProcedureWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
}

type SearchResultConnection struct {
	// Information to aid in pagination.
	Page *PageInfo `json:"page"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
	// A list of nodes with results.
	Nodes []SearchResult `json:"nodes"`
}

type Standard struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the long name of the standard body
	Name string `json:"name"`
	// short name of the standard, e.g. SOC 2, ISO 27001, etc.
	ShortName *string `json:"shortName,omitempty"`
	// unique identifier of the standard with version
	Framework *string `json:"framework,omitempty"`
	// description of the standard
	Description *string `json:"description,omitempty"`
	// governing body of the standard, e.g. AICPA, etc.
	GoverningBody *string `json:"governingBody,omitempty"`
	// domains the standard covers, e.g. availability, confidentiality, etc.
	Domains []string `json:"domains,omitempty"`
	// link to the official standard documentation
	Link *string `json:"link,omitempty"`
	// status of the standard - active, deprecated, etc.
	Status *string `json:"status,omitempty"`
	// indicates if the standard should be made available to all users, only for public standards
	IsPublic *bool `json:"isPublic,omitempty"`
	// indicates if the standard is freely distributable under a trial license, only for public standards
	FreeToUse *bool `json:"freeToUse,omitempty"`
	// indicates if the standard is owned by the the openlane system
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// type of the standard - security, privacy, etc.
	StandardType *string `json:"standardType,omitempty"`
	// version of the standard
	Version *string `json:"version,omitempty"`
	// internal revision of the standard
	Revision *string       `json:"revision,omitempty"`
	Owner    *Organization `json:"owner,omitempty"`
	Controls []*Control    `json:"controls,omitempty"`
}

func (Standard) IsNode() {}

// Return response for createBulkStandard mutation
type StandardBulkCreatePayload struct {
	// Created standards
	Standards []*Standard `json:"standards,omitempty"`
}

// A connection to a list of items.
type StandardConnection struct {
	// A list of edges.
	Edges []*StandardEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createStandard mutation
type StandardCreatePayload struct {
	// Created standard
	Standard *Standard `json:"standard"`
}

// Return response for deleteStandard mutation
type StandardDeletePayload struct {
	// Deleted standard ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type StandardEdge struct {
	// The item at the end of the edge.
	Node *Standard `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type StandardHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the long name of the standard body
	Name string `json:"name"`
	// short name of the standard, e.g. SOC 2, ISO 27001, etc.
	ShortName *string `json:"shortName,omitempty"`
	// unique identifier of the standard with version
	Framework *string `json:"framework,omitempty"`
	// description of the standard
	Description *string `json:"description,omitempty"`
	// governing body of the standard, e.g. AICPA, etc.
	GoverningBody *string `json:"governingBody,omitempty"`
	// domains the standard covers, e.g. availability, confidentiality, etc.
	Domains []string `json:"domains,omitempty"`
	// link to the official standard documentation
	Link *string `json:"link,omitempty"`
	// status of the standard - active, deprecated, etc.
	Status *string `json:"status,omitempty"`
	// indicates if the standard should be made available to all users, only for public standards
	IsPublic *bool `json:"isPublic,omitempty"`
	// indicates if the standard is freely distributable under a trial license, only for public standards
	FreeToUse *bool `json:"freeToUse,omitempty"`
	// indicates if the standard is owned by the the openlane system
	SystemOwned *bool `json:"systemOwned,omitempty"`
	// type of the standard - security, privacy, etc.
	StandardType *string `json:"standardType,omitempty"`
	// version of the standard
	Version *string `json:"version,omitempty"`
	// internal revision of the standard
	Revision *string `json:"revision,omitempty"`
}

func (StandardHistory) IsNode() {}

// A connection to a list of items.
type StandardHistoryConnection struct {
	// A list of edges.
	Edges []*StandardHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type StandardHistoryEdge struct {
	// The item at the end of the edge.
	Node *StandardHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// StandardHistoryWhereInput is used for filtering StandardHistory objects.
// Input was generated by ent.
type StandardHistoryWhereInput struct {
	Not *StandardHistoryWhereInput   `json:"not,omitempty"`
	And []*StandardHistoryWhereInput `json:"and,omitempty"`
	Or  []*StandardHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// short_name field predicates
	ShortName             *string  `json:"shortName,omitempty"`
	ShortNameNeq          *string  `json:"shortNameNEQ,omitempty"`
	ShortNameIn           []string `json:"shortNameIn,omitempty"`
	ShortNameNotIn        []string `json:"shortNameNotIn,omitempty"`
	ShortNameGt           *string  `json:"shortNameGT,omitempty"`
	ShortNameGte          *string  `json:"shortNameGTE,omitempty"`
	ShortNameLt           *string  `json:"shortNameLT,omitempty"`
	ShortNameLte          *string  `json:"shortNameLTE,omitempty"`
	ShortNameContains     *string  `json:"shortNameContains,omitempty"`
	ShortNameHasPrefix    *string  `json:"shortNameHasPrefix,omitempty"`
	ShortNameHasSuffix    *string  `json:"shortNameHasSuffix,omitempty"`
	ShortNameIsNil        *bool    `json:"shortNameIsNil,omitempty"`
	ShortNameNotNil       *bool    `json:"shortNameNotNil,omitempty"`
	ShortNameEqualFold    *string  `json:"shortNameEqualFold,omitempty"`
	ShortNameContainsFold *string  `json:"shortNameContainsFold,omitempty"`
	// framework field predicates
	Framework             *string  `json:"framework,omitempty"`
	FrameworkNeq          *string  `json:"frameworkNEQ,omitempty"`
	FrameworkIn           []string `json:"frameworkIn,omitempty"`
	FrameworkNotIn        []string `json:"frameworkNotIn,omitempty"`
	FrameworkGt           *string  `json:"frameworkGT,omitempty"`
	FrameworkGte          *string  `json:"frameworkGTE,omitempty"`
	FrameworkLt           *string  `json:"frameworkLT,omitempty"`
	FrameworkLte          *string  `json:"frameworkLTE,omitempty"`
	FrameworkContains     *string  `json:"frameworkContains,omitempty"`
	FrameworkHasPrefix    *string  `json:"frameworkHasPrefix,omitempty"`
	FrameworkHasSuffix    *string  `json:"frameworkHasSuffix,omitempty"`
	FrameworkIsNil        *bool    `json:"frameworkIsNil,omitempty"`
	FrameworkNotNil       *bool    `json:"frameworkNotNil,omitempty"`
	FrameworkEqualFold    *string  `json:"frameworkEqualFold,omitempty"`
	FrameworkContainsFold *string  `json:"frameworkContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// governing_body field predicates
	GoverningBody             *string  `json:"governingBody,omitempty"`
	GoverningBodyNeq          *string  `json:"governingBodyNEQ,omitempty"`
	GoverningBodyIn           []string `json:"governingBodyIn,omitempty"`
	GoverningBodyNotIn        []string `json:"governingBodyNotIn,omitempty"`
	GoverningBodyGt           *string  `json:"governingBodyGT,omitempty"`
	GoverningBodyGte          *string  `json:"governingBodyGTE,omitempty"`
	GoverningBodyLt           *string  `json:"governingBodyLT,omitempty"`
	GoverningBodyLte          *string  `json:"governingBodyLTE,omitempty"`
	GoverningBodyContains     *string  `json:"governingBodyContains,omitempty"`
	GoverningBodyHasPrefix    *string  `json:"governingBodyHasPrefix,omitempty"`
	GoverningBodyHasSuffix    *string  `json:"governingBodyHasSuffix,omitempty"`
	GoverningBodyIsNil        *bool    `json:"governingBodyIsNil,omitempty"`
	GoverningBodyNotNil       *bool    `json:"governingBodyNotNil,omitempty"`
	GoverningBodyEqualFold    *string  `json:"governingBodyEqualFold,omitempty"`
	GoverningBodyContainsFold *string  `json:"governingBodyContainsFold,omitempty"`
	// link field predicates
	Link             *string  `json:"link,omitempty"`
	LinkNeq          *string  `json:"linkNEQ,omitempty"`
	LinkIn           []string `json:"linkIn,omitempty"`
	LinkNotIn        []string `json:"linkNotIn,omitempty"`
	LinkGt           *string  `json:"linkGT,omitempty"`
	LinkGte          *string  `json:"linkGTE,omitempty"`
	LinkLt           *string  `json:"linkLT,omitempty"`
	LinkLte          *string  `json:"linkLTE,omitempty"`
	LinkContains     *string  `json:"linkContains,omitempty"`
	LinkHasPrefix    *string  `json:"linkHasPrefix,omitempty"`
	LinkHasSuffix    *string  `json:"linkHasSuffix,omitempty"`
	LinkIsNil        *bool    `json:"linkIsNil,omitempty"`
	LinkNotNil       *bool    `json:"linkNotNil,omitempty"`
	LinkEqualFold    *string  `json:"linkEqualFold,omitempty"`
	LinkContainsFold *string  `json:"linkContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// is_public field predicates
	IsPublic       *bool `json:"isPublic,omitempty"`
	IsPublicNeq    *bool `json:"isPublicNEQ,omitempty"`
	IsPublicIsNil  *bool `json:"isPublicIsNil,omitempty"`
	IsPublicNotNil *bool `json:"isPublicNotNil,omitempty"`
	// free_to_use field predicates
	FreeToUse       *bool `json:"freeToUse,omitempty"`
	FreeToUseNeq    *bool `json:"freeToUseNEQ,omitempty"`
	FreeToUseIsNil  *bool `json:"freeToUseIsNil,omitempty"`
	FreeToUseNotNil *bool `json:"freeToUseNotNil,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// standard_type field predicates
	StandardType             *string  `json:"standardType,omitempty"`
	StandardTypeNeq          *string  `json:"standardTypeNEQ,omitempty"`
	StandardTypeIn           []string `json:"standardTypeIn,omitempty"`
	StandardTypeNotIn        []string `json:"standardTypeNotIn,omitempty"`
	StandardTypeGt           *string  `json:"standardTypeGT,omitempty"`
	StandardTypeGte          *string  `json:"standardTypeGTE,omitempty"`
	StandardTypeLt           *string  `json:"standardTypeLT,omitempty"`
	StandardTypeLte          *string  `json:"standardTypeLTE,omitempty"`
	StandardTypeContains     *string  `json:"standardTypeContains,omitempty"`
	StandardTypeHasPrefix    *string  `json:"standardTypeHasPrefix,omitempty"`
	StandardTypeHasSuffix    *string  `json:"standardTypeHasSuffix,omitempty"`
	StandardTypeIsNil        *bool    `json:"standardTypeIsNil,omitempty"`
	StandardTypeNotNil       *bool    `json:"standardTypeNotNil,omitempty"`
	StandardTypeEqualFold    *string  `json:"standardTypeEqualFold,omitempty"`
	StandardTypeContainsFold *string  `json:"standardTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
}

type StandardSearchResult struct {
	Standards []*Standard `json:"standards,omitempty"`
}

func (StandardSearchResult) IsSearchResult() {}

// Return response for updateStandard mutation
type StandardUpdatePayload struct {
	// Updated standard
	Standard *Standard `json:"standard"`
}

// StandardWhereInput is used for filtering Standard objects.
// Input was generated by ent.
type StandardWhereInput struct {
	Not *StandardWhereInput   `json:"not,omitempty"`
	And []*StandardWhereInput `json:"and,omitempty"`
	Or  []*StandardWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// short_name field predicates
	ShortName             *string  `json:"shortName,omitempty"`
	ShortNameNeq          *string  `json:"shortNameNEQ,omitempty"`
	ShortNameIn           []string `json:"shortNameIn,omitempty"`
	ShortNameNotIn        []string `json:"shortNameNotIn,omitempty"`
	ShortNameGt           *string  `json:"shortNameGT,omitempty"`
	ShortNameGte          *string  `json:"shortNameGTE,omitempty"`
	ShortNameLt           *string  `json:"shortNameLT,omitempty"`
	ShortNameLte          *string  `json:"shortNameLTE,omitempty"`
	ShortNameContains     *string  `json:"shortNameContains,omitempty"`
	ShortNameHasPrefix    *string  `json:"shortNameHasPrefix,omitempty"`
	ShortNameHasSuffix    *string  `json:"shortNameHasSuffix,omitempty"`
	ShortNameIsNil        *bool    `json:"shortNameIsNil,omitempty"`
	ShortNameNotNil       *bool    `json:"shortNameNotNil,omitempty"`
	ShortNameEqualFold    *string  `json:"shortNameEqualFold,omitempty"`
	ShortNameContainsFold *string  `json:"shortNameContainsFold,omitempty"`
	// framework field predicates
	Framework             *string  `json:"framework,omitempty"`
	FrameworkNeq          *string  `json:"frameworkNEQ,omitempty"`
	FrameworkIn           []string `json:"frameworkIn,omitempty"`
	FrameworkNotIn        []string `json:"frameworkNotIn,omitempty"`
	FrameworkGt           *string  `json:"frameworkGT,omitempty"`
	FrameworkGte          *string  `json:"frameworkGTE,omitempty"`
	FrameworkLt           *string  `json:"frameworkLT,omitempty"`
	FrameworkLte          *string  `json:"frameworkLTE,omitempty"`
	FrameworkContains     *string  `json:"frameworkContains,omitempty"`
	FrameworkHasPrefix    *string  `json:"frameworkHasPrefix,omitempty"`
	FrameworkHasSuffix    *string  `json:"frameworkHasSuffix,omitempty"`
	FrameworkIsNil        *bool    `json:"frameworkIsNil,omitempty"`
	FrameworkNotNil       *bool    `json:"frameworkNotNil,omitempty"`
	FrameworkEqualFold    *string  `json:"frameworkEqualFold,omitempty"`
	FrameworkContainsFold *string  `json:"frameworkContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// governing_body field predicates
	GoverningBody             *string  `json:"governingBody,omitempty"`
	GoverningBodyNeq          *string  `json:"governingBodyNEQ,omitempty"`
	GoverningBodyIn           []string `json:"governingBodyIn,omitempty"`
	GoverningBodyNotIn        []string `json:"governingBodyNotIn,omitempty"`
	GoverningBodyGt           *string  `json:"governingBodyGT,omitempty"`
	GoverningBodyGte          *string  `json:"governingBodyGTE,omitempty"`
	GoverningBodyLt           *string  `json:"governingBodyLT,omitempty"`
	GoverningBodyLte          *string  `json:"governingBodyLTE,omitempty"`
	GoverningBodyContains     *string  `json:"governingBodyContains,omitempty"`
	GoverningBodyHasPrefix    *string  `json:"governingBodyHasPrefix,omitempty"`
	GoverningBodyHasSuffix    *string  `json:"governingBodyHasSuffix,omitempty"`
	GoverningBodyIsNil        *bool    `json:"governingBodyIsNil,omitempty"`
	GoverningBodyNotNil       *bool    `json:"governingBodyNotNil,omitempty"`
	GoverningBodyEqualFold    *string  `json:"governingBodyEqualFold,omitempty"`
	GoverningBodyContainsFold *string  `json:"governingBodyContainsFold,omitempty"`
	// link field predicates
	Link             *string  `json:"link,omitempty"`
	LinkNeq          *string  `json:"linkNEQ,omitempty"`
	LinkIn           []string `json:"linkIn,omitempty"`
	LinkNotIn        []string `json:"linkNotIn,omitempty"`
	LinkGt           *string  `json:"linkGT,omitempty"`
	LinkGte          *string  `json:"linkGTE,omitempty"`
	LinkLt           *string  `json:"linkLT,omitempty"`
	LinkLte          *string  `json:"linkLTE,omitempty"`
	LinkContains     *string  `json:"linkContains,omitempty"`
	LinkHasPrefix    *string  `json:"linkHasPrefix,omitempty"`
	LinkHasSuffix    *string  `json:"linkHasSuffix,omitempty"`
	LinkIsNil        *bool    `json:"linkIsNil,omitempty"`
	LinkNotNil       *bool    `json:"linkNotNil,omitempty"`
	LinkEqualFold    *string  `json:"linkEqualFold,omitempty"`
	LinkContainsFold *string  `json:"linkContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// is_public field predicates
	IsPublic       *bool `json:"isPublic,omitempty"`
	IsPublicNeq    *bool `json:"isPublicNEQ,omitempty"`
	IsPublicIsNil  *bool `json:"isPublicIsNil,omitempty"`
	IsPublicNotNil *bool `json:"isPublicNotNil,omitempty"`
	// free_to_use field predicates
	FreeToUse       *bool `json:"freeToUse,omitempty"`
	FreeToUseNeq    *bool `json:"freeToUseNEQ,omitempty"`
	FreeToUseIsNil  *bool `json:"freeToUseIsNil,omitempty"`
	FreeToUseNotNil *bool `json:"freeToUseNotNil,omitempty"`
	// system_owned field predicates
	SystemOwned       *bool `json:"systemOwned,omitempty"`
	SystemOwnedNeq    *bool `json:"systemOwnedNEQ,omitempty"`
	SystemOwnedIsNil  *bool `json:"systemOwnedIsNil,omitempty"`
	SystemOwnedNotNil *bool `json:"systemOwnedNotNil,omitempty"`
	// standard_type field predicates
	StandardType             *string  `json:"standardType,omitempty"`
	StandardTypeNeq          *string  `json:"standardTypeNEQ,omitempty"`
	StandardTypeIn           []string `json:"standardTypeIn,omitempty"`
	StandardTypeNotIn        []string `json:"standardTypeNotIn,omitempty"`
	StandardTypeGt           *string  `json:"standardTypeGT,omitempty"`
	StandardTypeGte          *string  `json:"standardTypeGTE,omitempty"`
	StandardTypeLt           *string  `json:"standardTypeLT,omitempty"`
	StandardTypeLte          *string  `json:"standardTypeLTE,omitempty"`
	StandardTypeContains     *string  `json:"standardTypeContains,omitempty"`
	StandardTypeHasPrefix    *string  `json:"standardTypeHasPrefix,omitempty"`
	StandardTypeHasSuffix    *string  `json:"standardTypeHasSuffix,omitempty"`
	StandardTypeIsNil        *bool    `json:"standardTypeIsNil,omitempty"`
	StandardTypeNotNil       *bool    `json:"standardTypeNotNil,omitempty"`
	StandardTypeEqualFold    *string  `json:"standardTypeEqualFold,omitempty"`
	StandardTypeContainsFold *string  `json:"standardTypeContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionIsNil        *bool    `json:"versionIsNil,omitempty"`
	VersionNotNil       *bool    `json:"versionNotNil,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// revision field predicates
	Revision             *string  `json:"revision,omitempty"`
	RevisionNeq          *string  `json:"revisionNEQ,omitempty"`
	RevisionIn           []string `json:"revisionIn,omitempty"`
	RevisionNotIn        []string `json:"revisionNotIn,omitempty"`
	RevisionGt           *string  `json:"revisionGT,omitempty"`
	RevisionGte          *string  `json:"revisionGTE,omitempty"`
	RevisionLt           *string  `json:"revisionLT,omitempty"`
	RevisionLte          *string  `json:"revisionLTE,omitempty"`
	RevisionContains     *string  `json:"revisionContains,omitempty"`
	RevisionHasPrefix    *string  `json:"revisionHasPrefix,omitempty"`
	RevisionHasSuffix    *string  `json:"revisionHasSuffix,omitempty"`
	RevisionIsNil        *bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil       *bool    `json:"revisionNotNil,omitempty"`
	RevisionEqualFold    *string  `json:"revisionEqualFold,omitempty"`
	RevisionContainsFold *string  `json:"revisionContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// controls edge predicates
	HasControls     *bool                `json:"hasControls,omitempty"`
	HasControlsWith []*ControlWhereInput `json:"hasControlsWith,omitempty"`
}

type Subcontrol struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// status of the control
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the unique reference code for the control
	RefCode string `json:"refCode"`
	// the id of the parent control
	ControlID string        `json:"controlID"`
	Owner     *Organization `json:"owner,omitempty"`
	Control   *Control      `json:"control"`
	// mapped subcontrols that have a relation to another control or subcontrol
	MappedControls    []*MappedControl    `json:"mappedControls,omitempty"`
	Evidence          []*Evidence         `json:"evidence,omitempty"`
	ControlObjectives []*ControlObjective `json:"controlObjectives,omitempty"`
	Tasks             []*Task             `json:"tasks,omitempty"`
	Narratives        []*Narrative        `json:"narratives,omitempty"`
	Risks             []*Risk             `json:"risks,omitempty"`
	ActionPlans       []*ActionPlan       `json:"actionPlans,omitempty"`
	Procedures        []*Procedure        `json:"procedures,omitempty"`
	InternalPolicies  []*InternalPolicy   `json:"internalPolicies,omitempty"`
	// the user who is responsible for the subcontrol, defaults to the parent control owner if not set
	ControlOwner *Group `json:"controlOwner,omitempty"`
	// temporary delegate for the control, used for temporary control ownership
	Delegate *Group `json:"delegate,omitempty"`
}

func (Subcontrol) IsNode() {}

// Return response for createBulkSubcontrol mutation
type SubcontrolBulkCreatePayload struct {
	// Created subcontrols
	Subcontrols []*Subcontrol `json:"subcontrols,omitempty"`
}

// A connection to a list of items.
type SubcontrolConnection struct {
	// A list of edges.
	Edges []*SubcontrolEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createSubcontrol mutation
type SubcontrolCreatePayload struct {
	// Created subcontrol
	Subcontrol *Subcontrol `json:"subcontrol"`
}

// Return response for deleteSubcontrol mutation
type SubcontrolDeletePayload struct {
	// Deleted subcontrol ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type SubcontrolEdge struct {
	// The item at the end of the edge.
	Node *Subcontrol `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type SubcontrolHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// description of what the control is supposed to accomplish
	Description *string `json:"description,omitempty"`
	// status of the control
	Status *string `json:"status,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source *enums.ControlSource `json:"source,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType *enums.ControlType `json:"controlType,omitempty"`
	// category of the control
	Category *string `json:"category,omitempty"`
	// category id of the control
	CategoryID *string `json:"categoryID,omitempty"`
	// subcategory of the control
	Subcategory *string `json:"subcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories []string `json:"mappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions []string `json:"controlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	// references for the control
	References []*models.Reference `json:"references,omitempty"`
	// the unique reference code for the control
	RefCode string `json:"refCode"`
	// the id of the parent control
	ControlID string `json:"controlID"`
}

func (SubcontrolHistory) IsNode() {}

// A connection to a list of items.
type SubcontrolHistoryConnection struct {
	// A list of edges.
	Edges []*SubcontrolHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type SubcontrolHistoryEdge struct {
	// The item at the end of the edge.
	Node *SubcontrolHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// SubcontrolHistoryWhereInput is used for filtering SubcontrolHistory objects.
// Input was generated by ent.
type SubcontrolHistoryWhereInput struct {
	Not *SubcontrolHistoryWhereInput   `json:"not,omitempty"`
	And []*SubcontrolHistoryWhereInput `json:"and,omitempty"`
	Or  []*SubcontrolHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// control_type field predicates
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNeq    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  *bool               `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil *bool               `json:"controlTypeNotNil,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// category_id field predicates
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIdneq          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIdgt           *string  `json:"categoryIDGT,omitempty"`
	CategoryIdgte          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIdlt           *string  `json:"categoryIDLT,omitempty"`
	CategoryIdlte          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        *bool    `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       *bool    `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
	// ref_code field predicates
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNeq          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGt           *string  `json:"refCodeGT,omitempty"`
	RefCodeGte          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLt           *string  `json:"refCodeLT,omitempty"`
	RefCodeLte          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`
	// control_id field predicates
	ControlID             *string  `json:"controlID,omitempty"`
	ControlIdneq          *string  `json:"controlIDNEQ,omitempty"`
	ControlIDIn           []string `json:"controlIDIn,omitempty"`
	ControlIDNotIn        []string `json:"controlIDNotIn,omitempty"`
	ControlIdgt           *string  `json:"controlIDGT,omitempty"`
	ControlIdgte          *string  `json:"controlIDGTE,omitempty"`
	ControlIdlt           *string  `json:"controlIDLT,omitempty"`
	ControlIdlte          *string  `json:"controlIDLTE,omitempty"`
	ControlIDContains     *string  `json:"controlIDContains,omitempty"`
	ControlIDHasPrefix    *string  `json:"controlIDHasPrefix,omitempty"`
	ControlIDHasSuffix    *string  `json:"controlIDHasSuffix,omitempty"`
	ControlIDEqualFold    *string  `json:"controlIDEqualFold,omitempty"`
	ControlIDContainsFold *string  `json:"controlIDContainsFold,omitempty"`
}

type SubcontrolSearchResult struct {
	Subcontrols []*Subcontrol `json:"subcontrols,omitempty"`
}

func (SubcontrolSearchResult) IsSearchResult() {}

// Return response for updateSubcontrol mutation
type SubcontrolUpdatePayload struct {
	// Updated subcontrol
	Subcontrol *Subcontrol `json:"subcontrol"`
}

// SubcontrolWhereInput is used for filtering Subcontrol objects.
// Input was generated by ent.
type SubcontrolWhereInput struct {
	Not *SubcontrolWhereInput   `json:"not,omitempty"`
	And []*SubcontrolWhereInput `json:"and,omitempty"`
	Or  []*SubcontrolWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// source field predicates
	Source       *enums.ControlSource  `json:"source,omitempty"`
	SourceNeq    *enums.ControlSource  `json:"sourceNEQ,omitempty"`
	SourceIn     []enums.ControlSource `json:"sourceIn,omitempty"`
	SourceNotIn  []enums.ControlSource `json:"sourceNotIn,omitempty"`
	SourceIsNil  *bool                 `json:"sourceIsNil,omitempty"`
	SourceNotNil *bool                 `json:"sourceNotNil,omitempty"`
	// control_type field predicates
	ControlType       *enums.ControlType  `json:"controlType,omitempty"`
	ControlTypeNeq    *enums.ControlType  `json:"controlTypeNEQ,omitempty"`
	ControlTypeIn     []enums.ControlType `json:"controlTypeIn,omitempty"`
	ControlTypeNotIn  []enums.ControlType `json:"controlTypeNotIn,omitempty"`
	ControlTypeIsNil  *bool               `json:"controlTypeIsNil,omitempty"`
	ControlTypeNotNil *bool               `json:"controlTypeNotNil,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// category_id field predicates
	CategoryID             *string  `json:"categoryID,omitempty"`
	CategoryIdneq          *string  `json:"categoryIDNEQ,omitempty"`
	CategoryIDIn           []string `json:"categoryIDIn,omitempty"`
	CategoryIDNotIn        []string `json:"categoryIDNotIn,omitempty"`
	CategoryIdgt           *string  `json:"categoryIDGT,omitempty"`
	CategoryIdgte          *string  `json:"categoryIDGTE,omitempty"`
	CategoryIdlt           *string  `json:"categoryIDLT,omitempty"`
	CategoryIdlte          *string  `json:"categoryIDLTE,omitempty"`
	CategoryIDContains     *string  `json:"categoryIDContains,omitempty"`
	CategoryIDHasPrefix    *string  `json:"categoryIDHasPrefix,omitempty"`
	CategoryIDHasSuffix    *string  `json:"categoryIDHasSuffix,omitempty"`
	CategoryIDIsNil        *bool    `json:"categoryIDIsNil,omitempty"`
	CategoryIDNotNil       *bool    `json:"categoryIDNotNil,omitempty"`
	CategoryIDEqualFold    *string  `json:"categoryIDEqualFold,omitempty"`
	CategoryIDContainsFold *string  `json:"categoryIDContainsFold,omitempty"`
	// subcategory field predicates
	Subcategory             *string  `json:"subcategory,omitempty"`
	SubcategoryNeq          *string  `json:"subcategoryNEQ,omitempty"`
	SubcategoryIn           []string `json:"subcategoryIn,omitempty"`
	SubcategoryNotIn        []string `json:"subcategoryNotIn,omitempty"`
	SubcategoryGt           *string  `json:"subcategoryGT,omitempty"`
	SubcategoryGte          *string  `json:"subcategoryGTE,omitempty"`
	SubcategoryLt           *string  `json:"subcategoryLT,omitempty"`
	SubcategoryLte          *string  `json:"subcategoryLTE,omitempty"`
	SubcategoryContains     *string  `json:"subcategoryContains,omitempty"`
	SubcategoryHasPrefix    *string  `json:"subcategoryHasPrefix,omitempty"`
	SubcategoryHasSuffix    *string  `json:"subcategoryHasSuffix,omitempty"`
	SubcategoryIsNil        *bool    `json:"subcategoryIsNil,omitempty"`
	SubcategoryNotNil       *bool    `json:"subcategoryNotNil,omitempty"`
	SubcategoryEqualFold    *string  `json:"subcategoryEqualFold,omitempty"`
	SubcategoryContainsFold *string  `json:"subcategoryContainsFold,omitempty"`
	// ref_code field predicates
	RefCode             *string  `json:"refCode,omitempty"`
	RefCodeNeq          *string  `json:"refCodeNEQ,omitempty"`
	RefCodeIn           []string `json:"refCodeIn,omitempty"`
	RefCodeNotIn        []string `json:"refCodeNotIn,omitempty"`
	RefCodeGt           *string  `json:"refCodeGT,omitempty"`
	RefCodeGte          *string  `json:"refCodeGTE,omitempty"`
	RefCodeLt           *string  `json:"refCodeLT,omitempty"`
	RefCodeLte          *string  `json:"refCodeLTE,omitempty"`
	RefCodeContains     *string  `json:"refCodeContains,omitempty"`
	RefCodeHasPrefix    *string  `json:"refCodeHasPrefix,omitempty"`
	RefCodeHasSuffix    *string  `json:"refCodeHasSuffix,omitempty"`
	RefCodeEqualFold    *string  `json:"refCodeEqualFold,omitempty"`
	RefCodeContainsFold *string  `json:"refCodeContainsFold,omitempty"`
	// control_id field predicates
	ControlID             *string  `json:"controlID,omitempty"`
	ControlIdneq          *string  `json:"controlIDNEQ,omitempty"`
	ControlIDIn           []string `json:"controlIDIn,omitempty"`
	ControlIDNotIn        []string `json:"controlIDNotIn,omitempty"`
	ControlIdgt           *string  `json:"controlIDGT,omitempty"`
	ControlIdgte          *string  `json:"controlIDGTE,omitempty"`
	ControlIdlt           *string  `json:"controlIDLT,omitempty"`
	ControlIdlte          *string  `json:"controlIDLTE,omitempty"`
	ControlIDContains     *string  `json:"controlIDContains,omitempty"`
	ControlIDHasPrefix    *string  `json:"controlIDHasPrefix,omitempty"`
	ControlIDHasSuffix    *string  `json:"controlIDHasSuffix,omitempty"`
	ControlIDEqualFold    *string  `json:"controlIDEqualFold,omitempty"`
	ControlIDContainsFold *string  `json:"controlIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// control edge predicates
	HasControl     *bool                `json:"hasControl,omitempty"`
	HasControlWith []*ControlWhereInput `json:"hasControlWith,omitempty"`
	// mapped_controls edge predicates
	HasMappedControls     *bool                      `json:"hasMappedControls,omitempty"`
	HasMappedControlsWith []*MappedControlWhereInput `json:"hasMappedControlsWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
	// control_objectives edge predicates
	HasControlObjectives     *bool                         `json:"hasControlObjectives,omitempty"`
	HasControlObjectivesWith []*ControlObjectiveWhereInput `json:"hasControlObjectivesWith,omitempty"`
	// tasks edge predicates
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
	// narratives edge predicates
	HasNarratives     *bool                  `json:"hasNarratives,omitempty"`
	HasNarrativesWith []*NarrativeWhereInput `json:"hasNarrativesWith,omitempty"`
	// risks edge predicates
	HasRisks     *bool             `json:"hasRisks,omitempty"`
	HasRisksWith []*RiskWhereInput `json:"hasRisksWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// procedures edge predicates
	HasProcedures     *bool                  `json:"hasProcedures,omitempty"`
	HasProceduresWith []*ProcedureWhereInput `json:"hasProceduresWith,omitempty"`
	// internal_policies edge predicates
	HasInternalPolicies     *bool                       `json:"hasInternalPolicies,omitempty"`
	HasInternalPoliciesWith []*InternalPolicyWhereInput `json:"hasInternalPoliciesWith,omitempty"`
	// control_owner edge predicates
	HasControlOwner     *bool              `json:"hasControlOwner,omitempty"`
	HasControlOwnerWith []*GroupWhereInput `json:"hasControlOwnerWith,omitempty"`
	// delegate edge predicates
	HasDelegate     *bool              `json:"hasDelegate,omitempty"`
	HasDelegateWith []*GroupWhereInput `json:"hasDelegateWith,omitempty"`
}

type Subscriber struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// email address of the subscriber
	Email string `json:"email"`
	// phone number of the subscriber
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// indicates if the email address has been verified
	VerifiedEmail bool `json:"verifiedEmail"`
	// indicates if the phone number has been verified
	VerifiedPhone bool `json:"verifiedPhone"`
	// indicates if the subscriber is active or not, active users will have at least one verified contact method
	Active bool          `json:"active"`
	Owner  *Organization `json:"owner,omitempty"`
	Events []*Event      `json:"events,omitempty"`
}

func (Subscriber) IsNode() {}

// Return response for createBulkSubscriber mutation
type SubscriberBulkCreatePayload struct {
	// Created subscribers
	Subscribers []*Subscriber `json:"subscribers,omitempty"`
}

// A connection to a list of items.
type SubscriberConnection struct {
	// A list of edges.
	Edges []*SubscriberEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createSubscriber mutation
type SubscriberCreatePayload struct {
	// Created subscriber
	Subscriber *Subscriber `json:"subscriber"`
}

// Return response for deleteSubscriber mutation
type SubscriberDeletePayload struct {
	// Deleted subscriber email
	Email string `json:"email"`
}

// An edge in a connection.
type SubscriberEdge struct {
	// The item at the end of the edge.
	Node *Subscriber `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type SubscriberSearchResult struct {
	Subscribers []*Subscriber `json:"subscribers,omitempty"`
}

func (SubscriberSearchResult) IsSearchResult() {}

// Return response for updateSubscriber mutation
type SubscriberUpdatePayload struct {
	// Updated subscriber
	Subscriber *Subscriber `json:"subscriber"`
}

// SubscriberWhereInput is used for filtering Subscriber objects.
// Input was generated by ent.
type SubscriberWhereInput struct {
	Not *SubscriberWhereInput   `json:"not,omitempty"`
	And []*SubscriberWhereInput `json:"and,omitempty"`
	Or  []*SubscriberWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// phone_number field predicates
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNeq          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGt           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGte          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLt           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLte          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        *bool    `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       *bool    `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`
	// verified_email field predicates
	VerifiedEmail    *bool `json:"verifiedEmail,omitempty"`
	VerifiedEmailNeq *bool `json:"verifiedEmailNEQ,omitempty"`
	// verified_phone field predicates
	VerifiedPhone    *bool `json:"verifiedPhone,omitempty"`
	VerifiedPhoneNeq *bool `json:"verifiedPhoneNEQ,omitempty"`
	// active field predicates
	Active    *bool `json:"active,omitempty"`
	ActiveNeq *bool `json:"activeNEQ,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type TFASetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// specifies if the TFA device has been verified
	Verified bool `json:"verified"`
	// specifies a user may complete authentication by verifying a TOTP code delivered through an authenticator app
	TotpAllowed *bool `json:"totpAllowed,omitempty"`
	Owner       *User `json:"owner,omitempty"`
}

func (TFASetting) IsNode() {}

// A connection to a list of items.
type TFASettingConnection struct {
	// A list of edges.
	Edges []*TFASettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTFASetting mutation
type TFASettingCreatePayload struct {
	// Created tfaSetting
	TfaSetting *TFASetting `json:"tfaSetting"`
	TfaSecret  *string     `json:"tfaSecret,omitempty"`
	QRCode     *string     `json:"qrCode,omitempty"`
}

// An edge in a connection.
type TFASettingEdge struct {
	// The item at the end of the edge.
	Node *TFASetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateTFASetting mutation
type TFASettingUpdatePayload struct {
	// Updated tfaSetting
	TfaSetting    *TFASetting `json:"tfaSetting"`
	TfaSecret     *string     `json:"tfaSecret,omitempty"`
	QRCode        *string     `json:"qrCode,omitempty"`
	RecoveryCodes []string    `json:"recoveryCodes,omitempty"`
}

// TFASettingWhereInput is used for filtering TFASetting objects.
// Input was generated by ent.
type TFASettingWhereInput struct {
	Not *TFASettingWhereInput   `json:"not,omitempty"`
	And []*TFASettingWhereInput `json:"and,omitempty"`
	Or  []*TFASettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// verified field predicates
	Verified    *bool `json:"verified,omitempty"`
	VerifiedNeq *bool `json:"verifiedNEQ,omitempty"`
	// totp_allowed field predicates
	TotpAllowed       *bool `json:"totpAllowed,omitempty"`
	TotpAllowedNeq    *bool `json:"totpAllowedNEQ,omitempty"`
	TotpAllowedIsNil  *bool `json:"totpAllowedIsNil,omitempty"`
	TotpAllowedNotNil *bool `json:"totpAllowedNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

type Task struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string     `json:"displayID"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the title of the task
	Title string `json:"title"`
	// the description of the task
	Description *string `json:"description,omitempty"`
	// the details of the task
	Details *string `json:"details,omitempty"`
	// the status of the task
	Status enums.TaskStatus `json:"status"`
	// the category of the task, e.g. evidence upload, risk review, policy review, etc.
	Category *string `json:"category,omitempty"`
	// the due date of the task
	Due *time.Time `json:"due,omitempty"`
	// the completion date of the task
	Completed *time.Time `json:"completed,omitempty"`
	// the id of the user who was assigned the task
	AssigneeID *string `json:"assigneeID,omitempty"`
	// the id of the user who assigned the task, can be left empty if created by the system or a service token
	AssignerID *string       `json:"assignerID,omitempty"`
	Owner      *Organization `json:"owner,omitempty"`
	Assigner   *User         `json:"assigner,omitempty"`
	Assignee   *User         `json:"assignee,omitempty"`
	// conversations related to the task
	Comments         []*Note             `json:"comments,omitempty"`
	Group            []*Group            `json:"group,omitempty"`
	InternalPolicy   []*InternalPolicy   `json:"internalPolicy,omitempty"`
	Procedure        []*Procedure        `json:"procedure,omitempty"`
	Control          []*Control          `json:"control,omitempty"`
	ControlObjective []*ControlObjective `json:"controlObjective,omitempty"`
	Subcontrol       []*Subcontrol       `json:"subcontrol,omitempty"`
	Program          []*Program          `json:"program,omitempty"`
	Evidence         []*Evidence         `json:"evidence,omitempty"`
}

func (Task) IsNode() {}

// Return response for createBulkTask mutation
type TaskBulkCreatePayload struct {
	// Created tasks
	Tasks []*Task `json:"tasks,omitempty"`
}

// A connection to a list of items.
type TaskConnection struct {
	// A list of edges.
	Edges []*TaskEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTask mutation
type TaskCreatePayload struct {
	// Created task
	Task *Task `json:"task"`
}

// Return response for deleteTask mutation
type TaskDeletePayload struct {
	// Deleted task ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TaskEdge struct {
	// The item at the end of the edge.
	Node *Task `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TaskHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string     `json:"displayID"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the ID of the organization owner of the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the title of the task
	Title string `json:"title"`
	// the description of the task
	Description *string `json:"description,omitempty"`
	// the details of the task
	Details *string `json:"details,omitempty"`
	// the status of the task
	Status enums.TaskStatus `json:"status"`
	// the category of the task, e.g. evidence upload, risk review, policy review, etc.
	Category *string `json:"category,omitempty"`
	// the due date of the task
	Due *time.Time `json:"due,omitempty"`
	// the completion date of the task
	Completed *time.Time `json:"completed,omitempty"`
	// the id of the user who was assigned the task
	AssigneeID *string `json:"assigneeID,omitempty"`
	// the id of the user who assigned the task, can be left empty if created by the system or a service token
	AssignerID *string `json:"assignerID,omitempty"`
}

func (TaskHistory) IsNode() {}

// A connection to a list of items.
type TaskHistoryConnection struct {
	// A list of edges.
	Edges []*TaskHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TaskHistoryEdge struct {
	// The item at the end of the edge.
	Node *TaskHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// TaskHistoryWhereInput is used for filtering TaskHistory objects.
// Input was generated by ent.
type TaskHistoryWhereInput struct {
	Not *TaskHistoryWhereInput   `json:"not,omitempty"`
	And []*TaskHistoryWhereInput `json:"and,omitempty"`
	Or  []*TaskHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// status field predicates
	Status      *enums.TaskStatus  `json:"status,omitempty"`
	StatusNeq   *enums.TaskStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.TaskStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.TaskStatus `json:"statusNotIn,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// due field predicates
	Due       *time.Time   `json:"due,omitempty"`
	DueNeq    *time.Time   `json:"dueNEQ,omitempty"`
	DueIn     []*time.Time `json:"dueIn,omitempty"`
	DueNotIn  []*time.Time `json:"dueNotIn,omitempty"`
	DueGt     *time.Time   `json:"dueGT,omitempty"`
	DueGte    *time.Time   `json:"dueGTE,omitempty"`
	DueLt     *time.Time   `json:"dueLT,omitempty"`
	DueLte    *time.Time   `json:"dueLTE,omitempty"`
	DueIsNil  *bool        `json:"dueIsNil,omitempty"`
	DueNotNil *bool        `json:"dueNotNil,omitempty"`
	// completed field predicates
	Completed       *time.Time   `json:"completed,omitempty"`
	CompletedNeq    *time.Time   `json:"completedNEQ,omitempty"`
	CompletedIn     []*time.Time `json:"completedIn,omitempty"`
	CompletedNotIn  []*time.Time `json:"completedNotIn,omitempty"`
	CompletedGt     *time.Time   `json:"completedGT,omitempty"`
	CompletedGte    *time.Time   `json:"completedGTE,omitempty"`
	CompletedLt     *time.Time   `json:"completedLT,omitempty"`
	CompletedLte    *time.Time   `json:"completedLTE,omitempty"`
	CompletedIsNil  *bool        `json:"completedIsNil,omitempty"`
	CompletedNotNil *bool        `json:"completedNotNil,omitempty"`
	// assignee_id field predicates
	AssigneeID             *string  `json:"assigneeID,omitempty"`
	AssigneeIdneq          *string  `json:"assigneeIDNEQ,omitempty"`
	AssigneeIDIn           []string `json:"assigneeIDIn,omitempty"`
	AssigneeIDNotIn        []string `json:"assigneeIDNotIn,omitempty"`
	AssigneeIdgt           *string  `json:"assigneeIDGT,omitempty"`
	AssigneeIdgte          *string  `json:"assigneeIDGTE,omitempty"`
	AssigneeIdlt           *string  `json:"assigneeIDLT,omitempty"`
	AssigneeIdlte          *string  `json:"assigneeIDLTE,omitempty"`
	AssigneeIDContains     *string  `json:"assigneeIDContains,omitempty"`
	AssigneeIDHasPrefix    *string  `json:"assigneeIDHasPrefix,omitempty"`
	AssigneeIDHasSuffix    *string  `json:"assigneeIDHasSuffix,omitempty"`
	AssigneeIDIsNil        *bool    `json:"assigneeIDIsNil,omitempty"`
	AssigneeIDNotNil       *bool    `json:"assigneeIDNotNil,omitempty"`
	AssigneeIDEqualFold    *string  `json:"assigneeIDEqualFold,omitempty"`
	AssigneeIDContainsFold *string  `json:"assigneeIDContainsFold,omitempty"`
	// assigner_id field predicates
	AssignerID             *string  `json:"assignerID,omitempty"`
	AssignerIdneq          *string  `json:"assignerIDNEQ,omitempty"`
	AssignerIDIn           []string `json:"assignerIDIn,omitempty"`
	AssignerIDNotIn        []string `json:"assignerIDNotIn,omitempty"`
	AssignerIdgt           *string  `json:"assignerIDGT,omitempty"`
	AssignerIdgte          *string  `json:"assignerIDGTE,omitempty"`
	AssignerIdlt           *string  `json:"assignerIDLT,omitempty"`
	AssignerIdlte          *string  `json:"assignerIDLTE,omitempty"`
	AssignerIDContains     *string  `json:"assignerIDContains,omitempty"`
	AssignerIDHasPrefix    *string  `json:"assignerIDHasPrefix,omitempty"`
	AssignerIDHasSuffix    *string  `json:"assignerIDHasSuffix,omitempty"`
	AssignerIDIsNil        *bool    `json:"assignerIDIsNil,omitempty"`
	AssignerIDNotNil       *bool    `json:"assignerIDNotNil,omitempty"`
	AssignerIDEqualFold    *string  `json:"assignerIDEqualFold,omitempty"`
	AssignerIDContainsFold *string  `json:"assignerIDContainsFold,omitempty"`
}

type TaskSearchResult struct {
	Tasks []*Task `json:"tasks,omitempty"`
}

func (TaskSearchResult) IsSearchResult() {}

// Return response for updateTask mutation
type TaskUpdatePayload struct {
	// Updated task
	Task *Task `json:"task"`
}

// TaskWhereInput is used for filtering Task objects.
// Input was generated by ent.
type TaskWhereInput struct {
	Not *TaskWhereInput   `json:"not,omitempty"`
	And []*TaskWhereInput `json:"and,omitempty"`
	Or  []*TaskWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// details field predicates
	Details             *string  `json:"details,omitempty"`
	DetailsNeq          *string  `json:"detailsNEQ,omitempty"`
	DetailsIn           []string `json:"detailsIn,omitempty"`
	DetailsNotIn        []string `json:"detailsNotIn,omitempty"`
	DetailsGt           *string  `json:"detailsGT,omitempty"`
	DetailsGte          *string  `json:"detailsGTE,omitempty"`
	DetailsLt           *string  `json:"detailsLT,omitempty"`
	DetailsLte          *string  `json:"detailsLTE,omitempty"`
	DetailsContains     *string  `json:"detailsContains,omitempty"`
	DetailsHasPrefix    *string  `json:"detailsHasPrefix,omitempty"`
	DetailsHasSuffix    *string  `json:"detailsHasSuffix,omitempty"`
	DetailsIsNil        *bool    `json:"detailsIsNil,omitempty"`
	DetailsNotNil       *bool    `json:"detailsNotNil,omitempty"`
	DetailsEqualFold    *string  `json:"detailsEqualFold,omitempty"`
	DetailsContainsFold *string  `json:"detailsContainsFold,omitempty"`
	// status field predicates
	Status      *enums.TaskStatus  `json:"status,omitempty"`
	StatusNeq   *enums.TaskStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.TaskStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.TaskStatus `json:"statusNotIn,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// due field predicates
	Due       *time.Time   `json:"due,omitempty"`
	DueNeq    *time.Time   `json:"dueNEQ,omitempty"`
	DueIn     []*time.Time `json:"dueIn,omitempty"`
	DueNotIn  []*time.Time `json:"dueNotIn,omitempty"`
	DueGt     *time.Time   `json:"dueGT,omitempty"`
	DueGte    *time.Time   `json:"dueGTE,omitempty"`
	DueLt     *time.Time   `json:"dueLT,omitempty"`
	DueLte    *time.Time   `json:"dueLTE,omitempty"`
	DueIsNil  *bool        `json:"dueIsNil,omitempty"`
	DueNotNil *bool        `json:"dueNotNil,omitempty"`
	// completed field predicates
	Completed       *time.Time   `json:"completed,omitempty"`
	CompletedNeq    *time.Time   `json:"completedNEQ,omitempty"`
	CompletedIn     []*time.Time `json:"completedIn,omitempty"`
	CompletedNotIn  []*time.Time `json:"completedNotIn,omitempty"`
	CompletedGt     *time.Time   `json:"completedGT,omitempty"`
	CompletedGte    *time.Time   `json:"completedGTE,omitempty"`
	CompletedLt     *time.Time   `json:"completedLT,omitempty"`
	CompletedLte    *time.Time   `json:"completedLTE,omitempty"`
	CompletedIsNil  *bool        `json:"completedIsNil,omitempty"`
	CompletedNotNil *bool        `json:"completedNotNil,omitempty"`
	// assignee_id field predicates
	AssigneeID             *string  `json:"assigneeID,omitempty"`
	AssigneeIdneq          *string  `json:"assigneeIDNEQ,omitempty"`
	AssigneeIDIn           []string `json:"assigneeIDIn,omitempty"`
	AssigneeIDNotIn        []string `json:"assigneeIDNotIn,omitempty"`
	AssigneeIdgt           *string  `json:"assigneeIDGT,omitempty"`
	AssigneeIdgte          *string  `json:"assigneeIDGTE,omitempty"`
	AssigneeIdlt           *string  `json:"assigneeIDLT,omitempty"`
	AssigneeIdlte          *string  `json:"assigneeIDLTE,omitempty"`
	AssigneeIDContains     *string  `json:"assigneeIDContains,omitempty"`
	AssigneeIDHasPrefix    *string  `json:"assigneeIDHasPrefix,omitempty"`
	AssigneeIDHasSuffix    *string  `json:"assigneeIDHasSuffix,omitempty"`
	AssigneeIDIsNil        *bool    `json:"assigneeIDIsNil,omitempty"`
	AssigneeIDNotNil       *bool    `json:"assigneeIDNotNil,omitempty"`
	AssigneeIDEqualFold    *string  `json:"assigneeIDEqualFold,omitempty"`
	AssigneeIDContainsFold *string  `json:"assigneeIDContainsFold,omitempty"`
	// assigner_id field predicates
	AssignerID             *string  `json:"assignerID,omitempty"`
	AssignerIdneq          *string  `json:"assignerIDNEQ,omitempty"`
	AssignerIDIn           []string `json:"assignerIDIn,omitempty"`
	AssignerIDNotIn        []string `json:"assignerIDNotIn,omitempty"`
	AssignerIdgt           *string  `json:"assignerIDGT,omitempty"`
	AssignerIdgte          *string  `json:"assignerIDGTE,omitempty"`
	AssignerIdlt           *string  `json:"assignerIDLT,omitempty"`
	AssignerIdlte          *string  `json:"assignerIDLTE,omitempty"`
	AssignerIDContains     *string  `json:"assignerIDContains,omitempty"`
	AssignerIDHasPrefix    *string  `json:"assignerIDHasPrefix,omitempty"`
	AssignerIDHasSuffix    *string  `json:"assignerIDHasSuffix,omitempty"`
	AssignerIDIsNil        *bool    `json:"assignerIDIsNil,omitempty"`
	AssignerIDNotNil       *bool    `json:"assignerIDNotNil,omitempty"`
	AssignerIDEqualFold    *string  `json:"assignerIDEqualFold,omitempty"`
	AssignerIDContainsFold *string  `json:"assignerIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// assigner edge predicates
	HasAssigner     *bool             `json:"hasAssigner,omitempty"`
	HasAssignerWith []*UserWhereInput `json:"hasAssignerWith,omitempty"`
	// assignee edge predicates
	HasAssignee     *bool             `json:"hasAssignee,omitempty"`
	HasAssigneeWith []*UserWhereInput `json:"hasAssigneeWith,omitempty"`
	// comments edge predicates
	HasComments     *bool             `json:"hasComments,omitempty"`
	HasCommentsWith []*NoteWhereInput `json:"hasCommentsWith,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
	// internal_policy edge predicates
	HasInternalPolicy     *bool                       `json:"hasInternalPolicy,omitempty"`
	HasInternalPolicyWith []*InternalPolicyWhereInput `json:"hasInternalPolicyWith,omitempty"`
	// procedure edge predicates
	HasProcedure     *bool                  `json:"hasProcedure,omitempty"`
	HasProcedureWith []*ProcedureWhereInput `json:"hasProcedureWith,omitempty"`
	// control edge predicates
	HasControl     *bool                `json:"hasControl,omitempty"`
	HasControlWith []*ControlWhereInput `json:"hasControlWith,omitempty"`
	// control_objective edge predicates
	HasControlObjective     *bool                         `json:"hasControlObjective,omitempty"`
	HasControlObjectiveWith []*ControlObjectiveWhereInput `json:"hasControlObjectiveWith,omitempty"`
	// subcontrol edge predicates
	HasSubcontrol     *bool                   `json:"hasSubcontrol,omitempty"`
	HasSubcontrolWith []*SubcontrolWhereInput `json:"hasSubcontrolWith,omitempty"`
	// program edge predicates
	HasProgram     *bool                `json:"hasProgram,omitempty"`
	HasProgramWith []*ProgramWhereInput `json:"hasProgramWith,omitempty"`
	// evidence edge predicates
	HasEvidence     *bool                 `json:"hasEvidence,omitempty"`
	HasEvidenceWith []*EvidenceWhereInput `json:"hasEvidenceWith,omitempty"`
}

type Template struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the template
	Name string `json:"name"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType enums.DocumentType `json:"templateType"`
	// the description of the template
	Description *string `json:"description,omitempty"`
	// the jsonschema object of the template
	Jsonconfig map[string]any `json:"jsonconfig"`
	// the uischema for the template to render in the UI
	Uischema  map[string]any  `json:"uischema,omitempty"`
	Owner     *Organization   `json:"owner,omitempty"`
	Documents []*DocumentData `json:"documents,omitempty"`
	Files     []*File         `json:"files,omitempty"`
}

func (Template) IsNode() {}

// Return response for createBulkTemplate mutation
type TemplateBulkCreatePayload struct {
	// Created templates
	Templates []*Template `json:"templates,omitempty"`
}

// A connection to a list of items.
type TemplateConnection struct {
	// A list of edges.
	Edges []*TemplateEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTemplate mutation
type TemplateCreatePayload struct {
	// Created template
	Template *Template `json:"template"`
}

// Return response for deleteTemplate mutation
type TemplateDeletePayload struct {
	// Deleted template ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TemplateEdge struct {
	// The item at the end of the edge.
	Node *Template `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TemplateHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the template
	Name string `json:"name"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType enums.DocumentType `json:"templateType"`
	// the description of the template
	Description *string `json:"description,omitempty"`
	// the jsonschema object of the template
	Jsonconfig map[string]any `json:"jsonconfig"`
	// the uischema for the template to render in the UI
	Uischema map[string]any `json:"uischema,omitempty"`
}

func (TemplateHistory) IsNode() {}

// A connection to a list of items.
type TemplateHistoryConnection struct {
	// A list of edges.
	Edges []*TemplateHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TemplateHistoryEdge struct {
	// The item at the end of the edge.
	Node *TemplateHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TemplateHistory connections
type TemplateHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TemplateHistories.
	Field TemplateHistoryOrderField `json:"field"`
}

// TemplateHistoryWhereInput is used for filtering TemplateHistory objects.
// Input was generated by ent.
type TemplateHistoryWhereInput struct {
	Not *TemplateHistoryWhereInput   `json:"not,omitempty"`
	And []*TemplateHistoryWhereInput `json:"and,omitempty"`
	Or  []*TemplateHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// template_type field predicates
	TemplateType      *enums.DocumentType  `json:"templateType,omitempty"`
	TemplateTypeNeq   *enums.DocumentType  `json:"templateTypeNEQ,omitempty"`
	TemplateTypeIn    []enums.DocumentType `json:"templateTypeIn,omitempty"`
	TemplateTypeNotIn []enums.DocumentType `json:"templateTypeNotIn,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
}

// Ordering options for Template connections
type TemplateOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Templates.
	Field TemplateOrderField `json:"field"`
}

type TemplateSearchResult struct {
	Templates []*Template `json:"templates,omitempty"`
}

func (TemplateSearchResult) IsSearchResult() {}

// Return response for updateTemplate mutation
type TemplateUpdatePayload struct {
	// Updated template
	Template *Template `json:"template"`
}

// TemplateWhereInput is used for filtering Template objects.
// Input was generated by ent.
type TemplateWhereInput struct {
	Not *TemplateWhereInput   `json:"not,omitempty"`
	And []*TemplateWhereInput `json:"and,omitempty"`
	Or  []*TemplateWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIdneq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIdgt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIdgte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIdlt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIdlte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// template_type field predicates
	TemplateType      *enums.DocumentType  `json:"templateType,omitempty"`
	TemplateTypeNeq   *enums.DocumentType  `json:"templateTypeNEQ,omitempty"`
	TemplateTypeIn    []enums.DocumentType `json:"templateTypeIn,omitempty"`
	TemplateTypeNotIn []enums.DocumentType `json:"templateTypeNotIn,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// documents edge predicates
	HasDocuments     *bool                     `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentDataWhereInput `json:"hasDocumentsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// UpdateAPITokenInput is used for update APIToken object.
// Input was generated by ent.
type UpdateAPITokenInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name associated with the token
	Name *string `json:"name,omitempty"`
	// a description of the token's purpose
	Description      *string    `json:"description,omitempty"`
	ClearDescription *bool      `json:"clearDescription,omitempty"`
	Scopes           []string   `json:"scopes,omitempty"`
	AppendScopes     []string   `json:"appendScopes,omitempty"`
	ClearScopes      *bool      `json:"clearScopes,omitempty"`
	LastUsedAt       *time.Time `json:"lastUsedAt,omitempty"`
	ClearLastUsedAt  *bool      `json:"clearLastUsedAt,omitempty"`
	// whether the token is active
	IsActive      *bool `json:"isActive,omitempty"`
	ClearIsActive *bool `json:"clearIsActive,omitempty"`
	// the reason the token was revoked
	RevokedReason      *string `json:"revokedReason,omitempty"`
	ClearRevokedReason *bool   `json:"clearRevokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy      *string `json:"revokedBy,omitempty"`
	ClearRevokedBy *bool   `json:"clearRevokedBy,omitempty"`
	// when the token was revoked
	RevokedAt      *time.Time `json:"revokedAt,omitempty"`
	ClearRevokedAt *bool      `json:"clearRevokedAt,omitempty"`
	OwnerID        *string    `json:"ownerID,omitempty"`
	ClearOwner     *bool      `json:"clearOwner,omitempty"`
}

// UpdateActionPlanInput is used for update ActionPlan object.
// Input was generated by ent.
type UpdateActionPlanInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the action plan
	Name *string `json:"name,omitempty"`
	// description of the action plan
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// status of the action plan
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// due date of the action plan
	DueDate      *time.Time `json:"dueDate,omitempty"`
	ClearDueDate *bool      `json:"clearDueDate,omitempty"`
	// priority of the action plan
	Priority      *string `json:"priority,omitempty"`
	ClearPriority *bool   `json:"clearPriority,omitempty"`
	// source of the action plan
	Source      *string `json:"source,omitempty"`
	ClearSource *bool   `json:"clearSource,omitempty"`
	// json data including details of the action plan
	Details          map[string]any `json:"details,omitempty"`
	ClearDetails     *bool          `json:"clearDetails,omitempty"`
	AddRiskIDs       []string       `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs    []string       `json:"removeRiskIDs,omitempty"`
	ClearRisk        *bool          `json:"clearRisk,omitempty"`
	AddControlIDs    []string       `json:"addControlIDs,omitempty"`
	RemoveControlIDs []string       `json:"removeControlIDs,omitempty"`
	ClearControl     *bool          `json:"clearControl,omitempty"`
	AddUserIDs       []string       `json:"addUserIDs,omitempty"`
	RemoveUserIDs    []string       `json:"removeUserIDs,omitempty"`
	ClearUser        *bool          `json:"clearUser,omitempty"`
	AddProgramIDs    []string       `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs []string       `json:"removeProgramIDs,omitempty"`
	ClearProgram     *bool          `json:"clearProgram,omitempty"`
}

// UpdateContactInput is used for update Contact object.
// Input was generated by ent.
type UpdateContactInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the full name of the contact
	FullName *string `json:"fullName,omitempty"`
	// the title of the contact
	Title      *string `json:"title,omitempty"`
	ClearTitle *bool   `json:"clearTitle,omitempty"`
	// the company of the contact
	Company      *string `json:"company,omitempty"`
	ClearCompany *bool   `json:"clearCompany,omitempty"`
	// the email of the contact
	Email      *string `json:"email,omitempty"`
	ClearEmail *bool   `json:"clearEmail,omitempty"`
	// the phone number of the contact
	PhoneNumber      *string `json:"phoneNumber,omitempty"`
	ClearPhoneNumber *bool   `json:"clearPhoneNumber,omitempty"`
	// the address of the contact
	Address      *string `json:"address,omitempty"`
	ClearAddress *bool   `json:"clearAddress,omitempty"`
	// status of the contact
	Status          *enums.UserStatus `json:"status,omitempty"`
	OwnerID         *string           `json:"ownerID,omitempty"`
	ClearOwner      *bool             `json:"clearOwner,omitempty"`
	AddEntityIDs    []string          `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs []string          `json:"removeEntityIDs,omitempty"`
	ClearEntities   *bool             `json:"clearEntities,omitempty"`
	AddFileIDs      []string          `json:"addFileIDs,omitempty"`
	RemoveFileIDs   []string          `json:"removeFileIDs,omitempty"`
	ClearFiles      *bool             `json:"clearFiles,omitempty"`
}

// UpdateControlImplementationInput is used for update ControlImplementation object.
// Input was generated by ent.
type UpdateControlImplementationInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// status of the control implementation
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// date the control was implemented
	ImplementationDate      *time.Time `json:"implementationDate,omitempty"`
	ClearImplementationDate *bool      `json:"clearImplementationDate,omitempty"`
	// set to true if the control implementation has been verified
	Verified      *bool `json:"verified,omitempty"`
	ClearVerified *bool `json:"clearVerified,omitempty"`
	// date the control implementation was verified
	VerificationDate      *time.Time `json:"verificationDate,omitempty"`
	ClearVerificationDate *bool      `json:"clearVerificationDate,omitempty"`
	// details of the control implementation
	Details          *string  `json:"details,omitempty"`
	ClearDetails     *bool    `json:"clearDetails,omitempty"`
	AddControlIDs    []string `json:"addControlIDs,omitempty"`
	RemoveControlIDs []string `json:"removeControlIDs,omitempty"`
	ClearControls    *bool    `json:"clearControls,omitempty"`
}

// UpdateControlInput is used for update Control object.
// Input was generated by ent.
type UpdateControlInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// description of what the control is supposed to accomplish
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// status of the control
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source      *enums.ControlSource `json:"source,omitempty"`
	ClearSource *bool                `json:"clearSource,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType      *enums.ControlType `json:"controlType,omitempty"`
	ClearControlType *bool              `json:"clearControlType,omitempty"`
	// category of the control
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// category id of the control
	CategoryID      *string `json:"categoryID,omitempty"`
	ClearCategoryID *bool   `json:"clearCategoryID,omitempty"`
	// subcategory of the control
	Subcategory      *string `json:"subcategory,omitempty"`
	ClearSubcategory *bool   `json:"clearSubcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories       []string `json:"mappedCategories,omitempty"`
	AppendMappedCategories []string `json:"appendMappedCategories,omitempty"`
	ClearMappedCategories  *bool    `json:"clearMappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives       []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	AppendAssessmentObjectives []*models.AssessmentObjective `json:"appendAssessmentObjectives,omitempty"`
	ClearAssessmentObjectives  *bool                         `json:"clearAssessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods       []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	AppendAssessmentMethods []*models.AssessmentMethod `json:"appendAssessmentMethods,omitempty"`
	ClearAssessmentMethods  *bool                      `json:"clearAssessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions       []string `json:"controlQuestions,omitempty"`
	AppendControlQuestions []string `json:"appendControlQuestions,omitempty"`
	ClearControlQuestions  *bool    `json:"clearControlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance       []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	AppendImplementationGuidance []*models.ImplementationGuidance `json:"appendImplementationGuidance,omitempty"`
	ClearImplementationGuidance  *bool                            `json:"clearImplementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence       []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	AppendExampleEvidence []*models.ExampleEvidence `json:"appendExampleEvidence,omitempty"`
	ClearExampleEvidence  *bool                     `json:"clearExampleEvidence,omitempty"`
	// references for the control
	References       []*models.Reference `json:"references,omitempty"`
	AppendReferences []*models.Reference `json:"appendReferences,omitempty"`
	ClearReferences  *bool               `json:"clearReferences,omitempty"`
	// the unique reference code for the control
	RefCode                        *string  `json:"refCode,omitempty"`
	AddBlockedGroupIDs             []string `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs          []string `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups             *bool    `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs                   []string `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs                []string `json:"removeEditorIDs,omitempty"`
	ClearEditors                   *bool    `json:"clearEditors,omitempty"`
	AddViewerIDs                   []string `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs                []string `json:"removeViewerIDs,omitempty"`
	ClearViewers                   *bool    `json:"clearViewers,omitempty"`
	StandardID                     *string  `json:"standardID,omitempty"`
	ClearStandard                  *bool    `json:"clearStandard,omitempty"`
	AddProgramIDs                  []string `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs               []string `json:"removeProgramIDs,omitempty"`
	ClearPrograms                  *bool    `json:"clearPrograms,omitempty"`
	AddEvidenceIDs                 []string `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs              []string `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence                  *bool    `json:"clearEvidence,omitempty"`
	AddControlImplementationIDs    []string `json:"addControlImplementationIDs,omitempty"`
	RemoveControlImplementationIDs []string `json:"removeControlImplementationIDs,omitempty"`
	ClearControlImplementations    *bool    `json:"clearControlImplementations,omitempty"`
	AddMappedControlIDs            []string `json:"addMappedControlIDs,omitempty"`
	RemoveMappedControlIDs         []string `json:"removeMappedControlIDs,omitempty"`
	ClearMappedControls            *bool    `json:"clearMappedControls,omitempty"`
	AddControlObjectiveIDs         []string `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs      []string `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives         *bool    `json:"clearControlObjectives,omitempty"`
	AddSubcontrolIDs               []string `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs            []string `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols               *bool    `json:"clearSubcontrols,omitempty"`
	AddTaskIDs                     []string `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs                  []string `json:"removeTaskIDs,omitempty"`
	ClearTasks                     *bool    `json:"clearTasks,omitempty"`
	AddNarrativeIDs                []string `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs             []string `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives                *bool    `json:"clearNarratives,omitempty"`
	AddRiskIDs                     []string `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs                  []string `json:"removeRiskIDs,omitempty"`
	ClearRisks                     *bool    `json:"clearRisks,omitempty"`
	AddActionPlanIDs               []string `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs            []string `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans               *bool    `json:"clearActionPlans,omitempty"`
	AddProcedureIDs                []string `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs             []string `json:"removeProcedureIDs,omitempty"`
	ClearProcedures                *bool    `json:"clearProcedures,omitempty"`
	AddInternalPolicyIDs           []string `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs        []string `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies          *bool    `json:"clearInternalPolicies,omitempty"`
	ControlOwnerID                 *string  `json:"controlOwnerID,omitempty"`
	ClearControlOwner              *bool    `json:"clearControlOwner,omitempty"`
	DelegateID                     *string  `json:"delegateID,omitempty"`
	ClearDelegate                  *bool    `json:"clearDelegate,omitempty"`
}

// UpdateControlObjectiveInput is used for update ControlObjective object.
// Input was generated by ent.
type UpdateControlObjectiveInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the control objective
	Name *string `json:"name,omitempty"`
	// the desired outcome or target of the control objective
	DesiredOutcome      *string `json:"desiredOutcome,omitempty"`
	ClearDesiredOutcome *bool   `json:"clearDesiredOutcome,omitempty"`
	// status of the control objective
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source      *enums.ControlSource `json:"source,omitempty"`
	ClearSource *bool                `json:"clearSource,omitempty"`
	// type of the control objective e.g. compliance, financial, operational, etc.
	ControlObjectiveType      *string `json:"controlObjectiveType,omitempty"`
	ClearControlObjectiveType *bool   `json:"clearControlObjectiveType,omitempty"`
	// version of the control objective
	Version      *string `json:"version,omitempty"`
	ClearVersion *bool   `json:"clearVersion,omitempty"`
	// category of the control
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// subcategory of the control
	Subcategory             *string  `json:"subcategory,omitempty"`
	ClearSubcategory        *bool    `json:"clearSubcategory,omitempty"`
	AddBlockedGroupIDs      []string `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs   []string `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups      *bool    `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs            []string `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs         []string `json:"removeEditorIDs,omitempty"`
	ClearEditors            *bool    `json:"clearEditors,omitempty"`
	AddViewerIDs            []string `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs         []string `json:"removeViewerIDs,omitempty"`
	ClearViewers            *bool    `json:"clearViewers,omitempty"`
	AddProgramIDs           []string `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs        []string `json:"removeProgramIDs,omitempty"`
	ClearPrograms           *bool    `json:"clearPrograms,omitempty"`
	AddEvidenceIDs          []string `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs       []string `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence           *bool    `json:"clearEvidence,omitempty"`
	AddControlIDs           []string `json:"addControlIDs,omitempty"`
	RemoveControlIDs        []string `json:"removeControlIDs,omitempty"`
	ClearControls           *bool    `json:"clearControls,omitempty"`
	AddSubcontrolIDs        []string `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs     []string `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols        *bool    `json:"clearSubcontrols,omitempty"`
	AddInternalPolicyIDs    []string `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs []string `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies   *bool    `json:"clearInternalPolicies,omitempty"`
	AddProcedureIDs         []string `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs      []string `json:"removeProcedureIDs,omitempty"`
	ClearProcedures         *bool    `json:"clearProcedures,omitempty"`
	AddRiskIDs              []string `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs           []string `json:"removeRiskIDs,omitempty"`
	ClearRisks              *bool    `json:"clearRisks,omitempty"`
	AddNarrativeIDs         []string `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs      []string `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives         *bool    `json:"clearNarratives,omitempty"`
	AddTaskIDs              []string `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs           []string `json:"removeTaskIDs,omitempty"`
	ClearTasks              *bool    `json:"clearTasks,omitempty"`
}

// UpdateDocumentDataInput is used for update DocumentData object.
// Input was generated by ent.
type UpdateDocumentDataInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the json data of the document
	Data            map[string]any `json:"data,omitempty"`
	TemplateID      *string        `json:"templateID,omitempty"`
	AddEntityIDs    []string       `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs []string       `json:"removeEntityIDs,omitempty"`
	ClearEntity     *bool          `json:"clearEntity,omitempty"`
	AddFileIDs      []string       `json:"addFileIDs,omitempty"`
	RemoveFileIDs   []string       `json:"removeFileIDs,omitempty"`
	ClearFiles      *bool          `json:"clearFiles,omitempty"`
}

// UpdateEntityInput is used for update Entity object.
// Input was generated by ent.
type UpdateEntityInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the entity
	Name      *string `json:"name,omitempty"`
	ClearName *bool   `json:"clearName,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName      *string `json:"displayName,omitempty"`
	ClearDisplayName *bool   `json:"clearDisplayName,omitempty"`
	// An optional description of the entity
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// domains associated with the entity
	Domains       []string `json:"domains,omitempty"`
	AppendDomains []string `json:"appendDomains,omitempty"`
	ClearDomains  *bool    `json:"clearDomains,omitempty"`
	// status of the entity
	Status            *string          `json:"status,omitempty"`
	ClearStatus       *bool            `json:"clearStatus,omitempty"`
	OwnerID           *string          `json:"ownerID,omitempty"`
	ClearOwner        *bool            `json:"clearOwner,omitempty"`
	AddContactIDs     []string         `json:"addContactIDs,omitempty"`
	RemoveContactIDs  []string         `json:"removeContactIDs,omitempty"`
	ClearContacts     *bool            `json:"clearContacts,omitempty"`
	AddDocumentIDs    []string         `json:"addDocumentIDs,omitempty"`
	RemoveDocumentIDs []string         `json:"removeDocumentIDs,omitempty"`
	ClearDocuments    *bool            `json:"clearDocuments,omitempty"`
	AddNoteIDs        []string         `json:"addNoteIDs,omitempty"`
	RemoveNoteIDs     []string         `json:"removeNoteIDs,omitempty"`
	ClearNotes        *bool            `json:"clearNotes,omitempty"`
	AddFileIDs        []string         `json:"addFileIDs,omitempty"`
	RemoveFileIDs     []string         `json:"removeFileIDs,omitempty"`
	ClearFiles        *bool            `json:"clearFiles,omitempty"`
	EntityTypeID      *string          `json:"entityTypeID,omitempty"`
	ClearEntityType   *bool            `json:"clearEntityType,omitempty"`
	Note              *CreateNoteInput `json:"note,omitempty"`
}

// UpdateEntityTypeInput is used for update EntityType object.
// Input was generated by ent.
type UpdateEntityTypeInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the entity
	Name            *string  `json:"name,omitempty"`
	OwnerID         *string  `json:"ownerID,omitempty"`
	ClearOwner      *bool    `json:"clearOwner,omitempty"`
	AddEntityIDs    []string `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs []string `json:"removeEntityIDs,omitempty"`
	ClearEntities   *bool    `json:"clearEntities,omitempty"`
}

// UpdateEventInput is used for update Event object.
// Input was generated by ent.
type UpdateEventInput struct {
	// tags associated with the object
	Tags                         []string       `json:"tags,omitempty"`
	AppendTags                   []string       `json:"appendTags,omitempty"`
	ClearTags                    *bool          `json:"clearTags,omitempty"`
	EventID                      *string        `json:"eventID,omitempty"`
	ClearEventID                 *bool          `json:"clearEventID,omitempty"`
	CorrelationID                *string        `json:"correlationID,omitempty"`
	ClearCorrelationID           *bool          `json:"clearCorrelationID,omitempty"`
	EventType                    *string        `json:"eventType,omitempty"`
	Metadata                     map[string]any `json:"metadata,omitempty"`
	ClearMetadata                *bool          `json:"clearMetadata,omitempty"`
	AddUserIDs                   []string       `json:"addUserIDs,omitempty"`
	RemoveUserIDs                []string       `json:"removeUserIDs,omitempty"`
	ClearUser                    *bool          `json:"clearUser,omitempty"`
	AddGroupIDs                  []string       `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs               []string       `json:"removeGroupIDs,omitempty"`
	ClearGroup                   *bool          `json:"clearGroup,omitempty"`
	AddIntegrationIDs            []string       `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs         []string       `json:"removeIntegrationIDs,omitempty"`
	ClearIntegration             *bool          `json:"clearIntegration,omitempty"`
	AddOrganizationIDs           []string       `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs        []string       `json:"removeOrganizationIDs,omitempty"`
	ClearOrganization            *bool          `json:"clearOrganization,omitempty"`
	AddInviteIDs                 []string       `json:"addInviteIDs,omitempty"`
	RemoveInviteIDs              []string       `json:"removeInviteIDs,omitempty"`
	ClearInvite                  *bool          `json:"clearInvite,omitempty"`
	AddPersonalAccessTokenIDs    []string       `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs []string       `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessToken     *bool          `json:"clearPersonalAccessToken,omitempty"`
	AddHushIDs                   []string       `json:"addHushIDs,omitempty"`
	RemoveHushIDs                []string       `json:"removeHushIDs,omitempty"`
	ClearHush                    *bool          `json:"clearHush,omitempty"`
	AddSubscriberIDs             []string       `json:"addSubscriberIDs,omitempty"`
	RemoveSubscriberIDs          []string       `json:"removeSubscriberIDs,omitempty"`
	ClearSubscriber              *bool          `json:"clearSubscriber,omitempty"`
	AddFileIDs                   []string       `json:"addFileIDs,omitempty"`
	RemoveFileIDs                []string       `json:"removeFileIDs,omitempty"`
	ClearFile                    *bool          `json:"clearFile,omitempty"`
	AddOrgsubscriptionIDs        []string       `json:"addOrgsubscriptionIDs,omitempty"`
	RemoveOrgsubscriptionIDs     []string       `json:"removeOrgsubscriptionIDs,omitempty"`
	ClearOrgsubscription         *bool          `json:"clearOrgsubscription,omitempty"`
}

// UpdateEvidenceInput is used for update Evidence object.
// Input was generated by ent.
type UpdateEvidenceInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the evidence
	Name *string `json:"name,omitempty"`
	// the description of the evidence, what is contained in the uploaded file(s) or url(s)
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// description of how the evidence was collected
	CollectionProcedure      *string `json:"collectionProcedure,omitempty"`
	ClearCollectionProcedure *bool   `json:"clearCollectionProcedure,omitempty"`
	// the date the evidence was retrieved
	CreationDate *time.Time `json:"creationDate,omitempty"`
	// the date the evidence should be renewed, defaults to a year from entry date
	RenewalDate      *time.Time `json:"renewalDate,omitempty"`
	ClearRenewalDate *bool      `json:"clearRenewalDate,omitempty"`
	// the source of the evidence, e.g. system the evidence was retrieved from (splunk, github, etc)
	Source      *string `json:"source,omitempty"`
	ClearSource *bool   `json:"clearSource,omitempty"`
	// whether the evidence was automatically generated
	IsAutomated      *bool `json:"isAutomated,omitempty"`
	ClearIsAutomated *bool `json:"clearIsAutomated,omitempty"`
	// the url of the evidence if not uploaded directly to the system
	URL                       *string  `json:"url,omitempty"`
	ClearURL                  *bool    `json:"clearURL,omitempty"`
	AddControlObjectiveIDs    []string `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs []string `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives    *bool    `json:"clearControlObjectives,omitempty"`
	AddControlIDs             []string `json:"addControlIDs,omitempty"`
	RemoveControlIDs          []string `json:"removeControlIDs,omitempty"`
	ClearControls             *bool    `json:"clearControls,omitempty"`
	AddSubcontrolIDs          []string `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs       []string `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols          *bool    `json:"clearSubcontrols,omitempty"`
	AddFileIDs                []string `json:"addFileIDs,omitempty"`
	RemoveFileIDs             []string `json:"removeFileIDs,omitempty"`
	ClearFiles                *bool    `json:"clearFiles,omitempty"`
	AddProgramIDs             []string `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs          []string `json:"removeProgramIDs,omitempty"`
	ClearPrograms             *bool    `json:"clearPrograms,omitempty"`
	AddTaskIDs                []string `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs             []string `json:"removeTaskIDs,omitempty"`
	ClearTasks                *bool    `json:"clearTasks,omitempty"`
}

// UpdateFileInput is used for update File object.
// Input was generated by ent.
type UpdateFileInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName *string `json:"providedFileName,omitempty"`
	// the extension of the file provided
	ProvidedFileExtension *string `json:"providedFileExtension,omitempty"`
	// the computed size of the file in the original http request
	ProvidedFileSize       *int64 `json:"providedFileSize,omitempty"`
	ClearProvidedFileSize  *bool  `json:"clearProvidedFileSize,omitempty"`
	PersistedFileSize      *int64 `json:"persistedFileSize,omitempty"`
	ClearPersistedFileSize *bool  `json:"clearPersistedFileSize,omitempty"`
	// the mime type detected by the system
	DetectedMimeType      *string `json:"detectedMimeType,omitempty"`
	ClearDetectedMimeType *bool   `json:"clearDetectedMimeType,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash      *string `json:"md5Hash,omitempty"`
	ClearMd5Hash *bool   `json:"clearMd5Hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType *string `json:"detectedContentType,omitempty"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey      *string `json:"storeKey,omitempty"`
	ClearStoreKey *bool   `json:"clearStoreKey,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType      *string `json:"categoryType,omitempty"`
	ClearCategoryType *bool   `json:"clearCategoryType,omitempty"`
	// the full URI of the file
	URI      *string `json:"uri,omitempty"`
	ClearURI *bool   `json:"clearURI,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme      *string `json:"storageScheme,omitempty"`
	ClearStorageScheme *bool   `json:"clearStorageScheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume      *string `json:"storageVolume,omitempty"`
	ClearStorageVolume *bool   `json:"clearStorageVolume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath                  *string  `json:"storagePath,omitempty"`
	ClearStoragePath             *bool    `json:"clearStoragePath,omitempty"`
	AddUserIDs                   []string `json:"addUserIDs,omitempty"`
	RemoveUserIDs                []string `json:"removeUserIDs,omitempty"`
	ClearUser                    *bool    `json:"clearUser,omitempty"`
	AddOrganizationIDs           []string `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs        []string `json:"removeOrganizationIDs,omitempty"`
	ClearOrganization            *bool    `json:"clearOrganization,omitempty"`
	AddGroupIDs                  []string `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs               []string `json:"removeGroupIDs,omitempty"`
	ClearGroup                   *bool    `json:"clearGroup,omitempty"`
	AddContactIDs                []string `json:"addContactIDs,omitempty"`
	RemoveContactIDs             []string `json:"removeContactIDs,omitempty"`
	ClearContact                 *bool    `json:"clearContact,omitempty"`
	AddEntityIDs                 []string `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs              []string `json:"removeEntityIDs,omitempty"`
	ClearEntity                  *bool    `json:"clearEntity,omitempty"`
	AddUserSettingIDs            []string `json:"addUserSettingIDs,omitempty"`
	RemoveUserSettingIDs         []string `json:"removeUserSettingIDs,omitempty"`
	ClearUserSetting             *bool    `json:"clearUserSetting,omitempty"`
	AddOrganizationSettingIDs    []string `json:"addOrganizationSettingIDs,omitempty"`
	RemoveOrganizationSettingIDs []string `json:"removeOrganizationSettingIDs,omitempty"`
	ClearOrganizationSetting     *bool    `json:"clearOrganizationSetting,omitempty"`
	AddTemplateIDs               []string `json:"addTemplateIDs,omitempty"`
	RemoveTemplateIDs            []string `json:"removeTemplateIDs,omitempty"`
	ClearTemplate                *bool    `json:"clearTemplate,omitempty"`
	AddDocumentDatumIDs          []string `json:"addDocumentDatumIDs,omitempty"`
	RemoveDocumentDatumIDs       []string `json:"removeDocumentDatumIDs,omitempty"`
	ClearDocumentData            *bool    `json:"clearDocumentData,omitempty"`
	AddEventIDs                  []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs               []string `json:"removeEventIDs,omitempty"`
	ClearEvents                  *bool    `json:"clearEvents,omitempty"`
	AddProgramIDs                []string `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs             []string `json:"removeProgramIDs,omitempty"`
	ClearProgram                 *bool    `json:"clearProgram,omitempty"`
	AddEvidenceIDs               []string `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs            []string `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence                *bool    `json:"clearEvidence,omitempty"`
}

// UpdateGroupInput is used for update Group object.
// Input was generated by ent.
type UpdateGroupInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the group - must be unique within the organization
	Name *string `json:"name,omitempty"`
	// the groups description
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL      *string `json:"gravatarLogoURL,omitempty"`
	ClearGravatarLogoURL *bool   `json:"clearGravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL      *string `json:"logoURL,omitempty"`
	ClearLogoURL *bool   `json:"clearLogoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName                           *string                       `json:"displayName,omitempty"`
	OwnerID                               *string                       `json:"ownerID,omitempty"`
	ClearOwner                            *bool                         `json:"clearOwner,omitempty"`
	AddProcedureEditorIDs                 []string                      `json:"addProcedureEditorIDs,omitempty"`
	RemoveProcedureEditorIDs              []string                      `json:"removeProcedureEditorIDs,omitempty"`
	ClearProcedureEditors                 *bool                         `json:"clearProcedureEditors,omitempty"`
	AddProcedureBlockedGroupIDs           []string                      `json:"addProcedureBlockedGroupIDs,omitempty"`
	RemoveProcedureBlockedGroupIDs        []string                      `json:"removeProcedureBlockedGroupIDs,omitempty"`
	ClearProcedureBlockedGroups           *bool                         `json:"clearProcedureBlockedGroups,omitempty"`
	AddInternalPolicyEditorIDs            []string                      `json:"addInternalPolicyEditorIDs,omitempty"`
	RemoveInternalPolicyEditorIDs         []string                      `json:"removeInternalPolicyEditorIDs,omitempty"`
	ClearInternalPolicyEditors            *bool                         `json:"clearInternalPolicyEditors,omitempty"`
	AddInternalPolicyBlockedGroupIDs      []string                      `json:"addInternalPolicyBlockedGroupIDs,omitempty"`
	RemoveInternalPolicyBlockedGroupIDs   []string                      `json:"removeInternalPolicyBlockedGroupIDs,omitempty"`
	ClearInternalPolicyBlockedGroups      *bool                         `json:"clearInternalPolicyBlockedGroups,omitempty"`
	AddProgramEditorIDs                   []string                      `json:"addProgramEditorIDs,omitempty"`
	RemoveProgramEditorIDs                []string                      `json:"removeProgramEditorIDs,omitempty"`
	ClearProgramEditors                   *bool                         `json:"clearProgramEditors,omitempty"`
	AddProgramBlockedGroupIDs             []string                      `json:"addProgramBlockedGroupIDs,omitempty"`
	RemoveProgramBlockedGroupIDs          []string                      `json:"removeProgramBlockedGroupIDs,omitempty"`
	ClearProgramBlockedGroups             *bool                         `json:"clearProgramBlockedGroups,omitempty"`
	AddProgramViewerIDs                   []string                      `json:"addProgramViewerIDs,omitempty"`
	RemoveProgramViewerIDs                []string                      `json:"removeProgramViewerIDs,omitempty"`
	ClearProgramViewers                   *bool                         `json:"clearProgramViewers,omitempty"`
	AddRiskEditorIDs                      []string                      `json:"addRiskEditorIDs,omitempty"`
	RemoveRiskEditorIDs                   []string                      `json:"removeRiskEditorIDs,omitempty"`
	ClearRiskEditors                      *bool                         `json:"clearRiskEditors,omitempty"`
	AddRiskBlockedGroupIDs                []string                      `json:"addRiskBlockedGroupIDs,omitempty"`
	RemoveRiskBlockedGroupIDs             []string                      `json:"removeRiskBlockedGroupIDs,omitempty"`
	ClearRiskBlockedGroups                *bool                         `json:"clearRiskBlockedGroups,omitempty"`
	AddRiskViewerIDs                      []string                      `json:"addRiskViewerIDs,omitempty"`
	RemoveRiskViewerIDs                   []string                      `json:"removeRiskViewerIDs,omitempty"`
	ClearRiskViewers                      *bool                         `json:"clearRiskViewers,omitempty"`
	AddControlObjectiveEditorIDs          []string                      `json:"addControlObjectiveEditorIDs,omitempty"`
	RemoveControlObjectiveEditorIDs       []string                      `json:"removeControlObjectiveEditorIDs,omitempty"`
	ClearControlObjectiveEditors          *bool                         `json:"clearControlObjectiveEditors,omitempty"`
	AddControlObjectiveBlockedGroupIDs    []string                      `json:"addControlObjectiveBlockedGroupIDs,omitempty"`
	RemoveControlObjectiveBlockedGroupIDs []string                      `json:"removeControlObjectiveBlockedGroupIDs,omitempty"`
	ClearControlObjectiveBlockedGroups    *bool                         `json:"clearControlObjectiveBlockedGroups,omitempty"`
	AddControlObjectiveViewerIDs          []string                      `json:"addControlObjectiveViewerIDs,omitempty"`
	RemoveControlObjectiveViewerIDs       []string                      `json:"removeControlObjectiveViewerIDs,omitempty"`
	ClearControlObjectiveViewers          *bool                         `json:"clearControlObjectiveViewers,omitempty"`
	AddControlEditorIDs                   []string                      `json:"addControlEditorIDs,omitempty"`
	RemoveControlEditorIDs                []string                      `json:"removeControlEditorIDs,omitempty"`
	ClearControlEditors                   *bool                         `json:"clearControlEditors,omitempty"`
	AddControlBlockedGroupIDs             []string                      `json:"addControlBlockedGroupIDs,omitempty"`
	RemoveControlBlockedGroupIDs          []string                      `json:"removeControlBlockedGroupIDs,omitempty"`
	ClearControlBlockedGroups             *bool                         `json:"clearControlBlockedGroups,omitempty"`
	AddControlViewerIDs                   []string                      `json:"addControlViewerIDs,omitempty"`
	RemoveControlViewerIDs                []string                      `json:"removeControlViewerIDs,omitempty"`
	ClearControlViewers                   *bool                         `json:"clearControlViewers,omitempty"`
	AddNarrativeEditorIDs                 []string                      `json:"addNarrativeEditorIDs,omitempty"`
	RemoveNarrativeEditorIDs              []string                      `json:"removeNarrativeEditorIDs,omitempty"`
	ClearNarrativeEditors                 *bool                         `json:"clearNarrativeEditors,omitempty"`
	AddNarrativeBlockedGroupIDs           []string                      `json:"addNarrativeBlockedGroupIDs,omitempty"`
	RemoveNarrativeBlockedGroupIDs        []string                      `json:"removeNarrativeBlockedGroupIDs,omitempty"`
	ClearNarrativeBlockedGroups           *bool                         `json:"clearNarrativeBlockedGroups,omitempty"`
	AddNarrativeViewerIDs                 []string                      `json:"addNarrativeViewerIDs,omitempty"`
	RemoveNarrativeViewerIDs              []string                      `json:"removeNarrativeViewerIDs,omitempty"`
	ClearNarrativeViewers                 *bool                         `json:"clearNarrativeViewers,omitempty"`
	SettingID                             *string                       `json:"settingID,omitempty"`
	ClearSetting                          *bool                         `json:"clearSetting,omitempty"`
	AddEventIDs                           []string                      `json:"addEventIDs,omitempty"`
	RemoveEventIDs                        []string                      `json:"removeEventIDs,omitempty"`
	ClearEvents                           *bool                         `json:"clearEvents,omitempty"`
	AddIntegrationIDs                     []string                      `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs                  []string                      `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations                     *bool                         `json:"clearIntegrations,omitempty"`
	AddFileIDs                            []string                      `json:"addFileIDs,omitempty"`
	RemoveFileIDs                         []string                      `json:"removeFileIDs,omitempty"`
	ClearFiles                            *bool                         `json:"clearFiles,omitempty"`
	AddTaskIDs                            []string                      `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs                         []string                      `json:"removeTaskIDs,omitempty"`
	ClearTasks                            *bool                         `json:"clearTasks,omitempty"`
	AddGroupMembers                       []*CreateGroupMembershipInput `json:"addGroupMembers,omitempty"`
	RemoveGroupMembers                    []string                      `json:"removeGroupMembers,omitempty"`
	UpdateGroupSettings                   *UpdateGroupSettingInput      `json:"updateGroupSettings,omitempty"`
	// inheritGroupPermissions allows a group to be updated with the same permissions
	// as the specified group ID, existing permissions will be removed
	InheritGroupPermissions *string `json:"inheritGroupPermissions,omitempty"`
}

// UpdateGroupMembershipInput is used for update GroupMembership object.
// Input was generated by ent.
type UpdateGroupMembershipInput struct {
	Role           *enums.Role `json:"role,omitempty"`
	AddEventIDs    []string    `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string    `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool       `json:"clearEvents,omitempty"`
}

// UpdateGroupSettingInput is used for update GroupSetting object.
// Input was generated by ent.
type UpdateGroupSettingInput struct {
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility *enums.Visibility `json:"visibility,omitempty"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy *enums.JoinPolicy `json:"joinPolicy,omitempty"`
	// whether to sync group members to slack groups
	SyncToSlack      *bool `json:"syncToSlack,omitempty"`
	ClearSyncToSlack *bool `json:"clearSyncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub      *bool   `json:"syncToGithub,omitempty"`
	ClearSyncToGithub *bool   `json:"clearSyncToGithub,omitempty"`
	GroupID           *string `json:"groupID,omitempty"`
	ClearGroup        *bool   `json:"clearGroup,omitempty"`
}

// UpdateHushInput is used for update Hush object.
// Input was generated by ent.
type UpdateHushInput struct {
	// the logical name of the corresponding hush secret or it's general grouping
	Name *string `json:"name,omitempty"`
	// a description of the hush value or purpose, such as github PAT
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind                  *string  `json:"kind,omitempty"`
	ClearKind             *bool    `json:"clearKind,omitempty"`
	AddIntegrationIDs     []string `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs  []string `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations     *bool    `json:"clearIntegrations,omitempty"`
	AddOrganizationIDs    []string `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs []string `json:"removeOrganizationIDs,omitempty"`
	ClearOrganization     *bool    `json:"clearOrganization,omitempty"`
	AddEventIDs           []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs        []string `json:"removeEventIDs,omitempty"`
	ClearEvents           *bool    `json:"clearEvents,omitempty"`
}

// UpdateIntegrationInput is used for update Integration object.
// Input was generated by ent.
type UpdateIntegrationInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the integration - must be unique within the organization
	Name *string `json:"name,omitempty"`
	// a description of the integration
	Description      *string  `json:"description,omitempty"`
	ClearDescription *bool    `json:"clearDescription,omitempty"`
	Kind             *string  `json:"kind,omitempty"`
	ClearKind        *bool    `json:"clearKind,omitempty"`
	OwnerID          *string  `json:"ownerID,omitempty"`
	ClearOwner       *bool    `json:"clearOwner,omitempty"`
	AddSecretIDs     []string `json:"addSecretIDs,omitempty"`
	RemoveSecretIDs  []string `json:"removeSecretIDs,omitempty"`
	ClearSecrets     *bool    `json:"clearSecrets,omitempty"`
	AddEventIDs      []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs   []string `json:"removeEventIDs,omitempty"`
	ClearEvents      *bool    `json:"clearEvents,omitempty"`
}

// UpdateInternalPolicyInput is used for update InternalPolicy object.
// Input was generated by ent.
type UpdateInternalPolicyInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the policy
	Name *string `json:"name,omitempty"`
	// description of the policy
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// status of the policy
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// the date the policy should be reviewed, defaults to a year from creation date
	ReviewDue      *time.Time `json:"reviewDue,omitempty"`
	ClearReviewDue *bool      `json:"clearReviewDue,omitempty"`
	// type of the policy
	PolicyType      *string `json:"policyType,omitempty"`
	ClearPolicyType *bool   `json:"clearPolicyType,omitempty"`
	// version of the policy
	Version      *string `json:"version,omitempty"`
	ClearVersion *bool   `json:"clearVersion,omitempty"`
	// purpose and scope
	PurposeAndScope      *string `json:"purposeAndScope,omitempty"`
	ClearPurposeAndScope *bool   `json:"clearPurposeAndScope,omitempty"`
	// background of the policy
	Background      *string `json:"background,omitempty"`
	ClearBackground *bool   `json:"clearBackground,omitempty"`
	// json data for the policy document
	Details                   map[string]any `json:"details,omitempty"`
	ClearDetails              *bool          `json:"clearDetails,omitempty"`
	OwnerID                   *string        `json:"ownerID,omitempty"`
	ClearOwner                *bool          `json:"clearOwner,omitempty"`
	AddBlockedGroupIDs        []string       `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs     []string       `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups        *bool          `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs              []string       `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs           []string       `json:"removeEditorIDs,omitempty"`
	ClearEditors              *bool          `json:"clearEditors,omitempty"`
	AddControlObjectiveIDs    []string       `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs []string       `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives    *bool          `json:"clearControlObjectives,omitempty"`
	AddControlIDs             []string       `json:"addControlIDs,omitempty"`
	RemoveControlIDs          []string       `json:"removeControlIDs,omitempty"`
	ClearControls             *bool          `json:"clearControls,omitempty"`
	AddProcedureIDs           []string       `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs        []string       `json:"removeProcedureIDs,omitempty"`
	ClearProcedures           *bool          `json:"clearProcedures,omitempty"`
	AddNarrativeIDs           []string       `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs        []string       `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives           *bool          `json:"clearNarratives,omitempty"`
	AddTaskIDs                []string       `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs             []string       `json:"removeTaskIDs,omitempty"`
	ClearTasks                *bool          `json:"clearTasks,omitempty"`
	AddProgramIDs             []string       `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs          []string       `json:"removeProgramIDs,omitempty"`
	ClearPrograms             *bool          `json:"clearPrograms,omitempty"`
}

// UpdateInviteInput is used for update Invite object.
// Input was generated by ent.
type UpdateInviteInput struct {
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires      *time.Time `json:"expires,omitempty"`
	ClearExpires *bool      `json:"clearExpires,omitempty"`
	// the status of the invitation
	Status *enums.InviteStatus `json:"status,omitempty"`
	Role   *enums.Role         `json:"role,omitempty"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts   *int64   `json:"sendAttempts,omitempty"`
	OwnerID        *string  `json:"ownerID,omitempty"`
	ClearOwner     *bool    `json:"clearOwner,omitempty"`
	AddEventIDs    []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool    `json:"clearEvents,omitempty"`
}

// UpdateMappedControlInput is used for update MappedControl object.
// Input was generated by ent.
type UpdateMappedControlInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the type of mapping between the two controls, e.g. subset, intersect, equal, superset
	MappingType      *string `json:"mappingType,omitempty"`
	ClearMappingType *bool   `json:"clearMappingType,omitempty"`
	// description of how the two controls are related
	Relation            *string  `json:"relation,omitempty"`
	ClearRelation       *bool    `json:"clearRelation,omitempty"`
	AddControlIDs       []string `json:"addControlIDs,omitempty"`
	RemoveControlIDs    []string `json:"removeControlIDs,omitempty"`
	ClearControls       *bool    `json:"clearControls,omitempty"`
	AddSubcontrolIDs    []string `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs []string `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols    *bool    `json:"clearSubcontrols,omitempty"`
}

// UpdateNarrativeInput is used for update Narrative object.
// Input was generated by ent.
type UpdateNarrativeInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the narrative
	Name *string `json:"name,omitempty"`
	// the description of the narrative
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// text data for the narrative document
	Details               *string  `json:"details,omitempty"`
	ClearDetails          *bool    `json:"clearDetails,omitempty"`
	AddBlockedGroupIDs    []string `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs []string `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups    *bool    `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs          []string `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs       []string `json:"removeEditorIDs,omitempty"`
	ClearEditors          *bool    `json:"clearEditors,omitempty"`
	AddViewerIDs          []string `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs       []string `json:"removeViewerIDs,omitempty"`
	ClearViewers          *bool    `json:"clearViewers,omitempty"`
	AddSatisfyIDs         []string `json:"addSatisfyIDs,omitempty"`
	RemoveSatisfyIDs      []string `json:"removeSatisfyIDs,omitempty"`
	ClearSatisfies        *bool    `json:"clearSatisfies,omitempty"`
	AddProgramIDs         []string `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs      []string `json:"removeProgramIDs,omitempty"`
	ClearPrograms         *bool    `json:"clearPrograms,omitempty"`
}

// UpdateNoteInput is used for update Note object.
// Input was generated by ent.
type UpdateNoteInput struct {
	// the text of the note
	Text      *string `json:"text,omitempty"`
	TaskID    *string `json:"taskID,omitempty"`
	ClearTask *bool   `json:"clearTask,omitempty"`
}

// UpdateOrgMembershipInput is used for update OrgMembership object.
// Input was generated by ent.
type UpdateOrgMembershipInput struct {
	Role           *enums.Role `json:"role,omitempty"`
	AddEventIDs    []string    `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string    `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool       `json:"clearEvents,omitempty"`
}

// UpdateOrganizationInput is used for update Organization object.
// Input was generated by ent.
type UpdateOrganizationInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the organization
	Name *string `json:"name,omitempty"`
	// The organization's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the organization
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL      *string `json:"avatarRemoteURL,omitempty"`
	ClearAvatarRemoteURL *bool   `json:"clearAvatarRemoteURL,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt                  *time.Time                      `json:"avatarUpdatedAt,omitempty"`
	ClearAvatarUpdatedAt             *bool                           `json:"clearAvatarUpdatedAt,omitempty"`
	AddControlCreatorIDs             []string                        `json:"addControlCreatorIDs,omitempty"`
	RemoveControlCreatorIDs          []string                        `json:"removeControlCreatorIDs,omitempty"`
	ClearControlCreators             *bool                           `json:"clearControlCreators,omitempty"`
	AddControlObjectiveCreatorIDs    []string                        `json:"addControlObjectiveCreatorIDs,omitempty"`
	RemoveControlObjectiveCreatorIDs []string                        `json:"removeControlObjectiveCreatorIDs,omitempty"`
	ClearControlObjectiveCreators    *bool                           `json:"clearControlObjectiveCreators,omitempty"`
	AddGroupCreatorIDs               []string                        `json:"addGroupCreatorIDs,omitempty"`
	RemoveGroupCreatorIDs            []string                        `json:"removeGroupCreatorIDs,omitempty"`
	ClearGroupCreators               *bool                           `json:"clearGroupCreators,omitempty"`
	AddInternalPolicyCreatorIDs      []string                        `json:"addInternalPolicyCreatorIDs,omitempty"`
	RemoveInternalPolicyCreatorIDs   []string                        `json:"removeInternalPolicyCreatorIDs,omitempty"`
	ClearInternalPolicyCreators      *bool                           `json:"clearInternalPolicyCreators,omitempty"`
	AddNarrativeCreatorIDs           []string                        `json:"addNarrativeCreatorIDs,omitempty"`
	RemoveNarrativeCreatorIDs        []string                        `json:"removeNarrativeCreatorIDs,omitempty"`
	ClearNarrativeCreators           *bool                           `json:"clearNarrativeCreators,omitempty"`
	AddProcedureCreatorIDs           []string                        `json:"addProcedureCreatorIDs,omitempty"`
	RemoveProcedureCreatorIDs        []string                        `json:"removeProcedureCreatorIDs,omitempty"`
	ClearProcedureCreators           *bool                           `json:"clearProcedureCreators,omitempty"`
	AddProgramCreatorIDs             []string                        `json:"addProgramCreatorIDs,omitempty"`
	RemoveProgramCreatorIDs          []string                        `json:"removeProgramCreatorIDs,omitempty"`
	ClearProgramCreators             *bool                           `json:"clearProgramCreators,omitempty"`
	AddRiskCreatorIDs                []string                        `json:"addRiskCreatorIDs,omitempty"`
	RemoveRiskCreatorIDs             []string                        `json:"removeRiskCreatorIDs,omitempty"`
	ClearRiskCreators                *bool                           `json:"clearRiskCreators,omitempty"`
	AddTemplateCreatorIDs            []string                        `json:"addTemplateCreatorIDs,omitempty"`
	RemoveTemplateCreatorIDs         []string                        `json:"removeTemplateCreatorIDs,omitempty"`
	ClearTemplateCreators            *bool                           `json:"clearTemplateCreators,omitempty"`
	SettingID                        *string                         `json:"settingID,omitempty"`
	ClearSetting                     *bool                           `json:"clearSetting,omitempty"`
	AddPersonalAccessTokenIDs        []string                        `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs     []string                        `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessTokens        *bool                           `json:"clearPersonalAccessTokens,omitempty"`
	AddAPITokenIDs                   []string                        `json:"addAPITokenIDs,omitempty"`
	RemoveAPITokenIDs                []string                        `json:"removeAPITokenIDs,omitempty"`
	ClearAPITokens                   *bool                           `json:"clearAPITokens,omitempty"`
	AddFileIDs                       []string                        `json:"addFileIDs,omitempty"`
	RemoveFileIDs                    []string                        `json:"removeFileIDs,omitempty"`
	ClearFiles                       *bool                           `json:"clearFiles,omitempty"`
	AddEventIDs                      []string                        `json:"addEventIDs,omitempty"`
	RemoveEventIDs                   []string                        `json:"removeEventIDs,omitempty"`
	ClearEvents                      *bool                           `json:"clearEvents,omitempty"`
	AddSecretIDs                     []string                        `json:"addSecretIDs,omitempty"`
	RemoveSecretIDs                  []string                        `json:"removeSecretIDs,omitempty"`
	ClearSecrets                     *bool                           `json:"clearSecrets,omitempty"`
	AvatarFileID                     *string                         `json:"avatarFileID,omitempty"`
	ClearAvatarFile                  *bool                           `json:"clearAvatarFile,omitempty"`
	AddGroupIDs                      []string                        `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs                   []string                        `json:"removeGroupIDs,omitempty"`
	ClearGroups                      *bool                           `json:"clearGroups,omitempty"`
	AddTemplateIDs                   []string                        `json:"addTemplateIDs,omitempty"`
	RemoveTemplateIDs                []string                        `json:"removeTemplateIDs,omitempty"`
	ClearTemplates                   *bool                           `json:"clearTemplates,omitempty"`
	AddIntegrationIDs                []string                        `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs             []string                        `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations                *bool                           `json:"clearIntegrations,omitempty"`
	AddDocumentDatumIDs              []string                        `json:"addDocumentDatumIDs,omitempty"`
	RemoveDocumentDatumIDs           []string                        `json:"removeDocumentDatumIDs,omitempty"`
	ClearDocumentData                *bool                           `json:"clearDocumentData,omitempty"`
	AddOrgSubscriptionIDs            []string                        `json:"addOrgSubscriptionIDs,omitempty"`
	RemoveOrgSubscriptionIDs         []string                        `json:"removeOrgSubscriptionIDs,omitempty"`
	ClearOrgSubscriptions            *bool                           `json:"clearOrgSubscriptions,omitempty"`
	AddInviteIDs                     []string                        `json:"addInviteIDs,omitempty"`
	RemoveInviteIDs                  []string                        `json:"removeInviteIDs,omitempty"`
	ClearInvites                     *bool                           `json:"clearInvites,omitempty"`
	AddSubscriberIDs                 []string                        `json:"addSubscriberIDs,omitempty"`
	RemoveSubscriberIDs              []string                        `json:"removeSubscriberIDs,omitempty"`
	ClearSubscribers                 *bool                           `json:"clearSubscribers,omitempty"`
	AddEntityIDs                     []string                        `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs                  []string                        `json:"removeEntityIDs,omitempty"`
	ClearEntities                    *bool                           `json:"clearEntities,omitempty"`
	AddEntityTypeIDs                 []string                        `json:"addEntityTypeIDs,omitempty"`
	RemoveEntityTypeIDs              []string                        `json:"removeEntityTypeIDs,omitempty"`
	ClearEntityTypes                 *bool                           `json:"clearEntityTypes,omitempty"`
	AddContactIDs                    []string                        `json:"addContactIDs,omitempty"`
	RemoveContactIDs                 []string                        `json:"removeContactIDs,omitempty"`
	ClearContacts                    *bool                           `json:"clearContacts,omitempty"`
	AddNoteIDs                       []string                        `json:"addNoteIDs,omitempty"`
	RemoveNoteIDs                    []string                        `json:"removeNoteIDs,omitempty"`
	ClearNotes                       *bool                           `json:"clearNotes,omitempty"`
	AddTaskIDs                       []string                        `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs                    []string                        `json:"removeTaskIDs,omitempty"`
	ClearTasks                       *bool                           `json:"clearTasks,omitempty"`
	AddProgramIDs                    []string                        `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs                 []string                        `json:"removeProgramIDs,omitempty"`
	ClearPrograms                    *bool                           `json:"clearPrograms,omitempty"`
	AddProcedureIDs                  []string                        `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs               []string                        `json:"removeProcedureIDs,omitempty"`
	ClearProcedures                  *bool                           `json:"clearProcedures,omitempty"`
	AddInternalPolicyIDs             []string                        `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs          []string                        `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies            *bool                           `json:"clearInternalPolicies,omitempty"`
	AddRiskIDs                       []string                        `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs                    []string                        `json:"removeRiskIDs,omitempty"`
	ClearRisks                       *bool                           `json:"clearRisks,omitempty"`
	AddControlObjectiveIDs           []string                        `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs        []string                        `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives           *bool                           `json:"clearControlObjectives,omitempty"`
	AddNarrativeIDs                  []string                        `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs               []string                        `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives                  *bool                           `json:"clearNarratives,omitempty"`
	AddControlIDs                    []string                        `json:"addControlIDs,omitempty"`
	RemoveControlIDs                 []string                        `json:"removeControlIDs,omitempty"`
	ClearControls                    *bool                           `json:"clearControls,omitempty"`
	AddSubcontrolIDs                 []string                        `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs              []string                        `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols                 *bool                           `json:"clearSubcontrols,omitempty"`
	AddEvidenceIDs                   []string                        `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs                []string                        `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence                    *bool                           `json:"clearEvidence,omitempty"`
	AddStandardIDs                   []string                        `json:"addStandardIDs,omitempty"`
	RemoveStandardIDs                []string                        `json:"removeStandardIDs,omitempty"`
	ClearStandards                   *bool                           `json:"clearStandards,omitempty"`
	AddOrgMembers                    []*CreateOrgMembershipInput     `json:"addOrgMembers,omitempty"`
	RemoveOrgMembers                 []string                        `json:"removeOrgMembers,omitempty"`
	UpdateOrgSettings                *UpdateOrganizationSettingInput `json:"updateOrgSettings,omitempty"`
}

// UpdateOrganizationSettingInput is used for update OrganizationSetting object.
// Input was generated by ent.
type UpdateOrganizationSettingInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// domains associated with the organization
	Domains       []string `json:"domains,omitempty"`
	AppendDomains []string `json:"appendDomains,omitempty"`
	ClearDomains  *bool    `json:"clearDomains,omitempty"`
	// Name of the person to contact for billing
	BillingContact      *string `json:"billingContact,omitempty"`
	ClearBillingContact *bool   `json:"clearBillingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail      *string `json:"billingEmail,omitempty"`
	ClearBillingEmail *bool   `json:"clearBillingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone      *string `json:"billingPhone,omitempty"`
	ClearBillingPhone *bool   `json:"clearBillingPhone,omitempty"`
	// the billing address to send billing information to
	BillingAddress      *models.Address `json:"billingAddress,omitempty"`
	ClearBillingAddress *bool           `json:"clearBillingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier      *string `json:"taxIdentifier,omitempty"`
	ClearTaxIdentifier *bool   `json:"clearTaxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation      *enums.Region `json:"geoLocation,omitempty"`
	ClearGeoLocation *bool         `json:"clearGeoLocation,omitempty"`
	// should we send email notifications related to billing
	BillingNotificationsEnabled *bool `json:"billingNotificationsEnabled,omitempty"`
	// domains allowed to access the organization, if empty all domains are allowed
	AllowedEmailDomains       []string `json:"allowedEmailDomains,omitempty"`
	AppendAllowedEmailDomains []string `json:"appendAllowedEmailDomains,omitempty"`
	ClearAllowedEmailDomains  *bool    `json:"clearAllowedEmailDomains,omitempty"`
	OrganizationID            *string  `json:"organizationID,omitempty"`
	ClearOrganization         *bool    `json:"clearOrganization,omitempty"`
	AddFileIDs                []string `json:"addFileIDs,omitempty"`
	RemoveFileIDs             []string `json:"removeFileIDs,omitempty"`
	ClearFiles                *bool    `json:"clearFiles,omitempty"`
}

// UpdatePersonalAccessTokenInput is used for update PersonalAccessToken object.
// Input was generated by ent.
type UpdatePersonalAccessTokenInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name associated with the token
	Name *string `json:"name,omitempty"`
	// a description of the token's purpose
	Description      *string    `json:"description,omitempty"`
	ClearDescription *bool      `json:"clearDescription,omitempty"`
	Scopes           []string   `json:"scopes,omitempty"`
	AppendScopes     []string   `json:"appendScopes,omitempty"`
	ClearScopes      *bool      `json:"clearScopes,omitempty"`
	LastUsedAt       *time.Time `json:"lastUsedAt,omitempty"`
	ClearLastUsedAt  *bool      `json:"clearLastUsedAt,omitempty"`
	// whether the token is active
	IsActive      *bool `json:"isActive,omitempty"`
	ClearIsActive *bool `json:"clearIsActive,omitempty"`
	// the reason the token was revoked
	RevokedReason      *string `json:"revokedReason,omitempty"`
	ClearRevokedReason *bool   `json:"clearRevokedReason,omitempty"`
	// the user who revoked the token
	RevokedBy      *string `json:"revokedBy,omitempty"`
	ClearRevokedBy *bool   `json:"clearRevokedBy,omitempty"`
	// when the token was revoked
	RevokedAt             *time.Time `json:"revokedAt,omitempty"`
	ClearRevokedAt        *bool      `json:"clearRevokedAt,omitempty"`
	AddOrganizationIDs    []string   `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs []string   `json:"removeOrganizationIDs,omitempty"`
	ClearOrganizations    *bool      `json:"clearOrganizations,omitempty"`
	AddEventIDs           []string   `json:"addEventIDs,omitempty"`
	RemoveEventIDs        []string   `json:"removeEventIDs,omitempty"`
	ClearEvents           *bool      `json:"clearEvents,omitempty"`
}

// UpdateProcedureInput is used for update Procedure object.
// Input was generated by ent.
type UpdateProcedureInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the procedure
	Name *string `json:"name,omitempty"`
	// description of the procedure
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// status of the procedure
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// type of the procedure
	ProcedureType      *string `json:"procedureType,omitempty"`
	ClearProcedureType *bool   `json:"clearProcedureType,omitempty"`
	// the date the procedure should be reviewed, defaults to a year from creation date
	ReviewDue      *time.Time `json:"reviewDue,omitempty"`
	ClearReviewDue *bool      `json:"clearReviewDue,omitempty"`
	// version of the procedure
	Version      *string `json:"version,omitempty"`
	ClearVersion *bool   `json:"clearVersion,omitempty"`
	// purpose and scope
	PurposeAndScope      *string `json:"purposeAndScope,omitempty"`
	ClearPurposeAndScope *bool   `json:"clearPurposeAndScope,omitempty"`
	// background of the procedure
	Background      *string `json:"background,omitempty"`
	ClearBackground *bool   `json:"clearBackground,omitempty"`
	// which controls are satisfied by the procedure
	Satisfies      *string `json:"satisfies,omitempty"`
	ClearSatisfies *bool   `json:"clearSatisfies,omitempty"`
	// json data for the procedure document
	Details                 map[string]any `json:"details,omitempty"`
	ClearDetails            *bool          `json:"clearDetails,omitempty"`
	OwnerID                 *string        `json:"ownerID,omitempty"`
	ClearOwner              *bool          `json:"clearOwner,omitempty"`
	AddBlockedGroupIDs      []string       `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs   []string       `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups      *bool          `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs            []string       `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs         []string       `json:"removeEditorIDs,omitempty"`
	ClearEditors            *bool          `json:"clearEditors,omitempty"`
	AddControlIDs           []string       `json:"addControlIDs,omitempty"`
	RemoveControlIDs        []string       `json:"removeControlIDs,omitempty"`
	ClearControls           *bool          `json:"clearControls,omitempty"`
	AddInternalPolicyIDs    []string       `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs []string       `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies   *bool          `json:"clearInternalPolicies,omitempty"`
	AddNarrativeIDs         []string       `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs      []string       `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives         *bool          `json:"clearNarratives,omitempty"`
	AddRiskIDs              []string       `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs           []string       `json:"removeRiskIDs,omitempty"`
	ClearRisks              *bool          `json:"clearRisks,omitempty"`
	AddTaskIDs              []string       `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs           []string       `json:"removeTaskIDs,omitempty"`
	ClearTasks              *bool          `json:"clearTasks,omitempty"`
	AddProgramIDs           []string       `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs        []string       `json:"removeProgramIDs,omitempty"`
	ClearPrograms           *bool          `json:"clearPrograms,omitempty"`
}

// UpdateProgramInput is used for update Program object.
// Input was generated by ent.
type UpdateProgramInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the program
	Name *string `json:"name,omitempty"`
	// the description of the program
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the status of the program
	Status *enums.ProgramStatus `json:"status,omitempty"`
	// the start date of the period
	StartDate      *time.Time `json:"startDate,omitempty"`
	ClearStartDate *bool      `json:"clearStartDate,omitempty"`
	// the end date of the period
	EndDate      *time.Time `json:"endDate,omitempty"`
	ClearEndDate *bool      `json:"clearEndDate,omitempty"`
	// is the program ready for the auditor
	AuditorReady *bool `json:"auditorReady,omitempty"`
	// can the auditor write comments
	AuditorWriteComments *bool `json:"auditorWriteComments,omitempty"`
	// can the auditor read comments
	AuditorReadComments       *bool                           `json:"auditorReadComments,omitempty"`
	OwnerID                   *string                         `json:"ownerID,omitempty"`
	ClearOwner                *bool                           `json:"clearOwner,omitempty"`
	AddBlockedGroupIDs        []string                        `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs     []string                        `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups        *bool                           `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs              []string                        `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs           []string                        `json:"removeEditorIDs,omitempty"`
	ClearEditors              *bool                           `json:"clearEditors,omitempty"`
	AddViewerIDs              []string                        `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs           []string                        `json:"removeViewerIDs,omitempty"`
	ClearViewers              *bool                           `json:"clearViewers,omitempty"`
	AddControlIDs             []string                        `json:"addControlIDs,omitempty"`
	RemoveControlIDs          []string                        `json:"removeControlIDs,omitempty"`
	ClearControls             *bool                           `json:"clearControls,omitempty"`
	AddSubcontrolIDs          []string                        `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs       []string                        `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols          *bool                           `json:"clearSubcontrols,omitempty"`
	AddControlObjectiveIDs    []string                        `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs []string                        `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives    *bool                           `json:"clearControlObjectives,omitempty"`
	AddInternalPolicyIDs      []string                        `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs   []string                        `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies     *bool                           `json:"clearInternalPolicies,omitempty"`
	AddProcedureIDs           []string                        `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs        []string                        `json:"removeProcedureIDs,omitempty"`
	ClearProcedures           *bool                           `json:"clearProcedures,omitempty"`
	AddRiskIDs                []string                        `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs             []string                        `json:"removeRiskIDs,omitempty"`
	ClearRisks                *bool                           `json:"clearRisks,omitempty"`
	AddTaskIDs                []string                        `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs             []string                        `json:"removeTaskIDs,omitempty"`
	ClearTasks                *bool                           `json:"clearTasks,omitempty"`
	AddNoteIDs                []string                        `json:"addNoteIDs,omitempty"`
	RemoveNoteIDs             []string                        `json:"removeNoteIDs,omitempty"`
	ClearNotes                *bool                           `json:"clearNotes,omitempty"`
	AddFileIDs                []string                        `json:"addFileIDs,omitempty"`
	RemoveFileIDs             []string                        `json:"removeFileIDs,omitempty"`
	ClearFiles                *bool                           `json:"clearFiles,omitempty"`
	AddEvidenceIDs            []string                        `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs         []string                        `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence             *bool                           `json:"clearEvidence,omitempty"`
	AddNarrativeIDs           []string                        `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs        []string                        `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives           *bool                           `json:"clearNarratives,omitempty"`
	AddActionPlanIDs          []string                        `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs       []string                        `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans          *bool                           `json:"clearActionPlans,omitempty"`
	AddProgramMembers         []*CreateProgramMembershipInput `json:"addProgramMembers,omitempty"`
	RemoveProgramMembers      []string                        `json:"removeProgramMembers,omitempty"`
}

// UpdateProgramMembershipInput is used for update ProgramMembership object.
// Input was generated by ent.
type UpdateProgramMembershipInput struct {
	Role *enums.Role `json:"role,omitempty"`
}

// UpdateRiskInput is used for update Risk object.
// Input was generated by ent.
type UpdateRiskInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the risk
	Name *string `json:"name,omitempty"`
	// description of the risk
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// status of the risk - mitigated or not, inflight, etc.
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// type of the risk, e.g. strategic, operational, financial, external, etc.
	RiskType      *string `json:"riskType,omitempty"`
	ClearRiskType *bool   `json:"clearRiskType,omitempty"`
	// business costs associated with the risk
	BusinessCosts      *string `json:"businessCosts,omitempty"`
	ClearBusinessCosts *bool   `json:"clearBusinessCosts,omitempty"`
	// impact of the risk - high, medium, low
	Impact      *enums.RiskImpact `json:"impact,omitempty"`
	ClearImpact *bool             `json:"clearImpact,omitempty"`
	// likelihood of the risk occurring; unlikely, likely, highly likely
	Likelihood      *enums.RiskLikelihood `json:"likelihood,omitempty"`
	ClearLikelihood *bool                 `json:"clearLikelihood,omitempty"`
	// mitigation for the risk
	Mitigation      *string `json:"mitigation,omitempty"`
	ClearMitigation *bool   `json:"clearMitigation,omitempty"`
	// which controls are satisfied by the risk
	Satisfies      *string `json:"satisfies,omitempty"`
	ClearSatisfies *bool   `json:"clearSatisfies,omitempty"`
	// json data for the risk document
	Details               map[string]any `json:"details,omitempty"`
	ClearDetails          *bool          `json:"clearDetails,omitempty"`
	AddBlockedGroupIDs    []string       `json:"addBlockedGroupIDs,omitempty"`
	RemoveBlockedGroupIDs []string       `json:"removeBlockedGroupIDs,omitempty"`
	ClearBlockedGroups    *bool          `json:"clearBlockedGroups,omitempty"`
	AddEditorIDs          []string       `json:"addEditorIDs,omitempty"`
	RemoveEditorIDs       []string       `json:"removeEditorIDs,omitempty"`
	ClearEditors          *bool          `json:"clearEditors,omitempty"`
	AddViewerIDs          []string       `json:"addViewerIDs,omitempty"`
	RemoveViewerIDs       []string       `json:"removeViewerIDs,omitempty"`
	ClearViewers          *bool          `json:"clearViewers,omitempty"`
	AddControlIDs         []string       `json:"addControlIDs,omitempty"`
	RemoveControlIDs      []string       `json:"removeControlIDs,omitempty"`
	ClearControl          *bool          `json:"clearControl,omitempty"`
	AddProcedureIDs       []string       `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs    []string       `json:"removeProcedureIDs,omitempty"`
	ClearProcedure        *bool          `json:"clearProcedure,omitempty"`
	AddActionPlanIDs      []string       `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs   []string       `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans      *bool          `json:"clearActionPlans,omitempty"`
	AddProgramIDs         []string       `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs      []string       `json:"removeProgramIDs,omitempty"`
	ClearPrograms         *bool          `json:"clearPrograms,omitempty"`
}

// UpdateStandardInput is used for update Standard object.
// Input was generated by ent.
type UpdateStandardInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the long name of the standard body
	Name *string `json:"name,omitempty"`
	// short name of the standard, e.g. SOC 2, ISO 27001, etc.
	ShortName      *string `json:"shortName,omitempty"`
	ClearShortName *bool   `json:"clearShortName,omitempty"`
	// unique identifier of the standard with version
	Framework      *string `json:"framework,omitempty"`
	ClearFramework *bool   `json:"clearFramework,omitempty"`
	// description of the standard
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// governing body of the standard, e.g. AICPA, etc.
	GoverningBody      *string `json:"governingBody,omitempty"`
	ClearGoverningBody *bool   `json:"clearGoverningBody,omitempty"`
	// domains the standard covers, e.g. availability, confidentiality, etc.
	Domains       []string `json:"domains,omitempty"`
	AppendDomains []string `json:"appendDomains,omitempty"`
	ClearDomains  *bool    `json:"clearDomains,omitempty"`
	// link to the official standard documentation
	Link      *string `json:"link,omitempty"`
	ClearLink *bool   `json:"clearLink,omitempty"`
	// status of the standard - active, deprecated, etc.
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// indicates if the standard should be made available to all users, only for public standards
	IsPublic      *bool `json:"isPublic,omitempty"`
	ClearIsPublic *bool `json:"clearIsPublic,omitempty"`
	// indicates if the standard is freely distributable under a trial license, only for public standards
	FreeToUse      *bool `json:"freeToUse,omitempty"`
	ClearFreeToUse *bool `json:"clearFreeToUse,omitempty"`
	// indicates if the standard is owned by the the openlane system
	SystemOwned      *bool `json:"systemOwned,omitempty"`
	ClearSystemOwned *bool `json:"clearSystemOwned,omitempty"`
	// type of the standard - security, privacy, etc.
	StandardType      *string `json:"standardType,omitempty"`
	ClearStandardType *bool   `json:"clearStandardType,omitempty"`
	// version of the standard
	Version      *string `json:"version,omitempty"`
	ClearVersion *bool   `json:"clearVersion,omitempty"`
	// internal revision of the standard
	Revision         *string  `json:"revision,omitempty"`
	ClearRevision    *bool    `json:"clearRevision,omitempty"`
	OwnerID          *string  `json:"ownerID,omitempty"`
	ClearOwner       *bool    `json:"clearOwner,omitempty"`
	AddControlIDs    []string `json:"addControlIDs,omitempty"`
	RemoveControlIDs []string `json:"removeControlIDs,omitempty"`
	ClearControls    *bool    `json:"clearControls,omitempty"`
}

// UpdateSubcontrolInput is used for update Subcontrol object.
// Input was generated by ent.
type UpdateSubcontrolInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// description of what the control is supposed to accomplish
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// status of the control
	Status      *string `json:"status,omitempty"`
	ClearStatus *bool   `json:"clearStatus,omitempty"`
	// source of the control, e.g. framework, template, custom, etc.
	Source      *enums.ControlSource `json:"source,omitempty"`
	ClearSource *bool                `json:"clearSource,omitempty"`
	// type of the control e.g. preventive, detective, corrective, or deterrent.
	ControlType      *enums.ControlType `json:"controlType,omitempty"`
	ClearControlType *bool              `json:"clearControlType,omitempty"`
	// category of the control
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// category id of the control
	CategoryID      *string `json:"categoryID,omitempty"`
	ClearCategoryID *bool   `json:"clearCategoryID,omitempty"`
	// subcategory of the control
	Subcategory      *string `json:"subcategory,omitempty"`
	ClearSubcategory *bool   `json:"clearSubcategory,omitempty"`
	// mapped categories of the control to other standards
	MappedCategories       []string `json:"mappedCategories,omitempty"`
	AppendMappedCategories []string `json:"appendMappedCategories,omitempty"`
	ClearMappedCategories  *bool    `json:"clearMappedCategories,omitempty"`
	// objectives of the audit assessment for the control
	AssessmentObjectives       []*models.AssessmentObjective `json:"assessmentObjectives,omitempty"`
	AppendAssessmentObjectives []*models.AssessmentObjective `json:"appendAssessmentObjectives,omitempty"`
	ClearAssessmentObjectives  *bool                         `json:"clearAssessmentObjectives,omitempty"`
	// methods used to verify the control implementation during an audit
	AssessmentMethods       []*models.AssessmentMethod `json:"assessmentMethods,omitempty"`
	AppendAssessmentMethods []*models.AssessmentMethod `json:"appendAssessmentMethods,omitempty"`
	ClearAssessmentMethods  *bool                      `json:"clearAssessmentMethods,omitempty"`
	// questions to ask to verify the control
	ControlQuestions       []string `json:"controlQuestions,omitempty"`
	AppendControlQuestions []string `json:"appendControlQuestions,omitempty"`
	ClearControlQuestions  *bool    `json:"clearControlQuestions,omitempty"`
	// implementation guidance for the control
	ImplementationGuidance       []*models.ImplementationGuidance `json:"implementationGuidance,omitempty"`
	AppendImplementationGuidance []*models.ImplementationGuidance `json:"appendImplementationGuidance,omitempty"`
	ClearImplementationGuidance  *bool                            `json:"clearImplementationGuidance,omitempty"`
	// examples of evidence for the control
	ExampleEvidence       []*models.ExampleEvidence `json:"exampleEvidence,omitempty"`
	AppendExampleEvidence []*models.ExampleEvidence `json:"appendExampleEvidence,omitempty"`
	ClearExampleEvidence  *bool                     `json:"clearExampleEvidence,omitempty"`
	// references for the control
	References       []*models.Reference `json:"references,omitempty"`
	AppendReferences []*models.Reference `json:"appendReferences,omitempty"`
	ClearReferences  *bool               `json:"clearReferences,omitempty"`
	// the unique reference code for the control
	RefCode                   *string  `json:"refCode,omitempty"`
	ControlID                 *string  `json:"controlID,omitempty"`
	AddMappedControlIDs       []string `json:"addMappedControlIDs,omitempty"`
	RemoveMappedControlIDs    []string `json:"removeMappedControlIDs,omitempty"`
	ClearMappedControls       *bool    `json:"clearMappedControls,omitempty"`
	AddEvidenceIDs            []string `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs         []string `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence             *bool    `json:"clearEvidence,omitempty"`
	AddControlObjectiveIDs    []string `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs []string `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjectives    *bool    `json:"clearControlObjectives,omitempty"`
	AddTaskIDs                []string `json:"addTaskIDs,omitempty"`
	RemoveTaskIDs             []string `json:"removeTaskIDs,omitempty"`
	ClearTasks                *bool    `json:"clearTasks,omitempty"`
	AddNarrativeIDs           []string `json:"addNarrativeIDs,omitempty"`
	RemoveNarrativeIDs        []string `json:"removeNarrativeIDs,omitempty"`
	ClearNarratives           *bool    `json:"clearNarratives,omitempty"`
	AddRiskIDs                []string `json:"addRiskIDs,omitempty"`
	RemoveRiskIDs             []string `json:"removeRiskIDs,omitempty"`
	ClearRisks                *bool    `json:"clearRisks,omitempty"`
	AddActionPlanIDs          []string `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs       []string `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans          *bool    `json:"clearActionPlans,omitempty"`
	AddProcedureIDs           []string `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs        []string `json:"removeProcedureIDs,omitempty"`
	ClearProcedures           *bool    `json:"clearProcedures,omitempty"`
	AddInternalPolicyIDs      []string `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs   []string `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicies     *bool    `json:"clearInternalPolicies,omitempty"`
	ControlOwnerID            *string  `json:"controlOwnerID,omitempty"`
	ClearControlOwner         *bool    `json:"clearControlOwner,omitempty"`
	DelegateID                *string  `json:"delegateID,omitempty"`
	ClearDelegate             *bool    `json:"clearDelegate,omitempty"`
}

// UpdateSubscriberInput is used for update Subscriber object.
// Input was generated by ent.
type UpdateSubscriberInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// email address of the subscriber
	Email *string `json:"email,omitempty"`
	// phone number of the subscriber
	PhoneNumber      *string  `json:"phoneNumber,omitempty"`
	ClearPhoneNumber *bool    `json:"clearPhoneNumber,omitempty"`
	OwnerID          *string  `json:"ownerID,omitempty"`
	ClearOwner       *bool    `json:"clearOwner,omitempty"`
	AddEventIDs      []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs   []string `json:"removeEventIDs,omitempty"`
	ClearEvents      *bool    `json:"clearEvents,omitempty"`
}

// UpdateTFASettingInput is used for update TFASetting object.
// Input was generated by ent.
type UpdateTFASettingInput struct {
	// specifies if the TFA device has been verified
	Verified *bool `json:"verified,omitempty"`
	// specifies a user may complete authentication by verifying a TOTP code delivered through an authenticator app
	TotpAllowed      *bool `json:"totpAllowed,omitempty"`
	ClearTotpAllowed *bool `json:"clearTotpAllowed,omitempty"`
	// Whether to regenerate backup codes
	RegenBackupCodes *bool `json:"regenBackupCodes,omitempty"`
}

// UpdateTaskInput is used for update Task object.
// Input was generated by ent.
type UpdateTaskInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the title of the task
	Title *string `json:"title,omitempty"`
	// the description of the task
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the details of the task
	Details      *string `json:"details,omitempty"`
	ClearDetails *bool   `json:"clearDetails,omitempty"`
	// the status of the task
	Status *enums.TaskStatus `json:"status,omitempty"`
	// the category of the task, e.g. evidence upload, risk review, policy review, etc.
	Category      *string `json:"category,omitempty"`
	ClearCategory *bool   `json:"clearCategory,omitempty"`
	// the due date of the task
	Due      *time.Time `json:"due,omitempty"`
	ClearDue *bool      `json:"clearDue,omitempty"`
	// the completion date of the task
	Completed                 *time.Time       `json:"completed,omitempty"`
	ClearCompleted            *bool            `json:"clearCompleted,omitempty"`
	AssignerID                *string          `json:"assignerID,omitempty"`
	ClearAssigner             *bool            `json:"clearAssigner,omitempty"`
	AssigneeID                *string          `json:"assigneeID,omitempty"`
	ClearAssignee             *bool            `json:"clearAssignee,omitempty"`
	AddCommentIDs             []string         `json:"addCommentIDs,omitempty"`
	RemoveCommentIDs          []string         `json:"removeCommentIDs,omitempty"`
	ClearComments             *bool            `json:"clearComments,omitempty"`
	AddGroupIDs               []string         `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs            []string         `json:"removeGroupIDs,omitempty"`
	ClearGroup                *bool            `json:"clearGroup,omitempty"`
	AddInternalPolicyIDs      []string         `json:"addInternalPolicyIDs,omitempty"`
	RemoveInternalPolicyIDs   []string         `json:"removeInternalPolicyIDs,omitempty"`
	ClearInternalPolicy       *bool            `json:"clearInternalPolicy,omitempty"`
	AddProcedureIDs           []string         `json:"addProcedureIDs,omitempty"`
	RemoveProcedureIDs        []string         `json:"removeProcedureIDs,omitempty"`
	ClearProcedure            *bool            `json:"clearProcedure,omitempty"`
	AddControlIDs             []string         `json:"addControlIDs,omitempty"`
	RemoveControlIDs          []string         `json:"removeControlIDs,omitempty"`
	ClearControl              *bool            `json:"clearControl,omitempty"`
	AddControlObjectiveIDs    []string         `json:"addControlObjectiveIDs,omitempty"`
	RemoveControlObjectiveIDs []string         `json:"removeControlObjectiveIDs,omitempty"`
	ClearControlObjective     *bool            `json:"clearControlObjective,omitempty"`
	AddSubcontrolIDs          []string         `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs       []string         `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrol           *bool            `json:"clearSubcontrol,omitempty"`
	AddProgramIDs             []string         `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs          []string         `json:"removeProgramIDs,omitempty"`
	ClearProgram              *bool            `json:"clearProgram,omitempty"`
	AddEvidenceIDs            []string         `json:"addEvidenceIDs,omitempty"`
	RemoveEvidenceIDs         []string         `json:"removeEvidenceIDs,omitempty"`
	ClearEvidence             *bool            `json:"clearEvidence,omitempty"`
	AddComment                *CreateNoteInput `json:"addComment,omitempty"`
	DeleteComment             *string          `json:"deleteComment,omitempty"`
}

// UpdateTemplateInput is used for update Template object.
// Input was generated by ent.
type UpdateTemplateInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the template
	Name *string `json:"name,omitempty"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType *enums.DocumentType `json:"templateType,omitempty"`
	// the description of the template
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the jsonschema object of the template
	Jsonconfig map[string]any `json:"jsonconfig,omitempty"`
	// the uischema for the template to render in the UI
	Uischema          map[string]any `json:"uischema,omitempty"`
	ClearUischema     *bool          `json:"clearUischema,omitempty"`
	OwnerID           *string        `json:"ownerID,omitempty"`
	ClearOwner        *bool          `json:"clearOwner,omitempty"`
	AddDocumentIDs    []string       `json:"addDocumentIDs,omitempty"`
	RemoveDocumentIDs []string       `json:"removeDocumentIDs,omitempty"`
	ClearDocuments    *bool          `json:"clearDocuments,omitempty"`
	AddFileIDs        []string       `json:"addFileIDs,omitempty"`
	RemoveFileIDs     []string       `json:"removeFileIDs,omitempty"`
	ClearFiles        *bool          `json:"clearFiles,omitempty"`
}

// UpdateUserInput is used for update User object.
// Input was generated by ent.
type UpdateUserInput struct {
	// tags associated with the object
	Tags           []string `json:"tags,omitempty"`
	AppendTags     []string `json:"appendTags,omitempty"`
	ClearTags      *bool    `json:"clearTags,omitempty"`
	Email          *string  `json:"email,omitempty"`
	FirstName      *string  `json:"firstName,omitempty"`
	ClearFirstName *bool    `json:"clearFirstName,omitempty"`
	LastName       *string  `json:"lastName,omitempty"`
	ClearLastName  *bool    `json:"clearLastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL      *string `json:"avatarRemoteURL,omitempty"`
	ClearAvatarRemoteURL *bool   `json:"clearAvatarRemoteURL,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt      *time.Time `json:"avatarUpdatedAt,omitempty"`
	ClearAvatarUpdatedAt *bool      `json:"clearAvatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen      *time.Time `json:"lastSeen,omitempty"`
	ClearLastSeen *bool      `json:"clearLastSeen,omitempty"`
	// user password hash
	Password      *string `json:"password,omitempty"`
	ClearPassword *bool   `json:"clearPassword,omitempty"`
	// the Subject of the user JWT
	Sub      *string `json:"sub,omitempty"`
	ClearSub *bool   `json:"clearSub,omitempty"`
	// auth provider used to register the account
	AuthProvider *enums.AuthProvider `json:"authProvider,omitempty"`
	// the user's role
	Role                            *enums.Role `json:"role,omitempty"`
	ClearRole                       *bool       `json:"clearRole,omitempty"`
	AddPersonalAccessTokenIDs       []string    `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs    []string    `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessTokens       *bool       `json:"clearPersonalAccessTokens,omitempty"`
	AddTfaSettingIDs                []string    `json:"addTfaSettingIDs,omitempty"`
	RemoveTfaSettingIDs             []string    `json:"removeTfaSettingIDs,omitempty"`
	ClearTfaSettings                *bool       `json:"clearTfaSettings,omitempty"`
	SettingID                       *string     `json:"settingID,omitempty"`
	AddEmailVerificationTokenIDs    []string    `json:"addEmailVerificationTokenIDs,omitempty"`
	RemoveEmailVerificationTokenIDs []string    `json:"removeEmailVerificationTokenIDs,omitempty"`
	ClearEmailVerificationTokens    *bool       `json:"clearEmailVerificationTokens,omitempty"`
	AddPasswordResetTokenIDs        []string    `json:"addPasswordResetTokenIDs,omitempty"`
	RemovePasswordResetTokenIDs     []string    `json:"removePasswordResetTokenIDs,omitempty"`
	ClearPasswordResetTokens        *bool       `json:"clearPasswordResetTokens,omitempty"`
	AddGroupIDs                     []string    `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs                  []string    `json:"removeGroupIDs,omitempty"`
	ClearGroups                     *bool       `json:"clearGroups,omitempty"`
	AddOrganizationIDs              []string    `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs           []string    `json:"removeOrganizationIDs,omitempty"`
	ClearOrganizations              *bool       `json:"clearOrganizations,omitempty"`
	AddWebauthnIDs                  []string    `json:"addWebauthnIDs,omitempty"`
	RemoveWebauthnIDs               []string    `json:"removeWebauthnIDs,omitempty"`
	ClearWebauthn                   *bool       `json:"clearWebauthn,omitempty"`
	AddFileIDs                      []string    `json:"addFileIDs,omitempty"`
	RemoveFileIDs                   []string    `json:"removeFileIDs,omitempty"`
	ClearFiles                      *bool       `json:"clearFiles,omitempty"`
	AvatarFileID                    *string     `json:"avatarFileID,omitempty"`
	ClearAvatarFile                 *bool       `json:"clearAvatarFile,omitempty"`
	AddEventIDs                     []string    `json:"addEventIDs,omitempty"`
	RemoveEventIDs                  []string    `json:"removeEventIDs,omitempty"`
	ClearEvents                     *bool       `json:"clearEvents,omitempty"`
	AddActionPlanIDs                []string    `json:"addActionPlanIDs,omitempty"`
	RemoveActionPlanIDs             []string    `json:"removeActionPlanIDs,omitempty"`
	ClearActionPlans                *bool       `json:"clearActionPlans,omitempty"`
	AddSubcontrolIDs                []string    `json:"addSubcontrolIDs,omitempty"`
	RemoveSubcontrolIDs             []string    `json:"removeSubcontrolIDs,omitempty"`
	ClearSubcontrols                *bool       `json:"clearSubcontrols,omitempty"`
	AddAssignerTaskIDs              []string    `json:"addAssignerTaskIDs,omitempty"`
	RemoveAssignerTaskIDs           []string    `json:"removeAssignerTaskIDs,omitempty"`
	ClearAssignerTasks              *bool       `json:"clearAssignerTasks,omitempty"`
	AddAssigneeTaskIDs              []string    `json:"addAssigneeTaskIDs,omitempty"`
	RemoveAssigneeTaskIDs           []string    `json:"removeAssigneeTaskIDs,omitempty"`
	ClearAssigneeTasks              *bool       `json:"clearAssigneeTasks,omitempty"`
	AddProgramIDs                   []string    `json:"addProgramIDs,omitempty"`
	RemoveProgramIDs                []string    `json:"removeProgramIDs,omitempty"`
	ClearPrograms                   *bool       `json:"clearPrograms,omitempty"`
}

// UpdateUserSettingInput is used for update UserSetting object.
// Input was generated by ent.
type UpdateUserSettingInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// The time notifications regarding the user were silenced
	SilencedAt      *time.Time `json:"silencedAt,omitempty"`
	ClearSilencedAt *bool      `json:"clearSilencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt      *time.Time `json:"suspendedAt,omitempty"`
	ClearSuspendedAt *bool      `json:"clearSuspendedAt,omitempty"`
	// status of the user account
	Status *enums.UserStatus `json:"status,omitempty"`
	// whether the user has confirmed their email address
	EmailConfirmed *bool `json:"emailConfirmed,omitempty"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed      *bool `json:"isWebauthnAllowed,omitempty"`
	ClearIsWebauthnAllowed *bool `json:"clearIsWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled      *bool    `json:"isTfaEnabled,omitempty"`
	ClearIsTfaEnabled *bool    `json:"clearIsTfaEnabled,omitempty"`
	UserID            *string  `json:"userID,omitempty"`
	ClearUser         *bool    `json:"clearUser,omitempty"`
	DefaultOrgID      *string  `json:"defaultOrgID,omitempty"`
	ClearDefaultOrg   *bool    `json:"clearDefaultOrg,omitempty"`
	AddFileIDs        []string `json:"addFileIDs,omitempty"`
	RemoveFileIDs     []string `json:"removeFileIDs,omitempty"`
	ClearFiles        *bool    `json:"clearFiles,omitempty"`
}

type User struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags      []string `json:"tags,omitempty"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName,omitempty"`
	LastName  *string  `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file id, takes precedence over the avatar remote URL
	AvatarLocalFileID *string `json:"avatarLocalFileID,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// auth provider used to register the account
	AuthProvider enums.AuthProvider `json:"authProvider"`
	// the user's role
	Role                 *enums.Role            `json:"role,omitempty"`
	PersonalAccessTokens []*PersonalAccessToken `json:"personalAccessTokens,omitempty"`
	TfaSettings          []*TFASetting          `json:"tfaSettings,omitempty"`
	Setting              *UserSetting           `json:"setting"`
	Groups               []*Group               `json:"groups,omitempty"`
	Organizations        []*Organization        `json:"organizations,omitempty"`
	Files                []*File                `json:"files,omitempty"`
	AvatarFile           *File                  `json:"avatarFile,omitempty"`
	Events               []*Event               `json:"events,omitempty"`
	ActionPlans          []*ActionPlan          `json:"actionPlans,omitempty"`
	Subcontrols          []*Subcontrol          `json:"subcontrols,omitempty"`
	AssignerTasks        []*Task                `json:"assignerTasks,omitempty"`
	AssigneeTasks        []*Task                `json:"assigneeTasks,omitempty"`
	Programs             []*Program             `json:"programs,omitempty"`
	GroupMemberships     []*GroupMembership     `json:"groupMemberships,omitempty"`
	OrgMemberships       []*OrgMembership       `json:"orgMemberships,omitempty"`
	ProgramMemberships   []*ProgramMembership   `json:"programMemberships,omitempty"`
}

func (User) IsNode() {}

// Return response for createBulkUser mutation
type UserBulkCreatePayload struct {
	// Created users
	Users []*User `json:"users,omitempty"`
}

// A connection to a list of items.
type UserConnection struct {
	// A list of edges.
	Edges []*UserEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUser mutation
type UserCreatePayload struct {
	// Created user
	User *User `json:"user"`
}

// Return response for deleteUser mutation
type UserDeletePayload struct {
	// Deleted user ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type UserEdge struct {
	// The item at the end of the edge.
	Node *User `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type UserHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// a shortened prefixed id field to use as a human readable identifier
	DisplayID string `json:"displayID"`
	// tags associated with the object
	Tags      []string `json:"tags,omitempty"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName,omitempty"`
	LastName  *string  `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file id, takes precedence over the avatar remote URL
	AvatarLocalFileID *string `json:"avatarLocalFileID,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// auth provider used to register the account
	AuthProvider enums.AuthProvider `json:"authProvider"`
	// the user's role
	Role *enums.Role `json:"role,omitempty"`
}

func (UserHistory) IsNode() {}

// A connection to a list of items.
type UserHistoryConnection struct {
	// A list of edges.
	Edges []*UserHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type UserHistoryEdge struct {
	// The item at the end of the edge.
	Node *UserHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for UserHistory connections
type UserHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order UserHistories.
	Field UserHistoryOrderField `json:"field"`
}

// UserHistoryWhereInput is used for filtering UserHistory objects.
// Input was generated by ent.
type UserHistoryWhereInput struct {
	Not *UserHistoryWhereInput   `json:"not,omitempty"`
	And []*UserHistoryWhereInput `json:"and,omitempty"`
	Or  []*UserHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// first_name field predicates
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNeq          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGt           *string  `json:"firstNameGT,omitempty"`
	FirstNameGte          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLt           *string  `json:"firstNameLT,omitempty"`
	FirstNameLte          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        *bool    `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       *bool    `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`
	// last_name field predicates
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNeq          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGt           *string  `json:"lastNameGT,omitempty"`
	LastNameGte          *string  `json:"lastNameGTE,omitempty"`
	LastNameLt           *string  `json:"lastNameLT,omitempty"`
	LastNameLte          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        *bool    `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       *bool    `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file_id field predicates
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIdneq          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIdgt           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIdgte          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIdlt           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIdlte          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        *bool    `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       *bool    `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// last_seen field predicates
	LastSeen       *time.Time   `json:"lastSeen,omitempty"`
	LastSeenNeq    *time.Time   `json:"lastSeenNEQ,omitempty"`
	LastSeenIn     []*time.Time `json:"lastSeenIn,omitempty"`
	LastSeenNotIn  []*time.Time `json:"lastSeenNotIn,omitempty"`
	LastSeenGt     *time.Time   `json:"lastSeenGT,omitempty"`
	LastSeenGte    *time.Time   `json:"lastSeenGTE,omitempty"`
	LastSeenLt     *time.Time   `json:"lastSeenLT,omitempty"`
	LastSeenLte    *time.Time   `json:"lastSeenLTE,omitempty"`
	LastSeenIsNil  *bool        `json:"lastSeenIsNil,omitempty"`
	LastSeenNotNil *bool        `json:"lastSeenNotNil,omitempty"`
	// sub field predicates
	Sub             *string  `json:"sub,omitempty"`
	SubNeq          *string  `json:"subNEQ,omitempty"`
	SubIn           []string `json:"subIn,omitempty"`
	SubNotIn        []string `json:"subNotIn,omitempty"`
	SubGt           *string  `json:"subGT,omitempty"`
	SubGte          *string  `json:"subGTE,omitempty"`
	SubLt           *string  `json:"subLT,omitempty"`
	SubLte          *string  `json:"subLTE,omitempty"`
	SubContains     *string  `json:"subContains,omitempty"`
	SubHasPrefix    *string  `json:"subHasPrefix,omitempty"`
	SubHasSuffix    *string  `json:"subHasSuffix,omitempty"`
	SubIsNil        *bool    `json:"subIsNil,omitempty"`
	SubNotNil       *bool    `json:"subNotNil,omitempty"`
	SubEqualFold    *string  `json:"subEqualFold,omitempty"`
	SubContainsFold *string  `json:"subContainsFold,omitempty"`
	// auth_provider field predicates
	AuthProvider      *enums.AuthProvider  `json:"authProvider,omitempty"`
	AuthProviderNeq   *enums.AuthProvider  `json:"authProviderNEQ,omitempty"`
	AuthProviderIn    []enums.AuthProvider `json:"authProviderIn,omitempty"`
	AuthProviderNotIn []enums.AuthProvider `json:"authProviderNotIn,omitempty"`
	// role field predicates
	Role       *enums.Role  `json:"role,omitempty"`
	RoleNeq    *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn     []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn  []enums.Role `json:"roleNotIn,omitempty"`
	RoleIsNil  *bool        `json:"roleIsNil,omitempty"`
	RoleNotNil *bool        `json:"roleNotNil,omitempty"`
}

// Ordering options for User connections
type UserOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Users.
	Field UserOrderField `json:"field"`
}

type UserSearchResult struct {
	Users []*User `json:"users,omitempty"`
}

func (UserSearchResult) IsSearchResult() {}

type UserSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	UserID    *string    `json:"userID,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked bool `json:"locked"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// status of the user account
	Status enums.UserStatus `json:"status"`
	// whether the user has confirmed their email address
	EmailConfirmed bool `json:"emailConfirmed"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed *bool `json:"isWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled *bool `json:"isTfaEnabled,omitempty"`
	User         *User `json:"user,omitempty"`
	// organization to load on user login
	DefaultOrg *Organization `json:"defaultOrg,omitempty"`
	Files      []*File       `json:"files,omitempty"`
}

func (UserSetting) IsNode() {}

// Return response for createBulkUserSetting mutation
type UserSettingBulkCreatePayload struct {
	// Created userSettings
	UserSettings []*UserSetting `json:"userSettings,omitempty"`
}

// A connection to a list of items.
type UserSettingConnection struct {
	// A list of edges.
	Edges []*UserSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUserSetting mutation
type UserSettingCreatePayload struct {
	// Created userSetting
	UserSetting *UserSetting `json:"userSetting"`
}

// An edge in a connection.
type UserSettingEdge struct {
	// The item at the end of the edge.
	Node *UserSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type UserSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	UserID    *string    `json:"userID,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked bool `json:"locked"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// status of the user account
	Status enums.UserStatus `json:"status"`
	// whether the user has confirmed their email address
	EmailConfirmed bool `json:"emailConfirmed"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed *bool `json:"isWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled *bool `json:"isTfaEnabled,omitempty"`
}

func (UserSettingHistory) IsNode() {}

// A connection to a list of items.
type UserSettingHistoryConnection struct {
	// A list of edges.
	Edges []*UserSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type UserSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *UserSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// UserSettingHistoryWhereInput is used for filtering UserSettingHistory objects.
// Input was generated by ent.
type UserSettingHistoryWhereInput struct {
	Not *UserSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*UserSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*UserSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        *bool    `json:"userIDIsNil,omitempty"`
	UserIDNotNil       *bool    `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
	// locked field predicates
	Locked    *bool `json:"locked,omitempty"`
	LockedNeq *bool `json:"lockedNEQ,omitempty"`
	// silenced_at field predicates
	SilencedAt       *time.Time   `json:"silencedAt,omitempty"`
	SilencedAtNeq    *time.Time   `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []*time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []*time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGt     *time.Time   `json:"silencedAtGT,omitempty"`
	SilencedAtGte    *time.Time   `json:"silencedAtGTE,omitempty"`
	SilencedAtLt     *time.Time   `json:"silencedAtLT,omitempty"`
	SilencedAtLte    *time.Time   `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  *bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil *bool        `json:"silencedAtNotNil,omitempty"`
	// suspended_at field predicates
	SuspendedAt       *time.Time   `json:"suspendedAt,omitempty"`
	SuspendedAtNeq    *time.Time   `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []*time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []*time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGt     *time.Time   `json:"suspendedAtGT,omitempty"`
	SuspendedAtGte    *time.Time   `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLt     *time.Time   `json:"suspendedAtLT,omitempty"`
	SuspendedAtLte    *time.Time   `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  *bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil *bool        `json:"suspendedAtNotNil,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
	// email_confirmed field predicates
	EmailConfirmed    *bool `json:"emailConfirmed,omitempty"`
	EmailConfirmedNeq *bool `json:"emailConfirmedNEQ,omitempty"`
	// is_webauthn_allowed field predicates
	IsWebauthnAllowed       *bool `json:"isWebauthnAllowed,omitempty"`
	IsWebauthnAllowedNeq    *bool `json:"isWebauthnAllowedNEQ,omitempty"`
	IsWebauthnAllowedIsNil  *bool `json:"isWebauthnAllowedIsNil,omitempty"`
	IsWebauthnAllowedNotNil *bool `json:"isWebauthnAllowedNotNil,omitempty"`
	// is_tfa_enabled field predicates
	IsTfaEnabled       *bool `json:"isTfaEnabled,omitempty"`
	IsTfaEnabledNeq    *bool `json:"isTfaEnabledNEQ,omitempty"`
	IsTfaEnabledIsNil  *bool `json:"isTfaEnabledIsNil,omitempty"`
	IsTfaEnabledNotNil *bool `json:"isTfaEnabledNotNil,omitempty"`
}

type UserSettingSearchResult struct {
	UserSettings []*UserSetting `json:"userSettings,omitempty"`
}

func (UserSettingSearchResult) IsSearchResult() {}

// Return response for updateUserSetting mutation
type UserSettingUpdatePayload struct {
	// Updated userSetting
	UserSetting *UserSetting `json:"userSetting"`
}

// UserSettingWhereInput is used for filtering UserSetting objects.
// Input was generated by ent.
type UserSettingWhereInput struct {
	Not *UserSettingWhereInput   `json:"not,omitempty"`
	And []*UserSettingWhereInput `json:"and,omitempty"`
	Or  []*UserSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIdneq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIdgt           *string  `json:"userIDGT,omitempty"`
	UserIdgte          *string  `json:"userIDGTE,omitempty"`
	UserIdlt           *string  `json:"userIDLT,omitempty"`
	UserIdlte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        *bool    `json:"userIDIsNil,omitempty"`
	UserIDNotNil       *bool    `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
	// locked field predicates
	Locked    *bool `json:"locked,omitempty"`
	LockedNeq *bool `json:"lockedNEQ,omitempty"`
	// silenced_at field predicates
	SilencedAt       *time.Time   `json:"silencedAt,omitempty"`
	SilencedAtNeq    *time.Time   `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []*time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []*time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGt     *time.Time   `json:"silencedAtGT,omitempty"`
	SilencedAtGte    *time.Time   `json:"silencedAtGTE,omitempty"`
	SilencedAtLt     *time.Time   `json:"silencedAtLT,omitempty"`
	SilencedAtLte    *time.Time   `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  *bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil *bool        `json:"silencedAtNotNil,omitempty"`
	// suspended_at field predicates
	SuspendedAt       *time.Time   `json:"suspendedAt,omitempty"`
	SuspendedAtNeq    *time.Time   `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []*time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []*time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGt     *time.Time   `json:"suspendedAtGT,omitempty"`
	SuspendedAtGte    *time.Time   `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLt     *time.Time   `json:"suspendedAtLT,omitempty"`
	SuspendedAtLte    *time.Time   `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  *bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil *bool        `json:"suspendedAtNotNil,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
	// email_confirmed field predicates
	EmailConfirmed    *bool `json:"emailConfirmed,omitempty"`
	EmailConfirmedNeq *bool `json:"emailConfirmedNEQ,omitempty"`
	// is_webauthn_allowed field predicates
	IsWebauthnAllowed       *bool `json:"isWebauthnAllowed,omitempty"`
	IsWebauthnAllowedNeq    *bool `json:"isWebauthnAllowedNEQ,omitempty"`
	IsWebauthnAllowedIsNil  *bool `json:"isWebauthnAllowedIsNil,omitempty"`
	IsWebauthnAllowedNotNil *bool `json:"isWebauthnAllowedNotNil,omitempty"`
	// is_tfa_enabled field predicates
	IsTfaEnabled       *bool `json:"isTfaEnabled,omitempty"`
	IsTfaEnabledNeq    *bool `json:"isTfaEnabledNEQ,omitempty"`
	IsTfaEnabledIsNil  *bool `json:"isTfaEnabledIsNil,omitempty"`
	IsTfaEnabledNotNil *bool `json:"isTfaEnabledNotNil,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// default_org edge predicates
	HasDefaultOrg     *bool                     `json:"hasDefaultOrg,omitempty"`
	HasDefaultOrgWith []*OrganizationWhereInput `json:"hasDefaultOrgWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
}

// Return response for updateUser mutation
type UserUpdatePayload struct {
	// Updated user
	User *User `json:"user"`
}

// UserWhereInput is used for filtering User objects.
// Input was generated by ent.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_id field predicates
	DisplayID             *string  `json:"displayID,omitempty"`
	DisplayIdneq          *string  `json:"displayIDNEQ,omitempty"`
	DisplayIDIn           []string `json:"displayIDIn,omitempty"`
	DisplayIDNotIn        []string `json:"displayIDNotIn,omitempty"`
	DisplayIdgt           *string  `json:"displayIDGT,omitempty"`
	DisplayIdgte          *string  `json:"displayIDGTE,omitempty"`
	DisplayIdlt           *string  `json:"displayIDLT,omitempty"`
	DisplayIdlte          *string  `json:"displayIDLTE,omitempty"`
	DisplayIDContains     *string  `json:"displayIDContains,omitempty"`
	DisplayIDHasPrefix    *string  `json:"displayIDHasPrefix,omitempty"`
	DisplayIDHasSuffix    *string  `json:"displayIDHasSuffix,omitempty"`
	DisplayIDEqualFold    *string  `json:"displayIDEqualFold,omitempty"`
	DisplayIDContainsFold *string  `json:"displayIDContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// first_name field predicates
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNeq          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGt           *string  `json:"firstNameGT,omitempty"`
	FirstNameGte          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLt           *string  `json:"firstNameLT,omitempty"`
	FirstNameLte          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        *bool    `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       *bool    `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`
	// last_name field predicates
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNeq          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGt           *string  `json:"lastNameGT,omitempty"`
	LastNameGte          *string  `json:"lastNameGTE,omitempty"`
	LastNameLt           *string  `json:"lastNameLT,omitempty"`
	LastNameLte          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        *bool    `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       *bool    `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file_id field predicates
	AvatarLocalFileID             *string  `json:"avatarLocalFileID,omitempty"`
	AvatarLocalFileIdneq          *string  `json:"avatarLocalFileIDNEQ,omitempty"`
	AvatarLocalFileIDIn           []string `json:"avatarLocalFileIDIn,omitempty"`
	AvatarLocalFileIDNotIn        []string `json:"avatarLocalFileIDNotIn,omitempty"`
	AvatarLocalFileIdgt           *string  `json:"avatarLocalFileIDGT,omitempty"`
	AvatarLocalFileIdgte          *string  `json:"avatarLocalFileIDGTE,omitempty"`
	AvatarLocalFileIdlt           *string  `json:"avatarLocalFileIDLT,omitempty"`
	AvatarLocalFileIdlte          *string  `json:"avatarLocalFileIDLTE,omitempty"`
	AvatarLocalFileIDContains     *string  `json:"avatarLocalFileIDContains,omitempty"`
	AvatarLocalFileIDHasPrefix    *string  `json:"avatarLocalFileIDHasPrefix,omitempty"`
	AvatarLocalFileIDHasSuffix    *string  `json:"avatarLocalFileIDHasSuffix,omitempty"`
	AvatarLocalFileIDIsNil        *bool    `json:"avatarLocalFileIDIsNil,omitempty"`
	AvatarLocalFileIDNotNil       *bool    `json:"avatarLocalFileIDNotNil,omitempty"`
	AvatarLocalFileIDEqualFold    *string  `json:"avatarLocalFileIDEqualFold,omitempty"`
	AvatarLocalFileIDContainsFold *string  `json:"avatarLocalFileIDContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// last_seen field predicates
	LastSeen       *time.Time   `json:"lastSeen,omitempty"`
	LastSeenNeq    *time.Time   `json:"lastSeenNEQ,omitempty"`
	LastSeenIn     []*time.Time `json:"lastSeenIn,omitempty"`
	LastSeenNotIn  []*time.Time `json:"lastSeenNotIn,omitempty"`
	LastSeenGt     *time.Time   `json:"lastSeenGT,omitempty"`
	LastSeenGte    *time.Time   `json:"lastSeenGTE,omitempty"`
	LastSeenLt     *time.Time   `json:"lastSeenLT,omitempty"`
	LastSeenLte    *time.Time   `json:"lastSeenLTE,omitempty"`
	LastSeenIsNil  *bool        `json:"lastSeenIsNil,omitempty"`
	LastSeenNotNil *bool        `json:"lastSeenNotNil,omitempty"`
	// sub field predicates
	Sub             *string  `json:"sub,omitempty"`
	SubNeq          *string  `json:"subNEQ,omitempty"`
	SubIn           []string `json:"subIn,omitempty"`
	SubNotIn        []string `json:"subNotIn,omitempty"`
	SubGt           *string  `json:"subGT,omitempty"`
	SubGte          *string  `json:"subGTE,omitempty"`
	SubLt           *string  `json:"subLT,omitempty"`
	SubLte          *string  `json:"subLTE,omitempty"`
	SubContains     *string  `json:"subContains,omitempty"`
	SubHasPrefix    *string  `json:"subHasPrefix,omitempty"`
	SubHasSuffix    *string  `json:"subHasSuffix,omitempty"`
	SubIsNil        *bool    `json:"subIsNil,omitempty"`
	SubNotNil       *bool    `json:"subNotNil,omitempty"`
	SubEqualFold    *string  `json:"subEqualFold,omitempty"`
	SubContainsFold *string  `json:"subContainsFold,omitempty"`
	// auth_provider field predicates
	AuthProvider      *enums.AuthProvider  `json:"authProvider,omitempty"`
	AuthProviderNeq   *enums.AuthProvider  `json:"authProviderNEQ,omitempty"`
	AuthProviderIn    []enums.AuthProvider `json:"authProviderIn,omitempty"`
	AuthProviderNotIn []enums.AuthProvider `json:"authProviderNotIn,omitempty"`
	// role field predicates
	Role       *enums.Role  `json:"role,omitempty"`
	RoleNeq    *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn     []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn  []enums.Role `json:"roleNotIn,omitempty"`
	RoleIsNil  *bool        `json:"roleIsNil,omitempty"`
	RoleNotNil *bool        `json:"roleNotNil,omitempty"`
	// personal_access_tokens edge predicates
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`
	// tfa_settings edge predicates
	HasTfaSettings     *bool                   `json:"hasTfaSettings,omitempty"`
	HasTfaSettingsWith []*TFASettingWhereInput `json:"hasTfaSettingsWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                    `json:"hasSetting,omitempty"`
	HasSettingWith []*UserSettingWhereInput `json:"hasSettingWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// organizations edge predicates
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// avatar_file edge predicates
	HasAvatarFile     *bool             `json:"hasAvatarFile,omitempty"`
	HasAvatarFileWith []*FileWhereInput `json:"hasAvatarFileWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// action_plans edge predicates
	HasActionPlans     *bool                   `json:"hasActionPlans,omitempty"`
	HasActionPlansWith []*ActionPlanWhereInput `json:"hasActionPlansWith,omitempty"`
	// subcontrols edge predicates
	HasSubcontrols     *bool                   `json:"hasSubcontrols,omitempty"`
	HasSubcontrolsWith []*SubcontrolWhereInput `json:"hasSubcontrolsWith,omitempty"`
	// assigner_tasks edge predicates
	HasAssignerTasks     *bool             `json:"hasAssignerTasks,omitempty"`
	HasAssignerTasksWith []*TaskWhereInput `json:"hasAssignerTasksWith,omitempty"`
	// assignee_tasks edge predicates
	HasAssigneeTasks     *bool             `json:"hasAssigneeTasks,omitempty"`
	HasAssigneeTasksWith []*TaskWhereInput `json:"hasAssigneeTasksWith,omitempty"`
	// programs edge predicates
	HasPrograms     *bool                `json:"hasPrograms,omitempty"`
	HasProgramsWith []*ProgramWhereInput `json:"hasProgramsWith,omitempty"`
	// group_memberships edge predicates
	HasGroupMemberships     *bool                        `json:"hasGroupMemberships,omitempty"`
	HasGroupMembershipsWith []*GroupMembershipWhereInput `json:"hasGroupMembershipsWith,omitempty"`
	// org_memberships edge predicates
	HasOrgMemberships     *bool                      `json:"hasOrgMemberships,omitempty"`
	HasOrgMembershipsWith []*OrgMembershipWhereInput `json:"hasOrgMembershipsWith,omitempty"`
	// program_memberships edge predicates
	HasProgramMemberships     *bool                          `json:"hasProgramMemberships,omitempty"`
	HasProgramMembershipsWith []*ProgramMembershipWhereInput `json:"hasProgramMembershipsWith,omitempty"`
}

// Properties by which EntityHistory connections can be ordered.
type EntityHistoryOrderField string

const (
	EntityHistoryOrderFieldName        EntityHistoryOrderField = "name"
	EntityHistoryOrderFieldDisplayName EntityHistoryOrderField = "display_name"
)

var AllEntityHistoryOrderField = []EntityHistoryOrderField{
	EntityHistoryOrderFieldName,
	EntityHistoryOrderFieldDisplayName,
}

func (e EntityHistoryOrderField) IsValid() bool {
	switch e {
	case EntityHistoryOrderFieldName, EntityHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e EntityHistoryOrderField) String() string {
	return string(e)
}

func (e *EntityHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityHistoryOrderField", str)
	}
	return nil
}

func (e EntityHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Entity connections can be ordered.
type EntityOrderField string

const (
	EntityOrderFieldName        EntityOrderField = "name"
	EntityOrderFieldDisplayName EntityOrderField = "display_name"
)

var AllEntityOrderField = []EntityOrderField{
	EntityOrderFieldName,
	EntityOrderFieldDisplayName,
}

func (e EntityOrderField) IsValid() bool {
	switch e {
	case EntityOrderFieldName, EntityOrderFieldDisplayName:
		return true
	}
	return false
}

func (e EntityOrderField) String() string {
	return string(e)
}

func (e *EntityOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityOrderField", str)
	}
	return nil
}

func (e EntityOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which EntityTypeHistory connections can be ordered.
type EntityTypeHistoryOrderField string

const (
	EntityTypeHistoryOrderFieldName EntityTypeHistoryOrderField = "name"
)

var AllEntityTypeHistoryOrderField = []EntityTypeHistoryOrderField{
	EntityTypeHistoryOrderFieldName,
}

func (e EntityTypeHistoryOrderField) IsValid() bool {
	switch e {
	case EntityTypeHistoryOrderFieldName:
		return true
	}
	return false
}

func (e EntityTypeHistoryOrderField) String() string {
	return string(e)
}

func (e *EntityTypeHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityTypeHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityTypeHistoryOrderField", str)
	}
	return nil
}

func (e EntityTypeHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which EntityType connections can be ordered.
type EntityTypeOrderField string

const (
	EntityTypeOrderFieldName EntityTypeOrderField = "name"
)

var AllEntityTypeOrderField = []EntityTypeOrderField{
	EntityTypeOrderFieldName,
}

func (e EntityTypeOrderField) IsValid() bool {
	switch e {
	case EntityTypeOrderFieldName:
		return true
	}
	return false
}

func (e EntityTypeOrderField) String() string {
	return string(e)
}

func (e *EntityTypeOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityTypeOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityTypeOrderField", str)
	}
	return nil
}

func (e EntityTypeOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which GroupHistory connections can be ordered.
type GroupHistoryOrderField string

const (
	GroupHistoryOrderFieldName        GroupHistoryOrderField = "name"
	GroupHistoryOrderFieldDisplayName GroupHistoryOrderField = "display_name"
)

var AllGroupHistoryOrderField = []GroupHistoryOrderField{
	GroupHistoryOrderFieldName,
	GroupHistoryOrderFieldDisplayName,
}

func (e GroupHistoryOrderField) IsValid() bool {
	switch e {
	case GroupHistoryOrderFieldName, GroupHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e GroupHistoryOrderField) String() string {
	return string(e)
}

func (e *GroupHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupHistoryOrderField", str)
	}
	return nil
}

func (e GroupHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Group connections can be ordered.
type GroupOrderField string

const (
	GroupOrderFieldName        GroupOrderField = "name"
	GroupOrderFieldDisplayName GroupOrderField = "display_name"
)

var AllGroupOrderField = []GroupOrderField{
	GroupOrderFieldName,
	GroupOrderFieldDisplayName,
}

func (e GroupOrderField) IsValid() bool {
	switch e {
	case GroupOrderFieldName, GroupOrderFieldDisplayName:
		return true
	}
	return false
}

func (e GroupOrderField) String() string {
	return string(e)
}

func (e *GroupOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupOrderField", str)
	}
	return nil
}

func (e GroupOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which HushHistory connections can be ordered.
type HushHistoryOrderField string

const (
	HushHistoryOrderFieldName HushHistoryOrderField = "name"
	HushHistoryOrderFieldKind HushHistoryOrderField = "kind"
)

var AllHushHistoryOrderField = []HushHistoryOrderField{
	HushHistoryOrderFieldName,
	HushHistoryOrderFieldKind,
}

func (e HushHistoryOrderField) IsValid() bool {
	switch e {
	case HushHistoryOrderFieldName, HushHistoryOrderFieldKind:
		return true
	}
	return false
}

func (e HushHistoryOrderField) String() string {
	return string(e)
}

func (e *HushHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HushHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HushHistoryOrderField", str)
	}
	return nil
}

func (e HushHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Hush connections can be ordered.
type HushOrderField string

const (
	HushOrderFieldName HushOrderField = "name"
	HushOrderFieldKind HushOrderField = "kind"
)

var AllHushOrderField = []HushOrderField{
	HushOrderFieldName,
	HushOrderFieldKind,
}

func (e HushOrderField) IsValid() bool {
	switch e {
	case HushOrderFieldName, HushOrderFieldKind:
		return true
	}
	return false
}

func (e HushOrderField) String() string {
	return string(e)
}

func (e *HushOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HushOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HushOrderField", str)
	}
	return nil
}

func (e HushOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which IntegrationHistory connections can be ordered.
type IntegrationHistoryOrderField string

const (
	IntegrationHistoryOrderFieldName IntegrationHistoryOrderField = "name"
	IntegrationHistoryOrderFieldKind IntegrationHistoryOrderField = "kind"
)

var AllIntegrationHistoryOrderField = []IntegrationHistoryOrderField{
	IntegrationHistoryOrderFieldName,
	IntegrationHistoryOrderFieldKind,
}

func (e IntegrationHistoryOrderField) IsValid() bool {
	switch e {
	case IntegrationHistoryOrderFieldName, IntegrationHistoryOrderFieldKind:
		return true
	}
	return false
}

func (e IntegrationHistoryOrderField) String() string {
	return string(e)
}

func (e *IntegrationHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationHistoryOrderField", str)
	}
	return nil
}

func (e IntegrationHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Integration connections can be ordered.
type IntegrationOrderField string

const (
	IntegrationOrderFieldName IntegrationOrderField = "name"
	IntegrationOrderFieldKind IntegrationOrderField = "kind"
)

var AllIntegrationOrderField = []IntegrationOrderField{
	IntegrationOrderFieldName,
	IntegrationOrderFieldKind,
}

func (e IntegrationOrderField) IsValid() bool {
	switch e {
	case IntegrationOrderFieldName, IntegrationOrderFieldKind:
		return true
	}
	return false
}

func (e IntegrationOrderField) String() string {
	return string(e)
}

func (e *IntegrationOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationOrderField", str)
	}
	return nil
}

func (e IntegrationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which OrganizationHistory connections can be ordered.
type OrganizationHistoryOrderField string

const (
	OrganizationHistoryOrderFieldName        OrganizationHistoryOrderField = "name"
	OrganizationHistoryOrderFieldDisplayName OrganizationHistoryOrderField = "display_name"
)

var AllOrganizationHistoryOrderField = []OrganizationHistoryOrderField{
	OrganizationHistoryOrderFieldName,
	OrganizationHistoryOrderFieldDisplayName,
}

func (e OrganizationHistoryOrderField) IsValid() bool {
	switch e {
	case OrganizationHistoryOrderFieldName, OrganizationHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e OrganizationHistoryOrderField) String() string {
	return string(e)
}

func (e *OrganizationHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationHistoryOrderField", str)
	}
	return nil
}

func (e OrganizationHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Organization connections can be ordered.
type OrganizationOrderField string

const (
	OrganizationOrderFieldName        OrganizationOrderField = "name"
	OrganizationOrderFieldDisplayName OrganizationOrderField = "display_name"
)

var AllOrganizationOrderField = []OrganizationOrderField{
	OrganizationOrderFieldName,
	OrganizationOrderFieldDisplayName,
}

func (e OrganizationOrderField) IsValid() bool {
	switch e {
	case OrganizationOrderFieldName, OrganizationOrderFieldDisplayName:
		return true
	}
	return false
}

func (e OrganizationOrderField) String() string {
	return string(e)
}

func (e *OrganizationOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

func (e OrganizationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which TemplateHistory connections can be ordered.
type TemplateHistoryOrderField string

const (
	TemplateHistoryOrderFieldName TemplateHistoryOrderField = "name"
)

var AllTemplateHistoryOrderField = []TemplateHistoryOrderField{
	TemplateHistoryOrderFieldName,
}

func (e TemplateHistoryOrderField) IsValid() bool {
	switch e {
	case TemplateHistoryOrderFieldName:
		return true
	}
	return false
}

func (e TemplateHistoryOrderField) String() string {
	return string(e)
}

func (e *TemplateHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateHistoryOrderField", str)
	}
	return nil
}

func (e TemplateHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Template connections can be ordered.
type TemplateOrderField string

const (
	TemplateOrderFieldName TemplateOrderField = "name"
)

var AllTemplateOrderField = []TemplateOrderField{
	TemplateOrderFieldName,
}

func (e TemplateOrderField) IsValid() bool {
	switch e {
	case TemplateOrderFieldName:
		return true
	}
	return false
}

func (e TemplateOrderField) String() string {
	return string(e)
}

func (e *TemplateOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateOrderField", str)
	}
	return nil
}

func (e TemplateOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which UserHistory connections can be ordered.
type UserHistoryOrderField string

const (
	UserHistoryOrderFieldFirstName   UserHistoryOrderField = "first_name"
	UserHistoryOrderFieldLastName    UserHistoryOrderField = "last_name"
	UserHistoryOrderFieldDisplayName UserHistoryOrderField = "display_name"
)

var AllUserHistoryOrderField = []UserHistoryOrderField{
	UserHistoryOrderFieldFirstName,
	UserHistoryOrderFieldLastName,
	UserHistoryOrderFieldDisplayName,
}

func (e UserHistoryOrderField) IsValid() bool {
	switch e {
	case UserHistoryOrderFieldFirstName, UserHistoryOrderFieldLastName, UserHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e UserHistoryOrderField) String() string {
	return string(e)
}

func (e *UserHistoryOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserHistoryOrderField", str)
	}
	return nil
}

func (e UserHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which User connections can be ordered.
type UserOrderField string

const (
	UserOrderFieldFirstName   UserOrderField = "first_name"
	UserOrderFieldLastName    UserOrderField = "last_name"
	UserOrderFieldDisplayName UserOrderField = "display_name"
)

var AllUserOrderField = []UserOrderField{
	UserOrderFieldFirstName,
	UserOrderFieldLastName,
	UserOrderFieldDisplayName,
}

func (e UserOrderField) IsValid() bool {
	switch e {
	case UserOrderFieldFirstName, UserOrderFieldLastName, UserOrderFieldDisplayName:
		return true
	}
	return false
}

func (e UserOrderField) String() string {
	return string(e)
}

func (e *UserOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

func (e UserOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
