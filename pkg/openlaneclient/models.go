// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package openlaneclient

import (
	"encoding/json"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/theopenlane/core/pkg/enums"
	"github.com/theopenlane/entx/history"
)

type SearchResult interface {
	IsSearchResult()
}

type APIToken struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name associated with the token
	Name  string `json:"name"`
	Token string `json:"token"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string       `json:"description,omitempty"`
	Scopes      []string      `json:"scopes,omitempty"`
	LastUsedAt  *time.Time    `json:"lastUsedAt,omitempty"`
	Owner       *Organization `json:"owner,omitempty"`
}

func (APIToken) IsNode() {}

// Return response for createBulkAPIToken mutation
type APITokenBulkCreatePayload struct {
	// Created apiTokens
	APITokens []*APIToken `json:"apiTokens,omitempty"`
}

// A connection to a list of items.
type APITokenConnection struct {
	// A list of edges.
	Edges []*APITokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createAPIToken mutation
type APITokenCreatePayload struct {
	// Created apiToken
	APIToken *APIToken `json:"apiToken"`
}

// Return response for deleteAPIToken mutation
type APITokenDeletePayload struct {
	// Deleted apiToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type APITokenEdge struct {
	// The item at the end of the edge.
	Node *APIToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateAPIToken mutation
type APITokenUpdatePayload struct {
	// Updated apiToken
	APIToken *APIToken `json:"apiToken"`
}

// APITokenWhereInput is used for filtering APIToken objects.
// Input was generated by ent.
type APITokenWhereInput struct {
	Not *APITokenWhereInput   `json:"not,omitempty"`
	And []*APITokenWhereInput `json:"and,omitempty"`
	Or  []*APITokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type AuditLog struct {
	Table     *string    `json:"table,omitempty"`
	Time      *time.Time `json:"time,omitempty"`
	ID        string     `json:"id"`
	Operation *string    `json:"operation,omitempty"`
	Changes   []string   `json:"changes,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
}

func (AuditLog) IsNode() {}

// A connection to a list of items.
type AuditLogConnection struct {
	// A list of edges.
	Edges []*AuditLogEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type AuditLogEdge struct {
	// The item at the end of the edge.
	Node *AuditLog `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type AuditLogWhereInput struct {
	RefID     *string    `json:"refID,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	Operation *string    `json:"operation,omitempty"`
	Table     *string    `json:"table,omitempty"`
	Before    *time.Time `json:"before,omitempty"`
	After     *time.Time `json:"after,omitempty"`
}

type Contact struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the full name of the contact
	FullName string `json:"fullName"`
	// the title of the contact
	Title *string `json:"title,omitempty"`
	// the company of the contact
	Company *string `json:"company,omitempty"`
	// the email of the contact
	Email *string `json:"email,omitempty"`
	// the phone number of the contact
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// the address of the contact
	Address *string `json:"address,omitempty"`
	// status of the contact
	Status   enums.UserStatus `json:"status"`
	Owner    *Organization    `json:"owner,omitempty"`
	Entities []*Entity        `json:"entities,omitempty"`
}

func (Contact) IsNode() {}

// Return response for createBulkContact mutation
type ContactBulkCreatePayload struct {
	// Created contacts
	Contacts []*Contact `json:"contacts,omitempty"`
}

// A connection to a list of items.
type ContactConnection struct {
	// A list of edges.
	Edges []*ContactEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createContact mutation
type ContactCreatePayload struct {
	// Created contact
	Contact *Contact `json:"contact"`
}

// Return response for deleteContact mutation
type ContactDeletePayload struct {
	// Deleted contact ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type ContactEdge struct {
	// The item at the end of the edge.
	Node *Contact `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type ContactHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the full name of the contact
	FullName string `json:"fullName"`
	// the title of the contact
	Title *string `json:"title,omitempty"`
	// the company of the contact
	Company *string `json:"company,omitempty"`
	// the email of the contact
	Email *string `json:"email,omitempty"`
	// the phone number of the contact
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// the address of the contact
	Address *string `json:"address,omitempty"`
	// status of the contact
	Status enums.UserStatus `json:"status"`
}

func (ContactHistory) IsNode() {}

// A connection to a list of items.
type ContactHistoryConnection struct {
	// A list of edges.
	Edges []*ContactHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type ContactHistoryEdge struct {
	// The item at the end of the edge.
	Node *ContactHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// ContactHistoryWhereInput is used for filtering ContactHistory objects.
// Input was generated by ent.
type ContactHistoryWhereInput struct {
	Not *ContactHistoryWhereInput   `json:"not,omitempty"`
	And []*ContactHistoryWhereInput `json:"and,omitempty"`
	Or  []*ContactHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// full_name field predicates
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNeq          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGt           *string  `json:"fullNameGT,omitempty"`
	FullNameGte          *string  `json:"fullNameGTE,omitempty"`
	FullNameLt           *string  `json:"fullNameLT,omitempty"`
	FullNameLte          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// company field predicates
	Company             *string  `json:"company,omitempty"`
	CompanyNeq          *string  `json:"companyNEQ,omitempty"`
	CompanyIn           []string `json:"companyIn,omitempty"`
	CompanyNotIn        []string `json:"companyNotIn,omitempty"`
	CompanyGt           *string  `json:"companyGT,omitempty"`
	CompanyGte          *string  `json:"companyGTE,omitempty"`
	CompanyLt           *string  `json:"companyLT,omitempty"`
	CompanyLte          *string  `json:"companyLTE,omitempty"`
	CompanyContains     *string  `json:"companyContains,omitempty"`
	CompanyHasPrefix    *string  `json:"companyHasPrefix,omitempty"`
	CompanyHasSuffix    *string  `json:"companyHasSuffix,omitempty"`
	CompanyIsNil        *bool    `json:"companyIsNil,omitempty"`
	CompanyNotNil       *bool    `json:"companyNotNil,omitempty"`
	CompanyEqualFold    *string  `json:"companyEqualFold,omitempty"`
	CompanyContainsFold *string  `json:"companyContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        *bool    `json:"emailIsNil,omitempty"`
	EmailNotNil       *bool    `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// phone_number field predicates
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNeq          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGt           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGte          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLt           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLte          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        *bool    `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       *bool    `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`
	// address field predicates
	Address             *string  `json:"address,omitempty"`
	AddressNeq          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGt           *string  `json:"addressGT,omitempty"`
	AddressGte          *string  `json:"addressGTE,omitempty"`
	AddressLt           *string  `json:"addressLT,omitempty"`
	AddressLte          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        *bool    `json:"addressIsNil,omitempty"`
	AddressNotNil       *bool    `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
}

type ContactSearchResult struct {
	Contacts []*Contact `json:"contacts,omitempty"`
}

func (ContactSearchResult) IsSearchResult() {}

// Return response for updateContact mutation
type ContactUpdatePayload struct {
	// Updated contact
	Contact *Contact `json:"contact"`
}

// ContactWhereInput is used for filtering Contact objects.
// Input was generated by ent.
type ContactWhereInput struct {
	Not *ContactWhereInput   `json:"not,omitempty"`
	And []*ContactWhereInput `json:"and,omitempty"`
	Or  []*ContactWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// full_name field predicates
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNeq          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGt           *string  `json:"fullNameGT,omitempty"`
	FullNameGte          *string  `json:"fullNameGTE,omitempty"`
	FullNameLt           *string  `json:"fullNameLT,omitempty"`
	FullNameLte          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`
	// title field predicates
	Title             *string  `json:"title,omitempty"`
	TitleNeq          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGt           *string  `json:"titleGT,omitempty"`
	TitleGte          *string  `json:"titleGTE,omitempty"`
	TitleLt           *string  `json:"titleLT,omitempty"`
	TitleLte          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        *bool    `json:"titleIsNil,omitempty"`
	TitleNotNil       *bool    `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`
	// company field predicates
	Company             *string  `json:"company,omitempty"`
	CompanyNeq          *string  `json:"companyNEQ,omitempty"`
	CompanyIn           []string `json:"companyIn,omitempty"`
	CompanyNotIn        []string `json:"companyNotIn,omitempty"`
	CompanyGt           *string  `json:"companyGT,omitempty"`
	CompanyGte          *string  `json:"companyGTE,omitempty"`
	CompanyLt           *string  `json:"companyLT,omitempty"`
	CompanyLte          *string  `json:"companyLTE,omitempty"`
	CompanyContains     *string  `json:"companyContains,omitempty"`
	CompanyHasPrefix    *string  `json:"companyHasPrefix,omitempty"`
	CompanyHasSuffix    *string  `json:"companyHasSuffix,omitempty"`
	CompanyIsNil        *bool    `json:"companyIsNil,omitempty"`
	CompanyNotNil       *bool    `json:"companyNotNil,omitempty"`
	CompanyEqualFold    *string  `json:"companyEqualFold,omitempty"`
	CompanyContainsFold *string  `json:"companyContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        *bool    `json:"emailIsNil,omitempty"`
	EmailNotNil       *bool    `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// phone_number field predicates
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNeq          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGt           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGte          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLt           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLte          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        *bool    `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       *bool    `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`
	// address field predicates
	Address             *string  `json:"address,omitempty"`
	AddressNeq          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGt           *string  `json:"addressGT,omitempty"`
	AddressGte          *string  `json:"addressGTE,omitempty"`
	AddressLt           *string  `json:"addressLT,omitempty"`
	AddressLte          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        *bool    `json:"addressIsNil,omitempty"`
	AddressNotNil       *bool    `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
}

// CreateAPITokenInput is used for create APIToken object.
// Input was generated by ent.
type CreateAPITokenInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name associated with the token
	Name string `json:"name"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string    `json:"description,omitempty"`
	Scopes      []string   `json:"scopes,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	OwnerID     *string    `json:"ownerID,omitempty"`
}

// CreateContactInput is used for create Contact object.
// Input was generated by ent.
type CreateContactInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the full name of the contact
	FullName string `json:"fullName"`
	// the title of the contact
	Title *string `json:"title,omitempty"`
	// the company of the contact
	Company *string `json:"company,omitempty"`
	// the email of the contact
	Email *string `json:"email,omitempty"`
	// the phone number of the contact
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// the address of the contact
	Address *string `json:"address,omitempty"`
	// status of the contact
	Status    *enums.UserStatus `json:"status,omitempty"`
	OwnerID   *string           `json:"ownerID,omitempty"`
	EntityIDs []string          `json:"entityIDs,omitempty"`
}

// CreateDocumentDataInput is used for create DocumentData object.
// Input was generated by ent.
type CreateDocumentDataInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the json data of the document
	Data       json.RawMessage `json:"data"`
	OwnerID    *string         `json:"ownerID,omitempty"`
	TemplateID string          `json:"templateID"`
	EntityIDs  []string        `json:"entityIDs,omitempty"`
}

// CreateEntitlementInput is used for create Entitlement object.
// Input was generated by ent.
type CreateEntitlementInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalCustomerID *string `json:"externalCustomerID,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalSubscriptionID *string `json:"externalSubscriptionID,omitempty"`
	// the time at which a customer's entitlement will expire, e.g. they've cancelled but paid through the end of the month
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// whether or not the customer has cancelled their entitlement - usually used in conjunction with expires and expires at
	Cancelled      *bool    `json:"cancelled,omitempty"`
	OwnerID        *string  `json:"ownerID,omitempty"`
	PlanID         string   `json:"planID"`
	OrganizationID string   `json:"organizationID"`
	EventIDs       []string `json:"eventIDs,omitempty"`
}

// CreateEntitlementPlanFeatureInput is used for create EntitlementPlanFeature object.
// Input was generated by ent.
type CreateEntitlementPlanFeatureInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// metadata for the entitlement plan feature such as usage limits
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
	OwnerID   *string                `json:"ownerID,omitempty"`
	PlanID    string                 `json:"planID"`
	FeatureID string                 `json:"featureID"`
	EventIDs  []string               `json:"eventIDs,omitempty"`
}

// CreateEntitlementPlanInput is used for create EntitlementPlan object.
// Input was generated by ent.
type CreateEntitlementPlanInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the displayed 'friendly' name of the plan
	DisplayName *string `json:"displayName,omitempty"`
	// the unique name of the plan
	Name string `json:"name"`
	// a description of the plan
	Description *string `json:"description,omitempty"`
	// the version of the plan
	Version string `json:"version"`
	// metadata for the plan
	Metadata       map[string]interface{} `json:"metadata,omitempty"`
	OwnerID        *string                `json:"ownerID,omitempty"`
	EntitlementIDs []string               `json:"entitlementIDs,omitempty"`
	BaseFeatureIDs []string               `json:"baseFeatureIDs,omitempty"`
	EventIDs       []string               `json:"eventIDs,omitempty"`
}

// CreateEntityInput is used for create Entity object.
// Input was generated by ent.
type CreateEntityInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the entity
	Name *string `json:"name,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the entity
	Description *string `json:"description,omitempty"`
	// domains associated with the entity
	Domains []string `json:"domains,omitempty"`
	// status of the entity
	Status       *string          `json:"status,omitempty"`
	OwnerID      *string          `json:"ownerID,omitempty"`
	ContactIDs   []string         `json:"contactIDs,omitempty"`
	DocumentIDs  []string         `json:"documentIDs,omitempty"`
	NoteIDs      []string         `json:"noteIDs,omitempty"`
	FileIDs      []string         `json:"fileIDs,omitempty"`
	EntityTypeID *string          `json:"entityTypeID,omitempty"`
	Note         *CreateNoteInput `json:"note,omitempty"`
}

// CreateEntityTypeInput is used for create EntityType object.
// Input was generated by ent.
type CreateEntityTypeInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the entity
	Name      string   `json:"name"`
	OwnerID   *string  `json:"ownerID,omitempty"`
	EntityIDs []string `json:"entityIDs,omitempty"`
}

// CreateEventInput is used for create Event object.
// Input was generated by ent.
type CreateEventInput struct {
	// tags associated with the object
	Tags                   []string               `json:"tags,omitempty"`
	EventID                *string                `json:"eventID,omitempty"`
	CorrelationID          *string                `json:"correlationID,omitempty"`
	EventType              string                 `json:"eventType"`
	Metadata               map[string]interface{} `json:"metadata,omitempty"`
	UserIDs                []string               `json:"userIDs,omitempty"`
	GroupIDs               []string               `json:"groupIDs,omitempty"`
	IntegrationIDs         []string               `json:"integrationIDs,omitempty"`
	OrganizationIDs        []string               `json:"organizationIDs,omitempty"`
	InviteIDs              []string               `json:"inviteIDs,omitempty"`
	FeatureIDs             []string               `json:"featureIDs,omitempty"`
	EntitlementplanIDs     []string               `json:"entitlementplanIDs,omitempty"`
	PersonalAccessTokenIDs []string               `json:"personalAccessTokenIDs,omitempty"`
	Oauth2tokenIDs         []string               `json:"oauth2tokenIDs,omitempty"`
	HushIDs                []string               `json:"hushIDs,omitempty"`
	EntitlementIDs         []string               `json:"entitlementIDs,omitempty"`
	WebhookIDs             []string               `json:"webhookIDs,omitempty"`
	SubscriberIDs          []string               `json:"subscriberIDs,omitempty"`
}

// CreateFeatureInput is used for create Feature object.
// Input was generated by ent.
type CreateFeatureInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the unique name of the feature
	Name string `json:"name"`
	// the displayed 'friendly' name of the feature
	DisplayName *string `json:"displayName,omitempty"`
	// enabled features are available for use
	Enabled *bool `json:"enabled,omitempty"`
	// a description of the feature
	Description *string `json:"description,omitempty"`
	// metadata for the feature
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	OwnerID  *string                `json:"ownerID,omitempty"`
	PlanIDs  []string               `json:"planIDs,omitempty"`
	EventIDs []string               `json:"eventIDs,omitempty"`
}

// CreateFileInput is used for create File object.
// Input was generated by ent.
type CreateFileInput struct {
	// tags associated with the object
	Tags            []string `json:"tags,omitempty"`
	FileName        string   `json:"fileName"`
	FileExtension   string   `json:"fileExtension"`
	FileSize        *int64   `json:"fileSize,omitempty"`
	ContentType     string   `json:"contentType"`
	StoreKey        string   `json:"storeKey"`
	Category        *string  `json:"category,omitempty"`
	Annotation      *string  `json:"annotation,omitempty"`
	UserID          *string  `json:"userID,omitempty"`
	OrganizationIDs []string `json:"organizationIDs,omitempty"`
	EntityIDs       []string `json:"entityIDs,omitempty"`
	GroupIDs        []string `json:"groupIDs,omitempty"`
}

// CreateGroupInput is used for create Group object.
// Input was generated by ent.
type CreateGroupInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the group - must be unique within the organization
	Name string `json:"name"`
	// the groups description
	Description *string `json:"description,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL *string `json:"gravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL *string `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName         *string                  `json:"displayName,omitempty"`
	OwnerID             *string                  `json:"ownerID,omitempty"`
	SettingID           string                   `json:"settingID"`
	UserIDs             []string                 `json:"userIDs,omitempty"`
	EventIDs            []string                 `json:"eventIDs,omitempty"`
	IntegrationIDs      []string                 `json:"integrationIDs,omitempty"`
	FileIDs             []string                 `json:"fileIDs,omitempty"`
	CreateGroupSettings *CreateGroupSettingInput `json:"createGroupSettings,omitempty"`
}

// CreateGroupMembershipInput is used for create GroupMembership object.
// Input was generated by ent.
type CreateGroupMembershipInput struct {
	Role     *enums.Role `json:"role,omitempty"`
	GroupID  string      `json:"groupID"`
	UserID   string      `json:"userID"`
	EventIDs []string    `json:"eventIDs,omitempty"`
}

// CreateGroupSettingInput is used for create GroupSetting object.
// Input was generated by ent.
type CreateGroupSettingInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility *enums.Visibility `json:"visibility,omitempty"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy *enums.JoinPolicy `json:"joinPolicy,omitempty"`
	// whether to sync group members to slack groups
	SyncToSlack *bool `json:"syncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub *bool   `json:"syncToGithub,omitempty"`
	GroupID      *string `json:"groupID,omitempty"`
}

// CreateHushInput is used for create Hush object.
// Input was generated by ent.
type CreateHushInput struct {
	// the logical name of the corresponding hush secret or it's general grouping
	Name string `json:"name"`
	// a description of the hush value or purpose, such as github PAT
	Description *string `json:"description,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind *string `json:"kind,omitempty"`
	// the generic name of a secret associated with the organization
	SecretName *string `json:"secretName,omitempty"`
	// the secret value
	SecretValue     *string  `json:"secretValue,omitempty"`
	IntegrationIDs  []string `json:"integrationIDs,omitempty"`
	OrganizationIDs []string `json:"organizationIDs,omitempty"`
	EventIDs        []string `json:"eventIDs,omitempty"`
}

// CreateIntegrationInput is used for create Integration object.
// Input was generated by ent.
type CreateIntegrationInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the integration - must be unique within the organization
	Name string `json:"name"`
	// a description of the integration
	Description    *string  `json:"description,omitempty"`
	Kind           *string  `json:"kind,omitempty"`
	OwnerID        *string  `json:"ownerID,omitempty"`
	SecretIDs      []string `json:"secretIDs,omitempty"`
	Oauth2tokenIDs []string `json:"oauth2tokenIDs,omitempty"`
	EventIDs       []string `json:"eventIDs,omitempty"`
	WebhookIDs     []string `json:"webhookIDs,omitempty"`
}

// CreateInviteInput is used for create Invite object.
// Input was generated by ent.
type CreateInviteInput struct {
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires *time.Time `json:"expires,omitempty"`
	// the email used as input to generate the invitation token and is the destination person the invitation is sent to who is required to accept to join the organization
	Recipient string `json:"recipient"`
	// the status of the invitation
	Status *enums.InviteStatus `json:"status,omitempty"`
	Role   *enums.Role         `json:"role,omitempty"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts *int64 `json:"sendAttempts,omitempty"`
	// the user who initiated the invitation
	RequestorID *string  `json:"requestorID,omitempty"`
	OwnerID     *string  `json:"ownerID,omitempty"`
	EventIDs    []string `json:"eventIDs,omitempty"`
}

// CreateNoteInput is used for create Note object.
// Input was generated by ent.
type CreateNoteInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the text of the note
	Text     string  `json:"text"`
	OwnerID  *string `json:"ownerID,omitempty"`
	EntityID *string `json:"entityID,omitempty"`
}

// CreateOauthProviderInput is used for create OauthProvider object.
// Input was generated by ent.
type CreateOauthProviderInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the oauth provider's name
	Name string `json:"name"`
	// the client id for the oauth provider
	ClientID string `json:"clientID"`
	// the client secret
	ClientSecret string `json:"clientSecret"`
	// the redirect url
	RedirectURL string `json:"redirectURL"`
	// the scopes
	Scopes string `json:"scopes"`
	// the auth url of the provider
	AuthURL string `json:"authURL"`
	// the token url of the provider
	TokenURL string `json:"tokenURL"`
	// the auth style, 0: auto detect 1: third party log in 2: log in with username and password
	AuthStyle string `json:"authStyle"`
	// the URL to request user information by token
	InfoURL string  `json:"infoURL"`
	OwnerID *string `json:"ownerID,omitempty"`
}

// CreateOhAuthTooTokenInput is used for create OhAuthTooToken object.
// Input was generated by ent.
type CreateOhAuthTooTokenInput struct {
	// tags associated with the object
	Tags                    []string   `json:"tags,omitempty"`
	ClientID                string     `json:"clientID"`
	Scopes                  []string   `json:"scopes,omitempty"`
	Nonce                   string     `json:"nonce"`
	ClaimsUserID            string     `json:"claimsUserID"`
	ClaimsUsername          string     `json:"claimsUsername"`
	ClaimsEmail             string     `json:"claimsEmail"`
	ClaimsEmailVerified     bool       `json:"claimsEmailVerified"`
	ClaimsGroups            []string   `json:"claimsGroups,omitempty"`
	ClaimsPreferredUsername string     `json:"claimsPreferredUsername"`
	ConnectorID             string     `json:"connectorID"`
	ConnectorData           []string   `json:"connectorData,omitempty"`
	LastUsed                *time.Time `json:"lastUsed,omitempty"`
	IntegrationIDs          []string   `json:"integrationIDs,omitempty"`
	EventIDs                []string   `json:"eventIDs,omitempty"`
}

// CreateOrgMembershipInput is used for create OrgMembership object.
// Input was generated by ent.
type CreateOrgMembershipInput struct {
	Role           *enums.Role `json:"role,omitempty"`
	OrganizationID string      `json:"organizationID"`
	UserID         string      `json:"userID"`
	EventIDs       []string    `json:"eventIDs,omitempty"`
}

// CreateOrganizationInput is used for create Organization object.
// Input was generated by ent.
type CreateOrganizationInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the organization
	Name string `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the organization
	Description *string `json:"description,omitempty"`
	// orgs directly associated with a user
	PersonalOrg *bool `json:"personalOrg,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// Whether the organization has a dedicated database
	DedicatedDb                *bool                           `json:"dedicatedDb,omitempty"`
	ParentID                   *string                         `json:"parentID,omitempty"`
	GroupIDs                   []string                        `json:"groupIDs,omitempty"`
	TemplateIDs                []string                        `json:"templateIDs,omitempty"`
	IntegrationIDs             []string                        `json:"integrationIDs,omitempty"`
	SettingID                  *string                         `json:"settingID,omitempty"`
	DocumentdatumIDs           []string                        `json:"documentdatumIDs,omitempty"`
	EntitlementIDs             []string                        `json:"entitlementIDs,omitempty"`
	OrganizationEntitlementIDs []string                        `json:"organizationEntitlementIDs,omitempty"`
	PersonalAccessTokenIDs     []string                        `json:"personalAccessTokenIDs,omitempty"`
	APITokenIDs                []string                        `json:"apiTokenIDs,omitempty"`
	OauthproviderIDs           []string                        `json:"oauthproviderIDs,omitempty"`
	UserIDs                    []string                        `json:"userIDs,omitempty"`
	InviteIDs                  []string                        `json:"inviteIDs,omitempty"`
	SubscriberIDs              []string                        `json:"subscriberIDs,omitempty"`
	WebhookIDs                 []string                        `json:"webhookIDs,omitempty"`
	EventIDs                   []string                        `json:"eventIDs,omitempty"`
	SecretIDs                  []string                        `json:"secretIDs,omitempty"`
	FeatureIDs                 []string                        `json:"featureIDs,omitempty"`
	FileIDs                    []string                        `json:"fileIDs,omitempty"`
	EntitlementplanIDs         []string                        `json:"entitlementplanIDs,omitempty"`
	EntityIDs                  []string                        `json:"entityIDs,omitempty"`
	EntitytypeIDs              []string                        `json:"entitytypeIDs,omitempty"`
	ContactIDs                 []string                        `json:"contactIDs,omitempty"`
	NoteIDs                    []string                        `json:"noteIDs,omitempty"`
	CreateOrgSettings          *CreateOrganizationSettingInput `json:"createOrgSettings,omitempty"`
}

// CreateOrganizationSettingInput is used for create OrganizationSetting object.
// Input was generated by ent.
type CreateOrganizationSettingInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// domains associated with the organization
	Domains []string `json:"domains,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone *string `json:"billingPhone,omitempty"`
	// Address to send billing information to
	BillingAddress *string `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation    *enums.Region `json:"geoLocation,omitempty"`
	OrganizationID *string       `json:"organizationID,omitempty"`
}

// CreatePersonalAccessTokenInput is used for create PersonalAccessToken object.
// Input was generated by ent.
type CreatePersonalAccessTokenInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name associated with the token
	Name string `json:"name"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description     *string    `json:"description,omitempty"`
	Scopes          []string   `json:"scopes,omitempty"`
	LastUsedAt      *time.Time `json:"lastUsedAt,omitempty"`
	OwnerID         string     `json:"ownerID"`
	OrganizationIDs []string   `json:"organizationIDs,omitempty"`
	EventIDs        []string   `json:"eventIDs,omitempty"`
}

// CreateSubscriberInput is used for create Subscriber object.
// Input was generated by ent.
type CreateSubscriberInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// email address of the subscriber
	Email string `json:"email"`
	// phone number of the subscriber
	PhoneNumber *string  `json:"phoneNumber,omitempty"`
	OwnerID     *string  `json:"ownerID,omitempty"`
	EventIDs    []string `json:"eventIDs,omitempty"`
}

// CreateTFASettingInput is used for create TFASetting object.
// Input was generated by ent.
type CreateTFASettingInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// specifies a user may complete authentication by verifying a TOTP code delivered through an authenticator app
	TotpAllowed *bool   `json:"totpAllowed,omitempty"`
	OwnerID     *string `json:"ownerID,omitempty"`
}

// CreateTemplateInput is used for create Template object.
// Input was generated by ent.
type CreateTemplateInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the template
	Name string `json:"name"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType *enums.DocumentType `json:"templateType,omitempty"`
	// the description of the template
	Description *string `json:"description,omitempty"`
	// the jsonschema object of the template
	Jsonconfig json.RawMessage `json:"jsonconfig"`
	// the uischema for the template to render in the UI
	Uischema    json.RawMessage `json:"uischema,omitempty"`
	OwnerID     *string         `json:"ownerID,omitempty"`
	DocumentIDs []string        `json:"documentIDs,omitempty"`
}

// CreateUserInput is used for create User object.
// Input was generated by ent.
type CreateUserInput struct {
	// tags associated with the object
	Tags      []string `json:"tags,omitempty"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName,omitempty"`
	LastName  *string  `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile *string `json:"avatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// user password hash
	Password *string `json:"password,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// auth provider used to register the account
	AuthProvider *enums.AuthProvider `json:"authProvider,omitempty"`
	// the user's role
	Role                      *enums.Role `json:"role,omitempty"`
	PersonalAccessTokenIDs    []string    `json:"personalAccessTokenIDs,omitempty"`
	TfaSettingIDs             []string    `json:"tfaSettingIDs,omitempty"`
	SettingID                 string      `json:"settingID"`
	EmailVerificationTokenIDs []string    `json:"emailVerificationTokenIDs,omitempty"`
	PasswordResetTokenIDs     []string    `json:"passwordResetTokenIDs,omitempty"`
	GroupIDs                  []string    `json:"groupIDs,omitempty"`
	OrganizationIDs           []string    `json:"organizationIDs,omitempty"`
	WebauthnIDs               []string    `json:"webauthnIDs,omitempty"`
	FileIDs                   []string    `json:"fileIDs,omitempty"`
	EventIDs                  []string    `json:"eventIDs,omitempty"`
}

// CreateUserSettingInput is used for create UserSetting object.
// Input was generated by ent.
type CreateUserSettingInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// status of the user account
	Status *enums.UserStatus `json:"status,omitempty"`
	// whether the user has confirmed their email address
	EmailConfirmed *bool `json:"emailConfirmed,omitempty"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed *bool `json:"isWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled *bool   `json:"isTfaEnabled,omitempty"`
	UserID       *string `json:"userID,omitempty"`
	DefaultOrgID *string `json:"defaultOrgID,omitempty"`
}

// CreateWebhookInput is used for create Webhook object.
// Input was generated by ent.
type CreateWebhookInput struct {
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name of the webhook
	Name string `json:"name"`
	// a description of the webhook
	Description *string `json:"description,omitempty"`
	// the url to send the webhook to
	DestinationURL string `json:"destinationURL"`
	// indicates if the webhook is active and enabled
	Enabled *bool `json:"enabled,omitempty"`
	// the number of failures
	Failures *int64 `json:"failures,omitempty"`
	// the last error message
	LastError *string `json:"lastError,omitempty"`
	// the last response
	LastResponse   *string  `json:"lastResponse,omitempty"`
	OwnerID        *string  `json:"ownerID,omitempty"`
	EventIDs       []string `json:"eventIDs,omitempty"`
	IntegrationIDs []string `json:"integrationIDs,omitempty"`
}

type DocumentData struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the template id of the document
	TemplateID string `json:"templateID"`
	// the json data of the document
	Data     json.RawMessage `json:"data"`
	Owner    *Organization   `json:"owner,omitempty"`
	Template *Template       `json:"template"`
	Entity   []*Entity       `json:"entity,omitempty"`
}

func (DocumentData) IsNode() {}

// Return response for createBulkDocumentData mutation
type DocumentDataBulkCreatePayload struct {
	// Created documentData
	DocumentData []*DocumentData `json:"documentData,omitempty"`
}

// A connection to a list of items.
type DocumentDataConnection struct {
	// A list of edges.
	Edges []*DocumentDataEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createDocumentData mutation
type DocumentDataCreatePayload struct {
	// Created documentData
	DocumentData *DocumentData `json:"documentData"`
}

// Return response for deleteDocumentData mutation
type DocumentDataDeletePayload struct {
	// Deleted documentData ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type DocumentDataEdge struct {
	// The item at the end of the edge.
	Node *DocumentData `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type DocumentDataHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the template id of the document
	TemplateID string `json:"templateID"`
	// the json data of the document
	Data json.RawMessage `json:"data"`
}

func (DocumentDataHistory) IsNode() {}

// A connection to a list of items.
type DocumentDataHistoryConnection struct {
	// A list of edges.
	Edges []*DocumentDataHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type DocumentDataHistoryEdge struct {
	// The item at the end of the edge.
	Node *DocumentDataHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// DocumentDataHistoryWhereInput is used for filtering DocumentDataHistory objects.
// Input was generated by ent.
type DocumentDataHistoryWhereInput struct {
	Not *DocumentDataHistoryWhereInput   `json:"not,omitempty"`
	And []*DocumentDataHistoryWhereInput `json:"and,omitempty"`
	Or  []*DocumentDataHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// template_id field predicates
	TemplateID             *string  `json:"templateID,omitempty"`
	TemplateIDNeq          *string  `json:"templateIDNEQ,omitempty"`
	TemplateIDIn           []string `json:"templateIDIn,omitempty"`
	TemplateIDNotIn        []string `json:"templateIDNotIn,omitempty"`
	TemplateIDGt           *string  `json:"templateIDGT,omitempty"`
	TemplateIDGte          *string  `json:"templateIDGTE,omitempty"`
	TemplateIDLt           *string  `json:"templateIDLT,omitempty"`
	TemplateIDLte          *string  `json:"templateIDLTE,omitempty"`
	TemplateIDContains     *string  `json:"templateIDContains,omitempty"`
	TemplateIDHasPrefix    *string  `json:"templateIDHasPrefix,omitempty"`
	TemplateIDHasSuffix    *string  `json:"templateIDHasSuffix,omitempty"`
	TemplateIDEqualFold    *string  `json:"templateIDEqualFold,omitempty"`
	TemplateIDContainsFold *string  `json:"templateIDContainsFold,omitempty"`
}

// Return response for updateDocumentData mutation
type DocumentDataUpdatePayload struct {
	// Updated documentData
	DocumentData *DocumentData `json:"documentData"`
}

// DocumentDataWhereInput is used for filtering DocumentData objects.
// Input was generated by ent.
type DocumentDataWhereInput struct {
	Not *DocumentDataWhereInput   `json:"not,omitempty"`
	And []*DocumentDataWhereInput `json:"and,omitempty"`
	Or  []*DocumentDataWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// template_id field predicates
	TemplateID             *string  `json:"templateID,omitempty"`
	TemplateIDNeq          *string  `json:"templateIDNEQ,omitempty"`
	TemplateIDIn           []string `json:"templateIDIn,omitempty"`
	TemplateIDNotIn        []string `json:"templateIDNotIn,omitempty"`
	TemplateIDGt           *string  `json:"templateIDGT,omitempty"`
	TemplateIDGte          *string  `json:"templateIDGTE,omitempty"`
	TemplateIDLt           *string  `json:"templateIDLT,omitempty"`
	TemplateIDLte          *string  `json:"templateIDLTE,omitempty"`
	TemplateIDContains     *string  `json:"templateIDContains,omitempty"`
	TemplateIDHasPrefix    *string  `json:"templateIDHasPrefix,omitempty"`
	TemplateIDHasSuffix    *string  `json:"templateIDHasSuffix,omitempty"`
	TemplateIDEqualFold    *string  `json:"templateIDEqualFold,omitempty"`
	TemplateIDContainsFold *string  `json:"templateIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// template edge predicates
	HasTemplate     *bool                 `json:"hasTemplate,omitempty"`
	HasTemplateWith []*TemplateWhereInput `json:"hasTemplateWith,omitempty"`
	// entity edge predicates
	HasEntity     *bool               `json:"hasEntity,omitempty"`
	HasEntityWith []*EntityWhereInput `json:"hasEntityWith,omitempty"`
}

type Entitlement struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the plan to which the entitlement belongs
	PlanID string `json:"planID"`
	// the organization to which the entitlement belongs
	OrganizationID string `json:"organizationID"`
	// used to store references to external systems, e.g. Stripe
	ExternalCustomerID *string `json:"externalCustomerID,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalSubscriptionID *string `json:"externalSubscriptionID,omitempty"`
	// whether or not the customers entitlement expires - expires_at will show the time
	Expires bool `json:"expires"`
	// the time at which a customer's entitlement will expire, e.g. they've cancelled but paid through the end of the month
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// whether or not the customer has cancelled their entitlement - usually used in conjunction with expires and expires at
	Cancelled    bool             `json:"cancelled"`
	Owner        *Organization    `json:"owner,omitempty"`
	Plan         *EntitlementPlan `json:"plan"`
	Organization *Organization    `json:"organization"`
	Events       []*Event         `json:"events,omitempty"`
}

func (Entitlement) IsNode() {}

// Return response for createBulkEntitlement mutation
type EntitlementBulkCreatePayload struct {
	// Created entitlements
	Entitlements []*Entitlement `json:"entitlements,omitempty"`
}

// A connection to a list of items.
type EntitlementConnection struct {
	// A list of edges.
	Edges []*EntitlementEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntitlement mutation
type EntitlementCreatePayload struct {
	// Created entitlement
	Entitlement *Entitlement `json:"entitlement"`
}

// Return response for deleteEntitlement mutation
type EntitlementDeletePayload struct {
	// Deleted entitlement ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntitlementEdge struct {
	// The item at the end of the edge.
	Node *Entitlement `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntitlementHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the plan to which the entitlement belongs
	PlanID string `json:"planID"`
	// the organization to which the entitlement belongs
	OrganizationID string `json:"organizationID"`
	// used to store references to external systems, e.g. Stripe
	ExternalCustomerID *string `json:"externalCustomerID,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalSubscriptionID *string `json:"externalSubscriptionID,omitempty"`
	// whether or not the customers entitlement expires - expires_at will show the time
	Expires bool `json:"expires"`
	// the time at which a customer's entitlement will expire, e.g. they've cancelled but paid through the end of the month
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// whether or not the customer has cancelled their entitlement - usually used in conjunction with expires and expires at
	Cancelled bool `json:"cancelled"`
}

func (EntitlementHistory) IsNode() {}

// A connection to a list of items.
type EntitlementHistoryConnection struct {
	// A list of edges.
	Edges []*EntitlementHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntitlementHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntitlementHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// EntitlementHistoryWhereInput is used for filtering EntitlementHistory objects.
// Input was generated by ent.
type EntitlementHistoryWhereInput struct {
	Not *EntitlementHistoryWhereInput   `json:"not,omitempty"`
	And []*EntitlementHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntitlementHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// plan_id field predicates
	PlanID             *string  `json:"planID,omitempty"`
	PlanIDNeq          *string  `json:"planIDNEQ,omitempty"`
	PlanIDIn           []string `json:"planIDIn,omitempty"`
	PlanIDNotIn        []string `json:"planIDNotIn,omitempty"`
	PlanIDGt           *string  `json:"planIDGT,omitempty"`
	PlanIDGte          *string  `json:"planIDGTE,omitempty"`
	PlanIDLt           *string  `json:"planIDLT,omitempty"`
	PlanIDLte          *string  `json:"planIDLTE,omitempty"`
	PlanIDContains     *string  `json:"planIDContains,omitempty"`
	PlanIDHasPrefix    *string  `json:"planIDHasPrefix,omitempty"`
	PlanIDHasSuffix    *string  `json:"planIDHasSuffix,omitempty"`
	PlanIDEqualFold    *string  `json:"planIDEqualFold,omitempty"`
	PlanIDContainsFold *string  `json:"planIDContainsFold,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIDNeq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIDGt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIDGte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIDLt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIDLte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// external_customer_id field predicates
	ExternalCustomerID             *string  `json:"externalCustomerID,omitempty"`
	ExternalCustomerIDNeq          *string  `json:"externalCustomerIDNEQ,omitempty"`
	ExternalCustomerIDIn           []string `json:"externalCustomerIDIn,omitempty"`
	ExternalCustomerIDNotIn        []string `json:"externalCustomerIDNotIn,omitempty"`
	ExternalCustomerIDGt           *string  `json:"externalCustomerIDGT,omitempty"`
	ExternalCustomerIDGte          *string  `json:"externalCustomerIDGTE,omitempty"`
	ExternalCustomerIDLt           *string  `json:"externalCustomerIDLT,omitempty"`
	ExternalCustomerIDLte          *string  `json:"externalCustomerIDLTE,omitempty"`
	ExternalCustomerIDContains     *string  `json:"externalCustomerIDContains,omitempty"`
	ExternalCustomerIDHasPrefix    *string  `json:"externalCustomerIDHasPrefix,omitempty"`
	ExternalCustomerIDHasSuffix    *string  `json:"externalCustomerIDHasSuffix,omitempty"`
	ExternalCustomerIDIsNil        *bool    `json:"externalCustomerIDIsNil,omitempty"`
	ExternalCustomerIDNotNil       *bool    `json:"externalCustomerIDNotNil,omitempty"`
	ExternalCustomerIDEqualFold    *string  `json:"externalCustomerIDEqualFold,omitempty"`
	ExternalCustomerIDContainsFold *string  `json:"externalCustomerIDContainsFold,omitempty"`
	// external_subscription_id field predicates
	ExternalSubscriptionID             *string  `json:"externalSubscriptionID,omitempty"`
	ExternalSubscriptionIDNeq          *string  `json:"externalSubscriptionIDNEQ,omitempty"`
	ExternalSubscriptionIDIn           []string `json:"externalSubscriptionIDIn,omitempty"`
	ExternalSubscriptionIDNotIn        []string `json:"externalSubscriptionIDNotIn,omitempty"`
	ExternalSubscriptionIDGt           *string  `json:"externalSubscriptionIDGT,omitempty"`
	ExternalSubscriptionIDGte          *string  `json:"externalSubscriptionIDGTE,omitempty"`
	ExternalSubscriptionIDLt           *string  `json:"externalSubscriptionIDLT,omitempty"`
	ExternalSubscriptionIDLte          *string  `json:"externalSubscriptionIDLTE,omitempty"`
	ExternalSubscriptionIDContains     *string  `json:"externalSubscriptionIDContains,omitempty"`
	ExternalSubscriptionIDHasPrefix    *string  `json:"externalSubscriptionIDHasPrefix,omitempty"`
	ExternalSubscriptionIDHasSuffix    *string  `json:"externalSubscriptionIDHasSuffix,omitempty"`
	ExternalSubscriptionIDIsNil        *bool    `json:"externalSubscriptionIDIsNil,omitempty"`
	ExternalSubscriptionIDNotNil       *bool    `json:"externalSubscriptionIDNotNil,omitempty"`
	ExternalSubscriptionIDEqualFold    *string  `json:"externalSubscriptionIDEqualFold,omitempty"`
	ExternalSubscriptionIDContainsFold *string  `json:"externalSubscriptionIDContainsFold,omitempty"`
	// expires field predicates
	Expires    *bool `json:"expires,omitempty"`
	ExpiresNeq *bool `json:"expiresNEQ,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// cancelled field predicates
	Cancelled    *bool `json:"cancelled,omitempty"`
	CancelledNeq *bool `json:"cancelledNEQ,omitempty"`
}

type EntitlementPlan struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the displayed 'friendly' name of the plan
	DisplayName *string `json:"displayName,omitempty"`
	// the unique name of the plan
	Name string `json:"name"`
	// a description of the plan
	Description *string `json:"description,omitempty"`
	// the version of the plan
	Version string `json:"version"`
	// metadata for the plan
	Metadata     map[string]interface{}    `json:"metadata,omitempty"`
	Owner        *Organization             `json:"owner,omitempty"`
	Entitlements []*Entitlement            `json:"entitlements,omitempty"`
	BaseFeatures []*Feature                `json:"baseFeatures,omitempty"`
	Events       []*Event                  `json:"events,omitempty"`
	Features     []*EntitlementPlanFeature `json:"features,omitempty"`
}

func (EntitlementPlan) IsNode() {}

// Return response for createBulkEntitlementPlan mutation
type EntitlementPlanBulkCreatePayload struct {
	// Created entitlementPlans
	EntitlementPlans []*EntitlementPlan `json:"entitlementPlans,omitempty"`
}

// A connection to a list of items.
type EntitlementPlanConnection struct {
	// A list of edges.
	Edges []*EntitlementPlanEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntitlementPlan mutation
type EntitlementPlanCreatePayload struct {
	// Created entitlementPlan
	EntitlementPlan *EntitlementPlan `json:"entitlementPlan"`
}

// Return response for deleteEntitlementPlan mutation
type EntitlementPlanDeletePayload struct {
	// Deleted entitlementPlan ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntitlementPlanEdge struct {
	// The item at the end of the edge.
	Node *EntitlementPlan `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntitlementPlanFeature struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// metadata for the entitlement plan feature such as usage limits
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
	PlanID    string                 `json:"planID"`
	FeatureID string                 `json:"featureID"`
	Owner     *Organization          `json:"owner,omitempty"`
	Plan      *EntitlementPlan       `json:"plan"`
	Feature   *Feature               `json:"feature"`
	Events    []*Event               `json:"events,omitempty"`
}

func (EntitlementPlanFeature) IsNode() {}

// Return response for createBulkEntitlementPlanFeature mutation
type EntitlementPlanFeatureBulkCreatePayload struct {
	// Created entitlementPlanFeatures
	EntitlementPlanFeatures []*EntitlementPlanFeature `json:"entitlementPlanFeatures,omitempty"`
}

// A connection to a list of items.
type EntitlementPlanFeatureConnection struct {
	// A list of edges.
	Edges []*EntitlementPlanFeatureEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntitlementPlanFeature mutation
type EntitlementPlanFeatureCreatePayload struct {
	// Created entitlementPlanFeature
	EntitlementPlanFeature *EntitlementPlanFeature `json:"entitlementPlanFeature"`
}

// Return response for deleteEntitlementPlanFeature mutation
type EntitlementPlanFeatureDeletePayload struct {
	// Deleted entitlementPlanFeature ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntitlementPlanFeatureEdge struct {
	// The item at the end of the edge.
	Node *EntitlementPlanFeature `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntitlementPlanFeatureHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// metadata for the entitlement plan feature such as usage limits
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
	PlanID    string                 `json:"planID"`
	FeatureID string                 `json:"featureID"`
}

func (EntitlementPlanFeatureHistory) IsNode() {}

// A connection to a list of items.
type EntitlementPlanFeatureHistoryConnection struct {
	// A list of edges.
	Edges []*EntitlementPlanFeatureHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntitlementPlanFeatureHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntitlementPlanFeatureHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// EntitlementPlanFeatureHistoryWhereInput is used for filtering EntitlementPlanFeatureHistory objects.
// Input was generated by ent.
type EntitlementPlanFeatureHistoryWhereInput struct {
	Not *EntitlementPlanFeatureHistoryWhereInput   `json:"not,omitempty"`
	And []*EntitlementPlanFeatureHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntitlementPlanFeatureHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// plan_id field predicates
	PlanID             *string  `json:"planID,omitempty"`
	PlanIDNeq          *string  `json:"planIDNEQ,omitempty"`
	PlanIDIn           []string `json:"planIDIn,omitempty"`
	PlanIDNotIn        []string `json:"planIDNotIn,omitempty"`
	PlanIDGt           *string  `json:"planIDGT,omitempty"`
	PlanIDGte          *string  `json:"planIDGTE,omitempty"`
	PlanIDLt           *string  `json:"planIDLT,omitempty"`
	PlanIDLte          *string  `json:"planIDLTE,omitempty"`
	PlanIDContains     *string  `json:"planIDContains,omitempty"`
	PlanIDHasPrefix    *string  `json:"planIDHasPrefix,omitempty"`
	PlanIDHasSuffix    *string  `json:"planIDHasSuffix,omitempty"`
	PlanIDEqualFold    *string  `json:"planIDEqualFold,omitempty"`
	PlanIDContainsFold *string  `json:"planIDContainsFold,omitempty"`
	// feature_id field predicates
	FeatureID             *string  `json:"featureID,omitempty"`
	FeatureIDNeq          *string  `json:"featureIDNEQ,omitempty"`
	FeatureIDIn           []string `json:"featureIDIn,omitempty"`
	FeatureIDNotIn        []string `json:"featureIDNotIn,omitempty"`
	FeatureIDGt           *string  `json:"featureIDGT,omitempty"`
	FeatureIDGte          *string  `json:"featureIDGTE,omitempty"`
	FeatureIDLt           *string  `json:"featureIDLT,omitempty"`
	FeatureIDLte          *string  `json:"featureIDLTE,omitempty"`
	FeatureIDContains     *string  `json:"featureIDContains,omitempty"`
	FeatureIDHasPrefix    *string  `json:"featureIDHasPrefix,omitempty"`
	FeatureIDHasSuffix    *string  `json:"featureIDHasSuffix,omitempty"`
	FeatureIDEqualFold    *string  `json:"featureIDEqualFold,omitempty"`
	FeatureIDContainsFold *string  `json:"featureIDContainsFold,omitempty"`
}

// Return response for updateEntitlementPlanFeature mutation
type EntitlementPlanFeatureUpdatePayload struct {
	// Updated entitlementPlanFeature
	EntitlementPlanFeature *EntitlementPlanFeature `json:"entitlementPlanFeature"`
}

// EntitlementPlanFeatureWhereInput is used for filtering EntitlementPlanFeature objects.
// Input was generated by ent.
type EntitlementPlanFeatureWhereInput struct {
	Not *EntitlementPlanFeatureWhereInput   `json:"not,omitempty"`
	And []*EntitlementPlanFeatureWhereInput `json:"and,omitempty"`
	Or  []*EntitlementPlanFeatureWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
}

type EntitlementPlanHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the displayed 'friendly' name of the plan
	DisplayName *string `json:"displayName,omitempty"`
	// the unique name of the plan
	Name string `json:"name"`
	// a description of the plan
	Description *string `json:"description,omitempty"`
	// the version of the plan
	Version string `json:"version"`
	// metadata for the plan
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

func (EntitlementPlanHistory) IsNode() {}

// A connection to a list of items.
type EntitlementPlanHistoryConnection struct {
	// A list of edges.
	Edges []*EntitlementPlanHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntitlementPlanHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntitlementPlanHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// EntitlementPlanHistoryWhereInput is used for filtering EntitlementPlanHistory objects.
// Input was generated by ent.
type EntitlementPlanHistoryWhereInput struct {
	Not *EntitlementPlanHistoryWhereInput   `json:"not,omitempty"`
	And []*EntitlementPlanHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntitlementPlanHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
}

// Return response for updateEntitlementPlan mutation
type EntitlementPlanUpdatePayload struct {
	// Updated entitlementPlan
	EntitlementPlan *EntitlementPlan `json:"entitlementPlan"`
}

// EntitlementPlanWhereInput is used for filtering EntitlementPlan objects.
// Input was generated by ent.
type EntitlementPlanWhereInput struct {
	Not *EntitlementPlanWhereInput   `json:"not,omitempty"`
	And []*EntitlementPlanWhereInput `json:"and,omitempty"`
	Or  []*EntitlementPlanWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// version field predicates
	Version             *string  `json:"version,omitempty"`
	VersionNeq          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGt           *string  `json:"versionGT,omitempty"`
	VersionGte          *string  `json:"versionGTE,omitempty"`
	VersionLt           *string  `json:"versionLT,omitempty"`
	VersionLte          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// entitlements edge predicates
	HasEntitlements     *bool                    `json:"hasEntitlements,omitempty"`
	HasEntitlementsWith []*EntitlementWhereInput `json:"hasEntitlementsWith,omitempty"`
	// base_features edge predicates
	HasBaseFeatures     *bool                `json:"hasBaseFeatures,omitempty"`
	HasBaseFeaturesWith []*FeatureWhereInput `json:"hasBaseFeaturesWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// features edge predicates
	HasFeatures     *bool                               `json:"hasFeatures,omitempty"`
	HasFeaturesWith []*EntitlementPlanFeatureWhereInput `json:"hasFeaturesWith,omitempty"`
}

// Return response for updateEntitlement mutation
type EntitlementUpdatePayload struct {
	// Updated entitlement
	Entitlement *Entitlement `json:"entitlement"`
}

// EntitlementWhereInput is used for filtering Entitlement objects.
// Input was generated by ent.
type EntitlementWhereInput struct {
	Not *EntitlementWhereInput   `json:"not,omitempty"`
	And []*EntitlementWhereInput `json:"and,omitempty"`
	Or  []*EntitlementWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// plan_id field predicates
	PlanID             *string  `json:"planID,omitempty"`
	PlanIDNeq          *string  `json:"planIDNEQ,omitempty"`
	PlanIDIn           []string `json:"planIDIn,omitempty"`
	PlanIDNotIn        []string `json:"planIDNotIn,omitempty"`
	PlanIDGt           *string  `json:"planIDGT,omitempty"`
	PlanIDGte          *string  `json:"planIDGTE,omitempty"`
	PlanIDLt           *string  `json:"planIDLT,omitempty"`
	PlanIDLte          *string  `json:"planIDLTE,omitempty"`
	PlanIDContains     *string  `json:"planIDContains,omitempty"`
	PlanIDHasPrefix    *string  `json:"planIDHasPrefix,omitempty"`
	PlanIDHasSuffix    *string  `json:"planIDHasSuffix,omitempty"`
	PlanIDEqualFold    *string  `json:"planIDEqualFold,omitempty"`
	PlanIDContainsFold *string  `json:"planIDContainsFold,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIDNeq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIDGt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIDGte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIDLt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIDLte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// external_customer_id field predicates
	ExternalCustomerID             *string  `json:"externalCustomerID,omitempty"`
	ExternalCustomerIDNeq          *string  `json:"externalCustomerIDNEQ,omitempty"`
	ExternalCustomerIDIn           []string `json:"externalCustomerIDIn,omitempty"`
	ExternalCustomerIDNotIn        []string `json:"externalCustomerIDNotIn,omitempty"`
	ExternalCustomerIDGt           *string  `json:"externalCustomerIDGT,omitempty"`
	ExternalCustomerIDGte          *string  `json:"externalCustomerIDGTE,omitempty"`
	ExternalCustomerIDLt           *string  `json:"externalCustomerIDLT,omitempty"`
	ExternalCustomerIDLte          *string  `json:"externalCustomerIDLTE,omitempty"`
	ExternalCustomerIDContains     *string  `json:"externalCustomerIDContains,omitempty"`
	ExternalCustomerIDHasPrefix    *string  `json:"externalCustomerIDHasPrefix,omitempty"`
	ExternalCustomerIDHasSuffix    *string  `json:"externalCustomerIDHasSuffix,omitempty"`
	ExternalCustomerIDIsNil        *bool    `json:"externalCustomerIDIsNil,omitempty"`
	ExternalCustomerIDNotNil       *bool    `json:"externalCustomerIDNotNil,omitempty"`
	ExternalCustomerIDEqualFold    *string  `json:"externalCustomerIDEqualFold,omitempty"`
	ExternalCustomerIDContainsFold *string  `json:"externalCustomerIDContainsFold,omitempty"`
	// external_subscription_id field predicates
	ExternalSubscriptionID             *string  `json:"externalSubscriptionID,omitempty"`
	ExternalSubscriptionIDNeq          *string  `json:"externalSubscriptionIDNEQ,omitempty"`
	ExternalSubscriptionIDIn           []string `json:"externalSubscriptionIDIn,omitempty"`
	ExternalSubscriptionIDNotIn        []string `json:"externalSubscriptionIDNotIn,omitempty"`
	ExternalSubscriptionIDGt           *string  `json:"externalSubscriptionIDGT,omitempty"`
	ExternalSubscriptionIDGte          *string  `json:"externalSubscriptionIDGTE,omitempty"`
	ExternalSubscriptionIDLt           *string  `json:"externalSubscriptionIDLT,omitempty"`
	ExternalSubscriptionIDLte          *string  `json:"externalSubscriptionIDLTE,omitempty"`
	ExternalSubscriptionIDContains     *string  `json:"externalSubscriptionIDContains,omitempty"`
	ExternalSubscriptionIDHasPrefix    *string  `json:"externalSubscriptionIDHasPrefix,omitempty"`
	ExternalSubscriptionIDHasSuffix    *string  `json:"externalSubscriptionIDHasSuffix,omitempty"`
	ExternalSubscriptionIDIsNil        *bool    `json:"externalSubscriptionIDIsNil,omitempty"`
	ExternalSubscriptionIDNotNil       *bool    `json:"externalSubscriptionIDNotNil,omitempty"`
	ExternalSubscriptionIDEqualFold    *string  `json:"externalSubscriptionIDEqualFold,omitempty"`
	ExternalSubscriptionIDContainsFold *string  `json:"externalSubscriptionIDContainsFold,omitempty"`
	// expires field predicates
	Expires    *bool `json:"expires,omitempty"`
	ExpiresNeq *bool `json:"expiresNEQ,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// cancelled field predicates
	Cancelled    *bool `json:"cancelled,omitempty"`
	CancelledNeq *bool `json:"cancelledNEQ,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// plan edge predicates
	HasPlan     *bool                        `json:"hasPlan,omitempty"`
	HasPlanWith []*EntitlementPlanWhereInput `json:"hasPlanWith,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Entity struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name *string `json:"name,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the entity
	Description *string `json:"description,omitempty"`
	// domains associated with the entity
	Domains []string `json:"domains,omitempty"`
	// The type of the entity
	EntityTypeID *string `json:"entityTypeID,omitempty"`
	// status of the entity
	Status     *string         `json:"status,omitempty"`
	Owner      *Organization   `json:"owner,omitempty"`
	Contacts   []*Contact      `json:"contacts,omitempty"`
	Documents  []*DocumentData `json:"documents,omitempty"`
	Notes      []*Note         `json:"notes,omitempty"`
	Files      []*File         `json:"files,omitempty"`
	EntityType *EntityType     `json:"entityType,omitempty"`
}

func (Entity) IsNode() {}

// Return response for createBulkEntity mutation
type EntityBulkCreatePayload struct {
	// Created entities
	Entities []*Entity `json:"entities,omitempty"`
}

// A connection to a list of items.
type EntityConnection struct {
	// A list of edges.
	Edges []*EntityEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntity mutation
type EntityCreatePayload struct {
	// Created entity
	Entity *Entity `json:"entity"`
}

// Return response for deleteEntity mutation
type EntityDeletePayload struct {
	// Deleted entity ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntityEdge struct {
	// The item at the end of the edge.
	Node *Entity `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntityHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name *string `json:"name,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the entity
	Description *string `json:"description,omitempty"`
	// domains associated with the entity
	Domains []string `json:"domains,omitempty"`
	// The type of the entity
	EntityTypeID *string `json:"entityTypeID,omitempty"`
	// status of the entity
	Status *string `json:"status,omitempty"`
}

func (EntityHistory) IsNode() {}

// A connection to a list of items.
type EntityHistoryConnection struct {
	// A list of edges.
	Edges []*EntityHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntityHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntityHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for EntityHistory connections
type EntityHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EntityHistories.
	Field EntityHistoryOrderField `json:"field"`
}

// EntityHistoryWhereInput is used for filtering EntityHistory objects.
// Input was generated by ent.
type EntityHistoryWhereInput struct {
	Not *EntityHistoryWhereInput   `json:"not,omitempty"`
	And []*EntityHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntityHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        *bool    `json:"nameIsNil,omitempty"`
	NameNotNil       *bool    `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// entity_type_id field predicates
	EntityTypeID             *string  `json:"entityTypeID,omitempty"`
	EntityTypeIDNeq          *string  `json:"entityTypeIDNEQ,omitempty"`
	EntityTypeIDIn           []string `json:"entityTypeIDIn,omitempty"`
	EntityTypeIDNotIn        []string `json:"entityTypeIDNotIn,omitempty"`
	EntityTypeIDGt           *string  `json:"entityTypeIDGT,omitempty"`
	EntityTypeIDGte          *string  `json:"entityTypeIDGTE,omitempty"`
	EntityTypeIDLt           *string  `json:"entityTypeIDLT,omitempty"`
	EntityTypeIDLte          *string  `json:"entityTypeIDLTE,omitempty"`
	EntityTypeIDContains     *string  `json:"entityTypeIDContains,omitempty"`
	EntityTypeIDHasPrefix    *string  `json:"entityTypeIDHasPrefix,omitempty"`
	EntityTypeIDHasSuffix    *string  `json:"entityTypeIDHasSuffix,omitempty"`
	EntityTypeIDIsNil        *bool    `json:"entityTypeIDIsNil,omitempty"`
	EntityTypeIDNotNil       *bool    `json:"entityTypeIDNotNil,omitempty"`
	EntityTypeIDEqualFold    *string  `json:"entityTypeIDEqualFold,omitempty"`
	EntityTypeIDContainsFold *string  `json:"entityTypeIDContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
}

// Ordering options for Entity connections
type EntityOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Entities.
	Field EntityOrderField `json:"field"`
}

type EntitySearchResult struct {
	Entities []*Entity `json:"entities,omitempty"`
}

func (EntitySearchResult) IsSearchResult() {}

type EntityType struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name     string        `json:"name"`
	Owner    *Organization `json:"owner,omitempty"`
	Entities []*Entity     `json:"entities,omitempty"`
}

func (EntityType) IsNode() {}

// Return response for createBulkEntityType mutation
type EntityTypeBulkCreatePayload struct {
	// Created entityTypes
	EntityTypes []*EntityType `json:"entityTypes,omitempty"`
}

// A connection to a list of items.
type EntityTypeConnection struct {
	// A list of edges.
	Edges []*EntityTypeEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEntityType mutation
type EntityTypeCreatePayload struct {
	// Created entityType
	EntityType *EntityType `json:"entityType"`
}

// Return response for deleteEntityType mutation
type EntityTypeDeletePayload struct {
	// Deleted entityType ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EntityTypeEdge struct {
	// The item at the end of the edge.
	Node *EntityType `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EntityTypeHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the entity
	Name string `json:"name"`
}

func (EntityTypeHistory) IsNode() {}

// A connection to a list of items.
type EntityTypeHistoryConnection struct {
	// A list of edges.
	Edges []*EntityTypeHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EntityTypeHistoryEdge struct {
	// The item at the end of the edge.
	Node *EntityTypeHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for EntityTypeHistory connections
type EntityTypeHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EntityTypeHistories.
	Field EntityTypeHistoryOrderField `json:"field"`
}

// EntityTypeHistoryWhereInput is used for filtering EntityTypeHistory objects.
// Input was generated by ent.
type EntityTypeHistoryWhereInput struct {
	Not *EntityTypeHistoryWhereInput   `json:"not,omitempty"`
	And []*EntityTypeHistoryWhereInput `json:"and,omitempty"`
	Or  []*EntityTypeHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// Ordering options for EntityType connections
type EntityTypeOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order EntityTypes.
	Field EntityTypeOrderField `json:"field"`
}

// Return response for updateEntityType mutation
type EntityTypeUpdatePayload struct {
	// Updated entityType
	EntityType *EntityType `json:"entityType"`
}

// EntityTypeWhereInput is used for filtering EntityType objects.
// Input was generated by ent.
type EntityTypeWhereInput struct {
	Not *EntityTypeWhereInput   `json:"not,omitempty"`
	And []*EntityTypeWhereInput `json:"and,omitempty"`
	Or  []*EntityTypeWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
}

// Return response for updateEntity mutation
type EntityUpdatePayload struct {
	// Updated entity
	Entity *Entity `json:"entity"`
}

// EntityWhereInput is used for filtering Entity objects.
// Input was generated by ent.
type EntityWhereInput struct {
	Not *EntityWhereInput   `json:"not,omitempty"`
	And []*EntityWhereInput `json:"and,omitempty"`
	Or  []*EntityWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        *bool    `json:"nameIsNil,omitempty"`
	NameNotNil       *bool    `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// entity_type_id field predicates
	EntityTypeID             *string  `json:"entityTypeID,omitempty"`
	EntityTypeIDNeq          *string  `json:"entityTypeIDNEQ,omitempty"`
	EntityTypeIDIn           []string `json:"entityTypeIDIn,omitempty"`
	EntityTypeIDNotIn        []string `json:"entityTypeIDNotIn,omitempty"`
	EntityTypeIDGt           *string  `json:"entityTypeIDGT,omitempty"`
	EntityTypeIDGte          *string  `json:"entityTypeIDGTE,omitempty"`
	EntityTypeIDLt           *string  `json:"entityTypeIDLT,omitempty"`
	EntityTypeIDLte          *string  `json:"entityTypeIDLTE,omitempty"`
	EntityTypeIDContains     *string  `json:"entityTypeIDContains,omitempty"`
	EntityTypeIDHasPrefix    *string  `json:"entityTypeIDHasPrefix,omitempty"`
	EntityTypeIDHasSuffix    *string  `json:"entityTypeIDHasSuffix,omitempty"`
	EntityTypeIDIsNil        *bool    `json:"entityTypeIDIsNil,omitempty"`
	EntityTypeIDNotNil       *bool    `json:"entityTypeIDNotNil,omitempty"`
	EntityTypeIDEqualFold    *string  `json:"entityTypeIDEqualFold,omitempty"`
	EntityTypeIDContainsFold *string  `json:"entityTypeIDContainsFold,omitempty"`
	// status field predicates
	Status             *string  `json:"status,omitempty"`
	StatusNeq          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGt           *string  `json:"statusGT,omitempty"`
	StatusGte          *string  `json:"statusGTE,omitempty"`
	StatusLt           *string  `json:"statusLT,omitempty"`
	StatusLte          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        *bool    `json:"statusIsNil,omitempty"`
	StatusNotNil       *bool    `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// contacts edge predicates
	HasContacts     *bool                `json:"hasContacts,omitempty"`
	HasContactsWith []*ContactWhereInput `json:"hasContactsWith,omitempty"`
	// documents edge predicates
	HasDocuments     *bool                     `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentDataWhereInput `json:"hasDocumentsWith,omitempty"`
	// notes edge predicates
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// entity_type edge predicates
	HasEntityType     *bool                   `json:"hasEntityType,omitempty"`
	HasEntityTypeWith []*EntityTypeWhereInput `json:"hasEntityTypeWith,omitempty"`
}

type Event struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags                   []string                  `json:"tags,omitempty"`
	EventID                *string                   `json:"eventID,omitempty"`
	CorrelationID          *string                   `json:"correlationID,omitempty"`
	EventType              string                    `json:"eventType"`
	Metadata               map[string]interface{}    `json:"metadata,omitempty"`
	User                   []*User                   `json:"user,omitempty"`
	Group                  []*Group                  `json:"group,omitempty"`
	Integration            []*Integration            `json:"integration,omitempty"`
	Organization           []*Organization           `json:"organization,omitempty"`
	Invite                 []*Invite                 `json:"invite,omitempty"`
	Feature                []*Feature                `json:"feature,omitempty"`
	Entitlementplan        []*EntitlementPlan        `json:"entitlementplan,omitempty"`
	Entitlementplanfeature []*EntitlementPlanFeature `json:"entitlementplanfeature,omitempty"`
	PersonalAccessToken    []*PersonalAccessToken    `json:"personalAccessToken,omitempty"`
	Oauth2token            []*OhAuthTooToken         `json:"oauth2token,omitempty"`
	Hush                   []*Hush                   `json:"hush,omitempty"`
	Orgmembership          []*OrgMembership          `json:"orgmembership,omitempty"`
	Groupmembership        []*GroupMembership        `json:"groupmembership,omitempty"`
	Entitlement            []*Entitlement            `json:"entitlement,omitempty"`
	Webhook                []*Webhook                `json:"webhook,omitempty"`
	Subscriber             []*Subscriber             `json:"subscriber,omitempty"`
}

func (Event) IsNode() {}

// Return response for createBulkEvent mutation
type EventBulkCreatePayload struct {
	// Created events
	Events []*Event `json:"events,omitempty"`
}

// A connection to a list of items.
type EventConnection struct {
	// A list of edges.
	Edges []*EventEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createEvent mutation
type EventCreatePayload struct {
	// Created event
	Event *Event `json:"event"`
}

// Return response for deleteEvent mutation
type EventDeletePayload struct {
	// Deleted event ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type EventEdge struct {
	// The item at the end of the edge.
	Node *Event `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type EventHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags          []string               `json:"tags,omitempty"`
	EventID       *string                `json:"eventID,omitempty"`
	CorrelationID *string                `json:"correlationID,omitempty"`
	EventType     string                 `json:"eventType"`
	Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

func (EventHistory) IsNode() {}

// A connection to a list of items.
type EventHistoryConnection struct {
	// A list of edges.
	Edges []*EventHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type EventHistoryEdge struct {
	// The item at the end of the edge.
	Node *EventHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// EventHistoryWhereInput is used for filtering EventHistory objects.
// Input was generated by ent.
type EventHistoryWhereInput struct {
	Not *EventHistoryWhereInput   `json:"not,omitempty"`
	And []*EventHistoryWhereInput `json:"and,omitempty"`
	Or  []*EventHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// event_id field predicates
	EventID             *string  `json:"eventID,omitempty"`
	EventIDNeq          *string  `json:"eventIDNEQ,omitempty"`
	EventIDIn           []string `json:"eventIDIn,omitempty"`
	EventIDNotIn        []string `json:"eventIDNotIn,omitempty"`
	EventIDGt           *string  `json:"eventIDGT,omitempty"`
	EventIDGte          *string  `json:"eventIDGTE,omitempty"`
	EventIDLt           *string  `json:"eventIDLT,omitempty"`
	EventIDLte          *string  `json:"eventIDLTE,omitempty"`
	EventIDContains     *string  `json:"eventIDContains,omitempty"`
	EventIDHasPrefix    *string  `json:"eventIDHasPrefix,omitempty"`
	EventIDHasSuffix    *string  `json:"eventIDHasSuffix,omitempty"`
	EventIDIsNil        *bool    `json:"eventIDIsNil,omitempty"`
	EventIDNotNil       *bool    `json:"eventIDNotNil,omitempty"`
	EventIDEqualFold    *string  `json:"eventIDEqualFold,omitempty"`
	EventIDContainsFold *string  `json:"eventIDContainsFold,omitempty"`
	// correlation_id field predicates
	CorrelationID             *string  `json:"correlationID,omitempty"`
	CorrelationIDNeq          *string  `json:"correlationIDNEQ,omitempty"`
	CorrelationIDIn           []string `json:"correlationIDIn,omitempty"`
	CorrelationIDNotIn        []string `json:"correlationIDNotIn,omitempty"`
	CorrelationIDGt           *string  `json:"correlationIDGT,omitempty"`
	CorrelationIDGte          *string  `json:"correlationIDGTE,omitempty"`
	CorrelationIDLt           *string  `json:"correlationIDLT,omitempty"`
	CorrelationIDLte          *string  `json:"correlationIDLTE,omitempty"`
	CorrelationIDContains     *string  `json:"correlationIDContains,omitempty"`
	CorrelationIDHasPrefix    *string  `json:"correlationIDHasPrefix,omitempty"`
	CorrelationIDHasSuffix    *string  `json:"correlationIDHasSuffix,omitempty"`
	CorrelationIDIsNil        *bool    `json:"correlationIDIsNil,omitempty"`
	CorrelationIDNotNil       *bool    `json:"correlationIDNotNil,omitempty"`
	CorrelationIDEqualFold    *string  `json:"correlationIDEqualFold,omitempty"`
	CorrelationIDContainsFold *string  `json:"correlationIDContainsFold,omitempty"`
	// event_type field predicates
	EventType             *string  `json:"eventType,omitempty"`
	EventTypeNeq          *string  `json:"eventTypeNEQ,omitempty"`
	EventTypeIn           []string `json:"eventTypeIn,omitempty"`
	EventTypeNotIn        []string `json:"eventTypeNotIn,omitempty"`
	EventTypeGt           *string  `json:"eventTypeGT,omitempty"`
	EventTypeGte          *string  `json:"eventTypeGTE,omitempty"`
	EventTypeLt           *string  `json:"eventTypeLT,omitempty"`
	EventTypeLte          *string  `json:"eventTypeLTE,omitempty"`
	EventTypeContains     *string  `json:"eventTypeContains,omitempty"`
	EventTypeHasPrefix    *string  `json:"eventTypeHasPrefix,omitempty"`
	EventTypeHasSuffix    *string  `json:"eventTypeHasSuffix,omitempty"`
	EventTypeEqualFold    *string  `json:"eventTypeEqualFold,omitempty"`
	EventTypeContainsFold *string  `json:"eventTypeContainsFold,omitempty"`
}

// Return response for updateEvent mutation
type EventUpdatePayload struct {
	// Updated event
	Event *Event `json:"event"`
}

// EventWhereInput is used for filtering Event objects.
// Input was generated by ent.
type EventWhereInput struct {
	Not *EventWhereInput   `json:"not,omitempty"`
	And []*EventWhereInput `json:"and,omitempty"`
	Or  []*EventWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// event_id field predicates
	EventID             *string  `json:"eventID,omitempty"`
	EventIDNeq          *string  `json:"eventIDNEQ,omitempty"`
	EventIDIn           []string `json:"eventIDIn,omitempty"`
	EventIDNotIn        []string `json:"eventIDNotIn,omitempty"`
	EventIDGt           *string  `json:"eventIDGT,omitempty"`
	EventIDGte          *string  `json:"eventIDGTE,omitempty"`
	EventIDLt           *string  `json:"eventIDLT,omitempty"`
	EventIDLte          *string  `json:"eventIDLTE,omitempty"`
	EventIDContains     *string  `json:"eventIDContains,omitempty"`
	EventIDHasPrefix    *string  `json:"eventIDHasPrefix,omitempty"`
	EventIDHasSuffix    *string  `json:"eventIDHasSuffix,omitempty"`
	EventIDIsNil        *bool    `json:"eventIDIsNil,omitempty"`
	EventIDNotNil       *bool    `json:"eventIDNotNil,omitempty"`
	EventIDEqualFold    *string  `json:"eventIDEqualFold,omitempty"`
	EventIDContainsFold *string  `json:"eventIDContainsFold,omitempty"`
	// correlation_id field predicates
	CorrelationID             *string  `json:"correlationID,omitempty"`
	CorrelationIDNeq          *string  `json:"correlationIDNEQ,omitempty"`
	CorrelationIDIn           []string `json:"correlationIDIn,omitempty"`
	CorrelationIDNotIn        []string `json:"correlationIDNotIn,omitempty"`
	CorrelationIDGt           *string  `json:"correlationIDGT,omitempty"`
	CorrelationIDGte          *string  `json:"correlationIDGTE,omitempty"`
	CorrelationIDLt           *string  `json:"correlationIDLT,omitempty"`
	CorrelationIDLte          *string  `json:"correlationIDLTE,omitempty"`
	CorrelationIDContains     *string  `json:"correlationIDContains,omitempty"`
	CorrelationIDHasPrefix    *string  `json:"correlationIDHasPrefix,omitempty"`
	CorrelationIDHasSuffix    *string  `json:"correlationIDHasSuffix,omitempty"`
	CorrelationIDIsNil        *bool    `json:"correlationIDIsNil,omitempty"`
	CorrelationIDNotNil       *bool    `json:"correlationIDNotNil,omitempty"`
	CorrelationIDEqualFold    *string  `json:"correlationIDEqualFold,omitempty"`
	CorrelationIDContainsFold *string  `json:"correlationIDContainsFold,omitempty"`
	// event_type field predicates
	EventType             *string  `json:"eventType,omitempty"`
	EventTypeNeq          *string  `json:"eventTypeNEQ,omitempty"`
	EventTypeIn           []string `json:"eventTypeIn,omitempty"`
	EventTypeNotIn        []string `json:"eventTypeNotIn,omitempty"`
	EventTypeGt           *string  `json:"eventTypeGT,omitempty"`
	EventTypeGte          *string  `json:"eventTypeGTE,omitempty"`
	EventTypeLt           *string  `json:"eventTypeLT,omitempty"`
	EventTypeLte          *string  `json:"eventTypeLTE,omitempty"`
	EventTypeContains     *string  `json:"eventTypeContains,omitempty"`
	EventTypeHasPrefix    *string  `json:"eventTypeHasPrefix,omitempty"`
	EventTypeHasSuffix    *string  `json:"eventTypeHasSuffix,omitempty"`
	EventTypeEqualFold    *string  `json:"eventTypeEqualFold,omitempty"`
	EventTypeContainsFold *string  `json:"eventTypeContainsFold,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
	// integration edge predicates
	HasIntegration     *bool                    `json:"hasIntegration,omitempty"`
	HasIntegrationWith []*IntegrationWhereInput `json:"hasIntegrationWith,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// invite edge predicates
	HasInvite     *bool               `json:"hasInvite,omitempty"`
	HasInviteWith []*InviteWhereInput `json:"hasInviteWith,omitempty"`
	// feature edge predicates
	HasFeature     *bool                `json:"hasFeature,omitempty"`
	HasFeatureWith []*FeatureWhereInput `json:"hasFeatureWith,omitempty"`
	// entitlementplan edge predicates
	HasEntitlementplan     *bool                        `json:"hasEntitlementplan,omitempty"`
	HasEntitlementplanWith []*EntitlementPlanWhereInput `json:"hasEntitlementplanWith,omitempty"`
	// entitlementplanfeature edge predicates
	HasEntitlementplanfeature     *bool                               `json:"hasEntitlementplanfeature,omitempty"`
	HasEntitlementplanfeatureWith []*EntitlementPlanFeatureWhereInput `json:"hasEntitlementplanfeatureWith,omitempty"`
	// personal_access_token edge predicates
	HasPersonalAccessToken     *bool                            `json:"hasPersonalAccessToken,omitempty"`
	HasPersonalAccessTokenWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokenWith,omitempty"`
	// oauth2token edge predicates
	HasOauth2token     *bool                       `json:"hasOauth2token,omitempty"`
	HasOauth2tokenWith []*OhAuthTooTokenWhereInput `json:"hasOauth2tokenWith,omitempty"`
	// hush edge predicates
	HasHush     *bool             `json:"hasHush,omitempty"`
	HasHushWith []*HushWhereInput `json:"hasHushWith,omitempty"`
	// orgmembership edge predicates
	HasOrgmembership     *bool                      `json:"hasOrgmembership,omitempty"`
	HasOrgmembershipWith []*OrgMembershipWhereInput `json:"hasOrgmembershipWith,omitempty"`
	// groupmembership edge predicates
	HasGroupmembership     *bool                        `json:"hasGroupmembership,omitempty"`
	HasGroupmembershipWith []*GroupMembershipWhereInput `json:"hasGroupmembershipWith,omitempty"`
	// entitlement edge predicates
	HasEntitlement     *bool                    `json:"hasEntitlement,omitempty"`
	HasEntitlementWith []*EntitlementWhereInput `json:"hasEntitlementWith,omitempty"`
	// webhook edge predicates
	HasWebhook     *bool                `json:"hasWebhook,omitempty"`
	HasWebhookWith []*WebhookWhereInput `json:"hasWebhookWith,omitempty"`
	// subscriber edge predicates
	HasSubscriber     *bool                   `json:"hasSubscriber,omitempty"`
	HasSubscriberWith []*SubscriberWhereInput `json:"hasSubscriberWith,omitempty"`
}

type Feature struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the unique name of the feature
	Name string `json:"name"`
	// the displayed 'friendly' name of the feature
	DisplayName *string `json:"displayName,omitempty"`
	// enabled features are available for use
	Enabled bool `json:"enabled"`
	// a description of the feature
	Description *string `json:"description,omitempty"`
	// metadata for the feature
	Metadata map[string]interface{}    `json:"metadata,omitempty"`
	Owner    *Organization             `json:"owner,omitempty"`
	Plans    []*EntitlementPlan        `json:"plans,omitempty"`
	Events   []*Event                  `json:"events,omitempty"`
	Features []*EntitlementPlanFeature `json:"features,omitempty"`
}

func (Feature) IsNode() {}

// Return response for createBulkFeature mutation
type FeatureBulkCreatePayload struct {
	// Created features
	Features []*Feature `json:"features,omitempty"`
}

// A connection to a list of items.
type FeatureConnection struct {
	// A list of edges.
	Edges []*FeatureEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createFeature mutation
type FeatureCreatePayload struct {
	// Created feature
	Feature *Feature `json:"feature"`
}

// Return response for deleteFeature mutation
type FeatureDeletePayload struct {
	// Deleted feature ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type FeatureEdge struct {
	// The item at the end of the edge.
	Node *Feature `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type FeatureHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the unique name of the feature
	Name string `json:"name"`
	// the displayed 'friendly' name of the feature
	DisplayName *string `json:"displayName,omitempty"`
	// enabled features are available for use
	Enabled bool `json:"enabled"`
	// a description of the feature
	Description *string `json:"description,omitempty"`
	// metadata for the feature
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

func (FeatureHistory) IsNode() {}

// A connection to a list of items.
type FeatureHistoryConnection struct {
	// A list of edges.
	Edges []*FeatureHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type FeatureHistoryEdge struct {
	// The item at the end of the edge.
	Node *FeatureHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// FeatureHistoryWhereInput is used for filtering FeatureHistory objects.
// Input was generated by ent.
type FeatureHistoryWhereInput struct {
	Not *FeatureHistoryWhereInput   `json:"not,omitempty"`
	And []*FeatureHistoryWhereInput `json:"and,omitempty"`
	Or  []*FeatureHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// enabled field predicates
	Enabled    *bool `json:"enabled,omitempty"`
	EnabledNeq *bool `json:"enabledNEQ,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
}

// Return response for updateFeature mutation
type FeatureUpdatePayload struct {
	// Updated feature
	Feature *Feature `json:"feature"`
}

// FeatureWhereInput is used for filtering Feature objects.
// Input was generated by ent.
type FeatureWhereInput struct {
	Not *FeatureWhereInput   `json:"not,omitempty"`
	And []*FeatureWhereInput `json:"and,omitempty"`
	Or  []*FeatureWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameIsNil        *bool    `json:"displayNameIsNil,omitempty"`
	DisplayNameNotNil       *bool    `json:"displayNameNotNil,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// enabled field predicates
	Enabled    *bool `json:"enabled,omitempty"`
	EnabledNeq *bool `json:"enabledNEQ,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// plans edge predicates
	HasPlans     *bool                        `json:"hasPlans,omitempty"`
	HasPlansWith []*EntitlementPlanWhereInput `json:"hasPlansWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// features edge predicates
	HasFeatures     *bool                               `json:"hasFeatures,omitempty"`
	HasFeaturesWith []*EntitlementPlanFeatureWhereInput `json:"hasFeaturesWith,omitempty"`
}

type File struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags          []string        `json:"tags,omitempty"`
	FileName      string          `json:"fileName"`
	FileExtension string          `json:"fileExtension"`
	FileSize      *int64          `json:"fileSize,omitempty"`
	ContentType   string          `json:"contentType"`
	StoreKey      string          `json:"storeKey"`
	Category      *string         `json:"category,omitempty"`
	Annotation    *string         `json:"annotation,omitempty"`
	User          *User           `json:"user,omitempty"`
	Organization  []*Organization `json:"organization,omitempty"`
	Entity        []*Entity       `json:"entity,omitempty"`
	Group         []*Group        `json:"group,omitempty"`
}

func (File) IsNode() {}

// Return response for createBulkFile mutation
type FileBulkCreatePayload struct {
	// Created files
	Files []*File `json:"files,omitempty"`
}

// A connection to a list of items.
type FileConnection struct {
	// A list of edges.
	Edges []*FileEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createFile mutation
type FileCreatePayload struct {
	// Created file
	File *File `json:"file"`
}

// Return response for deleteFile mutation
type FileDeletePayload struct {
	// Deleted file ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type FileEdge struct {
	// The item at the end of the edge.
	Node *File `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type FileHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags          []string `json:"tags,omitempty"`
	FileName      string   `json:"fileName"`
	FileExtension string   `json:"fileExtension"`
	FileSize      *int64   `json:"fileSize,omitempty"`
	ContentType   string   `json:"contentType"`
	StoreKey      string   `json:"storeKey"`
	Category      *string  `json:"category,omitempty"`
	Annotation    *string  `json:"annotation,omitempty"`
}

func (FileHistory) IsNode() {}

// A connection to a list of items.
type FileHistoryConnection struct {
	// A list of edges.
	Edges []*FileHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type FileHistoryEdge struct {
	// The item at the end of the edge.
	Node *FileHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// FileHistoryWhereInput is used for filtering FileHistory objects.
// Input was generated by ent.
type FileHistoryWhereInput struct {
	Not *FileHistoryWhereInput   `json:"not,omitempty"`
	And []*FileHistoryWhereInput `json:"and,omitempty"`
	Or  []*FileHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// file_name field predicates
	FileName             *string  `json:"fileName,omitempty"`
	FileNameNeq          *string  `json:"fileNameNEQ,omitempty"`
	FileNameIn           []string `json:"fileNameIn,omitempty"`
	FileNameNotIn        []string `json:"fileNameNotIn,omitempty"`
	FileNameGt           *string  `json:"fileNameGT,omitempty"`
	FileNameGte          *string  `json:"fileNameGTE,omitempty"`
	FileNameLt           *string  `json:"fileNameLT,omitempty"`
	FileNameLte          *string  `json:"fileNameLTE,omitempty"`
	FileNameContains     *string  `json:"fileNameContains,omitempty"`
	FileNameHasPrefix    *string  `json:"fileNameHasPrefix,omitempty"`
	FileNameHasSuffix    *string  `json:"fileNameHasSuffix,omitempty"`
	FileNameEqualFold    *string  `json:"fileNameEqualFold,omitempty"`
	FileNameContainsFold *string  `json:"fileNameContainsFold,omitempty"`
	// file_extension field predicates
	FileExtension             *string  `json:"fileExtension,omitempty"`
	FileExtensionNeq          *string  `json:"fileExtensionNEQ,omitempty"`
	FileExtensionIn           []string `json:"fileExtensionIn,omitempty"`
	FileExtensionNotIn        []string `json:"fileExtensionNotIn,omitempty"`
	FileExtensionGt           *string  `json:"fileExtensionGT,omitempty"`
	FileExtensionGte          *string  `json:"fileExtensionGTE,omitempty"`
	FileExtensionLt           *string  `json:"fileExtensionLT,omitempty"`
	FileExtensionLte          *string  `json:"fileExtensionLTE,omitempty"`
	FileExtensionContains     *string  `json:"fileExtensionContains,omitempty"`
	FileExtensionHasPrefix    *string  `json:"fileExtensionHasPrefix,omitempty"`
	FileExtensionHasSuffix    *string  `json:"fileExtensionHasSuffix,omitempty"`
	FileExtensionEqualFold    *string  `json:"fileExtensionEqualFold,omitempty"`
	FileExtensionContainsFold *string  `json:"fileExtensionContainsFold,omitempty"`
	// file_size field predicates
	FileSize       *int64  `json:"fileSize,omitempty"`
	FileSizeNeq    *int64  `json:"fileSizeNEQ,omitempty"`
	FileSizeIn     []int64 `json:"fileSizeIn,omitempty"`
	FileSizeNotIn  []int64 `json:"fileSizeNotIn,omitempty"`
	FileSizeGt     *int64  `json:"fileSizeGT,omitempty"`
	FileSizeGte    *int64  `json:"fileSizeGTE,omitempty"`
	FileSizeLt     *int64  `json:"fileSizeLT,omitempty"`
	FileSizeLte    *int64  `json:"fileSizeLTE,omitempty"`
	FileSizeIsNil  *bool   `json:"fileSizeIsNil,omitempty"`
	FileSizeNotNil *bool   `json:"fileSizeNotNil,omitempty"`
	// content_type field predicates
	ContentType             *string  `json:"contentType,omitempty"`
	ContentTypeNeq          *string  `json:"contentTypeNEQ,omitempty"`
	ContentTypeIn           []string `json:"contentTypeIn,omitempty"`
	ContentTypeNotIn        []string `json:"contentTypeNotIn,omitempty"`
	ContentTypeGt           *string  `json:"contentTypeGT,omitempty"`
	ContentTypeGte          *string  `json:"contentTypeGTE,omitempty"`
	ContentTypeLt           *string  `json:"contentTypeLT,omitempty"`
	ContentTypeLte          *string  `json:"contentTypeLTE,omitempty"`
	ContentTypeContains     *string  `json:"contentTypeContains,omitempty"`
	ContentTypeHasPrefix    *string  `json:"contentTypeHasPrefix,omitempty"`
	ContentTypeHasSuffix    *string  `json:"contentTypeHasSuffix,omitempty"`
	ContentTypeEqualFold    *string  `json:"contentTypeEqualFold,omitempty"`
	ContentTypeContainsFold *string  `json:"contentTypeContainsFold,omitempty"`
	// store_key field predicates
	StoreKey             *string  `json:"storeKey,omitempty"`
	StoreKeyNeq          *string  `json:"storeKeyNEQ,omitempty"`
	StoreKeyIn           []string `json:"storeKeyIn,omitempty"`
	StoreKeyNotIn        []string `json:"storeKeyNotIn,omitempty"`
	StoreKeyGt           *string  `json:"storeKeyGT,omitempty"`
	StoreKeyGte          *string  `json:"storeKeyGTE,omitempty"`
	StoreKeyLt           *string  `json:"storeKeyLT,omitempty"`
	StoreKeyLte          *string  `json:"storeKeyLTE,omitempty"`
	StoreKeyContains     *string  `json:"storeKeyContains,omitempty"`
	StoreKeyHasPrefix    *string  `json:"storeKeyHasPrefix,omitempty"`
	StoreKeyHasSuffix    *string  `json:"storeKeyHasSuffix,omitempty"`
	StoreKeyEqualFold    *string  `json:"storeKeyEqualFold,omitempty"`
	StoreKeyContainsFold *string  `json:"storeKeyContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// annotation field predicates
	Annotation             *string  `json:"annotation,omitempty"`
	AnnotationNeq          *string  `json:"annotationNEQ,omitempty"`
	AnnotationIn           []string `json:"annotationIn,omitempty"`
	AnnotationNotIn        []string `json:"annotationNotIn,omitempty"`
	AnnotationGt           *string  `json:"annotationGT,omitempty"`
	AnnotationGte          *string  `json:"annotationGTE,omitempty"`
	AnnotationLt           *string  `json:"annotationLT,omitempty"`
	AnnotationLte          *string  `json:"annotationLTE,omitempty"`
	AnnotationContains     *string  `json:"annotationContains,omitempty"`
	AnnotationHasPrefix    *string  `json:"annotationHasPrefix,omitempty"`
	AnnotationHasSuffix    *string  `json:"annotationHasSuffix,omitempty"`
	AnnotationIsNil        *bool    `json:"annotationIsNil,omitempty"`
	AnnotationNotNil       *bool    `json:"annotationNotNil,omitempty"`
	AnnotationEqualFold    *string  `json:"annotationEqualFold,omitempty"`
	AnnotationContainsFold *string  `json:"annotationContainsFold,omitempty"`
}

// Return response for updateFile mutation
type FileUpdatePayload struct {
	// Updated file
	File *File `json:"file"`
}

// FileWhereInput is used for filtering File objects.
// Input was generated by ent.
type FileWhereInput struct {
	Not *FileWhereInput   `json:"not,omitempty"`
	And []*FileWhereInput `json:"and,omitempty"`
	Or  []*FileWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// file_name field predicates
	FileName             *string  `json:"fileName,omitempty"`
	FileNameNeq          *string  `json:"fileNameNEQ,omitempty"`
	FileNameIn           []string `json:"fileNameIn,omitempty"`
	FileNameNotIn        []string `json:"fileNameNotIn,omitempty"`
	FileNameGt           *string  `json:"fileNameGT,omitempty"`
	FileNameGte          *string  `json:"fileNameGTE,omitempty"`
	FileNameLt           *string  `json:"fileNameLT,omitempty"`
	FileNameLte          *string  `json:"fileNameLTE,omitempty"`
	FileNameContains     *string  `json:"fileNameContains,omitempty"`
	FileNameHasPrefix    *string  `json:"fileNameHasPrefix,omitempty"`
	FileNameHasSuffix    *string  `json:"fileNameHasSuffix,omitempty"`
	FileNameEqualFold    *string  `json:"fileNameEqualFold,omitempty"`
	FileNameContainsFold *string  `json:"fileNameContainsFold,omitempty"`
	// file_extension field predicates
	FileExtension             *string  `json:"fileExtension,omitempty"`
	FileExtensionNeq          *string  `json:"fileExtensionNEQ,omitempty"`
	FileExtensionIn           []string `json:"fileExtensionIn,omitempty"`
	FileExtensionNotIn        []string `json:"fileExtensionNotIn,omitempty"`
	FileExtensionGt           *string  `json:"fileExtensionGT,omitempty"`
	FileExtensionGte          *string  `json:"fileExtensionGTE,omitempty"`
	FileExtensionLt           *string  `json:"fileExtensionLT,omitempty"`
	FileExtensionLte          *string  `json:"fileExtensionLTE,omitempty"`
	FileExtensionContains     *string  `json:"fileExtensionContains,omitempty"`
	FileExtensionHasPrefix    *string  `json:"fileExtensionHasPrefix,omitempty"`
	FileExtensionHasSuffix    *string  `json:"fileExtensionHasSuffix,omitempty"`
	FileExtensionEqualFold    *string  `json:"fileExtensionEqualFold,omitempty"`
	FileExtensionContainsFold *string  `json:"fileExtensionContainsFold,omitempty"`
	// file_size field predicates
	FileSize       *int64  `json:"fileSize,omitempty"`
	FileSizeNeq    *int64  `json:"fileSizeNEQ,omitempty"`
	FileSizeIn     []int64 `json:"fileSizeIn,omitempty"`
	FileSizeNotIn  []int64 `json:"fileSizeNotIn,omitempty"`
	FileSizeGt     *int64  `json:"fileSizeGT,omitempty"`
	FileSizeGte    *int64  `json:"fileSizeGTE,omitempty"`
	FileSizeLt     *int64  `json:"fileSizeLT,omitempty"`
	FileSizeLte    *int64  `json:"fileSizeLTE,omitempty"`
	FileSizeIsNil  *bool   `json:"fileSizeIsNil,omitempty"`
	FileSizeNotNil *bool   `json:"fileSizeNotNil,omitempty"`
	// content_type field predicates
	ContentType             *string  `json:"contentType,omitempty"`
	ContentTypeNeq          *string  `json:"contentTypeNEQ,omitempty"`
	ContentTypeIn           []string `json:"contentTypeIn,omitempty"`
	ContentTypeNotIn        []string `json:"contentTypeNotIn,omitempty"`
	ContentTypeGt           *string  `json:"contentTypeGT,omitempty"`
	ContentTypeGte          *string  `json:"contentTypeGTE,omitempty"`
	ContentTypeLt           *string  `json:"contentTypeLT,omitempty"`
	ContentTypeLte          *string  `json:"contentTypeLTE,omitempty"`
	ContentTypeContains     *string  `json:"contentTypeContains,omitempty"`
	ContentTypeHasPrefix    *string  `json:"contentTypeHasPrefix,omitempty"`
	ContentTypeHasSuffix    *string  `json:"contentTypeHasSuffix,omitempty"`
	ContentTypeEqualFold    *string  `json:"contentTypeEqualFold,omitempty"`
	ContentTypeContainsFold *string  `json:"contentTypeContainsFold,omitempty"`
	// store_key field predicates
	StoreKey             *string  `json:"storeKey,omitempty"`
	StoreKeyNeq          *string  `json:"storeKeyNEQ,omitempty"`
	StoreKeyIn           []string `json:"storeKeyIn,omitempty"`
	StoreKeyNotIn        []string `json:"storeKeyNotIn,omitempty"`
	StoreKeyGt           *string  `json:"storeKeyGT,omitempty"`
	StoreKeyGte          *string  `json:"storeKeyGTE,omitempty"`
	StoreKeyLt           *string  `json:"storeKeyLT,omitempty"`
	StoreKeyLte          *string  `json:"storeKeyLTE,omitempty"`
	StoreKeyContains     *string  `json:"storeKeyContains,omitempty"`
	StoreKeyHasPrefix    *string  `json:"storeKeyHasPrefix,omitempty"`
	StoreKeyHasSuffix    *string  `json:"storeKeyHasSuffix,omitempty"`
	StoreKeyEqualFold    *string  `json:"storeKeyEqualFold,omitempty"`
	StoreKeyContainsFold *string  `json:"storeKeyContainsFold,omitempty"`
	// category field predicates
	Category             *string  `json:"category,omitempty"`
	CategoryNeq          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGt           *string  `json:"categoryGT,omitempty"`
	CategoryGte          *string  `json:"categoryGTE,omitempty"`
	CategoryLt           *string  `json:"categoryLT,omitempty"`
	CategoryLte          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        *bool    `json:"categoryIsNil,omitempty"`
	CategoryNotNil       *bool    `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`
	// annotation field predicates
	Annotation             *string  `json:"annotation,omitempty"`
	AnnotationNeq          *string  `json:"annotationNEQ,omitempty"`
	AnnotationIn           []string `json:"annotationIn,omitempty"`
	AnnotationNotIn        []string `json:"annotationNotIn,omitempty"`
	AnnotationGt           *string  `json:"annotationGT,omitempty"`
	AnnotationGte          *string  `json:"annotationGTE,omitempty"`
	AnnotationLt           *string  `json:"annotationLT,omitempty"`
	AnnotationLte          *string  `json:"annotationLTE,omitempty"`
	AnnotationContains     *string  `json:"annotationContains,omitempty"`
	AnnotationHasPrefix    *string  `json:"annotationHasPrefix,omitempty"`
	AnnotationHasSuffix    *string  `json:"annotationHasSuffix,omitempty"`
	AnnotationIsNil        *bool    `json:"annotationIsNil,omitempty"`
	AnnotationNotNil       *bool    `json:"annotationNotNil,omitempty"`
	AnnotationEqualFold    *string  `json:"annotationEqualFold,omitempty"`
	AnnotationContainsFold *string  `json:"annotationContainsFold,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// entity edge predicates
	HasEntity     *bool               `json:"hasEntity,omitempty"`
	HasEntityWith []*EntityWhereInput `json:"hasEntityWith,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
}

type Group struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the group - must be unique within the organization
	Name string `json:"name"`
	// the groups description
	Description *string `json:"description,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL *string `json:"gravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL *string `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName  string             `json:"displayName"`
	Owner        *Organization      `json:"owner,omitempty"`
	Setting      *GroupSetting      `json:"setting"`
	Users        []*User            `json:"users,omitempty"`
	Events       []*Event           `json:"events,omitempty"`
	Integrations []*Integration     `json:"integrations,omitempty"`
	Files        []*File            `json:"files,omitempty"`
	Members      []*GroupMembership `json:"members,omitempty"`
}

func (Group) IsNode() {}

// Return response for createBulkGroup mutation
type GroupBulkCreatePayload struct {
	// Created groups
	Groups []*Group `json:"groups,omitempty"`
}

// A connection to a list of items.
type GroupConnection struct {
	// A list of edges.
	Edges []*GroupEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroup mutation
type GroupCreatePayload struct {
	// Created group
	Group *Group `json:"group"`
}

// Return response for deleteGroup mutation
type GroupDeletePayload struct {
	// Deleted group ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupEdge struct {
	// The item at the end of the edge.
	Node *Group `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type GroupHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the group - must be unique within the organization
	Name string `json:"name"`
	// the groups description
	Description *string `json:"description,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL *string `json:"gravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL *string `json:"logoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName string `json:"displayName"`
}

func (GroupHistory) IsNode() {}

// A connection to a list of items.
type GroupHistoryConnection struct {
	// A list of edges.
	Edges []*GroupHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupHistoryEdge struct {
	// The item at the end of the edge.
	Node *GroupHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for GroupHistory connections
type GroupHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order GroupHistories.
	Field GroupHistoryOrderField `json:"field"`
}

// GroupHistoryWhereInput is used for filtering GroupHistory objects.
// Input was generated by ent.
type GroupHistoryWhereInput struct {
	Not *GroupHistoryWhereInput   `json:"not,omitempty"`
	And []*GroupHistoryWhereInput `json:"and,omitempty"`
	Or  []*GroupHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
}

type GroupMembership struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	Role      enums.Role `json:"role"`
	GroupID   string     `json:"groupID"`
	UserID    string     `json:"userID"`
	Group     *Group     `json:"group"`
	User      *User      `json:"user"`
	Events    []*Event   `json:"events,omitempty"`
}

func (GroupMembership) IsNode() {}

// Return response for createBulkGroupMembership mutation
type GroupMembershipBulkCreatePayload struct {
	// Created groupMemberships
	GroupMemberships []*GroupMembership `json:"groupMemberships,omitempty"`
}

// A connection to a list of items.
type GroupMembershipConnection struct {
	// A list of edges.
	Edges []*GroupMembershipEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroupMembership mutation
type GroupMembershipCreatePayload struct {
	// Created groupMembership
	GroupMembership *GroupMembership `json:"groupMembership"`
}

// Return response for deleteGroupMembership mutation
type GroupMembershipDeletePayload struct {
	// Deleted groupMembership ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupMembershipEdge struct {
	// The item at the end of the edge.
	Node *GroupMembership `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type GroupMembershipHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	Role        enums.Role     `json:"role"`
	GroupID     string         `json:"groupID"`
	UserID      string         `json:"userID"`
}

func (GroupMembershipHistory) IsNode() {}

// A connection to a list of items.
type GroupMembershipHistoryConnection struct {
	// A list of edges.
	Edges []*GroupMembershipHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupMembershipHistoryEdge struct {
	// The item at the end of the edge.
	Node *GroupMembershipHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// GroupMembershipHistoryWhereInput is used for filtering GroupMembershipHistory objects.
// Input was generated by ent.
type GroupMembershipHistoryWhereInput struct {
	Not *GroupMembershipHistoryWhereInput   `json:"not,omitempty"`
	And []*GroupMembershipHistoryWhereInput `json:"and,omitempty"`
	Or  []*GroupMembershipHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// group_id field predicates
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIDNeq          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIDGt           *string  `json:"groupIDGT,omitempty"`
	GroupIDGte          *string  `json:"groupIDGTE,omitempty"`
	GroupIDLt           *string  `json:"groupIDLT,omitempty"`
	GroupIDLte          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIDNeq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGt           *string  `json:"userIDGT,omitempty"`
	UserIDGte          *string  `json:"userIDGTE,omitempty"`
	UserIDLt           *string  `json:"userIDLT,omitempty"`
	UserIDLte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// Return response for updateGroupMembership mutation
type GroupMembershipUpdatePayload struct {
	// Updated groupMembership
	GroupMembership *GroupMembership `json:"groupMembership"`
}

// GroupMembershipWhereInput is used for filtering GroupMembership objects.
// Input was generated by ent.
type GroupMembershipWhereInput struct {
	Not *GroupMembershipWhereInput   `json:"not,omitempty"`
	And []*GroupMembershipWhereInput `json:"and,omitempty"`
	Or  []*GroupMembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	GroupID   *string      `json:"groupID,omitempty"`
	UserID    *string      `json:"userID,omitempty"`
}

// Ordering options for Group connections
type GroupOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Groups.
	Field GroupOrderField `json:"field"`
}

type GroupSearchResult struct {
	Groups []*Group `json:"groups,omitempty"`
}

func (GroupSearchResult) IsSearchResult() {}

type GroupSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility enums.Visibility `json:"visibility"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy enums.JoinPolicy `json:"joinPolicy"`
	// whether to sync group members to slack groups
	SyncToSlack *bool `json:"syncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub *bool `json:"syncToGithub,omitempty"`
	// the group id associated with the settings
	GroupID *string `json:"groupID,omitempty"`
	Group   *Group  `json:"group,omitempty"`
}

func (GroupSetting) IsNode() {}

// Return response for createBulkGroupSetting mutation
type GroupSettingBulkCreatePayload struct {
	// Created groupSettings
	GroupSettings []*GroupSetting `json:"groupSettings,omitempty"`
}

// A connection to a list of items.
type GroupSettingConnection struct {
	// A list of edges.
	Edges []*GroupSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createGroupSetting mutation
type GroupSettingCreatePayload struct {
	// Created groupSetting
	GroupSetting *GroupSetting `json:"groupSetting"`
}

// Return response for deleteGroupSetting mutation
type GroupSettingDeletePayload struct {
	// Deleted groupSetting ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type GroupSettingEdge struct {
	// The item at the end of the edge.
	Node *GroupSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type GroupSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility enums.Visibility `json:"visibility"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy enums.JoinPolicy `json:"joinPolicy"`
	// whether to sync group members to slack groups
	SyncToSlack *bool `json:"syncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub *bool `json:"syncToGithub,omitempty"`
	// the group id associated with the settings
	GroupID *string `json:"groupID,omitempty"`
}

func (GroupSettingHistory) IsNode() {}

// A connection to a list of items.
type GroupSettingHistoryConnection struct {
	// A list of edges.
	Edges []*GroupSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type GroupSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *GroupSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// GroupSettingHistoryWhereInput is used for filtering GroupSettingHistory objects.
// Input was generated by ent.
type GroupSettingHistoryWhereInput struct {
	Not *GroupSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*GroupSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*GroupSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// visibility field predicates
	Visibility      *enums.Visibility  `json:"visibility,omitempty"`
	VisibilityNeq   *enums.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []enums.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []enums.Visibility `json:"visibilityNotIn,omitempty"`
	// join_policy field predicates
	JoinPolicy      *enums.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNeq   *enums.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []enums.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []enums.JoinPolicy `json:"joinPolicyNotIn,omitempty"`
	// sync_to_slack field predicates
	SyncToSlack       *bool `json:"syncToSlack,omitempty"`
	SyncToSlackNeq    *bool `json:"syncToSlackNEQ,omitempty"`
	SyncToSlackIsNil  *bool `json:"syncToSlackIsNil,omitempty"`
	SyncToSlackNotNil *bool `json:"syncToSlackNotNil,omitempty"`
	// sync_to_github field predicates
	SyncToGithub       *bool `json:"syncToGithub,omitempty"`
	SyncToGithubNeq    *bool `json:"syncToGithubNEQ,omitempty"`
	SyncToGithubIsNil  *bool `json:"syncToGithubIsNil,omitempty"`
	SyncToGithubNotNil *bool `json:"syncToGithubNotNil,omitempty"`
	// group_id field predicates
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIDNeq          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIDGt           *string  `json:"groupIDGT,omitempty"`
	GroupIDGte          *string  `json:"groupIDGTE,omitempty"`
	GroupIDLt           *string  `json:"groupIDLT,omitempty"`
	GroupIDLte          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDIsNil        *bool    `json:"groupIDIsNil,omitempty"`
	GroupIDNotNil       *bool    `json:"groupIDNotNil,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
}

// Return response for updateGroupSetting mutation
type GroupSettingUpdatePayload struct {
	// Updated groupSetting
	GroupSetting *GroupSetting `json:"groupSetting"`
}

// GroupSettingWhereInput is used for filtering GroupSetting objects.
// Input was generated by ent.
type GroupSettingWhereInput struct {
	Not *GroupSettingWhereInput   `json:"not,omitempty"`
	And []*GroupSettingWhereInput `json:"and,omitempty"`
	Or  []*GroupSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// visibility field predicates
	Visibility      *enums.Visibility  `json:"visibility,omitempty"`
	VisibilityNeq   *enums.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []enums.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []enums.Visibility `json:"visibilityNotIn,omitempty"`
	// join_policy field predicates
	JoinPolicy      *enums.JoinPolicy  `json:"joinPolicy,omitempty"`
	JoinPolicyNeq   *enums.JoinPolicy  `json:"joinPolicyNEQ,omitempty"`
	JoinPolicyIn    []enums.JoinPolicy `json:"joinPolicyIn,omitempty"`
	JoinPolicyNotIn []enums.JoinPolicy `json:"joinPolicyNotIn,omitempty"`
	// sync_to_slack field predicates
	SyncToSlack       *bool `json:"syncToSlack,omitempty"`
	SyncToSlackNeq    *bool `json:"syncToSlackNEQ,omitempty"`
	SyncToSlackIsNil  *bool `json:"syncToSlackIsNil,omitempty"`
	SyncToSlackNotNil *bool `json:"syncToSlackNotNil,omitempty"`
	// sync_to_github field predicates
	SyncToGithub       *bool `json:"syncToGithub,omitempty"`
	SyncToGithubNeq    *bool `json:"syncToGithubNEQ,omitempty"`
	SyncToGithubIsNil  *bool `json:"syncToGithubIsNil,omitempty"`
	SyncToGithubNotNil *bool `json:"syncToGithubNotNil,omitempty"`
	// group_id field predicates
	GroupID             *string  `json:"groupID,omitempty"`
	GroupIDNeq          *string  `json:"groupIDNEQ,omitempty"`
	GroupIDIn           []string `json:"groupIDIn,omitempty"`
	GroupIDNotIn        []string `json:"groupIDNotIn,omitempty"`
	GroupIDGt           *string  `json:"groupIDGT,omitempty"`
	GroupIDGte          *string  `json:"groupIDGTE,omitempty"`
	GroupIDLt           *string  `json:"groupIDLT,omitempty"`
	GroupIDLte          *string  `json:"groupIDLTE,omitempty"`
	GroupIDContains     *string  `json:"groupIDContains,omitempty"`
	GroupIDHasPrefix    *string  `json:"groupIDHasPrefix,omitempty"`
	GroupIDHasSuffix    *string  `json:"groupIDHasSuffix,omitempty"`
	GroupIDIsNil        *bool    `json:"groupIDIsNil,omitempty"`
	GroupIDNotNil       *bool    `json:"groupIDNotNil,omitempty"`
	GroupIDEqualFold    *string  `json:"groupIDEqualFold,omitempty"`
	GroupIDContainsFold *string  `json:"groupIDContainsFold,omitempty"`
	// group edge predicates
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`
}

// Return response for updateGroup mutation
type GroupUpdatePayload struct {
	// Updated group
	Group *Group `json:"group"`
}

// GroupWhereInput is used for filtering Group objects.
// Input was generated by ent.
type GroupWhereInput struct {
	Not *GroupWhereInput   `json:"not,omitempty"`
	And []*GroupWhereInput `json:"and,omitempty"`
	Or  []*GroupWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                     `json:"hasSetting,omitempty"`
	HasSettingWith []*GroupSettingWhereInput `json:"hasSettingWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// members edge predicates
	HasMembers     *bool                        `json:"hasMembers,omitempty"`
	HasMembersWith []*GroupMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

type Hush struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the logical name of the corresponding hush secret or it's general grouping
	Name string `json:"name"`
	// a description of the hush value or purpose, such as github PAT
	Description *string `json:"description,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind *string `json:"kind,omitempty"`
	// the generic name of a secret associated with the organization
	SecretName *string `json:"secretName,omitempty"`
	// the integration associated with the secret
	Integrations []*Integration  `json:"integrations,omitempty"`
	Organization []*Organization `json:"organization,omitempty"`
	Events       []*Event        `json:"events,omitempty"`
}

func (Hush) IsNode() {}

// Return response for createBulkHush mutation
type HushBulkCreatePayload struct {
	// Created hushs
	Hushes []*Hush `json:"hushes,omitempty"`
}

// A connection to a list of items.
type HushConnection struct {
	// A list of edges.
	Edges []*HushEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createHush mutation
type HushCreatePayload struct {
	// Created hush
	Hush *Hush `json:"hush"`
}

// Return response for deleteHush mutation
type HushDeletePayload struct {
	// Deleted hush ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type HushEdge struct {
	// The item at the end of the edge.
	Node *Hush `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type HushHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// the logical name of the corresponding hush secret or it's general grouping
	Name string `json:"name"`
	// a description of the hush value or purpose, such as github PAT
	Description *string `json:"description,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind *string `json:"kind,omitempty"`
	// the generic name of a secret associated with the organization
	SecretName *string `json:"secretName,omitempty"`
}

func (HushHistory) IsNode() {}

// A connection to a list of items.
type HushHistoryConnection struct {
	// A list of edges.
	Edges []*HushHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type HushHistoryEdge struct {
	// The item at the end of the edge.
	Node *HushHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for HushHistory connections
type HushHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order HushHistories.
	Field HushHistoryOrderField `json:"field"`
}

// HushHistoryWhereInput is used for filtering HushHistory objects.
// Input was generated by ent.
type HushHistoryWhereInput struct {
	Not *HushHistoryWhereInput   `json:"not,omitempty"`
	And []*HushHistoryWhereInput `json:"and,omitempty"`
	Or  []*HushHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// secret_name field predicates
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNeq          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGt           *string  `json:"secretNameGT,omitempty"`
	SecretNameGte          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLt           *string  `json:"secretNameLT,omitempty"`
	SecretNameLte          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameIsNil        *bool    `json:"secretNameIsNil,omitempty"`
	SecretNameNotNil       *bool    `json:"secretNameNotNil,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`
}

// Ordering options for Hush connections
type HushOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Hushes.
	Field HushOrderField `json:"field"`
}

// Return response for updateHush mutation
type HushUpdatePayload struct {
	// Updated hush
	Hush *Hush `json:"hush"`
}

// HushWhereInput is used for filtering Hush objects.
// Input was generated by ent.
type HushWhereInput struct {
	Not *HushWhereInput   `json:"not,omitempty"`
	And []*HushWhereInput `json:"and,omitempty"`
	Or  []*HushWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// secret_name field predicates
	SecretName             *string  `json:"secretName,omitempty"`
	SecretNameNeq          *string  `json:"secretNameNEQ,omitempty"`
	SecretNameIn           []string `json:"secretNameIn,omitempty"`
	SecretNameNotIn        []string `json:"secretNameNotIn,omitempty"`
	SecretNameGt           *string  `json:"secretNameGT,omitempty"`
	SecretNameGte          *string  `json:"secretNameGTE,omitempty"`
	SecretNameLt           *string  `json:"secretNameLT,omitempty"`
	SecretNameLte          *string  `json:"secretNameLTE,omitempty"`
	SecretNameContains     *string  `json:"secretNameContains,omitempty"`
	SecretNameHasPrefix    *string  `json:"secretNameHasPrefix,omitempty"`
	SecretNameHasSuffix    *string  `json:"secretNameHasSuffix,omitempty"`
	SecretNameIsNil        *bool    `json:"secretNameIsNil,omitempty"`
	SecretNameNotNil       *bool    `json:"secretNameNotNil,omitempty"`
	SecretNameEqualFold    *string  `json:"secretNameEqualFold,omitempty"`
	SecretNameContainsFold *string  `json:"secretNameContainsFold,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Integration struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the integration - must be unique within the organization
	Name string `json:"name"`
	// a description of the integration
	Description *string       `json:"description,omitempty"`
	Kind        *string       `json:"kind,omitempty"`
	Owner       *Organization `json:"owner,omitempty"`
	// the secrets associated with the integration
	Secrets []*Hush `json:"secrets,omitempty"`
	// the oauth2 tokens associated with the integration
	Oauth2tokens []*OhAuthTooToken `json:"oauth2tokens,omitempty"`
	Events       []*Event          `json:"events,omitempty"`
	Webhooks     []*Webhook        `json:"webhooks,omitempty"`
}

func (Integration) IsNode() {}

// Return response for createBulkIntegration mutation
type IntegrationBulkCreatePayload struct {
	// Created integrations
	Integrations []*Integration `json:"integrations,omitempty"`
}

// A connection to a list of items.
type IntegrationConnection struct {
	// A list of edges.
	Edges []*IntegrationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createIntegration mutation
type IntegrationCreatePayload struct {
	// Created integration
	Integration *Integration `json:"integration"`
}

// Return response for deleteIntegration mutation
type IntegrationDeletePayload struct {
	// Deleted integration ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type IntegrationEdge struct {
	// The item at the end of the edge.
	Node *Integration `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type IntegrationHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the integration - must be unique within the organization
	Name string `json:"name"`
	// a description of the integration
	Description *string `json:"description,omitempty"`
	Kind        *string `json:"kind,omitempty"`
}

func (IntegrationHistory) IsNode() {}

// A connection to a list of items.
type IntegrationHistoryConnection struct {
	// A list of edges.
	Edges []*IntegrationHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type IntegrationHistoryEdge struct {
	// The item at the end of the edge.
	Node *IntegrationHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for IntegrationHistory connections
type IntegrationHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order IntegrationHistories.
	Field IntegrationHistoryOrderField `json:"field"`
}

// IntegrationHistoryWhereInput is used for filtering IntegrationHistory objects.
// Input was generated by ent.
type IntegrationHistoryWhereInput struct {
	Not *IntegrationHistoryWhereInput   `json:"not,omitempty"`
	And []*IntegrationHistoryWhereInput `json:"and,omitempty"`
	Or  []*IntegrationHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
}

// Ordering options for Integration connections
type IntegrationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Integrations.
	Field IntegrationOrderField `json:"field"`
}

// Return response for updateIntegration mutation
type IntegrationUpdatePayload struct {
	// Updated integration
	Integration *Integration `json:"integration"`
}

// IntegrationWhereInput is used for filtering Integration objects.
// Input was generated by ent.
type IntegrationWhereInput struct {
	Not *IntegrationWhereInput   `json:"not,omitempty"`
	And []*IntegrationWhereInput `json:"and,omitempty"`
	Or  []*IntegrationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// kind field predicates
	Kind             *string  `json:"kind,omitempty"`
	KindNeq          *string  `json:"kindNEQ,omitempty"`
	KindIn           []string `json:"kindIn,omitempty"`
	KindNotIn        []string `json:"kindNotIn,omitempty"`
	KindGt           *string  `json:"kindGT,omitempty"`
	KindGte          *string  `json:"kindGTE,omitempty"`
	KindLt           *string  `json:"kindLT,omitempty"`
	KindLte          *string  `json:"kindLTE,omitempty"`
	KindContains     *string  `json:"kindContains,omitempty"`
	KindHasPrefix    *string  `json:"kindHasPrefix,omitempty"`
	KindHasSuffix    *string  `json:"kindHasSuffix,omitempty"`
	KindIsNil        *bool    `json:"kindIsNil,omitempty"`
	KindNotNil       *bool    `json:"kindNotNil,omitempty"`
	KindEqualFold    *string  `json:"kindEqualFold,omitempty"`
	KindContainsFold *string  `json:"kindContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// secrets edge predicates
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`
	// oauth2tokens edge predicates
	HasOauth2tokens     *bool                       `json:"hasOauth2tokens,omitempty"`
	HasOauth2tokensWith []*OhAuthTooTokenWhereInput `json:"hasOauth2tokensWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// webhooks edge predicates
	HasWebhooks     *bool                `json:"hasWebhooks,omitempty"`
	HasWebhooksWith []*WebhookWhereInput `json:"hasWebhooksWith,omitempty"`
}

type Invite struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires *time.Time `json:"expires,omitempty"`
	// the email used as input to generate the invitation token and is the destination person the invitation is sent to who is required to accept to join the organization
	Recipient string `json:"recipient"`
	// the status of the invitation
	Status enums.InviteStatus `json:"status"`
	Role   enums.Role         `json:"role"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts int64 `json:"sendAttempts"`
	// the user who initiated the invitation
	RequestorID *string       `json:"requestorID,omitempty"`
	Owner       *Organization `json:"owner,omitempty"`
	Events      []*Event      `json:"events,omitempty"`
}

func (Invite) IsNode() {}

// Return response for createBulkInvite mutation
type InviteBulkCreatePayload struct {
	// Created invites
	Invites []*Invite `json:"invites,omitempty"`
}

// A connection to a list of items.
type InviteConnection struct {
	// A list of edges.
	Edges []*InviteEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createInvite mutation
type InviteCreatePayload struct {
	// Created invite
	Invite *Invite `json:"invite"`
}

// Return response for deleteInvite mutation
type InviteDeletePayload struct {
	// Deleted invite ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type InviteEdge struct {
	// The item at the end of the edge.
	Node *Invite `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateInvite mutation
type InviteUpdatePayload struct {
	// Updated invite
	Invite *Invite `json:"invite"`
}

// InviteWhereInput is used for filtering Invite objects.
// Input was generated by ent.
type InviteWhereInput struct {
	Not *InviteWhereInput   `json:"not,omitempty"`
	And []*InviteWhereInput `json:"and,omitempty"`
	Or  []*InviteWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// expires field predicates
	Expires       *time.Time   `json:"expires,omitempty"`
	ExpiresNeq    *time.Time   `json:"expiresNEQ,omitempty"`
	ExpiresIn     []*time.Time `json:"expiresIn,omitempty"`
	ExpiresNotIn  []*time.Time `json:"expiresNotIn,omitempty"`
	ExpiresGt     *time.Time   `json:"expiresGT,omitempty"`
	ExpiresGte    *time.Time   `json:"expiresGTE,omitempty"`
	ExpiresLt     *time.Time   `json:"expiresLT,omitempty"`
	ExpiresLte    *time.Time   `json:"expiresLTE,omitempty"`
	ExpiresIsNil  *bool        `json:"expiresIsNil,omitempty"`
	ExpiresNotNil *bool        `json:"expiresNotNil,omitempty"`
	// recipient field predicates
	Recipient             *string  `json:"recipient,omitempty"`
	RecipientNeq          *string  `json:"recipientNEQ,omitempty"`
	RecipientIn           []string `json:"recipientIn,omitempty"`
	RecipientNotIn        []string `json:"recipientNotIn,omitempty"`
	RecipientGt           *string  `json:"recipientGT,omitempty"`
	RecipientGte          *string  `json:"recipientGTE,omitempty"`
	RecipientLt           *string  `json:"recipientLT,omitempty"`
	RecipientLte          *string  `json:"recipientLTE,omitempty"`
	RecipientContains     *string  `json:"recipientContains,omitempty"`
	RecipientHasPrefix    *string  `json:"recipientHasPrefix,omitempty"`
	RecipientHasSuffix    *string  `json:"recipientHasSuffix,omitempty"`
	RecipientEqualFold    *string  `json:"recipientEqualFold,omitempty"`
	RecipientContainsFold *string  `json:"recipientContainsFold,omitempty"`
	// status field predicates
	Status      *enums.InviteStatus  `json:"status,omitempty"`
	StatusNeq   *enums.InviteStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.InviteStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.InviteStatus `json:"statusNotIn,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// send_attempts field predicates
	SendAttempts      *int64  `json:"sendAttempts,omitempty"`
	SendAttemptsNeq   *int64  `json:"sendAttemptsNEQ,omitempty"`
	SendAttemptsIn    []int64 `json:"sendAttemptsIn,omitempty"`
	SendAttemptsNotIn []int64 `json:"sendAttemptsNotIn,omitempty"`
	SendAttemptsGt    *int64  `json:"sendAttemptsGT,omitempty"`
	SendAttemptsGte   *int64  `json:"sendAttemptsGTE,omitempty"`
	SendAttemptsLt    *int64  `json:"sendAttemptsLT,omitempty"`
	SendAttemptsLte   *int64  `json:"sendAttemptsLTE,omitempty"`
	// requestor_id field predicates
	RequestorID             *string  `json:"requestorID,omitempty"`
	RequestorIDNeq          *string  `json:"requestorIDNEQ,omitempty"`
	RequestorIDIn           []string `json:"requestorIDIn,omitempty"`
	RequestorIDNotIn        []string `json:"requestorIDNotIn,omitempty"`
	RequestorIDGt           *string  `json:"requestorIDGT,omitempty"`
	RequestorIDGte          *string  `json:"requestorIDGTE,omitempty"`
	RequestorIDLt           *string  `json:"requestorIDLT,omitempty"`
	RequestorIDLte          *string  `json:"requestorIDLTE,omitempty"`
	RequestorIDContains     *string  `json:"requestorIDContains,omitempty"`
	RequestorIDHasPrefix    *string  `json:"requestorIDHasPrefix,omitempty"`
	RequestorIDHasSuffix    *string  `json:"requestorIDHasSuffix,omitempty"`
	RequestorIDIsNil        *bool    `json:"requestorIDIsNil,omitempty"`
	RequestorIDNotNil       *bool    `json:"requestorIDNotNil,omitempty"`
	RequestorIDEqualFold    *string  `json:"requestorIDEqualFold,omitempty"`
	RequestorIDContainsFold *string  `json:"requestorIDContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Mutation struct {
}

type Note struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the text of the note
	Text   string        `json:"text"`
	Owner  *Organization `json:"owner,omitempty"`
	Entity *Entity       `json:"entity,omitempty"`
}

func (Note) IsNode() {}

// A connection to a list of items.
type NoteConnection struct {
	// A list of edges.
	Edges []*NoteEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type NoteEdge struct {
	// The item at the end of the edge.
	Node *Note `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type NoteHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the text of the note
	Text string `json:"text"`
}

func (NoteHistory) IsNode() {}

// A connection to a list of items.
type NoteHistoryConnection struct {
	// A list of edges.
	Edges []*NoteHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type NoteHistoryEdge struct {
	// The item at the end of the edge.
	Node *NoteHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// NoteHistoryWhereInput is used for filtering NoteHistory objects.
// Input was generated by ent.
type NoteHistoryWhereInput struct {
	Not *NoteHistoryWhereInput   `json:"not,omitempty"`
	And []*NoteHistoryWhereInput `json:"and,omitempty"`
	Or  []*NoteHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// text field predicates
	Text             *string  `json:"text,omitempty"`
	TextNeq          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGt           *string  `json:"textGT,omitempty"`
	TextGte          *string  `json:"textGTE,omitempty"`
	TextLt           *string  `json:"textLT,omitempty"`
	TextLte          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`
}

// NoteWhereInput is used for filtering Note objects.
// Input was generated by ent.
type NoteWhereInput struct {
	Not *NoteWhereInput   `json:"not,omitempty"`
	And []*NoteWhereInput `json:"and,omitempty"`
	Or  []*NoteWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// text field predicates
	Text             *string  `json:"text,omitempty"`
	TextNeq          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGt           *string  `json:"textGT,omitempty"`
	TextGte          *string  `json:"textGTE,omitempty"`
	TextLt           *string  `json:"textLT,omitempty"`
	TextLte          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// entity edge predicates
	HasEntity     *bool               `json:"hasEntity,omitempty"`
	HasEntityWith []*EntityWhereInput `json:"hasEntityWith,omitempty"`
}

type OauthProvider struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the oauth provider's name
	Name string `json:"name"`
	// the client id for the oauth provider
	ClientID string `json:"clientID"`
	// the client secret
	ClientSecret string `json:"clientSecret"`
	// the redirect url
	RedirectURL string `json:"redirectURL"`
	// the scopes
	Scopes string `json:"scopes"`
	// the auth url of the provider
	AuthURL string `json:"authURL"`
	// the token url of the provider
	TokenURL string `json:"tokenURL"`
	// the auth style, 0: auto detect 1: third party log in 2: log in with username and password
	AuthStyle string `json:"authStyle"`
	// the URL to request user information by token
	InfoURL string        `json:"infoURL"`
	Owner   *Organization `json:"owner,omitempty"`
}

func (OauthProvider) IsNode() {}

// Return response for createBulkOauthProvider mutation
type OauthProviderBulkCreatePayload struct {
	// Created oauthProviders
	OauthProviders []*OauthProvider `json:"oauthProviders,omitempty"`
}

// A connection to a list of items.
type OauthProviderConnection struct {
	// A list of edges.
	Edges []*OauthProviderEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOauthProvider mutation
type OauthProviderCreatePayload struct {
	// Created oauthProvider
	OauthProvider *OauthProvider `json:"oauthProvider"`
}

// Return response for deleteOauthProvider mutation
type OauthProviderDeletePayload struct {
	// Deleted oauthProvider ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OauthProviderEdge struct {
	// The item at the end of the edge.
	Node *OauthProvider `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OauthProviderHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the oauth provider's name
	Name string `json:"name"`
	// the client id for the oauth provider
	ClientID string `json:"clientID"`
	// the client secret
	ClientSecret string `json:"clientSecret"`
	// the redirect url
	RedirectURL string `json:"redirectURL"`
	// the scopes
	Scopes string `json:"scopes"`
	// the auth url of the provider
	AuthURL string `json:"authURL"`
	// the token url of the provider
	TokenURL string `json:"tokenURL"`
	// the auth style, 0: auto detect 1: third party log in 2: log in with username and password
	AuthStyle string `json:"authStyle"`
	// the URL to request user information by token
	InfoURL string `json:"infoURL"`
}

func (OauthProviderHistory) IsNode() {}

// A connection to a list of items.
type OauthProviderHistoryConnection struct {
	// A list of edges.
	Edges []*OauthProviderHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OauthProviderHistoryEdge struct {
	// The item at the end of the edge.
	Node *OauthProviderHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// OauthProviderHistoryWhereInput is used for filtering OauthProviderHistory objects.
// Input was generated by ent.
type OauthProviderHistoryWhereInput struct {
	Not *OauthProviderHistoryWhereInput   `json:"not,omitempty"`
	And []*OauthProviderHistoryWhereInput `json:"and,omitempty"`
	Or  []*OauthProviderHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// client_id field predicates
	ClientID             *string  `json:"clientID,omitempty"`
	ClientIDNeq          *string  `json:"clientIDNEQ,omitempty"`
	ClientIDIn           []string `json:"clientIDIn,omitempty"`
	ClientIDNotIn        []string `json:"clientIDNotIn,omitempty"`
	ClientIDGt           *string  `json:"clientIDGT,omitempty"`
	ClientIDGte          *string  `json:"clientIDGTE,omitempty"`
	ClientIDLt           *string  `json:"clientIDLT,omitempty"`
	ClientIDLte          *string  `json:"clientIDLTE,omitempty"`
	ClientIDContains     *string  `json:"clientIDContains,omitempty"`
	ClientIDHasPrefix    *string  `json:"clientIDHasPrefix,omitempty"`
	ClientIDHasSuffix    *string  `json:"clientIDHasSuffix,omitempty"`
	ClientIDEqualFold    *string  `json:"clientIDEqualFold,omitempty"`
	ClientIDContainsFold *string  `json:"clientIDContainsFold,omitempty"`
	// client_secret field predicates
	ClientSecret             *string  `json:"clientSecret,omitempty"`
	ClientSecretNeq          *string  `json:"clientSecretNEQ,omitempty"`
	ClientSecretIn           []string `json:"clientSecretIn,omitempty"`
	ClientSecretNotIn        []string `json:"clientSecretNotIn,omitempty"`
	ClientSecretGt           *string  `json:"clientSecretGT,omitempty"`
	ClientSecretGte          *string  `json:"clientSecretGTE,omitempty"`
	ClientSecretLt           *string  `json:"clientSecretLT,omitempty"`
	ClientSecretLte          *string  `json:"clientSecretLTE,omitempty"`
	ClientSecretContains     *string  `json:"clientSecretContains,omitempty"`
	ClientSecretHasPrefix    *string  `json:"clientSecretHasPrefix,omitempty"`
	ClientSecretHasSuffix    *string  `json:"clientSecretHasSuffix,omitempty"`
	ClientSecretEqualFold    *string  `json:"clientSecretEqualFold,omitempty"`
	ClientSecretContainsFold *string  `json:"clientSecretContainsFold,omitempty"`
	// redirect_url field predicates
	RedirectURL             *string  `json:"redirectURL,omitempty"`
	RedirectURLNeq          *string  `json:"redirectURLNEQ,omitempty"`
	RedirectURLIn           []string `json:"redirectURLIn,omitempty"`
	RedirectURLNotIn        []string `json:"redirectURLNotIn,omitempty"`
	RedirectURLGt           *string  `json:"redirectURLGT,omitempty"`
	RedirectURLGte          *string  `json:"redirectURLGTE,omitempty"`
	RedirectURLLt           *string  `json:"redirectURLLT,omitempty"`
	RedirectURLLte          *string  `json:"redirectURLLTE,omitempty"`
	RedirectURLContains     *string  `json:"redirectURLContains,omitempty"`
	RedirectURLHasPrefix    *string  `json:"redirectURLHasPrefix,omitempty"`
	RedirectURLHasSuffix    *string  `json:"redirectURLHasSuffix,omitempty"`
	RedirectURLEqualFold    *string  `json:"redirectURLEqualFold,omitempty"`
	RedirectURLContainsFold *string  `json:"redirectURLContainsFold,omitempty"`
	// scopes field predicates
	Scopes             *string  `json:"scopes,omitempty"`
	ScopesNeq          *string  `json:"scopesNEQ,omitempty"`
	ScopesIn           []string `json:"scopesIn,omitempty"`
	ScopesNotIn        []string `json:"scopesNotIn,omitempty"`
	ScopesGt           *string  `json:"scopesGT,omitempty"`
	ScopesGte          *string  `json:"scopesGTE,omitempty"`
	ScopesLt           *string  `json:"scopesLT,omitempty"`
	ScopesLte          *string  `json:"scopesLTE,omitempty"`
	ScopesContains     *string  `json:"scopesContains,omitempty"`
	ScopesHasPrefix    *string  `json:"scopesHasPrefix,omitempty"`
	ScopesHasSuffix    *string  `json:"scopesHasSuffix,omitempty"`
	ScopesEqualFold    *string  `json:"scopesEqualFold,omitempty"`
	ScopesContainsFold *string  `json:"scopesContainsFold,omitempty"`
	// auth_url field predicates
	AuthURL             *string  `json:"authURL,omitempty"`
	AuthURLNeq          *string  `json:"authURLNEQ,omitempty"`
	AuthURLIn           []string `json:"authURLIn,omitempty"`
	AuthURLNotIn        []string `json:"authURLNotIn,omitempty"`
	AuthURLGt           *string  `json:"authURLGT,omitempty"`
	AuthURLGte          *string  `json:"authURLGTE,omitempty"`
	AuthURLLt           *string  `json:"authURLLT,omitempty"`
	AuthURLLte          *string  `json:"authURLLTE,omitempty"`
	AuthURLContains     *string  `json:"authURLContains,omitempty"`
	AuthURLHasPrefix    *string  `json:"authURLHasPrefix,omitempty"`
	AuthURLHasSuffix    *string  `json:"authURLHasSuffix,omitempty"`
	AuthURLEqualFold    *string  `json:"authURLEqualFold,omitempty"`
	AuthURLContainsFold *string  `json:"authURLContainsFold,omitempty"`
	// token_url field predicates
	TokenURL             *string  `json:"tokenURL,omitempty"`
	TokenURLNeq          *string  `json:"tokenURLNEQ,omitempty"`
	TokenURLIn           []string `json:"tokenURLIn,omitempty"`
	TokenURLNotIn        []string `json:"tokenURLNotIn,omitempty"`
	TokenURLGt           *string  `json:"tokenURLGT,omitempty"`
	TokenURLGte          *string  `json:"tokenURLGTE,omitempty"`
	TokenURLLt           *string  `json:"tokenURLLT,omitempty"`
	TokenURLLte          *string  `json:"tokenURLLTE,omitempty"`
	TokenURLContains     *string  `json:"tokenURLContains,omitempty"`
	TokenURLHasPrefix    *string  `json:"tokenURLHasPrefix,omitempty"`
	TokenURLHasSuffix    *string  `json:"tokenURLHasSuffix,omitempty"`
	TokenURLEqualFold    *string  `json:"tokenURLEqualFold,omitempty"`
	TokenURLContainsFold *string  `json:"tokenURLContainsFold,omitempty"`
	// auth_style field predicates
	AuthStyle      *string  `json:"authStyle,omitempty"`
	AuthStyleNeq   *string  `json:"authStyleNEQ,omitempty"`
	AuthStyleIn    []string `json:"authStyleIn,omitempty"`
	AuthStyleNotIn []string `json:"authStyleNotIn,omitempty"`
	AuthStyleGt    *string  `json:"authStyleGT,omitempty"`
	AuthStyleGte   *string  `json:"authStyleGTE,omitempty"`
	AuthStyleLt    *string  `json:"authStyleLT,omitempty"`
	AuthStyleLte   *string  `json:"authStyleLTE,omitempty"`
	// info_url field predicates
	InfoURL             *string  `json:"infoURL,omitempty"`
	InfoURLNeq          *string  `json:"infoURLNEQ,omitempty"`
	InfoURLIn           []string `json:"infoURLIn,omitempty"`
	InfoURLNotIn        []string `json:"infoURLNotIn,omitempty"`
	InfoURLGt           *string  `json:"infoURLGT,omitempty"`
	InfoURLGte          *string  `json:"infoURLGTE,omitempty"`
	InfoURLLt           *string  `json:"infoURLLT,omitempty"`
	InfoURLLte          *string  `json:"infoURLLTE,omitempty"`
	InfoURLContains     *string  `json:"infoURLContains,omitempty"`
	InfoURLHasPrefix    *string  `json:"infoURLHasPrefix,omitempty"`
	InfoURLHasSuffix    *string  `json:"infoURLHasSuffix,omitempty"`
	InfoURLEqualFold    *string  `json:"infoURLEqualFold,omitempty"`
	InfoURLContainsFold *string  `json:"infoURLContainsFold,omitempty"`
}

// Return response for updateOauthProvider mutation
type OauthProviderUpdatePayload struct {
	// Updated oauthProvider
	OauthProvider *OauthProvider `json:"oauthProvider"`
}

// OauthProviderWhereInput is used for filtering OauthProvider objects.
// Input was generated by ent.
type OauthProviderWhereInput struct {
	Not *OauthProviderWhereInput   `json:"not,omitempty"`
	And []*OauthProviderWhereInput `json:"and,omitempty"`
	Or  []*OauthProviderWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// client_id field predicates
	ClientID             *string  `json:"clientID,omitempty"`
	ClientIDNeq          *string  `json:"clientIDNEQ,omitempty"`
	ClientIDIn           []string `json:"clientIDIn,omitempty"`
	ClientIDNotIn        []string `json:"clientIDNotIn,omitempty"`
	ClientIDGt           *string  `json:"clientIDGT,omitempty"`
	ClientIDGte          *string  `json:"clientIDGTE,omitempty"`
	ClientIDLt           *string  `json:"clientIDLT,omitempty"`
	ClientIDLte          *string  `json:"clientIDLTE,omitempty"`
	ClientIDContains     *string  `json:"clientIDContains,omitempty"`
	ClientIDHasPrefix    *string  `json:"clientIDHasPrefix,omitempty"`
	ClientIDHasSuffix    *string  `json:"clientIDHasSuffix,omitempty"`
	ClientIDEqualFold    *string  `json:"clientIDEqualFold,omitempty"`
	ClientIDContainsFold *string  `json:"clientIDContainsFold,omitempty"`
	// client_secret field predicates
	ClientSecret             *string  `json:"clientSecret,omitempty"`
	ClientSecretNeq          *string  `json:"clientSecretNEQ,omitempty"`
	ClientSecretIn           []string `json:"clientSecretIn,omitempty"`
	ClientSecretNotIn        []string `json:"clientSecretNotIn,omitempty"`
	ClientSecretGt           *string  `json:"clientSecretGT,omitempty"`
	ClientSecretGte          *string  `json:"clientSecretGTE,omitempty"`
	ClientSecretLt           *string  `json:"clientSecretLT,omitempty"`
	ClientSecretLte          *string  `json:"clientSecretLTE,omitempty"`
	ClientSecretContains     *string  `json:"clientSecretContains,omitempty"`
	ClientSecretHasPrefix    *string  `json:"clientSecretHasPrefix,omitempty"`
	ClientSecretHasSuffix    *string  `json:"clientSecretHasSuffix,omitempty"`
	ClientSecretEqualFold    *string  `json:"clientSecretEqualFold,omitempty"`
	ClientSecretContainsFold *string  `json:"clientSecretContainsFold,omitempty"`
	// redirect_url field predicates
	RedirectURL             *string  `json:"redirectURL,omitempty"`
	RedirectURLNeq          *string  `json:"redirectURLNEQ,omitempty"`
	RedirectURLIn           []string `json:"redirectURLIn,omitempty"`
	RedirectURLNotIn        []string `json:"redirectURLNotIn,omitempty"`
	RedirectURLGt           *string  `json:"redirectURLGT,omitempty"`
	RedirectURLGte          *string  `json:"redirectURLGTE,omitempty"`
	RedirectURLLt           *string  `json:"redirectURLLT,omitempty"`
	RedirectURLLte          *string  `json:"redirectURLLTE,omitempty"`
	RedirectURLContains     *string  `json:"redirectURLContains,omitempty"`
	RedirectURLHasPrefix    *string  `json:"redirectURLHasPrefix,omitempty"`
	RedirectURLHasSuffix    *string  `json:"redirectURLHasSuffix,omitempty"`
	RedirectURLEqualFold    *string  `json:"redirectURLEqualFold,omitempty"`
	RedirectURLContainsFold *string  `json:"redirectURLContainsFold,omitempty"`
	// scopes field predicates
	Scopes             *string  `json:"scopes,omitempty"`
	ScopesNeq          *string  `json:"scopesNEQ,omitempty"`
	ScopesIn           []string `json:"scopesIn,omitempty"`
	ScopesNotIn        []string `json:"scopesNotIn,omitempty"`
	ScopesGt           *string  `json:"scopesGT,omitempty"`
	ScopesGte          *string  `json:"scopesGTE,omitempty"`
	ScopesLt           *string  `json:"scopesLT,omitempty"`
	ScopesLte          *string  `json:"scopesLTE,omitempty"`
	ScopesContains     *string  `json:"scopesContains,omitempty"`
	ScopesHasPrefix    *string  `json:"scopesHasPrefix,omitempty"`
	ScopesHasSuffix    *string  `json:"scopesHasSuffix,omitempty"`
	ScopesEqualFold    *string  `json:"scopesEqualFold,omitempty"`
	ScopesContainsFold *string  `json:"scopesContainsFold,omitempty"`
	// auth_url field predicates
	AuthURL             *string  `json:"authURL,omitempty"`
	AuthURLNeq          *string  `json:"authURLNEQ,omitempty"`
	AuthURLIn           []string `json:"authURLIn,omitempty"`
	AuthURLNotIn        []string `json:"authURLNotIn,omitempty"`
	AuthURLGt           *string  `json:"authURLGT,omitempty"`
	AuthURLGte          *string  `json:"authURLGTE,omitempty"`
	AuthURLLt           *string  `json:"authURLLT,omitempty"`
	AuthURLLte          *string  `json:"authURLLTE,omitempty"`
	AuthURLContains     *string  `json:"authURLContains,omitempty"`
	AuthURLHasPrefix    *string  `json:"authURLHasPrefix,omitempty"`
	AuthURLHasSuffix    *string  `json:"authURLHasSuffix,omitempty"`
	AuthURLEqualFold    *string  `json:"authURLEqualFold,omitempty"`
	AuthURLContainsFold *string  `json:"authURLContainsFold,omitempty"`
	// token_url field predicates
	TokenURL             *string  `json:"tokenURL,omitempty"`
	TokenURLNeq          *string  `json:"tokenURLNEQ,omitempty"`
	TokenURLIn           []string `json:"tokenURLIn,omitempty"`
	TokenURLNotIn        []string `json:"tokenURLNotIn,omitempty"`
	TokenURLGt           *string  `json:"tokenURLGT,omitempty"`
	TokenURLGte          *string  `json:"tokenURLGTE,omitempty"`
	TokenURLLt           *string  `json:"tokenURLLT,omitempty"`
	TokenURLLte          *string  `json:"tokenURLLTE,omitempty"`
	TokenURLContains     *string  `json:"tokenURLContains,omitempty"`
	TokenURLHasPrefix    *string  `json:"tokenURLHasPrefix,omitempty"`
	TokenURLHasSuffix    *string  `json:"tokenURLHasSuffix,omitempty"`
	TokenURLEqualFold    *string  `json:"tokenURLEqualFold,omitempty"`
	TokenURLContainsFold *string  `json:"tokenURLContainsFold,omitempty"`
	// auth_style field predicates
	AuthStyle      *string  `json:"authStyle,omitempty"`
	AuthStyleNeq   *string  `json:"authStyleNEQ,omitempty"`
	AuthStyleIn    []string `json:"authStyleIn,omitempty"`
	AuthStyleNotIn []string `json:"authStyleNotIn,omitempty"`
	AuthStyleGt    *string  `json:"authStyleGT,omitempty"`
	AuthStyleGte   *string  `json:"authStyleGTE,omitempty"`
	AuthStyleLt    *string  `json:"authStyleLT,omitempty"`
	AuthStyleLte   *string  `json:"authStyleLTE,omitempty"`
	// info_url field predicates
	InfoURL             *string  `json:"infoURL,omitempty"`
	InfoURLNeq          *string  `json:"infoURLNEQ,omitempty"`
	InfoURLIn           []string `json:"infoURLIn,omitempty"`
	InfoURLNotIn        []string `json:"infoURLNotIn,omitempty"`
	InfoURLGt           *string  `json:"infoURLGT,omitempty"`
	InfoURLGte          *string  `json:"infoURLGTE,omitempty"`
	InfoURLLt           *string  `json:"infoURLLT,omitempty"`
	InfoURLLte          *string  `json:"infoURLLTE,omitempty"`
	InfoURLContains     *string  `json:"infoURLContains,omitempty"`
	InfoURLHasPrefix    *string  `json:"infoURLHasPrefix,omitempty"`
	InfoURLHasSuffix    *string  `json:"infoURLHasSuffix,omitempty"`
	InfoURLEqualFold    *string  `json:"infoURLEqualFold,omitempty"`
	InfoURLContainsFold *string  `json:"infoURLContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
}

type OhAuthTooToken struct {
	ID string `json:"id"`
	// tags associated with the object
	Tags                    []string       `json:"tags,omitempty"`
	ClientID                string         `json:"clientID"`
	Scopes                  []string       `json:"scopes,omitempty"`
	Nonce                   string         `json:"nonce"`
	ClaimsUserID            string         `json:"claimsUserID"`
	ClaimsUsername          string         `json:"claimsUsername"`
	ClaimsEmail             string         `json:"claimsEmail"`
	ClaimsEmailVerified     bool           `json:"claimsEmailVerified"`
	ClaimsGroups            []string       `json:"claimsGroups,omitempty"`
	ClaimsPreferredUsername string         `json:"claimsPreferredUsername"`
	ConnectorID             string         `json:"connectorID"`
	ConnectorData           []string       `json:"connectorData,omitempty"`
	LastUsed                time.Time      `json:"lastUsed"`
	Integration             []*Integration `json:"integration,omitempty"`
	Events                  []*Event       `json:"events,omitempty"`
}

func (OhAuthTooToken) IsNode() {}

// Return response for createBulkOhAuthTooToken mutation
type OhAuthTooTokenBulkCreatePayload struct {
	// Created ohAuthTooTokens
	OhAuthTooTokens []*OhAuthTooToken `json:"ohAuthTooTokens,omitempty"`
}

// A connection to a list of items.
type OhAuthTooTokenConnection struct {
	// A list of edges.
	Edges []*OhAuthTooTokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOhAuthTooToken mutation
type OhAuthTooTokenCreatePayload struct {
	// Created ohAuthTooToken
	OhAuthTooToken *OhAuthTooToken `json:"ohAuthTooToken"`
}

// Return response for deleteOhAuthTooToken mutation
type OhAuthTooTokenDeletePayload struct {
	// Deleted ohAuthTooToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OhAuthTooTokenEdge struct {
	// The item at the end of the edge.
	Node *OhAuthTooToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateOhAuthTooToken mutation
type OhAuthTooTokenUpdatePayload struct {
	// Updated ohAuthTooToken
	OhAuthTooToken *OhAuthTooToken `json:"ohAuthTooToken"`
}

// OhAuthTooTokenWhereInput is used for filtering OhAuthTooToken objects.
// Input was generated by ent.
type OhAuthTooTokenWhereInput struct {
	Not *OhAuthTooTokenWhereInput   `json:"not,omitempty"`
	And []*OhAuthTooTokenWhereInput `json:"and,omitempty"`
	Or  []*OhAuthTooTokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// client_id field predicates
	ClientID             *string  `json:"clientID,omitempty"`
	ClientIDNeq          *string  `json:"clientIDNEQ,omitempty"`
	ClientIDIn           []string `json:"clientIDIn,omitempty"`
	ClientIDNotIn        []string `json:"clientIDNotIn,omitempty"`
	ClientIDGt           *string  `json:"clientIDGT,omitempty"`
	ClientIDGte          *string  `json:"clientIDGTE,omitempty"`
	ClientIDLt           *string  `json:"clientIDLT,omitempty"`
	ClientIDLte          *string  `json:"clientIDLTE,omitempty"`
	ClientIDContains     *string  `json:"clientIDContains,omitempty"`
	ClientIDHasPrefix    *string  `json:"clientIDHasPrefix,omitempty"`
	ClientIDHasSuffix    *string  `json:"clientIDHasSuffix,omitempty"`
	ClientIDEqualFold    *string  `json:"clientIDEqualFold,omitempty"`
	ClientIDContainsFold *string  `json:"clientIDContainsFold,omitempty"`
	// nonce field predicates
	Nonce             *string  `json:"nonce,omitempty"`
	NonceNeq          *string  `json:"nonceNEQ,omitempty"`
	NonceIn           []string `json:"nonceIn,omitempty"`
	NonceNotIn        []string `json:"nonceNotIn,omitempty"`
	NonceGt           *string  `json:"nonceGT,omitempty"`
	NonceGte          *string  `json:"nonceGTE,omitempty"`
	NonceLt           *string  `json:"nonceLT,omitempty"`
	NonceLte          *string  `json:"nonceLTE,omitempty"`
	NonceContains     *string  `json:"nonceContains,omitempty"`
	NonceHasPrefix    *string  `json:"nonceHasPrefix,omitempty"`
	NonceHasSuffix    *string  `json:"nonceHasSuffix,omitempty"`
	NonceEqualFold    *string  `json:"nonceEqualFold,omitempty"`
	NonceContainsFold *string  `json:"nonceContainsFold,omitempty"`
	// claims_user_id field predicates
	ClaimsUserID             *string  `json:"claimsUserID,omitempty"`
	ClaimsUserIDNeq          *string  `json:"claimsUserIDNEQ,omitempty"`
	ClaimsUserIDIn           []string `json:"claimsUserIDIn,omitempty"`
	ClaimsUserIDNotIn        []string `json:"claimsUserIDNotIn,omitempty"`
	ClaimsUserIDGt           *string  `json:"claimsUserIDGT,omitempty"`
	ClaimsUserIDGte          *string  `json:"claimsUserIDGTE,omitempty"`
	ClaimsUserIDLt           *string  `json:"claimsUserIDLT,omitempty"`
	ClaimsUserIDLte          *string  `json:"claimsUserIDLTE,omitempty"`
	ClaimsUserIDContains     *string  `json:"claimsUserIDContains,omitempty"`
	ClaimsUserIDHasPrefix    *string  `json:"claimsUserIDHasPrefix,omitempty"`
	ClaimsUserIDHasSuffix    *string  `json:"claimsUserIDHasSuffix,omitempty"`
	ClaimsUserIDEqualFold    *string  `json:"claimsUserIDEqualFold,omitempty"`
	ClaimsUserIDContainsFold *string  `json:"claimsUserIDContainsFold,omitempty"`
	// claims_username field predicates
	ClaimsUsername             *string  `json:"claimsUsername,omitempty"`
	ClaimsUsernameNeq          *string  `json:"claimsUsernameNEQ,omitempty"`
	ClaimsUsernameIn           []string `json:"claimsUsernameIn,omitempty"`
	ClaimsUsernameNotIn        []string `json:"claimsUsernameNotIn,omitempty"`
	ClaimsUsernameGt           *string  `json:"claimsUsernameGT,omitempty"`
	ClaimsUsernameGte          *string  `json:"claimsUsernameGTE,omitempty"`
	ClaimsUsernameLt           *string  `json:"claimsUsernameLT,omitempty"`
	ClaimsUsernameLte          *string  `json:"claimsUsernameLTE,omitempty"`
	ClaimsUsernameContains     *string  `json:"claimsUsernameContains,omitempty"`
	ClaimsUsernameHasPrefix    *string  `json:"claimsUsernameHasPrefix,omitempty"`
	ClaimsUsernameHasSuffix    *string  `json:"claimsUsernameHasSuffix,omitempty"`
	ClaimsUsernameEqualFold    *string  `json:"claimsUsernameEqualFold,omitempty"`
	ClaimsUsernameContainsFold *string  `json:"claimsUsernameContainsFold,omitempty"`
	// claims_email field predicates
	ClaimsEmail             *string  `json:"claimsEmail,omitempty"`
	ClaimsEmailNeq          *string  `json:"claimsEmailNEQ,omitempty"`
	ClaimsEmailIn           []string `json:"claimsEmailIn,omitempty"`
	ClaimsEmailNotIn        []string `json:"claimsEmailNotIn,omitempty"`
	ClaimsEmailGt           *string  `json:"claimsEmailGT,omitempty"`
	ClaimsEmailGte          *string  `json:"claimsEmailGTE,omitempty"`
	ClaimsEmailLt           *string  `json:"claimsEmailLT,omitempty"`
	ClaimsEmailLte          *string  `json:"claimsEmailLTE,omitempty"`
	ClaimsEmailContains     *string  `json:"claimsEmailContains,omitempty"`
	ClaimsEmailHasPrefix    *string  `json:"claimsEmailHasPrefix,omitempty"`
	ClaimsEmailHasSuffix    *string  `json:"claimsEmailHasSuffix,omitempty"`
	ClaimsEmailEqualFold    *string  `json:"claimsEmailEqualFold,omitempty"`
	ClaimsEmailContainsFold *string  `json:"claimsEmailContainsFold,omitempty"`
	// claims_email_verified field predicates
	ClaimsEmailVerified    *bool `json:"claimsEmailVerified,omitempty"`
	ClaimsEmailVerifiedNeq *bool `json:"claimsEmailVerifiedNEQ,omitempty"`
	// claims_preferred_username field predicates
	ClaimsPreferredUsername             *string  `json:"claimsPreferredUsername,omitempty"`
	ClaimsPreferredUsernameNeq          *string  `json:"claimsPreferredUsernameNEQ,omitempty"`
	ClaimsPreferredUsernameIn           []string `json:"claimsPreferredUsernameIn,omitempty"`
	ClaimsPreferredUsernameNotIn        []string `json:"claimsPreferredUsernameNotIn,omitempty"`
	ClaimsPreferredUsernameGt           *string  `json:"claimsPreferredUsernameGT,omitempty"`
	ClaimsPreferredUsernameGte          *string  `json:"claimsPreferredUsernameGTE,omitempty"`
	ClaimsPreferredUsernameLt           *string  `json:"claimsPreferredUsernameLT,omitempty"`
	ClaimsPreferredUsernameLte          *string  `json:"claimsPreferredUsernameLTE,omitempty"`
	ClaimsPreferredUsernameContains     *string  `json:"claimsPreferredUsernameContains,omitempty"`
	ClaimsPreferredUsernameHasPrefix    *string  `json:"claimsPreferredUsernameHasPrefix,omitempty"`
	ClaimsPreferredUsernameHasSuffix    *string  `json:"claimsPreferredUsernameHasSuffix,omitempty"`
	ClaimsPreferredUsernameEqualFold    *string  `json:"claimsPreferredUsernameEqualFold,omitempty"`
	ClaimsPreferredUsernameContainsFold *string  `json:"claimsPreferredUsernameContainsFold,omitempty"`
	// connector_id field predicates
	ConnectorID             *string  `json:"connectorID,omitempty"`
	ConnectorIDNeq          *string  `json:"connectorIDNEQ,omitempty"`
	ConnectorIDIn           []string `json:"connectorIDIn,omitempty"`
	ConnectorIDNotIn        []string `json:"connectorIDNotIn,omitempty"`
	ConnectorIDGt           *string  `json:"connectorIDGT,omitempty"`
	ConnectorIDGte          *string  `json:"connectorIDGTE,omitempty"`
	ConnectorIDLt           *string  `json:"connectorIDLT,omitempty"`
	ConnectorIDLte          *string  `json:"connectorIDLTE,omitempty"`
	ConnectorIDContains     *string  `json:"connectorIDContains,omitempty"`
	ConnectorIDHasPrefix    *string  `json:"connectorIDHasPrefix,omitempty"`
	ConnectorIDHasSuffix    *string  `json:"connectorIDHasSuffix,omitempty"`
	ConnectorIDEqualFold    *string  `json:"connectorIDEqualFold,omitempty"`
	ConnectorIDContainsFold *string  `json:"connectorIDContainsFold,omitempty"`
	// last_used field predicates
	LastUsed      *time.Time   `json:"lastUsed,omitempty"`
	LastUsedNeq   *time.Time   `json:"lastUsedNEQ,omitempty"`
	LastUsedIn    []*time.Time `json:"lastUsedIn,omitempty"`
	LastUsedNotIn []*time.Time `json:"lastUsedNotIn,omitempty"`
	LastUsedGt    *time.Time   `json:"lastUsedGT,omitempty"`
	LastUsedGte   *time.Time   `json:"lastUsedGTE,omitempty"`
	LastUsedLt    *time.Time   `json:"lastUsedLT,omitempty"`
	LastUsedLte   *time.Time   `json:"lastUsedLTE,omitempty"`
	// integration edge predicates
	HasIntegration     *bool                    `json:"hasIntegration,omitempty"`
	HasIntegrationWith []*IntegrationWhereInput `json:"hasIntegrationWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type OrgMembership struct {
	ID             string        `json:"id"`
	CreatedAt      *time.Time    `json:"createdAt,omitempty"`
	UpdatedAt      *time.Time    `json:"updatedAt,omitempty"`
	CreatedBy      *string       `json:"createdBy,omitempty"`
	UpdatedBy      *string       `json:"updatedBy,omitempty"`
	DeletedAt      *time.Time    `json:"deletedAt,omitempty"`
	DeletedBy      *string       `json:"deletedBy,omitempty"`
	Role           enums.Role    `json:"role"`
	OrganizationID string        `json:"organizationID"`
	UserID         string        `json:"userID"`
	Organization   *Organization `json:"organization"`
	User           *User         `json:"user"`
	Events         []*Event      `json:"events,omitempty"`
}

func (OrgMembership) IsNode() {}

// Return response for createBulkOrgMembership mutation
type OrgMembershipBulkCreatePayload struct {
	// Created orgMemberships
	OrgMemberships []*OrgMembership `json:"orgMemberships,omitempty"`
}

// A connection to a list of items.
type OrgMembershipConnection struct {
	// A list of edges.
	Edges []*OrgMembershipEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrgMembership mutation
type OrgMembershipCreatePayload struct {
	// Created orgMembership
	OrgMembership *OrgMembership `json:"orgMembership"`
}

// Return response for deleteOrgMembership mutation
type OrgMembershipDeletePayload struct {
	// Deleted orgMembership ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrgMembershipEdge struct {
	// The item at the end of the edge.
	Node *OrgMembership `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrgMembershipHistory struct {
	ID             string         `json:"id"`
	HistoryTime    time.Time      `json:"historyTime"`
	Ref            *string        `json:"ref,omitempty"`
	Operation      history.OpType `json:"operation"`
	CreatedAt      *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt      *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy      *string        `json:"createdBy,omitempty"`
	UpdatedBy      *string        `json:"updatedBy,omitempty"`
	DeletedAt      *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy      *string        `json:"deletedBy,omitempty"`
	Role           enums.Role     `json:"role"`
	OrganizationID string         `json:"organizationID"`
	UserID         string         `json:"userID"`
}

func (OrgMembershipHistory) IsNode() {}

// A connection to a list of items.
type OrgMembershipHistoryConnection struct {
	// A list of edges.
	Edges []*OrgMembershipHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrgMembershipHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrgMembershipHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// OrgMembershipHistoryWhereInput is used for filtering OrgMembershipHistory objects.
// Input was generated by ent.
type OrgMembershipHistoryWhereInput struct {
	Not *OrgMembershipHistoryWhereInput   `json:"not,omitempty"`
	And []*OrgMembershipHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrgMembershipHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role      *enums.Role  `json:"role,omitempty"`
	RoleNeq   *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn []enums.Role `json:"roleNotIn,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIDNeq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIDGt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIDGte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIDLt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIDLte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIDNeq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGt           *string  `json:"userIDGT,omitempty"`
	UserIDGte          *string  `json:"userIDGTE,omitempty"`
	UserIDLt           *string  `json:"userIDLT,omitempty"`
	UserIDLte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
}

// Return response for updateOrgMembership mutation
type OrgMembershipUpdatePayload struct {
	// Updated orgMembership
	OrgMembership *OrgMembership `json:"orgMembership"`
}

// OrgMembershipWhereInput is used for filtering OrgMembership objects.
// Input was generated by ent.
type OrgMembershipWhereInput struct {
	Not *OrgMembershipWhereInput   `json:"not,omitempty"`
	And []*OrgMembershipWhereInput `json:"and,omitempty"`
	Or  []*OrgMembershipWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// role field predicates
	Role           *enums.Role  `json:"role,omitempty"`
	RoleNeq        *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn         []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn      []enums.Role `json:"roleNotIn,omitempty"`
	OrganizationID *string      `json:"organizationID,omitempty"`
	UserID         *string      `json:"userID,omitempty"`
}

type Organization struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the name of the organization
	Name string `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// An optional description of the organization
	Description *string `json:"description,omitempty"`
	// orgs directly associated with a user
	PersonalOrg *bool `json:"personalOrg,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// Whether the organization has a dedicated database
	DedicatedDb             bool                      `json:"dedicatedDb"`
	Parent                  *Organization             `json:"parent,omitempty"`
	Children                *OrganizationConnection   `json:"children"`
	Groups                  []*Group                  `json:"groups,omitempty"`
	Templates               []*Template               `json:"templates,omitempty"`
	Integrations            []*Integration            `json:"integrations,omitempty"`
	Setting                 *OrganizationSetting      `json:"setting,omitempty"`
	Documentdata            []*DocumentData           `json:"documentdata,omitempty"`
	Entitlements            []*Entitlement            `json:"entitlements,omitempty"`
	OrganizationEntitlement []*Entitlement            `json:"organizationEntitlement,omitempty"`
	PersonalAccessTokens    []*PersonalAccessToken    `json:"personalAccessTokens,omitempty"`
	APITokens               []*APIToken               `json:"apiTokens,omitempty"`
	Oauthprovider           []*OauthProvider          `json:"oauthprovider,omitempty"`
	Users                   []*User                   `json:"users,omitempty"`
	Invites                 []*Invite                 `json:"invites,omitempty"`
	Subscribers             []*Subscriber             `json:"subscribers,omitempty"`
	Webhooks                []*Webhook                `json:"webhooks,omitempty"`
	Events                  []*Event                  `json:"events,omitempty"`
	Secrets                 []*Hush                   `json:"secrets,omitempty"`
	Features                []*Feature                `json:"features,omitempty"`
	Files                   []*File                   `json:"files,omitempty"`
	Entitlementplans        []*EntitlementPlan        `json:"entitlementplans,omitempty"`
	Entitlementplanfeatures []*EntitlementPlanFeature `json:"entitlementplanfeatures,omitempty"`
	Entities                []*Entity                 `json:"entities,omitempty"`
	Entitytypes             []*EntityType             `json:"entitytypes,omitempty"`
	Contacts                []*Contact                `json:"contacts,omitempty"`
	Notes                   []*Note                   `json:"notes,omitempty"`
	Members                 []*OrgMembership          `json:"members,omitempty"`
}

func (Organization) IsNode() {}

// Return response for createBulkOrganization mutation
type OrganizationBulkCreatePayload struct {
	// Created organizations
	Organizations []*Organization `json:"organizations,omitempty"`
}

// A connection to a list of items.
type OrganizationConnection struct {
	// A list of edges.
	Edges []*OrganizationEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrganization mutation
type OrganizationCreatePayload struct {
	// Created organization
	Organization *Organization `json:"organization"`
}

// Return response for deleteOrganization mutation
type OrganizationDeletePayload struct {
	// Deleted organization ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrganizationEdge struct {
	// The item at the end of the edge.
	Node *Organization `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrganizationHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// the name of the organization
	Name string `json:"name"`
	// The organization's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// An optional description of the organization
	Description *string `json:"description,omitempty"`
	// orgs directly associated with a user
	PersonalOrg *bool `json:"personalOrg,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// Whether the organization has a dedicated database
	DedicatedDb bool `json:"dedicatedDb"`
}

func (OrganizationHistory) IsNode() {}

// A connection to a list of items.
type OrganizationHistoryConnection struct {
	// A list of edges.
	Edges []*OrganizationHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrganizationHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrganizationHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for OrganizationHistory connections
type OrganizationHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order OrganizationHistories.
	Field OrganizationHistoryOrderField `json:"field"`
}

// OrganizationHistoryWhereInput is used for filtering OrganizationHistory objects.
// Input was generated by ent.
type OrganizationHistoryWhereInput struct {
	Not *OrganizationHistoryWhereInput   `json:"not,omitempty"`
	And []*OrganizationHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrganizationHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// parent_organization_id field predicates
	ParentOrganizationID             *string  `json:"parentOrganizationID,omitempty"`
	ParentOrganizationIDNeq          *string  `json:"parentOrganizationIDNEQ,omitempty"`
	ParentOrganizationIDIn           []string `json:"parentOrganizationIDIn,omitempty"`
	ParentOrganizationIDNotIn        []string `json:"parentOrganizationIDNotIn,omitempty"`
	ParentOrganizationIDGt           *string  `json:"parentOrganizationIDGT,omitempty"`
	ParentOrganizationIDGte          *string  `json:"parentOrganizationIDGTE,omitempty"`
	ParentOrganizationIDLt           *string  `json:"parentOrganizationIDLT,omitempty"`
	ParentOrganizationIDLte          *string  `json:"parentOrganizationIDLTE,omitempty"`
	ParentOrganizationIDContains     *string  `json:"parentOrganizationIDContains,omitempty"`
	ParentOrganizationIDHasPrefix    *string  `json:"parentOrganizationIDHasPrefix,omitempty"`
	ParentOrganizationIDHasSuffix    *string  `json:"parentOrganizationIDHasSuffix,omitempty"`
	ParentOrganizationIDIsNil        *bool    `json:"parentOrganizationIDIsNil,omitempty"`
	ParentOrganizationIDNotNil       *bool    `json:"parentOrganizationIDNotNil,omitempty"`
	ParentOrganizationIDEqualFold    *string  `json:"parentOrganizationIDEqualFold,omitempty"`
	ParentOrganizationIDContainsFold *string  `json:"parentOrganizationIDContainsFold,omitempty"`
	// personal_org field predicates
	PersonalOrg       *bool `json:"personalOrg,omitempty"`
	PersonalOrgNeq    *bool `json:"personalOrgNEQ,omitempty"`
	PersonalOrgIsNil  *bool `json:"personalOrgIsNil,omitempty"`
	PersonalOrgNotNil *bool `json:"personalOrgNotNil,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
}

// Ordering options for Organization connections
type OrganizationOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Organizations.
	Field OrganizationOrderField `json:"field"`
}

type OrganizationSearchResult struct {
	Organizations []*Organization `json:"organizations,omitempty"`
}

func (OrganizationSearchResult) IsSearchResult() {}

type OrganizationSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// domains associated with the organization
	Domains []string `json:"domains,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone *string `json:"billingPhone,omitempty"`
	// Address to send billing information to
	BillingAddress *string `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation *enums.Region `json:"geoLocation,omitempty"`
	// the ID of the organization the settings belong to
	OrganizationID *string       `json:"organizationID,omitempty"`
	Organization   *Organization `json:"organization,omitempty"`
}

func (OrganizationSetting) IsNode() {}

// Return response for createBulkOrganizationSetting mutation
type OrganizationSettingBulkCreatePayload struct {
	// Created organizationSettings
	OrganizationSettings []*OrganizationSetting `json:"organizationSettings,omitempty"`
}

// A connection to a list of items.
type OrganizationSettingConnection struct {
	// A list of edges.
	Edges []*OrganizationSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createOrganizationSetting mutation
type OrganizationSettingCreatePayload struct {
	// Created organizationSetting
	OrganizationSetting *OrganizationSetting `json:"organizationSetting"`
}

// Return response for deleteOrganizationSetting mutation
type OrganizationSettingDeletePayload struct {
	// Deleted organizationSetting ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type OrganizationSettingEdge struct {
	// The item at the end of the edge.
	Node *OrganizationSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type OrganizationSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// domains associated with the organization
	Domains []string `json:"domains,omitempty"`
	// Name of the person to contact for billing
	BillingContact *string `json:"billingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail *string `json:"billingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone *string `json:"billingPhone,omitempty"`
	// Address to send billing information to
	BillingAddress *string `json:"billingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier *string `json:"taxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation *enums.Region `json:"geoLocation,omitempty"`
	// the ID of the organization the settings belong to
	OrganizationID *string `json:"organizationID,omitempty"`
}

func (OrganizationSettingHistory) IsNode() {}

// A connection to a list of items.
type OrganizationSettingHistoryConnection struct {
	// A list of edges.
	Edges []*OrganizationSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type OrganizationSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *OrganizationSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// OrganizationSettingHistoryWhereInput is used for filtering OrganizationSettingHistory objects.
// Input was generated by ent.
type OrganizationSettingHistoryWhereInput struct {
	Not *OrganizationSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*OrganizationSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*OrganizationSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// billing_contact field predicates
	BillingContact             *string  `json:"billingContact,omitempty"`
	BillingContactNeq          *string  `json:"billingContactNEQ,omitempty"`
	BillingContactIn           []string `json:"billingContactIn,omitempty"`
	BillingContactNotIn        []string `json:"billingContactNotIn,omitempty"`
	BillingContactGt           *string  `json:"billingContactGT,omitempty"`
	BillingContactGte          *string  `json:"billingContactGTE,omitempty"`
	BillingContactLt           *string  `json:"billingContactLT,omitempty"`
	BillingContactLte          *string  `json:"billingContactLTE,omitempty"`
	BillingContactContains     *string  `json:"billingContactContains,omitempty"`
	BillingContactHasPrefix    *string  `json:"billingContactHasPrefix,omitempty"`
	BillingContactHasSuffix    *string  `json:"billingContactHasSuffix,omitempty"`
	BillingContactIsNil        *bool    `json:"billingContactIsNil,omitempty"`
	BillingContactNotNil       *bool    `json:"billingContactNotNil,omitempty"`
	BillingContactEqualFold    *string  `json:"billingContactEqualFold,omitempty"`
	BillingContactContainsFold *string  `json:"billingContactContainsFold,omitempty"`
	// billing_email field predicates
	BillingEmail             *string  `json:"billingEmail,omitempty"`
	BillingEmailNeq          *string  `json:"billingEmailNEQ,omitempty"`
	BillingEmailIn           []string `json:"billingEmailIn,omitempty"`
	BillingEmailNotIn        []string `json:"billingEmailNotIn,omitempty"`
	BillingEmailGt           *string  `json:"billingEmailGT,omitempty"`
	BillingEmailGte          *string  `json:"billingEmailGTE,omitempty"`
	BillingEmailLt           *string  `json:"billingEmailLT,omitempty"`
	BillingEmailLte          *string  `json:"billingEmailLTE,omitempty"`
	BillingEmailContains     *string  `json:"billingEmailContains,omitempty"`
	BillingEmailHasPrefix    *string  `json:"billingEmailHasPrefix,omitempty"`
	BillingEmailHasSuffix    *string  `json:"billingEmailHasSuffix,omitempty"`
	BillingEmailIsNil        *bool    `json:"billingEmailIsNil,omitempty"`
	BillingEmailNotNil       *bool    `json:"billingEmailNotNil,omitempty"`
	BillingEmailEqualFold    *string  `json:"billingEmailEqualFold,omitempty"`
	BillingEmailContainsFold *string  `json:"billingEmailContainsFold,omitempty"`
	// billing_phone field predicates
	BillingPhone             *string  `json:"billingPhone,omitempty"`
	BillingPhoneNeq          *string  `json:"billingPhoneNEQ,omitempty"`
	BillingPhoneIn           []string `json:"billingPhoneIn,omitempty"`
	BillingPhoneNotIn        []string `json:"billingPhoneNotIn,omitempty"`
	BillingPhoneGt           *string  `json:"billingPhoneGT,omitempty"`
	BillingPhoneGte          *string  `json:"billingPhoneGTE,omitempty"`
	BillingPhoneLt           *string  `json:"billingPhoneLT,omitempty"`
	BillingPhoneLte          *string  `json:"billingPhoneLTE,omitempty"`
	BillingPhoneContains     *string  `json:"billingPhoneContains,omitempty"`
	BillingPhoneHasPrefix    *string  `json:"billingPhoneHasPrefix,omitempty"`
	BillingPhoneHasSuffix    *string  `json:"billingPhoneHasSuffix,omitempty"`
	BillingPhoneIsNil        *bool    `json:"billingPhoneIsNil,omitempty"`
	BillingPhoneNotNil       *bool    `json:"billingPhoneNotNil,omitempty"`
	BillingPhoneEqualFold    *string  `json:"billingPhoneEqualFold,omitempty"`
	BillingPhoneContainsFold *string  `json:"billingPhoneContainsFold,omitempty"`
	// billing_address field predicates
	BillingAddress             *string  `json:"billingAddress,omitempty"`
	BillingAddressNeq          *string  `json:"billingAddressNEQ,omitempty"`
	BillingAddressIn           []string `json:"billingAddressIn,omitempty"`
	BillingAddressNotIn        []string `json:"billingAddressNotIn,omitempty"`
	BillingAddressGt           *string  `json:"billingAddressGT,omitempty"`
	BillingAddressGte          *string  `json:"billingAddressGTE,omitempty"`
	BillingAddressLt           *string  `json:"billingAddressLT,omitempty"`
	BillingAddressLte          *string  `json:"billingAddressLTE,omitempty"`
	BillingAddressContains     *string  `json:"billingAddressContains,omitempty"`
	BillingAddressHasPrefix    *string  `json:"billingAddressHasPrefix,omitempty"`
	BillingAddressHasSuffix    *string  `json:"billingAddressHasSuffix,omitempty"`
	BillingAddressIsNil        *bool    `json:"billingAddressIsNil,omitempty"`
	BillingAddressNotNil       *bool    `json:"billingAddressNotNil,omitempty"`
	BillingAddressEqualFold    *string  `json:"billingAddressEqualFold,omitempty"`
	BillingAddressContainsFold *string  `json:"billingAddressContainsFold,omitempty"`
	// tax_identifier field predicates
	TaxIdentifier             *string  `json:"taxIdentifier,omitempty"`
	TaxIdentifierNeq          *string  `json:"taxIdentifierNEQ,omitempty"`
	TaxIdentifierIn           []string `json:"taxIdentifierIn,omitempty"`
	TaxIdentifierNotIn        []string `json:"taxIdentifierNotIn,omitempty"`
	TaxIdentifierGt           *string  `json:"taxIdentifierGT,omitempty"`
	TaxIdentifierGte          *string  `json:"taxIdentifierGTE,omitempty"`
	TaxIdentifierLt           *string  `json:"taxIdentifierLT,omitempty"`
	TaxIdentifierLte          *string  `json:"taxIdentifierLTE,omitempty"`
	TaxIdentifierContains     *string  `json:"taxIdentifierContains,omitempty"`
	TaxIdentifierHasPrefix    *string  `json:"taxIdentifierHasPrefix,omitempty"`
	TaxIdentifierHasSuffix    *string  `json:"taxIdentifierHasSuffix,omitempty"`
	TaxIdentifierIsNil        *bool    `json:"taxIdentifierIsNil,omitempty"`
	TaxIdentifierNotNil       *bool    `json:"taxIdentifierNotNil,omitempty"`
	TaxIdentifierEqualFold    *string  `json:"taxIdentifierEqualFold,omitempty"`
	TaxIdentifierContainsFold *string  `json:"taxIdentifierContainsFold,omitempty"`
	// geo_location field predicates
	GeoLocation       *enums.Region  `json:"geoLocation,omitempty"`
	GeoLocationNeq    *enums.Region  `json:"geoLocationNEQ,omitempty"`
	GeoLocationIn     []enums.Region `json:"geoLocationIn,omitempty"`
	GeoLocationNotIn  []enums.Region `json:"geoLocationNotIn,omitempty"`
	GeoLocationIsNil  *bool          `json:"geoLocationIsNil,omitempty"`
	GeoLocationNotNil *bool          `json:"geoLocationNotNil,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIDNeq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIDGt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIDGte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIDLt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIDLte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        *bool    `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       *bool    `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
}

// Return response for updateOrganizationSetting mutation
type OrganizationSettingUpdatePayload struct {
	// Updated organizationSetting
	OrganizationSetting *OrganizationSetting `json:"organizationSetting"`
}

// OrganizationSettingWhereInput is used for filtering OrganizationSetting objects.
// Input was generated by ent.
type OrganizationSettingWhereInput struct {
	Not *OrganizationSettingWhereInput   `json:"not,omitempty"`
	And []*OrganizationSettingWhereInput `json:"and,omitempty"`
	Or  []*OrganizationSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// billing_contact field predicates
	BillingContact             *string  `json:"billingContact,omitempty"`
	BillingContactNeq          *string  `json:"billingContactNEQ,omitempty"`
	BillingContactIn           []string `json:"billingContactIn,omitempty"`
	BillingContactNotIn        []string `json:"billingContactNotIn,omitempty"`
	BillingContactGt           *string  `json:"billingContactGT,omitempty"`
	BillingContactGte          *string  `json:"billingContactGTE,omitempty"`
	BillingContactLt           *string  `json:"billingContactLT,omitempty"`
	BillingContactLte          *string  `json:"billingContactLTE,omitempty"`
	BillingContactContains     *string  `json:"billingContactContains,omitempty"`
	BillingContactHasPrefix    *string  `json:"billingContactHasPrefix,omitempty"`
	BillingContactHasSuffix    *string  `json:"billingContactHasSuffix,omitempty"`
	BillingContactIsNil        *bool    `json:"billingContactIsNil,omitempty"`
	BillingContactNotNil       *bool    `json:"billingContactNotNil,omitempty"`
	BillingContactEqualFold    *string  `json:"billingContactEqualFold,omitempty"`
	BillingContactContainsFold *string  `json:"billingContactContainsFold,omitempty"`
	// billing_email field predicates
	BillingEmail             *string  `json:"billingEmail,omitempty"`
	BillingEmailNeq          *string  `json:"billingEmailNEQ,omitempty"`
	BillingEmailIn           []string `json:"billingEmailIn,omitempty"`
	BillingEmailNotIn        []string `json:"billingEmailNotIn,omitempty"`
	BillingEmailGt           *string  `json:"billingEmailGT,omitempty"`
	BillingEmailGte          *string  `json:"billingEmailGTE,omitempty"`
	BillingEmailLt           *string  `json:"billingEmailLT,omitempty"`
	BillingEmailLte          *string  `json:"billingEmailLTE,omitempty"`
	BillingEmailContains     *string  `json:"billingEmailContains,omitempty"`
	BillingEmailHasPrefix    *string  `json:"billingEmailHasPrefix,omitempty"`
	BillingEmailHasSuffix    *string  `json:"billingEmailHasSuffix,omitempty"`
	BillingEmailIsNil        *bool    `json:"billingEmailIsNil,omitempty"`
	BillingEmailNotNil       *bool    `json:"billingEmailNotNil,omitempty"`
	BillingEmailEqualFold    *string  `json:"billingEmailEqualFold,omitempty"`
	BillingEmailContainsFold *string  `json:"billingEmailContainsFold,omitempty"`
	// billing_phone field predicates
	BillingPhone             *string  `json:"billingPhone,omitempty"`
	BillingPhoneNeq          *string  `json:"billingPhoneNEQ,omitempty"`
	BillingPhoneIn           []string `json:"billingPhoneIn,omitempty"`
	BillingPhoneNotIn        []string `json:"billingPhoneNotIn,omitempty"`
	BillingPhoneGt           *string  `json:"billingPhoneGT,omitempty"`
	BillingPhoneGte          *string  `json:"billingPhoneGTE,omitempty"`
	BillingPhoneLt           *string  `json:"billingPhoneLT,omitempty"`
	BillingPhoneLte          *string  `json:"billingPhoneLTE,omitempty"`
	BillingPhoneContains     *string  `json:"billingPhoneContains,omitempty"`
	BillingPhoneHasPrefix    *string  `json:"billingPhoneHasPrefix,omitempty"`
	BillingPhoneHasSuffix    *string  `json:"billingPhoneHasSuffix,omitempty"`
	BillingPhoneIsNil        *bool    `json:"billingPhoneIsNil,omitempty"`
	BillingPhoneNotNil       *bool    `json:"billingPhoneNotNil,omitempty"`
	BillingPhoneEqualFold    *string  `json:"billingPhoneEqualFold,omitempty"`
	BillingPhoneContainsFold *string  `json:"billingPhoneContainsFold,omitempty"`
	// billing_address field predicates
	BillingAddress             *string  `json:"billingAddress,omitempty"`
	BillingAddressNeq          *string  `json:"billingAddressNEQ,omitempty"`
	BillingAddressIn           []string `json:"billingAddressIn,omitempty"`
	BillingAddressNotIn        []string `json:"billingAddressNotIn,omitempty"`
	BillingAddressGt           *string  `json:"billingAddressGT,omitempty"`
	BillingAddressGte          *string  `json:"billingAddressGTE,omitempty"`
	BillingAddressLt           *string  `json:"billingAddressLT,omitempty"`
	BillingAddressLte          *string  `json:"billingAddressLTE,omitempty"`
	BillingAddressContains     *string  `json:"billingAddressContains,omitempty"`
	BillingAddressHasPrefix    *string  `json:"billingAddressHasPrefix,omitempty"`
	BillingAddressHasSuffix    *string  `json:"billingAddressHasSuffix,omitempty"`
	BillingAddressIsNil        *bool    `json:"billingAddressIsNil,omitempty"`
	BillingAddressNotNil       *bool    `json:"billingAddressNotNil,omitempty"`
	BillingAddressEqualFold    *string  `json:"billingAddressEqualFold,omitempty"`
	BillingAddressContainsFold *string  `json:"billingAddressContainsFold,omitempty"`
	// tax_identifier field predicates
	TaxIdentifier             *string  `json:"taxIdentifier,omitempty"`
	TaxIdentifierNeq          *string  `json:"taxIdentifierNEQ,omitempty"`
	TaxIdentifierIn           []string `json:"taxIdentifierIn,omitempty"`
	TaxIdentifierNotIn        []string `json:"taxIdentifierNotIn,omitempty"`
	TaxIdentifierGt           *string  `json:"taxIdentifierGT,omitempty"`
	TaxIdentifierGte          *string  `json:"taxIdentifierGTE,omitempty"`
	TaxIdentifierLt           *string  `json:"taxIdentifierLT,omitempty"`
	TaxIdentifierLte          *string  `json:"taxIdentifierLTE,omitempty"`
	TaxIdentifierContains     *string  `json:"taxIdentifierContains,omitempty"`
	TaxIdentifierHasPrefix    *string  `json:"taxIdentifierHasPrefix,omitempty"`
	TaxIdentifierHasSuffix    *string  `json:"taxIdentifierHasSuffix,omitempty"`
	TaxIdentifierIsNil        *bool    `json:"taxIdentifierIsNil,omitempty"`
	TaxIdentifierNotNil       *bool    `json:"taxIdentifierNotNil,omitempty"`
	TaxIdentifierEqualFold    *string  `json:"taxIdentifierEqualFold,omitempty"`
	TaxIdentifierContainsFold *string  `json:"taxIdentifierContainsFold,omitempty"`
	// geo_location field predicates
	GeoLocation       *enums.Region  `json:"geoLocation,omitempty"`
	GeoLocationNeq    *enums.Region  `json:"geoLocationNEQ,omitempty"`
	GeoLocationIn     []enums.Region `json:"geoLocationIn,omitempty"`
	GeoLocationNotIn  []enums.Region `json:"geoLocationNotIn,omitempty"`
	GeoLocationIsNil  *bool          `json:"geoLocationIsNil,omitempty"`
	GeoLocationNotNil *bool          `json:"geoLocationNotNil,omitempty"`
	// organization_id field predicates
	OrganizationID             *string  `json:"organizationID,omitempty"`
	OrganizationIDNeq          *string  `json:"organizationIDNEQ,omitempty"`
	OrganizationIDIn           []string `json:"organizationIDIn,omitempty"`
	OrganizationIDNotIn        []string `json:"organizationIDNotIn,omitempty"`
	OrganizationIDGt           *string  `json:"organizationIDGT,omitempty"`
	OrganizationIDGte          *string  `json:"organizationIDGTE,omitempty"`
	OrganizationIDLt           *string  `json:"organizationIDLT,omitempty"`
	OrganizationIDLte          *string  `json:"organizationIDLTE,omitempty"`
	OrganizationIDContains     *string  `json:"organizationIDContains,omitempty"`
	OrganizationIDHasPrefix    *string  `json:"organizationIDHasPrefix,omitempty"`
	OrganizationIDHasSuffix    *string  `json:"organizationIDHasSuffix,omitempty"`
	OrganizationIDIsNil        *bool    `json:"organizationIDIsNil,omitempty"`
	OrganizationIDNotNil       *bool    `json:"organizationIDNotNil,omitempty"`
	OrganizationIDEqualFold    *string  `json:"organizationIDEqualFold,omitempty"`
	OrganizationIDContainsFold *string  `json:"organizationIDContainsFold,omitempty"`
	// organization edge predicates
	HasOrganization     *bool                     `json:"hasOrganization,omitempty"`
	HasOrganizationWith []*OrganizationWhereInput `json:"hasOrganizationWith,omitempty"`
}

// Return response for updateOrganization mutation
type OrganizationUpdatePayload struct {
	// Updated organization
	Organization *Organization `json:"organization"`
}

// OrganizationWhereInput is used for filtering Organization objects.
// Input was generated by ent.
type OrganizationWhereInput struct {
	Not *OrganizationWhereInput   `json:"not,omitempty"`
	And []*OrganizationWhereInput `json:"and,omitempty"`
	Or  []*OrganizationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// parent_organization_id field predicates
	ParentOrganizationID             *string  `json:"parentOrganizationID,omitempty"`
	ParentOrganizationIDNeq          *string  `json:"parentOrganizationIDNEQ,omitempty"`
	ParentOrganizationIDIn           []string `json:"parentOrganizationIDIn,omitempty"`
	ParentOrganizationIDNotIn        []string `json:"parentOrganizationIDNotIn,omitempty"`
	ParentOrganizationIDGt           *string  `json:"parentOrganizationIDGT,omitempty"`
	ParentOrganizationIDGte          *string  `json:"parentOrganizationIDGTE,omitempty"`
	ParentOrganizationIDLt           *string  `json:"parentOrganizationIDLT,omitempty"`
	ParentOrganizationIDLte          *string  `json:"parentOrganizationIDLTE,omitempty"`
	ParentOrganizationIDContains     *string  `json:"parentOrganizationIDContains,omitempty"`
	ParentOrganizationIDHasPrefix    *string  `json:"parentOrganizationIDHasPrefix,omitempty"`
	ParentOrganizationIDHasSuffix    *string  `json:"parentOrganizationIDHasSuffix,omitempty"`
	ParentOrganizationIDIsNil        *bool    `json:"parentOrganizationIDIsNil,omitempty"`
	ParentOrganizationIDNotNil       *bool    `json:"parentOrganizationIDNotNil,omitempty"`
	ParentOrganizationIDEqualFold    *string  `json:"parentOrganizationIDEqualFold,omitempty"`
	ParentOrganizationIDContainsFold *string  `json:"parentOrganizationIDContainsFold,omitempty"`
	// personal_org field predicates
	PersonalOrg       *bool `json:"personalOrg,omitempty"`
	PersonalOrgNeq    *bool `json:"personalOrgNEQ,omitempty"`
	PersonalOrgIsNil  *bool `json:"personalOrgIsNil,omitempty"`
	PersonalOrgNotNil *bool `json:"personalOrgNotNil,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// parent edge predicates
	HasParent     *bool                     `json:"hasParent,omitempty"`
	HasParentWith []*OrganizationWhereInput `json:"hasParentWith,omitempty"`
	// children edge predicates
	HasChildren     *bool                     `json:"hasChildren,omitempty"`
	HasChildrenWith []*OrganizationWhereInput `json:"hasChildrenWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// templates edge predicates
	HasTemplates     *bool                 `json:"hasTemplates,omitempty"`
	HasTemplatesWith []*TemplateWhereInput `json:"hasTemplatesWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                            `json:"hasSetting,omitempty"`
	HasSettingWith []*OrganizationSettingWhereInput `json:"hasSettingWith,omitempty"`
	// documentdata edge predicates
	HasDocumentdata     *bool                     `json:"hasDocumentdata,omitempty"`
	HasDocumentdataWith []*DocumentDataWhereInput `json:"hasDocumentdataWith,omitempty"`
	// entitlements edge predicates
	HasEntitlements     *bool                    `json:"hasEntitlements,omitempty"`
	HasEntitlementsWith []*EntitlementWhereInput `json:"hasEntitlementsWith,omitempty"`
	// organization_entitlement edge predicates
	HasOrganizationEntitlement     *bool                    `json:"hasOrganizationEntitlement,omitempty"`
	HasOrganizationEntitlementWith []*EntitlementWhereInput `json:"hasOrganizationEntitlementWith,omitempty"`
	// personal_access_tokens edge predicates
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`
	// api_tokens edge predicates
	HasAPITokens     *bool                 `json:"hasAPITokens,omitempty"`
	HasAPITokensWith []*APITokenWhereInput `json:"hasAPITokensWith,omitempty"`
	// oauthprovider edge predicates
	HasOauthprovider     *bool                      `json:"hasOauthprovider,omitempty"`
	HasOauthproviderWith []*OauthProviderWhereInput `json:"hasOauthproviderWith,omitempty"`
	// users edge predicates
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
	// invites edge predicates
	HasInvites     *bool               `json:"hasInvites,omitempty"`
	HasInvitesWith []*InviteWhereInput `json:"hasInvitesWith,omitempty"`
	// subscribers edge predicates
	HasSubscribers     *bool                   `json:"hasSubscribers,omitempty"`
	HasSubscribersWith []*SubscriberWhereInput `json:"hasSubscribersWith,omitempty"`
	// webhooks edge predicates
	HasWebhooks     *bool                `json:"hasWebhooks,omitempty"`
	HasWebhooksWith []*WebhookWhereInput `json:"hasWebhooksWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// secrets edge predicates
	HasSecrets     *bool             `json:"hasSecrets,omitempty"`
	HasSecretsWith []*HushWhereInput `json:"hasSecretsWith,omitempty"`
	// features edge predicates
	HasFeatures     *bool                `json:"hasFeatures,omitempty"`
	HasFeaturesWith []*FeatureWhereInput `json:"hasFeaturesWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// entitlementplans edge predicates
	HasEntitlementplans     *bool                        `json:"hasEntitlementplans,omitempty"`
	HasEntitlementplansWith []*EntitlementPlanWhereInput `json:"hasEntitlementplansWith,omitempty"`
	// entitlementplanfeatures edge predicates
	HasEntitlementplanfeatures     *bool                               `json:"hasEntitlementplanfeatures,omitempty"`
	HasEntitlementplanfeaturesWith []*EntitlementPlanFeatureWhereInput `json:"hasEntitlementplanfeaturesWith,omitempty"`
	// entities edge predicates
	HasEntities     *bool               `json:"hasEntities,omitempty"`
	HasEntitiesWith []*EntityWhereInput `json:"hasEntitiesWith,omitempty"`
	// entitytypes edge predicates
	HasEntitytypes     *bool                   `json:"hasEntitytypes,omitempty"`
	HasEntitytypesWith []*EntityTypeWhereInput `json:"hasEntitytypesWith,omitempty"`
	// contacts edge predicates
	HasContacts     *bool                `json:"hasContacts,omitempty"`
	HasContactsWith []*ContactWhereInput `json:"hasContactsWith,omitempty"`
	// notes edge predicates
	HasNotes     *bool             `json:"hasNotes,omitempty"`
	HasNotesWith []*NoteWhereInput `json:"hasNotesWith,omitempty"`
	// members edge predicates
	HasMembers     *bool                      `json:"hasMembers,omitempty"`
	HasMembersWith []*OrgMembershipWhereInput `json:"hasMembersWith,omitempty"`
}

// Information about pagination in a connection.
// https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
type PageInfo struct {
	// When paginating forwards, are there more items?
	HasNextPage bool `json:"hasNextPage"`
	// When paginating backwards, are there more items?
	HasPreviousPage bool `json:"hasPreviousPage"`
	// When paginating backwards, the cursor to continue.
	StartCursor *string `json:"startCursor,omitempty"`
	// When paginating forwards, the cursor to continue.
	EndCursor *string `json:"endCursor,omitempty"`
}

type PersonalAccessToken struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// the name associated with the token
	Name  string `json:"name"`
	Token string `json:"token"`
	// when the token expires
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	// a description of the token's purpose
	Description *string    `json:"description,omitempty"`
	Scopes      []string   `json:"scopes,omitempty"`
	LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
	Owner       *User      `json:"owner"`
	// the organization(s) the token is associated with
	Organizations []*Organization `json:"organizations,omitempty"`
	Events        []*Event        `json:"events,omitempty"`
}

func (PersonalAccessToken) IsNode() {}

// Return response for createBulkPersonalAccessToken mutation
type PersonalAccessTokenBulkCreatePayload struct {
	// Created personalAccessTokens
	PersonalAccessTokens []*PersonalAccessToken `json:"personalAccessTokens,omitempty"`
}

// A connection to a list of items.
type PersonalAccessTokenConnection struct {
	// A list of edges.
	Edges []*PersonalAccessTokenEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createPersonalAccessToken mutation
type PersonalAccessTokenCreatePayload struct {
	// Created personalAccessToken
	PersonalAccessToken *PersonalAccessToken `json:"personalAccessToken"`
}

// Return response for deletePersonalAccessToken mutation
type PersonalAccessTokenDeletePayload struct {
	// Deleted personalAccessToken ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type PersonalAccessTokenEdge struct {
	// The item at the end of the edge.
	Node *PersonalAccessToken `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updatePersonalAccessToken mutation
type PersonalAccessTokenUpdatePayload struct {
	// Updated personalAccessToken
	PersonalAccessToken *PersonalAccessToken `json:"personalAccessToken"`
}

// PersonalAccessTokenWhereInput is used for filtering PersonalAccessToken objects.
// Input was generated by ent.
type PersonalAccessTokenWhereInput struct {
	Not *PersonalAccessTokenWhereInput   `json:"not,omitempty"`
	And []*PersonalAccessTokenWhereInput `json:"and,omitempty"`
	Or  []*PersonalAccessTokenWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// expires_at field predicates
	ExpiresAt       *time.Time   `json:"expiresAt,omitempty"`
	ExpiresAtNeq    *time.Time   `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []*time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []*time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGt     *time.Time   `json:"expiresAtGT,omitempty"`
	ExpiresAtGte    *time.Time   `json:"expiresAtGTE,omitempty"`
	ExpiresAtLt     *time.Time   `json:"expiresAtLT,omitempty"`
	ExpiresAtLte    *time.Time   `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  *bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil *bool        `json:"expiresAtNotNil,omitempty"`
	// last_used_at field predicates
	LastUsedAt       *time.Time   `json:"lastUsedAt,omitempty"`
	LastUsedAtNeq    *time.Time   `json:"lastUsedAtNEQ,omitempty"`
	LastUsedAtIn     []*time.Time `json:"lastUsedAtIn,omitempty"`
	LastUsedAtNotIn  []*time.Time `json:"lastUsedAtNotIn,omitempty"`
	LastUsedAtGt     *time.Time   `json:"lastUsedAtGT,omitempty"`
	LastUsedAtGte    *time.Time   `json:"lastUsedAtGTE,omitempty"`
	LastUsedAtLt     *time.Time   `json:"lastUsedAtLT,omitempty"`
	LastUsedAtLte    *time.Time   `json:"lastUsedAtLTE,omitempty"`
	LastUsedAtIsNil  *bool        `json:"lastUsedAtIsNil,omitempty"`
	LastUsedAtNotNil *bool        `json:"lastUsedAtNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
	// organizations edge predicates
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type Query struct {
}

type SearchResultConnection struct {
	Page  *PageInfo      `json:"page"`
	Nodes []SearchResult `json:"nodes"`
}

type Subscriber struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// email address of the subscriber
	Email string `json:"email"`
	// phone number of the subscriber
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// indicates if the email address has been verified
	VerifiedEmail bool `json:"verifiedEmail"`
	// indicates if the phone number has been verified
	VerifiedPhone bool `json:"verifiedPhone"`
	// indicates if the subscriber is active or not, active users will have at least one verified contact method
	Active bool          `json:"active"`
	Owner  *Organization `json:"owner,omitempty"`
	Events []*Event      `json:"events,omitempty"`
}

func (Subscriber) IsNode() {}

// Return response for createBulkSubscriber mutation
type SubscriberBulkCreatePayload struct {
	// Created subscribers
	Subscribers []*Subscriber `json:"subscribers,omitempty"`
}

// A connection to a list of items.
type SubscriberConnection struct {
	// A list of edges.
	Edges []*SubscriberEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createSubscriber mutation
type SubscriberCreatePayload struct {
	// Created subscriber
	Subscriber *Subscriber `json:"subscriber"`
}

// Return response for deleteSubscriber mutation
type SubscriberDeletePayload struct {
	// Deleted subscriber email
	Email string `json:"email"`
}

// An edge in a connection.
type SubscriberEdge struct {
	// The item at the end of the edge.
	Node *Subscriber `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type SubscriberSearchResult struct {
	Subscribers []*Subscriber `json:"subscribers,omitempty"`
}

func (SubscriberSearchResult) IsSearchResult() {}

// Return response for updateSubscriber mutation
type SubscriberUpdatePayload struct {
	// Updated subscriber
	Subscriber *Subscriber `json:"subscriber"`
}

// SubscriberWhereInput is used for filtering Subscriber objects.
// Input was generated by ent.
type SubscriberWhereInput struct {
	Not *SubscriberWhereInput   `json:"not,omitempty"`
	And []*SubscriberWhereInput `json:"and,omitempty"`
	Or  []*SubscriberWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// phone_number field predicates
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNeq          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGt           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGte          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLt           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLte          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        *bool    `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       *bool    `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`
	// verified_email field predicates
	VerifiedEmail    *bool `json:"verifiedEmail,omitempty"`
	VerifiedEmailNeq *bool `json:"verifiedEmailNEQ,omitempty"`
	// verified_phone field predicates
	VerifiedPhone    *bool `json:"verifiedPhone,omitempty"`
	VerifiedPhoneNeq *bool `json:"verifiedPhoneNEQ,omitempty"`
	// active field predicates
	Active    *bool `json:"active,omitempty"`
	ActiveNeq *bool `json:"activeNEQ,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
}

type TFASetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// TFA secret for the user
	TfaSecret *string `json:"tfaSecret,omitempty"`
	// specifies if the TFA device has been verified
	Verified bool `json:"verified"`
	// recovery codes for 2fa
	RecoveryCodes []string `json:"recoveryCodes,omitempty"`
	// specifies a user may complete authentication by verifying a TOTP code delivered through an authenticator app
	TotpAllowed *bool `json:"totpAllowed,omitempty"`
	Owner       *User `json:"owner,omitempty"`
}

func (TFASetting) IsNode() {}

// A connection to a list of items.
type TFASettingConnection struct {
	// A list of edges.
	Edges []*TFASettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTFASetting mutation
type TFASettingCreatePayload struct {
	// Created tfaSetting
	TfaSetting *TFASetting `json:"tfaSetting"`
}

// An edge in a connection.
type TFASettingEdge struct {
	// The item at the end of the edge.
	Node *TFASetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Return response for updateTFASetting mutation
type TFASettingUpdatePayload struct {
	// Updated tfaSetting
	TfaSetting *TFASetting `json:"tfaSetting"`
}

// TFASettingWhereInput is used for filtering TFASetting objects.
// Input was generated by ent.
type TFASettingWhereInput struct {
	Not *TFASettingWhereInput   `json:"not,omitempty"`
	And []*TFASettingWhereInput `json:"and,omitempty"`
	Or  []*TFASettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// tfa_secret field predicates
	TfaSecret             *string  `json:"tfaSecret,omitempty"`
	TfaSecretNeq          *string  `json:"tfaSecretNEQ,omitempty"`
	TfaSecretIn           []string `json:"tfaSecretIn,omitempty"`
	TfaSecretNotIn        []string `json:"tfaSecretNotIn,omitempty"`
	TfaSecretGt           *string  `json:"tfaSecretGT,omitempty"`
	TfaSecretGte          *string  `json:"tfaSecretGTE,omitempty"`
	TfaSecretLt           *string  `json:"tfaSecretLT,omitempty"`
	TfaSecretLte          *string  `json:"tfaSecretLTE,omitempty"`
	TfaSecretContains     *string  `json:"tfaSecretContains,omitempty"`
	TfaSecretHasPrefix    *string  `json:"tfaSecretHasPrefix,omitempty"`
	TfaSecretHasSuffix    *string  `json:"tfaSecretHasSuffix,omitempty"`
	TfaSecretIsNil        *bool    `json:"tfaSecretIsNil,omitempty"`
	TfaSecretNotNil       *bool    `json:"tfaSecretNotNil,omitempty"`
	TfaSecretEqualFold    *string  `json:"tfaSecretEqualFold,omitempty"`
	TfaSecretContainsFold *string  `json:"tfaSecretContainsFold,omitempty"`
	// verified field predicates
	Verified    *bool `json:"verified,omitempty"`
	VerifiedNeq *bool `json:"verifiedNEQ,omitempty"`
	// totp_allowed field predicates
	TotpAllowed       *bool `json:"totpAllowed,omitempty"`
	TotpAllowedNeq    *bool `json:"totpAllowedNEQ,omitempty"`
	TotpAllowedIsNil  *bool `json:"totpAllowedIsNil,omitempty"`
	TotpAllowedNotNil *bool `json:"totpAllowedNotNil,omitempty"`
	// owner edge predicates
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

type Template struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the template
	Name string `json:"name"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType enums.DocumentType `json:"templateType"`
	// the description of the template
	Description *string `json:"description,omitempty"`
	// the jsonschema object of the template
	Jsonconfig json.RawMessage `json:"jsonconfig"`
	// the uischema for the template to render in the UI
	Uischema  json.RawMessage `json:"uischema,omitempty"`
	Owner     *Organization   `json:"owner,omitempty"`
	Documents []*DocumentData `json:"documents,omitempty"`
}

func (Template) IsNode() {}

// Return response for createBulkTemplate mutation
type TemplateBulkCreatePayload struct {
	// Created templates
	Templates []*Template `json:"templates,omitempty"`
}

// A connection to a list of items.
type TemplateConnection struct {
	// A list of edges.
	Edges []*TemplateEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createTemplate mutation
type TemplateCreatePayload struct {
	// Created template
	Template *Template `json:"template"`
}

// Return response for deleteTemplate mutation
type TemplateDeletePayload struct {
	// Deleted template ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type TemplateEdge struct {
	// The item at the end of the edge.
	Node *Template `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type TemplateHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the template
	Name string `json:"name"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType enums.DocumentType `json:"templateType"`
	// the description of the template
	Description *string `json:"description,omitempty"`
	// the jsonschema object of the template
	Jsonconfig json.RawMessage `json:"jsonconfig"`
	// the uischema for the template to render in the UI
	Uischema json.RawMessage `json:"uischema,omitempty"`
}

func (TemplateHistory) IsNode() {}

// A connection to a list of items.
type TemplateHistoryConnection struct {
	// A list of edges.
	Edges []*TemplateHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type TemplateHistoryEdge struct {
	// The item at the end of the edge.
	Node *TemplateHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for TemplateHistory connections
type TemplateHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order TemplateHistories.
	Field TemplateHistoryOrderField `json:"field"`
}

// TemplateHistoryWhereInput is used for filtering TemplateHistory objects.
// Input was generated by ent.
type TemplateHistoryWhereInput struct {
	Not *TemplateHistoryWhereInput   `json:"not,omitempty"`
	And []*TemplateHistoryWhereInput `json:"and,omitempty"`
	Or  []*TemplateHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// template_type field predicates
	TemplateType      *enums.DocumentType  `json:"templateType,omitempty"`
	TemplateTypeNeq   *enums.DocumentType  `json:"templateTypeNEQ,omitempty"`
	TemplateTypeIn    []enums.DocumentType `json:"templateTypeIn,omitempty"`
	TemplateTypeNotIn []enums.DocumentType `json:"templateTypeNotIn,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
}

// Ordering options for Template connections
type TemplateOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Templates.
	Field TemplateOrderField `json:"field"`
}

// Return response for updateTemplate mutation
type TemplateUpdatePayload struct {
	// Updated template
	Template *Template `json:"template"`
}

// TemplateWhereInput is used for filtering Template objects.
// Input was generated by ent.
type TemplateWhereInput struct {
	Not *TemplateWhereInput   `json:"not,omitempty"`
	And []*TemplateWhereInput `json:"and,omitempty"`
	Or  []*TemplateWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// template_type field predicates
	TemplateType      *enums.DocumentType  `json:"templateType,omitempty"`
	TemplateTypeNeq   *enums.DocumentType  `json:"templateTypeNEQ,omitempty"`
	TemplateTypeIn    []enums.DocumentType `json:"templateTypeIn,omitempty"`
	TemplateTypeNotIn []enums.DocumentType `json:"templateTypeNotIn,omitempty"`
	// description field predicates
	Description             *string  `json:"description,omitempty"`
	DescriptionNeq          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGt           *string  `json:"descriptionGT,omitempty"`
	DescriptionGte          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLt           *string  `json:"descriptionLT,omitempty"`
	DescriptionLte          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        *bool    `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       *bool    `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// documents edge predicates
	HasDocuments     *bool                     `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentDataWhereInput `json:"hasDocumentsWith,omitempty"`
}

// UpdateAPITokenInput is used for update APIToken object.
// Input was generated by ent.
type UpdateAPITokenInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name associated with the token
	Name *string `json:"name,omitempty"`
	// a description of the token's purpose
	Description      *string    `json:"description,omitempty"`
	ClearDescription *bool      `json:"clearDescription,omitempty"`
	Scopes           []string   `json:"scopes,omitempty"`
	AppendScopes     []string   `json:"appendScopes,omitempty"`
	ClearScopes      *bool      `json:"clearScopes,omitempty"`
	LastUsedAt       *time.Time `json:"lastUsedAt,omitempty"`
	ClearLastUsedAt  *bool      `json:"clearLastUsedAt,omitempty"`
	OwnerID          *string    `json:"ownerID,omitempty"`
	ClearOwner       *bool      `json:"clearOwner,omitempty"`
}

// UpdateContactInput is used for update Contact object.
// Input was generated by ent.
type UpdateContactInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the full name of the contact
	FullName *string `json:"fullName,omitempty"`
	// the title of the contact
	Title      *string `json:"title,omitempty"`
	ClearTitle *bool   `json:"clearTitle,omitempty"`
	// the company of the contact
	Company      *string `json:"company,omitempty"`
	ClearCompany *bool   `json:"clearCompany,omitempty"`
	// the email of the contact
	Email      *string `json:"email,omitempty"`
	ClearEmail *bool   `json:"clearEmail,omitempty"`
	// the phone number of the contact
	PhoneNumber      *string `json:"phoneNumber,omitempty"`
	ClearPhoneNumber *bool   `json:"clearPhoneNumber,omitempty"`
	// the address of the contact
	Address      *string `json:"address,omitempty"`
	ClearAddress *bool   `json:"clearAddress,omitempty"`
	// status of the contact
	Status          *enums.UserStatus `json:"status,omitempty"`
	OwnerID         *string           `json:"ownerID,omitempty"`
	ClearOwner      *bool             `json:"clearOwner,omitempty"`
	AddEntityIDs    []string          `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs []string          `json:"removeEntityIDs,omitempty"`
	ClearEntities   *bool             `json:"clearEntities,omitempty"`
}

// UpdateDocumentDataInput is used for update DocumentData object.
// Input was generated by ent.
type UpdateDocumentDataInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the json data of the document
	Data            json.RawMessage `json:"data,omitempty"`
	OwnerID         *string         `json:"ownerID,omitempty"`
	ClearOwner      *bool           `json:"clearOwner,omitempty"`
	TemplateID      *string         `json:"templateID,omitempty"`
	AddEntityIDs    []string        `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs []string        `json:"removeEntityIDs,omitempty"`
	ClearEntity     *bool           `json:"clearEntity,omitempty"`
}

// UpdateEntitlementInput is used for update Entitlement object.
// Input was generated by ent.
type UpdateEntitlementInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalCustomerID      *string `json:"externalCustomerID,omitempty"`
	ClearExternalCustomerID *bool   `json:"clearExternalCustomerID,omitempty"`
	// used to store references to external systems, e.g. Stripe
	ExternalSubscriptionID      *string `json:"externalSubscriptionID,omitempty"`
	ClearExternalSubscriptionID *bool   `json:"clearExternalSubscriptionID,omitempty"`
	// the time at which a customer's entitlement will expire, e.g. they've cancelled but paid through the end of the month
	ExpiresAt      *time.Time `json:"expiresAt,omitempty"`
	ClearExpiresAt *bool      `json:"clearExpiresAt,omitempty"`
	// whether or not the customer has cancelled their entitlement - usually used in conjunction with expires and expires at
	Cancelled      *bool    `json:"cancelled,omitempty"`
	OwnerID        *string  `json:"ownerID,omitempty"`
	ClearOwner     *bool    `json:"clearOwner,omitempty"`
	AddEventIDs    []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool    `json:"clearEvents,omitempty"`
}

// UpdateEntitlementPlanFeatureInput is used for update EntitlementPlanFeature object.
// Input was generated by ent.
type UpdateEntitlementPlanFeatureInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// metadata for the entitlement plan feature such as usage limits
	Metadata       map[string]interface{} `json:"metadata,omitempty"`
	ClearMetadata  *bool                  `json:"clearMetadata,omitempty"`
	OwnerID        *string                `json:"ownerID,omitempty"`
	ClearOwner     *bool                  `json:"clearOwner,omitempty"`
	AddEventIDs    []string               `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string               `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool                  `json:"clearEvents,omitempty"`
}

// UpdateEntitlementPlanInput is used for update EntitlementPlan object.
// Input was generated by ent.
type UpdateEntitlementPlanInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the displayed 'friendly' name of the plan
	DisplayName      *string `json:"displayName,omitempty"`
	ClearDisplayName *bool   `json:"clearDisplayName,omitempty"`
	// a description of the plan
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// metadata for the plan
	Metadata             map[string]interface{} `json:"metadata,omitempty"`
	ClearMetadata        *bool                  `json:"clearMetadata,omitempty"`
	OwnerID              *string                `json:"ownerID,omitempty"`
	ClearOwner           *bool                  `json:"clearOwner,omitempty"`
	AddEntitlementIDs    []string               `json:"addEntitlementIDs,omitempty"`
	RemoveEntitlementIDs []string               `json:"removeEntitlementIDs,omitempty"`
	ClearEntitlements    *bool                  `json:"clearEntitlements,omitempty"`
	AddBaseFeatureIDs    []string               `json:"addBaseFeatureIDs,omitempty"`
	RemoveBaseFeatureIDs []string               `json:"removeBaseFeatureIDs,omitempty"`
	ClearBaseFeatures    *bool                  `json:"clearBaseFeatures,omitempty"`
	AddEventIDs          []string               `json:"addEventIDs,omitempty"`
	RemoveEventIDs       []string               `json:"removeEventIDs,omitempty"`
	ClearEvents          *bool                  `json:"clearEvents,omitempty"`
}

// UpdateEntityInput is used for update Entity object.
// Input was generated by ent.
type UpdateEntityInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the entity
	Name      *string `json:"name,omitempty"`
	ClearName *bool   `json:"clearName,omitempty"`
	// The entity's displayed 'friendly' name
	DisplayName      *string `json:"displayName,omitempty"`
	ClearDisplayName *bool   `json:"clearDisplayName,omitempty"`
	// An optional description of the entity
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// domains associated with the entity
	Domains       []string `json:"domains,omitempty"`
	AppendDomains []string `json:"appendDomains,omitempty"`
	ClearDomains  *bool    `json:"clearDomains,omitempty"`
	// status of the entity
	Status            *string          `json:"status,omitempty"`
	ClearStatus       *bool            `json:"clearStatus,omitempty"`
	OwnerID           *string          `json:"ownerID,omitempty"`
	ClearOwner        *bool            `json:"clearOwner,omitempty"`
	AddContactIDs     []string         `json:"addContactIDs,omitempty"`
	RemoveContactIDs  []string         `json:"removeContactIDs,omitempty"`
	ClearContacts     *bool            `json:"clearContacts,omitempty"`
	AddDocumentIDs    []string         `json:"addDocumentIDs,omitempty"`
	RemoveDocumentIDs []string         `json:"removeDocumentIDs,omitempty"`
	ClearDocuments    *bool            `json:"clearDocuments,omitempty"`
	AddNoteIDs        []string         `json:"addNoteIDs,omitempty"`
	RemoveNoteIDs     []string         `json:"removeNoteIDs,omitempty"`
	ClearNotes        *bool            `json:"clearNotes,omitempty"`
	AddFileIDs        []string         `json:"addFileIDs,omitempty"`
	RemoveFileIDs     []string         `json:"removeFileIDs,omitempty"`
	ClearFiles        *bool            `json:"clearFiles,omitempty"`
	EntityTypeID      *string          `json:"entityTypeID,omitempty"`
	ClearEntityType   *bool            `json:"clearEntityType,omitempty"`
	Note              *CreateNoteInput `json:"note,omitempty"`
}

// UpdateEntityTypeInput is used for update EntityType object.
// Input was generated by ent.
type UpdateEntityTypeInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the entity
	Name            *string  `json:"name,omitempty"`
	OwnerID         *string  `json:"ownerID,omitempty"`
	ClearOwner      *bool    `json:"clearOwner,omitempty"`
	AddEntityIDs    []string `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs []string `json:"removeEntityIDs,omitempty"`
	ClearEntities   *bool    `json:"clearEntities,omitempty"`
}

// UpdateEventInput is used for update Event object.
// Input was generated by ent.
type UpdateEventInput struct {
	// tags associated with the object
	Tags                         []string               `json:"tags,omitempty"`
	AppendTags                   []string               `json:"appendTags,omitempty"`
	ClearTags                    *bool                  `json:"clearTags,omitempty"`
	EventID                      *string                `json:"eventID,omitempty"`
	ClearEventID                 *bool                  `json:"clearEventID,omitempty"`
	CorrelationID                *string                `json:"correlationID,omitempty"`
	ClearCorrelationID           *bool                  `json:"clearCorrelationID,omitempty"`
	EventType                    *string                `json:"eventType,omitempty"`
	Metadata                     map[string]interface{} `json:"metadata,omitempty"`
	ClearMetadata                *bool                  `json:"clearMetadata,omitempty"`
	AddUserIDs                   []string               `json:"addUserIDs,omitempty"`
	RemoveUserIDs                []string               `json:"removeUserIDs,omitempty"`
	ClearUser                    *bool                  `json:"clearUser,omitempty"`
	AddGroupIDs                  []string               `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs               []string               `json:"removeGroupIDs,omitempty"`
	ClearGroup                   *bool                  `json:"clearGroup,omitempty"`
	AddIntegrationIDs            []string               `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs         []string               `json:"removeIntegrationIDs,omitempty"`
	ClearIntegration             *bool                  `json:"clearIntegration,omitempty"`
	AddOrganizationIDs           []string               `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs        []string               `json:"removeOrganizationIDs,omitempty"`
	ClearOrganization            *bool                  `json:"clearOrganization,omitempty"`
	AddInviteIDs                 []string               `json:"addInviteIDs,omitempty"`
	RemoveInviteIDs              []string               `json:"removeInviteIDs,omitempty"`
	ClearInvite                  *bool                  `json:"clearInvite,omitempty"`
	AddFeatureIDs                []string               `json:"addFeatureIDs,omitempty"`
	RemoveFeatureIDs             []string               `json:"removeFeatureIDs,omitempty"`
	ClearFeature                 *bool                  `json:"clearFeature,omitempty"`
	AddEntitlementplanIDs        []string               `json:"addEntitlementplanIDs,omitempty"`
	RemoveEntitlementplanIDs     []string               `json:"removeEntitlementplanIDs,omitempty"`
	ClearEntitlementplan         *bool                  `json:"clearEntitlementplan,omitempty"`
	AddPersonalAccessTokenIDs    []string               `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs []string               `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessToken     *bool                  `json:"clearPersonalAccessToken,omitempty"`
	AddOauth2tokenIDs            []string               `json:"addOauth2tokenIDs,omitempty"`
	RemoveOauth2tokenIDs         []string               `json:"removeOauth2tokenIDs,omitempty"`
	ClearOauth2token             *bool                  `json:"clearOauth2token,omitempty"`
	AddHushIDs                   []string               `json:"addHushIDs,omitempty"`
	RemoveHushIDs                []string               `json:"removeHushIDs,omitempty"`
	ClearHush                    *bool                  `json:"clearHush,omitempty"`
	AddEntitlementIDs            []string               `json:"addEntitlementIDs,omitempty"`
	RemoveEntitlementIDs         []string               `json:"removeEntitlementIDs,omitempty"`
	ClearEntitlement             *bool                  `json:"clearEntitlement,omitempty"`
	AddWebhookIDs                []string               `json:"addWebhookIDs,omitempty"`
	RemoveWebhookIDs             []string               `json:"removeWebhookIDs,omitempty"`
	ClearWebhook                 *bool                  `json:"clearWebhook,omitempty"`
	AddSubscriberIDs             []string               `json:"addSubscriberIDs,omitempty"`
	RemoveSubscriberIDs          []string               `json:"removeSubscriberIDs,omitempty"`
	ClearSubscriber              *bool                  `json:"clearSubscriber,omitempty"`
}

// UpdateFeatureInput is used for update Feature object.
// Input was generated by ent.
type UpdateFeatureInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the displayed 'friendly' name of the feature
	DisplayName      *string `json:"displayName,omitempty"`
	ClearDisplayName *bool   `json:"clearDisplayName,omitempty"`
	// enabled features are available for use
	Enabled *bool `json:"enabled,omitempty"`
	// a description of the feature
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// metadata for the feature
	Metadata       map[string]interface{} `json:"metadata,omitempty"`
	ClearMetadata  *bool                  `json:"clearMetadata,omitempty"`
	OwnerID        *string                `json:"ownerID,omitempty"`
	ClearOwner     *bool                  `json:"clearOwner,omitempty"`
	AddPlanIDs     []string               `json:"addPlanIDs,omitempty"`
	RemovePlanIDs  []string               `json:"removePlanIDs,omitempty"`
	ClearPlans     *bool                  `json:"clearPlans,omitempty"`
	AddEventIDs    []string               `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string               `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool                  `json:"clearEvents,omitempty"`
}

// UpdateFileInput is used for update File object.
// Input was generated by ent.
type UpdateFileInput struct {
	// tags associated with the object
	Tags                  []string `json:"tags,omitempty"`
	AppendTags            []string `json:"appendTags,omitempty"`
	ClearTags             *bool    `json:"clearTags,omitempty"`
	FileName              *string  `json:"fileName,omitempty"`
	FileExtension         *string  `json:"fileExtension,omitempty"`
	FileSize              *int64   `json:"fileSize,omitempty"`
	ClearFileSize         *bool    `json:"clearFileSize,omitempty"`
	ContentType           *string  `json:"contentType,omitempty"`
	StoreKey              *string  `json:"storeKey,omitempty"`
	Category              *string  `json:"category,omitempty"`
	ClearCategory         *bool    `json:"clearCategory,omitempty"`
	Annotation            *string  `json:"annotation,omitempty"`
	ClearAnnotation       *bool    `json:"clearAnnotation,omitempty"`
	UserID                *string  `json:"userID,omitempty"`
	ClearUser             *bool    `json:"clearUser,omitempty"`
	AddOrganizationIDs    []string `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs []string `json:"removeOrganizationIDs,omitempty"`
	ClearOrganization     *bool    `json:"clearOrganization,omitempty"`
	AddEntityIDs          []string `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs       []string `json:"removeEntityIDs,omitempty"`
	ClearEntity           *bool    `json:"clearEntity,omitempty"`
	AddGroupIDs           []string `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs        []string `json:"removeGroupIDs,omitempty"`
	ClearGroup            *bool    `json:"clearGroup,omitempty"`
}

// UpdateGroupInput is used for update Group object.
// Input was generated by ent.
type UpdateGroupInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the group - must be unique within the organization
	Name *string `json:"name,omitempty"`
	// the groups description
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the URL to an auto generated gravatar image for the group
	GravatarLogoURL      *string `json:"gravatarLogoURL,omitempty"`
	ClearGravatarLogoURL *bool   `json:"clearGravatarLogoURL,omitempty"`
	// the URL to an image uploaded by the customer for the groups avatar image
	LogoURL      *string `json:"logoURL,omitempty"`
	ClearLogoURL *bool   `json:"clearLogoURL,omitempty"`
	// The group's displayed 'friendly' name
	DisplayName          *string                       `json:"displayName,omitempty"`
	OwnerID              *string                       `json:"ownerID,omitempty"`
	ClearOwner           *bool                         `json:"clearOwner,omitempty"`
	SettingID            *string                       `json:"settingID,omitempty"`
	AddUserIDs           []string                      `json:"addUserIDs,omitempty"`
	RemoveUserIDs        []string                      `json:"removeUserIDs,omitempty"`
	ClearUsers           *bool                         `json:"clearUsers,omitempty"`
	AddEventIDs          []string                      `json:"addEventIDs,omitempty"`
	RemoveEventIDs       []string                      `json:"removeEventIDs,omitempty"`
	ClearEvents          *bool                         `json:"clearEvents,omitempty"`
	AddIntegrationIDs    []string                      `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs []string                      `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations    *bool                         `json:"clearIntegrations,omitempty"`
	AddFileIDs           []string                      `json:"addFileIDs,omitempty"`
	RemoveFileIDs        []string                      `json:"removeFileIDs,omitempty"`
	ClearFiles           *bool                         `json:"clearFiles,omitempty"`
	AddGroupMembers      []*CreateGroupMembershipInput `json:"addGroupMembers,omitempty"`
	UpdateGroupSettings  *UpdateGroupSettingInput      `json:"updateGroupSettings,omitempty"`
}

// UpdateGroupMembershipInput is used for update GroupMembership object.
// Input was generated by ent.
type UpdateGroupMembershipInput struct {
	Role           *enums.Role `json:"role,omitempty"`
	AddEventIDs    []string    `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string    `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool       `json:"clearEvents,omitempty"`
}

// UpdateGroupSettingInput is used for update GroupSetting object.
// Input was generated by ent.
type UpdateGroupSettingInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// whether the group is visible to it's members / owners only or if it's searchable by anyone within the organization
	Visibility *enums.Visibility `json:"visibility,omitempty"`
	// the policy governing ability to freely join a group, whether it requires an invitation, application, or either
	JoinPolicy *enums.JoinPolicy `json:"joinPolicy,omitempty"`
	// whether to sync group members to slack groups
	SyncToSlack      *bool `json:"syncToSlack,omitempty"`
	ClearSyncToSlack *bool `json:"clearSyncToSlack,omitempty"`
	// whether to sync group members to github groups
	SyncToGithub      *bool   `json:"syncToGithub,omitempty"`
	ClearSyncToGithub *bool   `json:"clearSyncToGithub,omitempty"`
	GroupID           *string `json:"groupID,omitempty"`
	ClearGroup        *bool   `json:"clearGroup,omitempty"`
}

// UpdateHushInput is used for update Hush object.
// Input was generated by ent.
type UpdateHushInput struct {
	// the logical name of the corresponding hush secret or it's general grouping
	Name *string `json:"name,omitempty"`
	// a description of the hush value or purpose, such as github PAT
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the kind of secret, such as sshkey, certificate, api token, etc.
	Kind                  *string  `json:"kind,omitempty"`
	ClearKind             *bool    `json:"clearKind,omitempty"`
	AddIntegrationIDs     []string `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs  []string `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations     *bool    `json:"clearIntegrations,omitempty"`
	AddOrganizationIDs    []string `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs []string `json:"removeOrganizationIDs,omitempty"`
	ClearOrganization     *bool    `json:"clearOrganization,omitempty"`
	AddEventIDs           []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs        []string `json:"removeEventIDs,omitempty"`
	ClearEvents           *bool    `json:"clearEvents,omitempty"`
}

// UpdateIntegrationInput is used for update Integration object.
// Input was generated by ent.
type UpdateIntegrationInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the integration - must be unique within the organization
	Name *string `json:"name,omitempty"`
	// a description of the integration
	Description          *string  `json:"description,omitempty"`
	ClearDescription     *bool    `json:"clearDescription,omitempty"`
	Kind                 *string  `json:"kind,omitempty"`
	ClearKind            *bool    `json:"clearKind,omitempty"`
	OwnerID              *string  `json:"ownerID,omitempty"`
	ClearOwner           *bool    `json:"clearOwner,omitempty"`
	AddSecretIDs         []string `json:"addSecretIDs,omitempty"`
	RemoveSecretIDs      []string `json:"removeSecretIDs,omitempty"`
	ClearSecrets         *bool    `json:"clearSecrets,omitempty"`
	AddOauth2tokenIDs    []string `json:"addOauth2tokenIDs,omitempty"`
	RemoveOauth2tokenIDs []string `json:"removeOauth2tokenIDs,omitempty"`
	ClearOauth2tokens    *bool    `json:"clearOauth2tokens,omitempty"`
	AddEventIDs          []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs       []string `json:"removeEventIDs,omitempty"`
	ClearEvents          *bool    `json:"clearEvents,omitempty"`
	AddWebhookIDs        []string `json:"addWebhookIDs,omitempty"`
	RemoveWebhookIDs     []string `json:"removeWebhookIDs,omitempty"`
	ClearWebhooks        *bool    `json:"clearWebhooks,omitempty"`
}

// UpdateInviteInput is used for update Invite object.
// Input was generated by ent.
type UpdateInviteInput struct {
	// the expiration date of the invitation token which defaults to 14 days in the future from creation
	Expires      *time.Time `json:"expires,omitempty"`
	ClearExpires *bool      `json:"clearExpires,omitempty"`
	// the status of the invitation
	Status *enums.InviteStatus `json:"status,omitempty"`
	Role   *enums.Role         `json:"role,omitempty"`
	// the number of attempts made to perform email send of the invitation, maximum of 5
	SendAttempts   *int64   `json:"sendAttempts,omitempty"`
	OwnerID        *string  `json:"ownerID,omitempty"`
	ClearOwner     *bool    `json:"clearOwner,omitempty"`
	AddEventIDs    []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool    `json:"clearEvents,omitempty"`
}

// UpdateNoteInput is used for update Note object.
// Input was generated by ent.
type UpdateNoteInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the text of the note
	Text        *string `json:"text,omitempty"`
	OwnerID     *string `json:"ownerID,omitempty"`
	ClearOwner  *bool   `json:"clearOwner,omitempty"`
	EntityID    *string `json:"entityID,omitempty"`
	ClearEntity *bool   `json:"clearEntity,omitempty"`
}

// UpdateOauthProviderInput is used for update OauthProvider object.
// Input was generated by ent.
type UpdateOauthProviderInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the oauth provider's name
	Name *string `json:"name,omitempty"`
	// the client id for the oauth provider
	ClientID *string `json:"clientID,omitempty"`
	// the client secret
	ClientSecret *string `json:"clientSecret,omitempty"`
	// the redirect url
	RedirectURL *string `json:"redirectURL,omitempty"`
	// the scopes
	Scopes *string `json:"scopes,omitempty"`
	// the auth url of the provider
	AuthURL *string `json:"authURL,omitempty"`
	// the token url of the provider
	TokenURL *string `json:"tokenURL,omitempty"`
	// the auth style, 0: auto detect 1: third party log in 2: log in with username and password
	AuthStyle *string `json:"authStyle,omitempty"`
	// the URL to request user information by token
	InfoURL    *string `json:"infoURL,omitempty"`
	OwnerID    *string `json:"ownerID,omitempty"`
	ClearOwner *bool   `json:"clearOwner,omitempty"`
}

// UpdateOhAuthTooTokenInput is used for update OhAuthTooToken object.
// Input was generated by ent.
type UpdateOhAuthTooTokenInput struct {
	// tags associated with the object
	Tags                    []string   `json:"tags,omitempty"`
	AppendTags              []string   `json:"appendTags,omitempty"`
	ClearTags               *bool      `json:"clearTags,omitempty"`
	ClientID                *string    `json:"clientID,omitempty"`
	Scopes                  []string   `json:"scopes,omitempty"`
	AppendScopes            []string   `json:"appendScopes,omitempty"`
	ClearScopes             *bool      `json:"clearScopes,omitempty"`
	Nonce                   *string    `json:"nonce,omitempty"`
	ClaimsUserID            *string    `json:"claimsUserID,omitempty"`
	ClaimsUsername          *string    `json:"claimsUsername,omitempty"`
	ClaimsEmail             *string    `json:"claimsEmail,omitempty"`
	ClaimsEmailVerified     *bool      `json:"claimsEmailVerified,omitempty"`
	ClaimsGroups            []string   `json:"claimsGroups,omitempty"`
	AppendClaimsGroups      []string   `json:"appendClaimsGroups,omitempty"`
	ClearClaimsGroups       *bool      `json:"clearClaimsGroups,omitempty"`
	ClaimsPreferredUsername *string    `json:"claimsPreferredUsername,omitempty"`
	ConnectorID             *string    `json:"connectorID,omitempty"`
	ConnectorData           []string   `json:"connectorData,omitempty"`
	AppendConnectorData     []string   `json:"appendConnectorData,omitempty"`
	ClearConnectorData      *bool      `json:"clearConnectorData,omitempty"`
	LastUsed                *time.Time `json:"lastUsed,omitempty"`
	AddIntegrationIDs       []string   `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs    []string   `json:"removeIntegrationIDs,omitempty"`
	ClearIntegration        *bool      `json:"clearIntegration,omitempty"`
	AddEventIDs             []string   `json:"addEventIDs,omitempty"`
	RemoveEventIDs          []string   `json:"removeEventIDs,omitempty"`
	ClearEvents             *bool      `json:"clearEvents,omitempty"`
}

// UpdateOrgMembershipInput is used for update OrgMembership object.
// Input was generated by ent.
type UpdateOrgMembershipInput struct {
	Role           *enums.Role `json:"role,omitempty"`
	AddEventIDs    []string    `json:"addEventIDs,omitempty"`
	RemoveEventIDs []string    `json:"removeEventIDs,omitempty"`
	ClearEvents    *bool       `json:"clearEvents,omitempty"`
}

// UpdateOrganizationInput is used for update Organization object.
// Input was generated by ent.
type UpdateOrganizationInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the organization
	Name *string `json:"name,omitempty"`
	// The organization's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// An optional description of the organization
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL                  *string                         `json:"avatarRemoteURL,omitempty"`
	ClearAvatarRemoteURL             *bool                           `json:"clearAvatarRemoteURL,omitempty"`
	AddGroupIDs                      []string                        `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs                   []string                        `json:"removeGroupIDs,omitempty"`
	ClearGroups                      *bool                           `json:"clearGroups,omitempty"`
	AddTemplateIDs                   []string                        `json:"addTemplateIDs,omitempty"`
	RemoveTemplateIDs                []string                        `json:"removeTemplateIDs,omitempty"`
	ClearTemplates                   *bool                           `json:"clearTemplates,omitempty"`
	AddIntegrationIDs                []string                        `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs             []string                        `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations                *bool                           `json:"clearIntegrations,omitempty"`
	SettingID                        *string                         `json:"settingID,omitempty"`
	ClearSetting                     *bool                           `json:"clearSetting,omitempty"`
	AddDocumentdatumIDs              []string                        `json:"addDocumentdatumIDs,omitempty"`
	RemoveDocumentdatumIDs           []string                        `json:"removeDocumentdatumIDs,omitempty"`
	ClearDocumentdata                *bool                           `json:"clearDocumentdata,omitempty"`
	AddEntitlementIDs                []string                        `json:"addEntitlementIDs,omitempty"`
	RemoveEntitlementIDs             []string                        `json:"removeEntitlementIDs,omitempty"`
	ClearEntitlements                *bool                           `json:"clearEntitlements,omitempty"`
	AddOrganizationEntitlementIDs    []string                        `json:"addOrganizationEntitlementIDs,omitempty"`
	RemoveOrganizationEntitlementIDs []string                        `json:"removeOrganizationEntitlementIDs,omitempty"`
	ClearOrganizationEntitlement     *bool                           `json:"clearOrganizationEntitlement,omitempty"`
	AddPersonalAccessTokenIDs        []string                        `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs     []string                        `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessTokens        *bool                           `json:"clearPersonalAccessTokens,omitempty"`
	AddAPITokenIDs                   []string                        `json:"addAPITokenIDs,omitempty"`
	RemoveAPITokenIDs                []string                        `json:"removeAPITokenIDs,omitempty"`
	ClearAPITokens                   *bool                           `json:"clearAPITokens,omitempty"`
	AddOauthproviderIDs              []string                        `json:"addOauthproviderIDs,omitempty"`
	RemoveOauthproviderIDs           []string                        `json:"removeOauthproviderIDs,omitempty"`
	ClearOauthprovider               *bool                           `json:"clearOauthprovider,omitempty"`
	AddUserIDs                       []string                        `json:"addUserIDs,omitempty"`
	RemoveUserIDs                    []string                        `json:"removeUserIDs,omitempty"`
	ClearUsers                       *bool                           `json:"clearUsers,omitempty"`
	AddInviteIDs                     []string                        `json:"addInviteIDs,omitempty"`
	RemoveInviteIDs                  []string                        `json:"removeInviteIDs,omitempty"`
	ClearInvites                     *bool                           `json:"clearInvites,omitempty"`
	AddSubscriberIDs                 []string                        `json:"addSubscriberIDs,omitempty"`
	RemoveSubscriberIDs              []string                        `json:"removeSubscriberIDs,omitempty"`
	ClearSubscribers                 *bool                           `json:"clearSubscribers,omitempty"`
	AddWebhookIDs                    []string                        `json:"addWebhookIDs,omitempty"`
	RemoveWebhookIDs                 []string                        `json:"removeWebhookIDs,omitempty"`
	ClearWebhooks                    *bool                           `json:"clearWebhooks,omitempty"`
	AddEventIDs                      []string                        `json:"addEventIDs,omitempty"`
	RemoveEventIDs                   []string                        `json:"removeEventIDs,omitempty"`
	ClearEvents                      *bool                           `json:"clearEvents,omitempty"`
	AddSecretIDs                     []string                        `json:"addSecretIDs,omitempty"`
	RemoveSecretIDs                  []string                        `json:"removeSecretIDs,omitempty"`
	ClearSecrets                     *bool                           `json:"clearSecrets,omitempty"`
	AddFeatureIDs                    []string                        `json:"addFeatureIDs,omitempty"`
	RemoveFeatureIDs                 []string                        `json:"removeFeatureIDs,omitempty"`
	ClearFeatures                    *bool                           `json:"clearFeatures,omitempty"`
	AddFileIDs                       []string                        `json:"addFileIDs,omitempty"`
	RemoveFileIDs                    []string                        `json:"removeFileIDs,omitempty"`
	ClearFiles                       *bool                           `json:"clearFiles,omitempty"`
	AddEntitlementplanIDs            []string                        `json:"addEntitlementplanIDs,omitempty"`
	RemoveEntitlementplanIDs         []string                        `json:"removeEntitlementplanIDs,omitempty"`
	ClearEntitlementplans            *bool                           `json:"clearEntitlementplans,omitempty"`
	AddEntityIDs                     []string                        `json:"addEntityIDs,omitempty"`
	RemoveEntityIDs                  []string                        `json:"removeEntityIDs,omitempty"`
	ClearEntities                    *bool                           `json:"clearEntities,omitempty"`
	AddEntitytypeIDs                 []string                        `json:"addEntitytypeIDs,omitempty"`
	RemoveEntitytypeIDs              []string                        `json:"removeEntitytypeIDs,omitempty"`
	ClearEntitytypes                 *bool                           `json:"clearEntitytypes,omitempty"`
	AddContactIDs                    []string                        `json:"addContactIDs,omitempty"`
	RemoveContactIDs                 []string                        `json:"removeContactIDs,omitempty"`
	ClearContacts                    *bool                           `json:"clearContacts,omitempty"`
	AddNoteIDs                       []string                        `json:"addNoteIDs,omitempty"`
	RemoveNoteIDs                    []string                        `json:"removeNoteIDs,omitempty"`
	ClearNotes                       *bool                           `json:"clearNotes,omitempty"`
	AddOrgMembers                    []*CreateOrgMembershipInput     `json:"addOrgMembers,omitempty"`
	UpdateOrgSettings                *UpdateOrganizationSettingInput `json:"updateOrgSettings,omitempty"`
}

// UpdateOrganizationSettingInput is used for update OrganizationSetting object.
// Input was generated by ent.
type UpdateOrganizationSettingInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// domains associated with the organization
	Domains       []string `json:"domains,omitempty"`
	AppendDomains []string `json:"appendDomains,omitempty"`
	ClearDomains  *bool    `json:"clearDomains,omitempty"`
	// Name of the person to contact for billing
	BillingContact      *string `json:"billingContact,omitempty"`
	ClearBillingContact *bool   `json:"clearBillingContact,omitempty"`
	// Email address of the person to contact for billing
	BillingEmail      *string `json:"billingEmail,omitempty"`
	ClearBillingEmail *bool   `json:"clearBillingEmail,omitempty"`
	// Phone number to contact for billing
	BillingPhone      *string `json:"billingPhone,omitempty"`
	ClearBillingPhone *bool   `json:"clearBillingPhone,omitempty"`
	// Address to send billing information to
	BillingAddress      *string `json:"billingAddress,omitempty"`
	ClearBillingAddress *bool   `json:"clearBillingAddress,omitempty"`
	// Usually government-issued tax ID or business ID such as ABN in Australia
	TaxIdentifier      *string `json:"taxIdentifier,omitempty"`
	ClearTaxIdentifier *bool   `json:"clearTaxIdentifier,omitempty"`
	// geographical location of the organization
	GeoLocation       *enums.Region `json:"geoLocation,omitempty"`
	ClearGeoLocation  *bool         `json:"clearGeoLocation,omitempty"`
	OrganizationID    *string       `json:"organizationID,omitempty"`
	ClearOrganization *bool         `json:"clearOrganization,omitempty"`
}

// UpdatePersonalAccessTokenInput is used for update PersonalAccessToken object.
// Input was generated by ent.
type UpdatePersonalAccessTokenInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name associated with the token
	Name *string `json:"name,omitempty"`
	// a description of the token's purpose
	Description           *string    `json:"description,omitempty"`
	ClearDescription      *bool      `json:"clearDescription,omitempty"`
	Scopes                []string   `json:"scopes,omitempty"`
	AppendScopes          []string   `json:"appendScopes,omitempty"`
	ClearScopes           *bool      `json:"clearScopes,omitempty"`
	LastUsedAt            *time.Time `json:"lastUsedAt,omitempty"`
	ClearLastUsedAt       *bool      `json:"clearLastUsedAt,omitempty"`
	AddOrganizationIDs    []string   `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs []string   `json:"removeOrganizationIDs,omitempty"`
	ClearOrganizations    *bool      `json:"clearOrganizations,omitempty"`
	AddEventIDs           []string   `json:"addEventIDs,omitempty"`
	RemoveEventIDs        []string   `json:"removeEventIDs,omitempty"`
	ClearEvents           *bool      `json:"clearEvents,omitempty"`
}

// UpdateSubscriberInput is used for update Subscriber object.
// Input was generated by ent.
type UpdateSubscriberInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// email address of the subscriber
	Email *string `json:"email,omitempty"`
	// phone number of the subscriber
	PhoneNumber      *string  `json:"phoneNumber,omitempty"`
	ClearPhoneNumber *bool    `json:"clearPhoneNumber,omitempty"`
	OwnerID          *string  `json:"ownerID,omitempty"`
	ClearOwner       *bool    `json:"clearOwner,omitempty"`
	AddEventIDs      []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs   []string `json:"removeEventIDs,omitempty"`
	ClearEvents      *bool    `json:"clearEvents,omitempty"`
}

// UpdateTFASettingInput is used for update TFASetting object.
// Input was generated by ent.
type UpdateTFASettingInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// specifies if the TFA device has been verified
	Verified *bool `json:"verified,omitempty"`
	// specifies a user may complete authentication by verifying a TOTP code delivered through an authenticator app
	TotpAllowed      *bool `json:"totpAllowed,omitempty"`
	ClearTotpAllowed *bool `json:"clearTotpAllowed,omitempty"`
	// Whether to regenerate backup codes
	RegenBackupCodes *bool `json:"regenBackupCodes,omitempty"`
}

// UpdateTemplateInput is used for update Template object.
// Input was generated by ent.
type UpdateTemplateInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the template
	Name *string `json:"name,omitempty"`
	// the type of the template, either a provided template or an implementation (document)
	TemplateType *enums.DocumentType `json:"templateType,omitempty"`
	// the description of the template
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the jsonschema object of the template
	Jsonconfig json.RawMessage `json:"jsonconfig,omitempty"`
	// the uischema for the template to render in the UI
	Uischema          json.RawMessage `json:"uischema,omitempty"`
	ClearUischema     *bool           `json:"clearUischema,omitempty"`
	OwnerID           *string         `json:"ownerID,omitempty"`
	ClearOwner        *bool           `json:"clearOwner,omitempty"`
	AddDocumentIDs    []string        `json:"addDocumentIDs,omitempty"`
	RemoveDocumentIDs []string        `json:"removeDocumentIDs,omitempty"`
	ClearDocuments    *bool           `json:"clearDocuments,omitempty"`
}

// UpdateUserInput is used for update User object.
// Input was generated by ent.
type UpdateUserInput struct {
	// tags associated with the object
	Tags           []string `json:"tags,omitempty"`
	AppendTags     []string `json:"appendTags,omitempty"`
	ClearTags      *bool    `json:"clearTags,omitempty"`
	Email          *string  `json:"email,omitempty"`
	FirstName      *string  `json:"firstName,omitempty"`
	ClearFirstName *bool    `json:"clearFirstName,omitempty"`
	LastName       *string  `json:"lastName,omitempty"`
	ClearLastName  *bool    `json:"clearLastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName *string `json:"displayName,omitempty"`
	// URL of the user's remote avatar
	AvatarRemoteURL      *string `json:"avatarRemoteURL,omitempty"`
	ClearAvatarRemoteURL *bool   `json:"clearAvatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile      *string `json:"avatarLocalFile,omitempty"`
	ClearAvatarLocalFile *bool   `json:"clearAvatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt      *time.Time `json:"avatarUpdatedAt,omitempty"`
	ClearAvatarUpdatedAt *bool      `json:"clearAvatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen      *time.Time `json:"lastSeen,omitempty"`
	ClearLastSeen *bool      `json:"clearLastSeen,omitempty"`
	// user password hash
	Password      *string `json:"password,omitempty"`
	ClearPassword *bool   `json:"clearPassword,omitempty"`
	// the Subject of the user JWT
	Sub      *string `json:"sub,omitempty"`
	ClearSub *bool   `json:"clearSub,omitempty"`
	// auth provider used to register the account
	AuthProvider *enums.AuthProvider `json:"authProvider,omitempty"`
	// the user's role
	Role                            *enums.Role `json:"role,omitempty"`
	ClearRole                       *bool       `json:"clearRole,omitempty"`
	AddPersonalAccessTokenIDs       []string    `json:"addPersonalAccessTokenIDs,omitempty"`
	RemovePersonalAccessTokenIDs    []string    `json:"removePersonalAccessTokenIDs,omitempty"`
	ClearPersonalAccessTokens       *bool       `json:"clearPersonalAccessTokens,omitempty"`
	AddTfaSettingIDs                []string    `json:"addTfaSettingIDs,omitempty"`
	RemoveTfaSettingIDs             []string    `json:"removeTfaSettingIDs,omitempty"`
	ClearTfaSettings                *bool       `json:"clearTfaSettings,omitempty"`
	SettingID                       *string     `json:"settingID,omitempty"`
	AddEmailVerificationTokenIDs    []string    `json:"addEmailVerificationTokenIDs,omitempty"`
	RemoveEmailVerificationTokenIDs []string    `json:"removeEmailVerificationTokenIDs,omitempty"`
	ClearEmailVerificationTokens    *bool       `json:"clearEmailVerificationTokens,omitempty"`
	AddPasswordResetTokenIDs        []string    `json:"addPasswordResetTokenIDs,omitempty"`
	RemovePasswordResetTokenIDs     []string    `json:"removePasswordResetTokenIDs,omitempty"`
	ClearPasswordResetTokens        *bool       `json:"clearPasswordResetTokens,omitempty"`
	AddGroupIDs                     []string    `json:"addGroupIDs,omitempty"`
	RemoveGroupIDs                  []string    `json:"removeGroupIDs,omitempty"`
	ClearGroups                     *bool       `json:"clearGroups,omitempty"`
	AddOrganizationIDs              []string    `json:"addOrganizationIDs,omitempty"`
	RemoveOrganizationIDs           []string    `json:"removeOrganizationIDs,omitempty"`
	ClearOrganizations              *bool       `json:"clearOrganizations,omitempty"`
	AddWebauthnIDs                  []string    `json:"addWebauthnIDs,omitempty"`
	RemoveWebauthnIDs               []string    `json:"removeWebauthnIDs,omitempty"`
	ClearWebauthn                   *bool       `json:"clearWebauthn,omitempty"`
	AddFileIDs                      []string    `json:"addFileIDs,omitempty"`
	RemoveFileIDs                   []string    `json:"removeFileIDs,omitempty"`
	ClearFiles                      *bool       `json:"clearFiles,omitempty"`
	AddEventIDs                     []string    `json:"addEventIDs,omitempty"`
	RemoveEventIDs                  []string    `json:"removeEventIDs,omitempty"`
	ClearEvents                     *bool       `json:"clearEvents,omitempty"`
}

// UpdateUserSettingInput is used for update UserSetting object.
// Input was generated by ent.
type UpdateUserSettingInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked *bool `json:"locked,omitempty"`
	// The time notifications regarding the user were silenced
	SilencedAt      *time.Time `json:"silencedAt,omitempty"`
	ClearSilencedAt *bool      `json:"clearSilencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt      *time.Time `json:"suspendedAt,omitempty"`
	ClearSuspendedAt *bool      `json:"clearSuspendedAt,omitempty"`
	// status of the user account
	Status *enums.UserStatus `json:"status,omitempty"`
	// whether the user has confirmed their email address
	EmailConfirmed *bool `json:"emailConfirmed,omitempty"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed      *bool `json:"isWebauthnAllowed,omitempty"`
	ClearIsWebauthnAllowed *bool `json:"clearIsWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled      *bool   `json:"isTfaEnabled,omitempty"`
	ClearIsTfaEnabled *bool   `json:"clearIsTfaEnabled,omitempty"`
	UserID            *string `json:"userID,omitempty"`
	ClearUser         *bool   `json:"clearUser,omitempty"`
	DefaultOrgID      *string `json:"defaultOrgID,omitempty"`
	ClearDefaultOrg   *bool   `json:"clearDefaultOrg,omitempty"`
}

// UpdateWebhookInput is used for update Webhook object.
// Input was generated by ent.
type UpdateWebhookInput struct {
	// tags associated with the object
	Tags       []string `json:"tags,omitempty"`
	AppendTags []string `json:"appendTags,omitempty"`
	ClearTags  *bool    `json:"clearTags,omitempty"`
	// the name of the webhook
	Name *string `json:"name,omitempty"`
	// a description of the webhook
	Description      *string `json:"description,omitempty"`
	ClearDescription *bool   `json:"clearDescription,omitempty"`
	// the url to send the webhook to
	DestinationURL *string `json:"destinationURL,omitempty"`
	// indicates if the webhook is active and enabled
	Enabled *bool `json:"enabled,omitempty"`
	// the number of failures
	Failures      *int64 `json:"failures,omitempty"`
	ClearFailures *bool  `json:"clearFailures,omitempty"`
	// the last error message
	LastError      *string `json:"lastError,omitempty"`
	ClearLastError *bool   `json:"clearLastError,omitempty"`
	// the last response
	LastResponse         *string  `json:"lastResponse,omitempty"`
	ClearLastResponse    *bool    `json:"clearLastResponse,omitempty"`
	OwnerID              *string  `json:"ownerID,omitempty"`
	ClearOwner           *bool    `json:"clearOwner,omitempty"`
	AddEventIDs          []string `json:"addEventIDs,omitempty"`
	RemoveEventIDs       []string `json:"removeEventIDs,omitempty"`
	ClearEvents          *bool    `json:"clearEvents,omitempty"`
	AddIntegrationIDs    []string `json:"addIntegrationIDs,omitempty"`
	RemoveIntegrationIDs []string `json:"removeIntegrationIDs,omitempty"`
	ClearIntegrations    *bool    `json:"clearIntegrations,omitempty"`
}

type User struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags      []string `json:"tags,omitempty"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName,omitempty"`
	LastName  *string  `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile *string `json:"avatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// auth provider used to register the account
	AuthProvider enums.AuthProvider `json:"authProvider"`
	// the user's role
	Role                 *enums.Role            `json:"role,omitempty"`
	PersonalAccessTokens []*PersonalAccessToken `json:"personalAccessTokens,omitempty"`
	TfaSettings          []*TFASetting          `json:"tfaSettings,omitempty"`
	Setting              *UserSetting           `json:"setting"`
	Groups               []*Group               `json:"groups,omitempty"`
	Organizations        []*Organization        `json:"organizations,omitempty"`
	Files                []*File                `json:"files,omitempty"`
	Events               []*Event               `json:"events,omitempty"`
	GroupMemberships     []*GroupMembership     `json:"groupMemberships,omitempty"`
	OrgMemberships       []*OrgMembership       `json:"orgMemberships,omitempty"`
}

func (User) IsNode() {}

// Return response for createBulkUser mutation
type UserBulkCreatePayload struct {
	// Created users
	Users []*User `json:"users,omitempty"`
}

// A connection to a list of items.
type UserConnection struct {
	// A list of edges.
	Edges []*UserEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUser mutation
type UserCreatePayload struct {
	// Created user
	User *User `json:"user"`
}

// Return response for deleteUser mutation
type UserDeletePayload struct {
	// Deleted user ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type UserEdge struct {
	// The item at the end of the edge.
	Node *User `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type UserHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	DeletedAt   *time.Time     `json:"deletedAt,omitempty"`
	DeletedBy   *string        `json:"deletedBy,omitempty"`
	// tags associated with the object
	Tags      []string `json:"tags,omitempty"`
	Email     string   `json:"email"`
	FirstName *string  `json:"firstName,omitempty"`
	LastName  *string  `json:"lastName,omitempty"`
	// The user's displayed 'friendly' name
	DisplayName string `json:"displayName"`
	// URL of the user's remote avatar
	AvatarRemoteURL *string `json:"avatarRemoteURL,omitempty"`
	// The user's local avatar file
	AvatarLocalFile *string `json:"avatarLocalFile,omitempty"`
	// The time the user's (local) avatar was last updated
	AvatarUpdatedAt *time.Time `json:"avatarUpdatedAt,omitempty"`
	// the time the user was last seen
	LastSeen *time.Time `json:"lastSeen,omitempty"`
	// the Subject of the user JWT
	Sub *string `json:"sub,omitempty"`
	// auth provider used to register the account
	AuthProvider enums.AuthProvider `json:"authProvider"`
	// the user's role
	Role *enums.Role `json:"role,omitempty"`
}

func (UserHistory) IsNode() {}

// A connection to a list of items.
type UserHistoryConnection struct {
	// A list of edges.
	Edges []*UserHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type UserHistoryEdge struct {
	// The item at the end of the edge.
	Node *UserHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for UserHistory connections
type UserHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order UserHistories.
	Field UserHistoryOrderField `json:"field"`
}

// UserHistoryWhereInput is used for filtering UserHistory objects.
// Input was generated by ent.
type UserHistoryWhereInput struct {
	Not *UserHistoryWhereInput   `json:"not,omitempty"`
	And []*UserHistoryWhereInput `json:"and,omitempty"`
	Or  []*UserHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// first_name field predicates
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNeq          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGt           *string  `json:"firstNameGT,omitempty"`
	FirstNameGte          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLt           *string  `json:"firstNameLT,omitempty"`
	FirstNameLte          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        *bool    `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       *bool    `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`
	// last_name field predicates
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNeq          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGt           *string  `json:"lastNameGT,omitempty"`
	LastNameGte          *string  `json:"lastNameGTE,omitempty"`
	LastNameLt           *string  `json:"lastNameLT,omitempty"`
	LastNameLte          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        *bool    `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       *bool    `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file field predicates
	AvatarLocalFile             *string  `json:"avatarLocalFile,omitempty"`
	AvatarLocalFileNeq          *string  `json:"avatarLocalFileNEQ,omitempty"`
	AvatarLocalFileIn           []string `json:"avatarLocalFileIn,omitempty"`
	AvatarLocalFileNotIn        []string `json:"avatarLocalFileNotIn,omitempty"`
	AvatarLocalFileGt           *string  `json:"avatarLocalFileGT,omitempty"`
	AvatarLocalFileGte          *string  `json:"avatarLocalFileGTE,omitempty"`
	AvatarLocalFileLt           *string  `json:"avatarLocalFileLT,omitempty"`
	AvatarLocalFileLte          *string  `json:"avatarLocalFileLTE,omitempty"`
	AvatarLocalFileContains     *string  `json:"avatarLocalFileContains,omitempty"`
	AvatarLocalFileHasPrefix    *string  `json:"avatarLocalFileHasPrefix,omitempty"`
	AvatarLocalFileHasSuffix    *string  `json:"avatarLocalFileHasSuffix,omitempty"`
	AvatarLocalFileIsNil        *bool    `json:"avatarLocalFileIsNil,omitempty"`
	AvatarLocalFileNotNil       *bool    `json:"avatarLocalFileNotNil,omitempty"`
	AvatarLocalFileEqualFold    *string  `json:"avatarLocalFileEqualFold,omitempty"`
	AvatarLocalFileContainsFold *string  `json:"avatarLocalFileContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// last_seen field predicates
	LastSeen       *time.Time   `json:"lastSeen,omitempty"`
	LastSeenNeq    *time.Time   `json:"lastSeenNEQ,omitempty"`
	LastSeenIn     []*time.Time `json:"lastSeenIn,omitempty"`
	LastSeenNotIn  []*time.Time `json:"lastSeenNotIn,omitempty"`
	LastSeenGt     *time.Time   `json:"lastSeenGT,omitempty"`
	LastSeenGte    *time.Time   `json:"lastSeenGTE,omitempty"`
	LastSeenLt     *time.Time   `json:"lastSeenLT,omitempty"`
	LastSeenLte    *time.Time   `json:"lastSeenLTE,omitempty"`
	LastSeenIsNil  *bool        `json:"lastSeenIsNil,omitempty"`
	LastSeenNotNil *bool        `json:"lastSeenNotNil,omitempty"`
	// sub field predicates
	Sub             *string  `json:"sub,omitempty"`
	SubNeq          *string  `json:"subNEQ,omitempty"`
	SubIn           []string `json:"subIn,omitempty"`
	SubNotIn        []string `json:"subNotIn,omitempty"`
	SubGt           *string  `json:"subGT,omitempty"`
	SubGte          *string  `json:"subGTE,omitempty"`
	SubLt           *string  `json:"subLT,omitempty"`
	SubLte          *string  `json:"subLTE,omitempty"`
	SubContains     *string  `json:"subContains,omitempty"`
	SubHasPrefix    *string  `json:"subHasPrefix,omitempty"`
	SubHasSuffix    *string  `json:"subHasSuffix,omitempty"`
	SubIsNil        *bool    `json:"subIsNil,omitempty"`
	SubNotNil       *bool    `json:"subNotNil,omitempty"`
	SubEqualFold    *string  `json:"subEqualFold,omitempty"`
	SubContainsFold *string  `json:"subContainsFold,omitempty"`
	// auth_provider field predicates
	AuthProvider      *enums.AuthProvider  `json:"authProvider,omitempty"`
	AuthProviderNeq   *enums.AuthProvider  `json:"authProviderNEQ,omitempty"`
	AuthProviderIn    []enums.AuthProvider `json:"authProviderIn,omitempty"`
	AuthProviderNotIn []enums.AuthProvider `json:"authProviderNotIn,omitempty"`
	// role field predicates
	Role       *enums.Role  `json:"role,omitempty"`
	RoleNeq    *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn     []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn  []enums.Role `json:"roleNotIn,omitempty"`
	RoleIsNil  *bool        `json:"roleIsNil,omitempty"`
	RoleNotNil *bool        `json:"roleNotNil,omitempty"`
}

// Ordering options for User connections
type UserOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Users.
	Field UserOrderField `json:"field"`
}

type UserSetting struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	UserID    *string    `json:"userID,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked bool `json:"locked"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// status of the user account
	Status enums.UserStatus `json:"status"`
	// whether the user has confirmed their email address
	EmailConfirmed bool `json:"emailConfirmed"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed *bool `json:"isWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled *bool `json:"isTfaEnabled,omitempty"`
	User         *User `json:"user,omitempty"`
	// organization to load on user login
	DefaultOrg *Organization `json:"defaultOrg,omitempty"`
}

func (UserSetting) IsNode() {}

// Return response for createBulkUserSetting mutation
type UserSettingBulkCreatePayload struct {
	// Created userSettings
	UserSettings []*UserSetting `json:"userSettings,omitempty"`
}

// A connection to a list of items.
type UserSettingConnection struct {
	// A list of edges.
	Edges []*UserSettingEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createUserSetting mutation
type UserSettingCreatePayload struct {
	// Created userSetting
	UserSetting *UserSetting `json:"userSetting"`
}

// An edge in a connection.
type UserSettingEdge struct {
	// The item at the end of the edge.
	Node *UserSetting `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type UserSettingHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	UserID    *string    `json:"userID,omitempty"`
	// user account is locked if unconfirmed or explicitly locked
	Locked bool `json:"locked"`
	// The time notifications regarding the user were silenced
	SilencedAt *time.Time `json:"silencedAt,omitempty"`
	// The time the user was suspended
	SuspendedAt *time.Time `json:"suspendedAt,omitempty"`
	// status of the user account
	Status enums.UserStatus `json:"status"`
	// whether the user has confirmed their email address
	EmailConfirmed bool `json:"emailConfirmed"`
	// specifies a user may complete authentication by verifying a WebAuthn capable device
	IsWebauthnAllowed *bool `json:"isWebauthnAllowed,omitempty"`
	// whether the user has two factor authentication enabled
	IsTfaEnabled *bool `json:"isTfaEnabled,omitempty"`
}

func (UserSettingHistory) IsNode() {}

// A connection to a list of items.
type UserSettingHistoryConnection struct {
	// A list of edges.
	Edges []*UserSettingHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type UserSettingHistoryEdge struct {
	// The item at the end of the edge.
	Node *UserSettingHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// UserSettingHistoryWhereInput is used for filtering UserSettingHistory objects.
// Input was generated by ent.
type UserSettingHistoryWhereInput struct {
	Not *UserSettingHistoryWhereInput   `json:"not,omitempty"`
	And []*UserSettingHistoryWhereInput `json:"and,omitempty"`
	Or  []*UserSettingHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIDNeq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGt           *string  `json:"userIDGT,omitempty"`
	UserIDGte          *string  `json:"userIDGTE,omitempty"`
	UserIDLt           *string  `json:"userIDLT,omitempty"`
	UserIDLte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        *bool    `json:"userIDIsNil,omitempty"`
	UserIDNotNil       *bool    `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
	// locked field predicates
	Locked    *bool `json:"locked,omitempty"`
	LockedNeq *bool `json:"lockedNEQ,omitempty"`
	// silenced_at field predicates
	SilencedAt       *time.Time   `json:"silencedAt,omitempty"`
	SilencedAtNeq    *time.Time   `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []*time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []*time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGt     *time.Time   `json:"silencedAtGT,omitempty"`
	SilencedAtGte    *time.Time   `json:"silencedAtGTE,omitempty"`
	SilencedAtLt     *time.Time   `json:"silencedAtLT,omitempty"`
	SilencedAtLte    *time.Time   `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  *bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil *bool        `json:"silencedAtNotNil,omitempty"`
	// suspended_at field predicates
	SuspendedAt       *time.Time   `json:"suspendedAt,omitempty"`
	SuspendedAtNeq    *time.Time   `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []*time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []*time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGt     *time.Time   `json:"suspendedAtGT,omitempty"`
	SuspendedAtGte    *time.Time   `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLt     *time.Time   `json:"suspendedAtLT,omitempty"`
	SuspendedAtLte    *time.Time   `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  *bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil *bool        `json:"suspendedAtNotNil,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
	// email_confirmed field predicates
	EmailConfirmed    *bool `json:"emailConfirmed,omitempty"`
	EmailConfirmedNeq *bool `json:"emailConfirmedNEQ,omitempty"`
	// is_webauthn_allowed field predicates
	IsWebauthnAllowed       *bool `json:"isWebauthnAllowed,omitempty"`
	IsWebauthnAllowedNeq    *bool `json:"isWebauthnAllowedNEQ,omitempty"`
	IsWebauthnAllowedIsNil  *bool `json:"isWebauthnAllowedIsNil,omitempty"`
	IsWebauthnAllowedNotNil *bool `json:"isWebauthnAllowedNotNil,omitempty"`
	// is_tfa_enabled field predicates
	IsTfaEnabled       *bool `json:"isTfaEnabled,omitempty"`
	IsTfaEnabledNeq    *bool `json:"isTfaEnabledNEQ,omitempty"`
	IsTfaEnabledIsNil  *bool `json:"isTfaEnabledIsNil,omitempty"`
	IsTfaEnabledNotNil *bool `json:"isTfaEnabledNotNil,omitempty"`
}

// Return response for updateUserSetting mutation
type UserSettingUpdatePayload struct {
	// Updated userSetting
	UserSetting *UserSetting `json:"userSetting"`
}

// UserSettingWhereInput is used for filtering UserSetting objects.
// Input was generated by ent.
type UserSettingWhereInput struct {
	Not *UserSettingWhereInput   `json:"not,omitempty"`
	And []*UserSettingWhereInput `json:"and,omitempty"`
	Or  []*UserSettingWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// user_id field predicates
	UserID             *string  `json:"userID,omitempty"`
	UserIDNeq          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGt           *string  `json:"userIDGT,omitempty"`
	UserIDGte          *string  `json:"userIDGTE,omitempty"`
	UserIDLt           *string  `json:"userIDLT,omitempty"`
	UserIDLte          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        *bool    `json:"userIDIsNil,omitempty"`
	UserIDNotNil       *bool    `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`
	// locked field predicates
	Locked    *bool `json:"locked,omitempty"`
	LockedNeq *bool `json:"lockedNEQ,omitempty"`
	// silenced_at field predicates
	SilencedAt       *time.Time   `json:"silencedAt,omitempty"`
	SilencedAtNeq    *time.Time   `json:"silencedAtNEQ,omitempty"`
	SilencedAtIn     []*time.Time `json:"silencedAtIn,omitempty"`
	SilencedAtNotIn  []*time.Time `json:"silencedAtNotIn,omitempty"`
	SilencedAtGt     *time.Time   `json:"silencedAtGT,omitempty"`
	SilencedAtGte    *time.Time   `json:"silencedAtGTE,omitempty"`
	SilencedAtLt     *time.Time   `json:"silencedAtLT,omitempty"`
	SilencedAtLte    *time.Time   `json:"silencedAtLTE,omitempty"`
	SilencedAtIsNil  *bool        `json:"silencedAtIsNil,omitempty"`
	SilencedAtNotNil *bool        `json:"silencedAtNotNil,omitempty"`
	// suspended_at field predicates
	SuspendedAt       *time.Time   `json:"suspendedAt,omitempty"`
	SuspendedAtNeq    *time.Time   `json:"suspendedAtNEQ,omitempty"`
	SuspendedAtIn     []*time.Time `json:"suspendedAtIn,omitempty"`
	SuspendedAtNotIn  []*time.Time `json:"suspendedAtNotIn,omitempty"`
	SuspendedAtGt     *time.Time   `json:"suspendedAtGT,omitempty"`
	SuspendedAtGte    *time.Time   `json:"suspendedAtGTE,omitempty"`
	SuspendedAtLt     *time.Time   `json:"suspendedAtLT,omitempty"`
	SuspendedAtLte    *time.Time   `json:"suspendedAtLTE,omitempty"`
	SuspendedAtIsNil  *bool        `json:"suspendedAtIsNil,omitempty"`
	SuspendedAtNotNil *bool        `json:"suspendedAtNotNil,omitempty"`
	// status field predicates
	Status      *enums.UserStatus  `json:"status,omitempty"`
	StatusNeq   *enums.UserStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enums.UserStatus `json:"statusIn,omitempty"`
	StatusNotIn []enums.UserStatus `json:"statusNotIn,omitempty"`
	// email_confirmed field predicates
	EmailConfirmed    *bool `json:"emailConfirmed,omitempty"`
	EmailConfirmedNeq *bool `json:"emailConfirmedNEQ,omitempty"`
	// is_webauthn_allowed field predicates
	IsWebauthnAllowed       *bool `json:"isWebauthnAllowed,omitempty"`
	IsWebauthnAllowedNeq    *bool `json:"isWebauthnAllowedNEQ,omitempty"`
	IsWebauthnAllowedIsNil  *bool `json:"isWebauthnAllowedIsNil,omitempty"`
	IsWebauthnAllowedNotNil *bool `json:"isWebauthnAllowedNotNil,omitempty"`
	// is_tfa_enabled field predicates
	IsTfaEnabled       *bool `json:"isTfaEnabled,omitempty"`
	IsTfaEnabledNeq    *bool `json:"isTfaEnabledNEQ,omitempty"`
	IsTfaEnabledIsNil  *bool `json:"isTfaEnabledIsNil,omitempty"`
	IsTfaEnabledNotNil *bool `json:"isTfaEnabledNotNil,omitempty"`
	// user edge predicates
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
	// default_org edge predicates
	HasDefaultOrg     *bool                     `json:"hasDefaultOrg,omitempty"`
	HasDefaultOrgWith []*OrganizationWhereInput `json:"hasDefaultOrgWith,omitempty"`
}

// Return response for updateUser mutation
type UserUpdatePayload struct {
	// Updated user
	User *User `json:"user"`
}

// UserWhereInput is used for filtering User objects.
// Input was generated by ent.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// email field predicates
	Email             *string  `json:"email,omitempty"`
	EmailNeq          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGt           *string  `json:"emailGT,omitempty"`
	EmailGte          *string  `json:"emailGTE,omitempty"`
	EmailLt           *string  `json:"emailLT,omitempty"`
	EmailLte          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`
	// first_name field predicates
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNeq          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGt           *string  `json:"firstNameGT,omitempty"`
	FirstNameGte          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLt           *string  `json:"firstNameLT,omitempty"`
	FirstNameLte          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        *bool    `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       *bool    `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`
	// last_name field predicates
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNeq          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGt           *string  `json:"lastNameGT,omitempty"`
	LastNameGte          *string  `json:"lastNameGTE,omitempty"`
	LastNameLt           *string  `json:"lastNameLT,omitempty"`
	LastNameLte          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        *bool    `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       *bool    `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`
	// display_name field predicates
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNeq          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGt           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGte          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLt           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLte          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
	// avatar_remote_url field predicates
	AvatarRemoteURL             *string  `json:"avatarRemoteURL,omitempty"`
	AvatarRemoteURLNeq          *string  `json:"avatarRemoteURLNEQ,omitempty"`
	AvatarRemoteURLIn           []string `json:"avatarRemoteURLIn,omitempty"`
	AvatarRemoteURLNotIn        []string `json:"avatarRemoteURLNotIn,omitempty"`
	AvatarRemoteURLGt           *string  `json:"avatarRemoteURLGT,omitempty"`
	AvatarRemoteURLGte          *string  `json:"avatarRemoteURLGTE,omitempty"`
	AvatarRemoteURLLt           *string  `json:"avatarRemoteURLLT,omitempty"`
	AvatarRemoteURLLte          *string  `json:"avatarRemoteURLLTE,omitempty"`
	AvatarRemoteURLContains     *string  `json:"avatarRemoteURLContains,omitempty"`
	AvatarRemoteURLHasPrefix    *string  `json:"avatarRemoteURLHasPrefix,omitempty"`
	AvatarRemoteURLHasSuffix    *string  `json:"avatarRemoteURLHasSuffix,omitempty"`
	AvatarRemoteURLIsNil        *bool    `json:"avatarRemoteURLIsNil,omitempty"`
	AvatarRemoteURLNotNil       *bool    `json:"avatarRemoteURLNotNil,omitempty"`
	AvatarRemoteURLEqualFold    *string  `json:"avatarRemoteURLEqualFold,omitempty"`
	AvatarRemoteURLContainsFold *string  `json:"avatarRemoteURLContainsFold,omitempty"`
	// avatar_local_file field predicates
	AvatarLocalFile             *string  `json:"avatarLocalFile,omitempty"`
	AvatarLocalFileNeq          *string  `json:"avatarLocalFileNEQ,omitempty"`
	AvatarLocalFileIn           []string `json:"avatarLocalFileIn,omitempty"`
	AvatarLocalFileNotIn        []string `json:"avatarLocalFileNotIn,omitempty"`
	AvatarLocalFileGt           *string  `json:"avatarLocalFileGT,omitempty"`
	AvatarLocalFileGte          *string  `json:"avatarLocalFileGTE,omitempty"`
	AvatarLocalFileLt           *string  `json:"avatarLocalFileLT,omitempty"`
	AvatarLocalFileLte          *string  `json:"avatarLocalFileLTE,omitempty"`
	AvatarLocalFileContains     *string  `json:"avatarLocalFileContains,omitempty"`
	AvatarLocalFileHasPrefix    *string  `json:"avatarLocalFileHasPrefix,omitempty"`
	AvatarLocalFileHasSuffix    *string  `json:"avatarLocalFileHasSuffix,omitempty"`
	AvatarLocalFileIsNil        *bool    `json:"avatarLocalFileIsNil,omitempty"`
	AvatarLocalFileNotNil       *bool    `json:"avatarLocalFileNotNil,omitempty"`
	AvatarLocalFileEqualFold    *string  `json:"avatarLocalFileEqualFold,omitempty"`
	AvatarLocalFileContainsFold *string  `json:"avatarLocalFileContainsFold,omitempty"`
	// avatar_updated_at field predicates
	AvatarUpdatedAt       *time.Time   `json:"avatarUpdatedAt,omitempty"`
	AvatarUpdatedAtNeq    *time.Time   `json:"avatarUpdatedAtNEQ,omitempty"`
	AvatarUpdatedAtIn     []*time.Time `json:"avatarUpdatedAtIn,omitempty"`
	AvatarUpdatedAtNotIn  []*time.Time `json:"avatarUpdatedAtNotIn,omitempty"`
	AvatarUpdatedAtGt     *time.Time   `json:"avatarUpdatedAtGT,omitempty"`
	AvatarUpdatedAtGte    *time.Time   `json:"avatarUpdatedAtGTE,omitempty"`
	AvatarUpdatedAtLt     *time.Time   `json:"avatarUpdatedAtLT,omitempty"`
	AvatarUpdatedAtLte    *time.Time   `json:"avatarUpdatedAtLTE,omitempty"`
	AvatarUpdatedAtIsNil  *bool        `json:"avatarUpdatedAtIsNil,omitempty"`
	AvatarUpdatedAtNotNil *bool        `json:"avatarUpdatedAtNotNil,omitempty"`
	// last_seen field predicates
	LastSeen       *time.Time   `json:"lastSeen,omitempty"`
	LastSeenNeq    *time.Time   `json:"lastSeenNEQ,omitempty"`
	LastSeenIn     []*time.Time `json:"lastSeenIn,omitempty"`
	LastSeenNotIn  []*time.Time `json:"lastSeenNotIn,omitempty"`
	LastSeenGt     *time.Time   `json:"lastSeenGT,omitempty"`
	LastSeenGte    *time.Time   `json:"lastSeenGTE,omitempty"`
	LastSeenLt     *time.Time   `json:"lastSeenLT,omitempty"`
	LastSeenLte    *time.Time   `json:"lastSeenLTE,omitempty"`
	LastSeenIsNil  *bool        `json:"lastSeenIsNil,omitempty"`
	LastSeenNotNil *bool        `json:"lastSeenNotNil,omitempty"`
	// sub field predicates
	Sub             *string  `json:"sub,omitempty"`
	SubNeq          *string  `json:"subNEQ,omitempty"`
	SubIn           []string `json:"subIn,omitempty"`
	SubNotIn        []string `json:"subNotIn,omitempty"`
	SubGt           *string  `json:"subGT,omitempty"`
	SubGte          *string  `json:"subGTE,omitempty"`
	SubLt           *string  `json:"subLT,omitempty"`
	SubLte          *string  `json:"subLTE,omitempty"`
	SubContains     *string  `json:"subContains,omitempty"`
	SubHasPrefix    *string  `json:"subHasPrefix,omitempty"`
	SubHasSuffix    *string  `json:"subHasSuffix,omitempty"`
	SubIsNil        *bool    `json:"subIsNil,omitempty"`
	SubNotNil       *bool    `json:"subNotNil,omitempty"`
	SubEqualFold    *string  `json:"subEqualFold,omitempty"`
	SubContainsFold *string  `json:"subContainsFold,omitempty"`
	// auth_provider field predicates
	AuthProvider      *enums.AuthProvider  `json:"authProvider,omitempty"`
	AuthProviderNeq   *enums.AuthProvider  `json:"authProviderNEQ,omitempty"`
	AuthProviderIn    []enums.AuthProvider `json:"authProviderIn,omitempty"`
	AuthProviderNotIn []enums.AuthProvider `json:"authProviderNotIn,omitempty"`
	// role field predicates
	Role       *enums.Role  `json:"role,omitempty"`
	RoleNeq    *enums.Role  `json:"roleNEQ,omitempty"`
	RoleIn     []enums.Role `json:"roleIn,omitempty"`
	RoleNotIn  []enums.Role `json:"roleNotIn,omitempty"`
	RoleIsNil  *bool        `json:"roleIsNil,omitempty"`
	RoleNotNil *bool        `json:"roleNotNil,omitempty"`
	// personal_access_tokens edge predicates
	HasPersonalAccessTokens     *bool                            `json:"hasPersonalAccessTokens,omitempty"`
	HasPersonalAccessTokensWith []*PersonalAccessTokenWhereInput `json:"hasPersonalAccessTokensWith,omitempty"`
	// tfa_settings edge predicates
	HasTfaSettings     *bool                   `json:"hasTfaSettings,omitempty"`
	HasTfaSettingsWith []*TFASettingWhereInput `json:"hasTfaSettingsWith,omitempty"`
	// setting edge predicates
	HasSetting     *bool                    `json:"hasSetting,omitempty"`
	HasSettingWith []*UserSettingWhereInput `json:"hasSettingWith,omitempty"`
	// groups edge predicates
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`
	// organizations edge predicates
	HasOrganizations     *bool                     `json:"hasOrganizations,omitempty"`
	HasOrganizationsWith []*OrganizationWhereInput `json:"hasOrganizationsWith,omitempty"`
	// files edge predicates
	HasFiles     *bool             `json:"hasFiles,omitempty"`
	HasFilesWith []*FileWhereInput `json:"hasFilesWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// group_memberships edge predicates
	HasGroupMemberships     *bool                        `json:"hasGroupMemberships,omitempty"`
	HasGroupMembershipsWith []*GroupMembershipWhereInput `json:"hasGroupMembershipsWith,omitempty"`
	// org_memberships edge predicates
	HasOrgMemberships     *bool                      `json:"hasOrgMemberships,omitempty"`
	HasOrgMembershipsWith []*OrgMembershipWhereInput `json:"hasOrgMembershipsWith,omitempty"`
}

type Webhook struct {
	ID        string     `json:"id"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	CreatedBy *string    `json:"createdBy,omitempty"`
	UpdatedBy *string    `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the webhook
	Name string `json:"name"`
	// a description of the webhook
	Description *string `json:"description,omitempty"`
	// the url to send the webhook to
	DestinationURL string `json:"destinationURL"`
	// indicates if the webhook is active and enabled
	Enabled bool `json:"enabled"`
	// the number of failures
	Failures *int64 `json:"failures,omitempty"`
	// the last error message
	LastError *string `json:"lastError,omitempty"`
	// the last response
	LastResponse *string        `json:"lastResponse,omitempty"`
	Owner        *Organization  `json:"owner,omitempty"`
	Events       []*Event       `json:"events,omitempty"`
	Integrations []*Integration `json:"integrations,omitempty"`
}

func (Webhook) IsNode() {}

// Return response for createBulkWebhook mutation
type WebhookBulkCreatePayload struct {
	// Created webhooks
	Webhooks []*Webhook `json:"webhooks,omitempty"`
}

// A connection to a list of items.
type WebhookConnection struct {
	// A list of edges.
	Edges []*WebhookEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// Return response for createWebhook mutation
type WebhookCreatePayload struct {
	// Created webhook
	Webhook *Webhook `json:"webhook"`
}

// Return response for deleteWebhook mutation
type WebhookDeletePayload struct {
	// Deleted webhook ID
	DeletedID string `json:"deletedID"`
}

// An edge in a connection.
type WebhookEdge struct {
	// The item at the end of the edge.
	Node *Webhook `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

type WebhookHistory struct {
	ID          string         `json:"id"`
	HistoryTime time.Time      `json:"historyTime"`
	Ref         *string        `json:"ref,omitempty"`
	Operation   history.OpType `json:"operation"`
	CreatedAt   *time.Time     `json:"createdAt,omitempty"`
	UpdatedAt   *time.Time     `json:"updatedAt,omitempty"`
	CreatedBy   *string        `json:"createdBy,omitempty"`
	UpdatedBy   *string        `json:"updatedBy,omitempty"`
	// tags associated with the object
	Tags      []string   `json:"tags,omitempty"`
	DeletedAt *time.Time `json:"deletedAt,omitempty"`
	DeletedBy *string    `json:"deletedBy,omitempty"`
	// The organization id that owns the object
	OwnerID *string `json:"ownerID,omitempty"`
	// the name of the webhook
	Name string `json:"name"`
	// a description of the webhook
	Description *string `json:"description,omitempty"`
	// the url to send the webhook to
	DestinationURL string `json:"destinationURL"`
	// indicates if the webhook is active and enabled
	Enabled bool `json:"enabled"`
	// the number of failures
	Failures *int64 `json:"failures,omitempty"`
	// the last error message
	LastError *string `json:"lastError,omitempty"`
	// the last response
	LastResponse *string `json:"lastResponse,omitempty"`
}

func (WebhookHistory) IsNode() {}

// A connection to a list of items.
type WebhookHistoryConnection struct {
	// A list of edges.
	Edges []*WebhookHistoryEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *PageInfo `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int64 `json:"totalCount"`
}

// An edge in a connection.
type WebhookHistoryEdge struct {
	// The item at the end of the edge.
	Node *WebhookHistory `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor string `json:"cursor"`
}

// Ordering options for WebhookHistory connections
type WebhookHistoryOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order WebhookHistories.
	Field WebhookHistoryOrderField `json:"field"`
}

// WebhookHistoryWhereInput is used for filtering WebhookHistory objects.
// Input was generated by ent.
type WebhookHistoryWhereInput struct {
	Not *WebhookHistoryWhereInput   `json:"not,omitempty"`
	And []*WebhookHistoryWhereInput `json:"and,omitempty"`
	Or  []*WebhookHistoryWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// history_time field predicates
	HistoryTime      *time.Time   `json:"historyTime,omitempty"`
	HistoryTimeNeq   *time.Time   `json:"historyTimeNEQ,omitempty"`
	HistoryTimeIn    []*time.Time `json:"historyTimeIn,omitempty"`
	HistoryTimeNotIn []*time.Time `json:"historyTimeNotIn,omitempty"`
	HistoryTimeGt    *time.Time   `json:"historyTimeGT,omitempty"`
	HistoryTimeGte   *time.Time   `json:"historyTimeGTE,omitempty"`
	HistoryTimeLt    *time.Time   `json:"historyTimeLT,omitempty"`
	HistoryTimeLte   *time.Time   `json:"historyTimeLTE,omitempty"`
	// ref field predicates
	Ref             *string  `json:"ref,omitempty"`
	RefNeq          *string  `json:"refNEQ,omitempty"`
	RefIn           []string `json:"refIn,omitempty"`
	RefNotIn        []string `json:"refNotIn,omitempty"`
	RefGt           *string  `json:"refGT,omitempty"`
	RefGte          *string  `json:"refGTE,omitempty"`
	RefLt           *string  `json:"refLT,omitempty"`
	RefLte          *string  `json:"refLTE,omitempty"`
	RefContains     *string  `json:"refContains,omitempty"`
	RefHasPrefix    *string  `json:"refHasPrefix,omitempty"`
	RefHasSuffix    *string  `json:"refHasSuffix,omitempty"`
	RefIsNil        *bool    `json:"refIsNil,omitempty"`
	RefNotNil       *bool    `json:"refNotNil,omitempty"`
	RefEqualFold    *string  `json:"refEqualFold,omitempty"`
	RefContainsFold *string  `json:"refContainsFold,omitempty"`
	// operation field predicates
	Operation      *history.OpType  `json:"operation,omitempty"`
	OperationNeq   *history.OpType  `json:"operationNEQ,omitempty"`
	OperationIn    []history.OpType `json:"operationIn,omitempty"`
	OperationNotIn []history.OpType `json:"operationNotIn,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// destination_url field predicates
	DestinationURL             *string  `json:"destinationURL,omitempty"`
	DestinationURLNeq          *string  `json:"destinationURLNEQ,omitempty"`
	DestinationURLIn           []string `json:"destinationURLIn,omitempty"`
	DestinationURLNotIn        []string `json:"destinationURLNotIn,omitempty"`
	DestinationURLGt           *string  `json:"destinationURLGT,omitempty"`
	DestinationURLGte          *string  `json:"destinationURLGTE,omitempty"`
	DestinationURLLt           *string  `json:"destinationURLLT,omitempty"`
	DestinationURLLte          *string  `json:"destinationURLLTE,omitempty"`
	DestinationURLContains     *string  `json:"destinationURLContains,omitempty"`
	DestinationURLHasPrefix    *string  `json:"destinationURLHasPrefix,omitempty"`
	DestinationURLHasSuffix    *string  `json:"destinationURLHasSuffix,omitempty"`
	DestinationURLEqualFold    *string  `json:"destinationURLEqualFold,omitempty"`
	DestinationURLContainsFold *string  `json:"destinationURLContainsFold,omitempty"`
	// enabled field predicates
	Enabled    *bool `json:"enabled,omitempty"`
	EnabledNeq *bool `json:"enabledNEQ,omitempty"`
	// failures field predicates
	Failures       *int64  `json:"failures,omitempty"`
	FailuresNeq    *int64  `json:"failuresNEQ,omitempty"`
	FailuresIn     []int64 `json:"failuresIn,omitempty"`
	FailuresNotIn  []int64 `json:"failuresNotIn,omitempty"`
	FailuresGt     *int64  `json:"failuresGT,omitempty"`
	FailuresGte    *int64  `json:"failuresGTE,omitempty"`
	FailuresLt     *int64  `json:"failuresLT,omitempty"`
	FailuresLte    *int64  `json:"failuresLTE,omitempty"`
	FailuresIsNil  *bool   `json:"failuresIsNil,omitempty"`
	FailuresNotNil *bool   `json:"failuresNotNil,omitempty"`
	// last_error field predicates
	LastError             *string  `json:"lastError,omitempty"`
	LastErrorNeq          *string  `json:"lastErrorNEQ,omitempty"`
	LastErrorIn           []string `json:"lastErrorIn,omitempty"`
	LastErrorNotIn        []string `json:"lastErrorNotIn,omitempty"`
	LastErrorGt           *string  `json:"lastErrorGT,omitempty"`
	LastErrorGte          *string  `json:"lastErrorGTE,omitempty"`
	LastErrorLt           *string  `json:"lastErrorLT,omitempty"`
	LastErrorLte          *string  `json:"lastErrorLTE,omitempty"`
	LastErrorContains     *string  `json:"lastErrorContains,omitempty"`
	LastErrorHasPrefix    *string  `json:"lastErrorHasPrefix,omitempty"`
	LastErrorHasSuffix    *string  `json:"lastErrorHasSuffix,omitempty"`
	LastErrorIsNil        *bool    `json:"lastErrorIsNil,omitempty"`
	LastErrorNotNil       *bool    `json:"lastErrorNotNil,omitempty"`
	LastErrorEqualFold    *string  `json:"lastErrorEqualFold,omitempty"`
	LastErrorContainsFold *string  `json:"lastErrorContainsFold,omitempty"`
	// last_response field predicates
	LastResponse             *string  `json:"lastResponse,omitempty"`
	LastResponseNeq          *string  `json:"lastResponseNEQ,omitempty"`
	LastResponseIn           []string `json:"lastResponseIn,omitempty"`
	LastResponseNotIn        []string `json:"lastResponseNotIn,omitempty"`
	LastResponseGt           *string  `json:"lastResponseGT,omitempty"`
	LastResponseGte          *string  `json:"lastResponseGTE,omitempty"`
	LastResponseLt           *string  `json:"lastResponseLT,omitempty"`
	LastResponseLte          *string  `json:"lastResponseLTE,omitempty"`
	LastResponseContains     *string  `json:"lastResponseContains,omitempty"`
	LastResponseHasPrefix    *string  `json:"lastResponseHasPrefix,omitempty"`
	LastResponseHasSuffix    *string  `json:"lastResponseHasSuffix,omitempty"`
	LastResponseIsNil        *bool    `json:"lastResponseIsNil,omitempty"`
	LastResponseNotNil       *bool    `json:"lastResponseNotNil,omitempty"`
	LastResponseEqualFold    *string  `json:"lastResponseEqualFold,omitempty"`
	LastResponseContainsFold *string  `json:"lastResponseContainsFold,omitempty"`
}

// Ordering options for Webhook connections
type WebhookOrder struct {
	// The ordering direction.
	Direction OrderDirection `json:"direction"`
	// The field by which to order Webhooks.
	Field WebhookOrderField `json:"field"`
}

// Return response for updateWebhook mutation
type WebhookUpdatePayload struct {
	// Updated webhook
	Webhook *Webhook `json:"webhook"`
}

// WebhookWhereInput is used for filtering Webhook objects.
// Input was generated by ent.
type WebhookWhereInput struct {
	Not *WebhookWhereInput   `json:"not,omitempty"`
	And []*WebhookWhereInput `json:"and,omitempty"`
	Or  []*WebhookWhereInput `json:"or,omitempty"`
	// id field predicates
	ID             *string  `json:"id,omitempty"`
	IDNeq          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGt           *string  `json:"idGT,omitempty"`
	IDGte          *string  `json:"idGTE,omitempty"`
	IDLt           *string  `json:"idLT,omitempty"`
	IDLte          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`
	// created_at field predicates
	CreatedAt       *time.Time   `json:"createdAt,omitempty"`
	CreatedAtNeq    *time.Time   `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []*time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []*time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGt     *time.Time   `json:"createdAtGT,omitempty"`
	CreatedAtGte    *time.Time   `json:"createdAtGTE,omitempty"`
	CreatedAtLt     *time.Time   `json:"createdAtLT,omitempty"`
	CreatedAtLte    *time.Time   `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  *bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil *bool        `json:"createdAtNotNil,omitempty"`
	// updated_at field predicates
	UpdatedAt       *time.Time   `json:"updatedAt,omitempty"`
	UpdatedAtNeq    *time.Time   `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []*time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []*time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGt     *time.Time   `json:"updatedAtGT,omitempty"`
	UpdatedAtGte    *time.Time   `json:"updatedAtGTE,omitempty"`
	UpdatedAtLt     *time.Time   `json:"updatedAtLT,omitempty"`
	UpdatedAtLte    *time.Time   `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  *bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil *bool        `json:"updatedAtNotNil,omitempty"`
	// created_by field predicates
	CreatedBy             *string  `json:"createdBy,omitempty"`
	CreatedByNeq          *string  `json:"createdByNEQ,omitempty"`
	CreatedByIn           []string `json:"createdByIn,omitempty"`
	CreatedByNotIn        []string `json:"createdByNotIn,omitempty"`
	CreatedByGt           *string  `json:"createdByGT,omitempty"`
	CreatedByGte          *string  `json:"createdByGTE,omitempty"`
	CreatedByLt           *string  `json:"createdByLT,omitempty"`
	CreatedByLte          *string  `json:"createdByLTE,omitempty"`
	CreatedByContains     *string  `json:"createdByContains,omitempty"`
	CreatedByHasPrefix    *string  `json:"createdByHasPrefix,omitempty"`
	CreatedByHasSuffix    *string  `json:"createdByHasSuffix,omitempty"`
	CreatedByIsNil        *bool    `json:"createdByIsNil,omitempty"`
	CreatedByNotNil       *bool    `json:"createdByNotNil,omitempty"`
	CreatedByEqualFold    *string  `json:"createdByEqualFold,omitempty"`
	CreatedByContainsFold *string  `json:"createdByContainsFold,omitempty"`
	// updated_by field predicates
	UpdatedBy             *string  `json:"updatedBy,omitempty"`
	UpdatedByNeq          *string  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn           []string `json:"updatedByIn,omitempty"`
	UpdatedByNotIn        []string `json:"updatedByNotIn,omitempty"`
	UpdatedByGt           *string  `json:"updatedByGT,omitempty"`
	UpdatedByGte          *string  `json:"updatedByGTE,omitempty"`
	UpdatedByLt           *string  `json:"updatedByLT,omitempty"`
	UpdatedByLte          *string  `json:"updatedByLTE,omitempty"`
	UpdatedByContains     *string  `json:"updatedByContains,omitempty"`
	UpdatedByHasPrefix    *string  `json:"updatedByHasPrefix,omitempty"`
	UpdatedByHasSuffix    *string  `json:"updatedByHasSuffix,omitempty"`
	UpdatedByIsNil        *bool    `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil       *bool    `json:"updatedByNotNil,omitempty"`
	UpdatedByEqualFold    *string  `json:"updatedByEqualFold,omitempty"`
	UpdatedByContainsFold *string  `json:"updatedByContainsFold,omitempty"`
	// deleted_at field predicates
	DeletedAt       *time.Time   `json:"deletedAt,omitempty"`
	DeletedAtNeq    *time.Time   `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []*time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []*time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGt     *time.Time   `json:"deletedAtGT,omitempty"`
	DeletedAtGte    *time.Time   `json:"deletedAtGTE,omitempty"`
	DeletedAtLt     *time.Time   `json:"deletedAtLT,omitempty"`
	DeletedAtLte    *time.Time   `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  *bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil *bool        `json:"deletedAtNotNil,omitempty"`
	// deleted_by field predicates
	DeletedBy             *string  `json:"deletedBy,omitempty"`
	DeletedByNeq          *string  `json:"deletedByNEQ,omitempty"`
	DeletedByIn           []string `json:"deletedByIn,omitempty"`
	DeletedByNotIn        []string `json:"deletedByNotIn,omitempty"`
	DeletedByGt           *string  `json:"deletedByGT,omitempty"`
	DeletedByGte          *string  `json:"deletedByGTE,omitempty"`
	DeletedByLt           *string  `json:"deletedByLT,omitempty"`
	DeletedByLte          *string  `json:"deletedByLTE,omitempty"`
	DeletedByContains     *string  `json:"deletedByContains,omitempty"`
	DeletedByHasPrefix    *string  `json:"deletedByHasPrefix,omitempty"`
	DeletedByHasSuffix    *string  `json:"deletedByHasSuffix,omitempty"`
	DeletedByIsNil        *bool    `json:"deletedByIsNil,omitempty"`
	DeletedByNotNil       *bool    `json:"deletedByNotNil,omitempty"`
	DeletedByEqualFold    *string  `json:"deletedByEqualFold,omitempty"`
	DeletedByContainsFold *string  `json:"deletedByContainsFold,omitempty"`
	// owner_id field predicates
	OwnerID             *string  `json:"ownerID,omitempty"`
	OwnerIDNeq          *string  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn           []string `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn        []string `json:"ownerIDNotIn,omitempty"`
	OwnerIDGt           *string  `json:"ownerIDGT,omitempty"`
	OwnerIDGte          *string  `json:"ownerIDGTE,omitempty"`
	OwnerIDLt           *string  `json:"ownerIDLT,omitempty"`
	OwnerIDLte          *string  `json:"ownerIDLTE,omitempty"`
	OwnerIDContains     *string  `json:"ownerIDContains,omitempty"`
	OwnerIDHasPrefix    *string  `json:"ownerIDHasPrefix,omitempty"`
	OwnerIDHasSuffix    *string  `json:"ownerIDHasSuffix,omitempty"`
	OwnerIDIsNil        *bool    `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil       *bool    `json:"ownerIDNotNil,omitempty"`
	OwnerIDEqualFold    *string  `json:"ownerIDEqualFold,omitempty"`
	OwnerIDContainsFold *string  `json:"ownerIDContainsFold,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// destination_url field predicates
	DestinationURL             *string  `json:"destinationURL,omitempty"`
	DestinationURLNeq          *string  `json:"destinationURLNEQ,omitempty"`
	DestinationURLIn           []string `json:"destinationURLIn,omitempty"`
	DestinationURLNotIn        []string `json:"destinationURLNotIn,omitempty"`
	DestinationURLGt           *string  `json:"destinationURLGT,omitempty"`
	DestinationURLGte          *string  `json:"destinationURLGTE,omitempty"`
	DestinationURLLt           *string  `json:"destinationURLLT,omitempty"`
	DestinationURLLte          *string  `json:"destinationURLLTE,omitempty"`
	DestinationURLContains     *string  `json:"destinationURLContains,omitempty"`
	DestinationURLHasPrefix    *string  `json:"destinationURLHasPrefix,omitempty"`
	DestinationURLHasSuffix    *string  `json:"destinationURLHasSuffix,omitempty"`
	DestinationURLEqualFold    *string  `json:"destinationURLEqualFold,omitempty"`
	DestinationURLContainsFold *string  `json:"destinationURLContainsFold,omitempty"`
	// enabled field predicates
	Enabled    *bool `json:"enabled,omitempty"`
	EnabledNeq *bool `json:"enabledNEQ,omitempty"`
	// failures field predicates
	Failures       *int64  `json:"failures,omitempty"`
	FailuresNeq    *int64  `json:"failuresNEQ,omitempty"`
	FailuresIn     []int64 `json:"failuresIn,omitempty"`
	FailuresNotIn  []int64 `json:"failuresNotIn,omitempty"`
	FailuresGt     *int64  `json:"failuresGT,omitempty"`
	FailuresGte    *int64  `json:"failuresGTE,omitempty"`
	FailuresLt     *int64  `json:"failuresLT,omitempty"`
	FailuresLte    *int64  `json:"failuresLTE,omitempty"`
	FailuresIsNil  *bool   `json:"failuresIsNil,omitempty"`
	FailuresNotNil *bool   `json:"failuresNotNil,omitempty"`
	// last_error field predicates
	LastError             *string  `json:"lastError,omitempty"`
	LastErrorNeq          *string  `json:"lastErrorNEQ,omitempty"`
	LastErrorIn           []string `json:"lastErrorIn,omitempty"`
	LastErrorNotIn        []string `json:"lastErrorNotIn,omitempty"`
	LastErrorGt           *string  `json:"lastErrorGT,omitempty"`
	LastErrorGte          *string  `json:"lastErrorGTE,omitempty"`
	LastErrorLt           *string  `json:"lastErrorLT,omitempty"`
	LastErrorLte          *string  `json:"lastErrorLTE,omitempty"`
	LastErrorContains     *string  `json:"lastErrorContains,omitempty"`
	LastErrorHasPrefix    *string  `json:"lastErrorHasPrefix,omitempty"`
	LastErrorHasSuffix    *string  `json:"lastErrorHasSuffix,omitempty"`
	LastErrorIsNil        *bool    `json:"lastErrorIsNil,omitempty"`
	LastErrorNotNil       *bool    `json:"lastErrorNotNil,omitempty"`
	LastErrorEqualFold    *string  `json:"lastErrorEqualFold,omitempty"`
	LastErrorContainsFold *string  `json:"lastErrorContainsFold,omitempty"`
	// last_response field predicates
	LastResponse             *string  `json:"lastResponse,omitempty"`
	LastResponseNeq          *string  `json:"lastResponseNEQ,omitempty"`
	LastResponseIn           []string `json:"lastResponseIn,omitempty"`
	LastResponseNotIn        []string `json:"lastResponseNotIn,omitempty"`
	LastResponseGt           *string  `json:"lastResponseGT,omitempty"`
	LastResponseGte          *string  `json:"lastResponseGTE,omitempty"`
	LastResponseLt           *string  `json:"lastResponseLT,omitempty"`
	LastResponseLte          *string  `json:"lastResponseLTE,omitempty"`
	LastResponseContains     *string  `json:"lastResponseContains,omitempty"`
	LastResponseHasPrefix    *string  `json:"lastResponseHasPrefix,omitempty"`
	LastResponseHasSuffix    *string  `json:"lastResponseHasSuffix,omitempty"`
	LastResponseIsNil        *bool    `json:"lastResponseIsNil,omitempty"`
	LastResponseNotNil       *bool    `json:"lastResponseNotNil,omitempty"`
	LastResponseEqualFold    *string  `json:"lastResponseEqualFold,omitempty"`
	LastResponseContainsFold *string  `json:"lastResponseContainsFold,omitempty"`
	// owner edge predicates
	HasOwner     *bool                     `json:"hasOwner,omitempty"`
	HasOwnerWith []*OrganizationWhereInput `json:"hasOwnerWith,omitempty"`
	// events edge predicates
	HasEvents     *bool              `json:"hasEvents,omitempty"`
	HasEventsWith []*EventWhereInput `json:"hasEventsWith,omitempty"`
	// integrations edge predicates
	HasIntegrations     *bool                    `json:"hasIntegrations,omitempty"`
	HasIntegrationsWith []*IntegrationWhereInput `json:"hasIntegrationsWith,omitempty"`
}

// Properties by which EntityHistory connections can be ordered.
type EntityHistoryOrderField string

const (
	EntityHistoryOrderFieldName        EntityHistoryOrderField = "name"
	EntityHistoryOrderFieldDisplayName EntityHistoryOrderField = "display_name"
)

var AllEntityHistoryOrderField = []EntityHistoryOrderField{
	EntityHistoryOrderFieldName,
	EntityHistoryOrderFieldDisplayName,
}

func (e EntityHistoryOrderField) IsValid() bool {
	switch e {
	case EntityHistoryOrderFieldName, EntityHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e EntityHistoryOrderField) String() string {
	return string(e)
}

func (e *EntityHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityHistoryOrderField", str)
	}
	return nil
}

func (e EntityHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Entity connections can be ordered.
type EntityOrderField string

const (
	EntityOrderFieldName        EntityOrderField = "name"
	EntityOrderFieldDisplayName EntityOrderField = "display_name"
)

var AllEntityOrderField = []EntityOrderField{
	EntityOrderFieldName,
	EntityOrderFieldDisplayName,
}

func (e EntityOrderField) IsValid() bool {
	switch e {
	case EntityOrderFieldName, EntityOrderFieldDisplayName:
		return true
	}
	return false
}

func (e EntityOrderField) String() string {
	return string(e)
}

func (e *EntityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityOrderField", str)
	}
	return nil
}

func (e EntityOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which EntityTypeHistory connections can be ordered.
type EntityTypeHistoryOrderField string

const (
	EntityTypeHistoryOrderFieldName EntityTypeHistoryOrderField = "name"
)

var AllEntityTypeHistoryOrderField = []EntityTypeHistoryOrderField{
	EntityTypeHistoryOrderFieldName,
}

func (e EntityTypeHistoryOrderField) IsValid() bool {
	switch e {
	case EntityTypeHistoryOrderFieldName:
		return true
	}
	return false
}

func (e EntityTypeHistoryOrderField) String() string {
	return string(e)
}

func (e *EntityTypeHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityTypeHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityTypeHistoryOrderField", str)
	}
	return nil
}

func (e EntityTypeHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which EntityType connections can be ordered.
type EntityTypeOrderField string

const (
	EntityTypeOrderFieldName EntityTypeOrderField = "name"
)

var AllEntityTypeOrderField = []EntityTypeOrderField{
	EntityTypeOrderFieldName,
}

func (e EntityTypeOrderField) IsValid() bool {
	switch e {
	case EntityTypeOrderFieldName:
		return true
	}
	return false
}

func (e EntityTypeOrderField) String() string {
	return string(e)
}

func (e *EntityTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EntityTypeOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EntityTypeOrderField", str)
	}
	return nil
}

func (e EntityTypeOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which GroupHistory connections can be ordered.
type GroupHistoryOrderField string

const (
	GroupHistoryOrderFieldName        GroupHistoryOrderField = "name"
	GroupHistoryOrderFieldDisplayName GroupHistoryOrderField = "display_name"
)

var AllGroupHistoryOrderField = []GroupHistoryOrderField{
	GroupHistoryOrderFieldName,
	GroupHistoryOrderFieldDisplayName,
}

func (e GroupHistoryOrderField) IsValid() bool {
	switch e {
	case GroupHistoryOrderFieldName, GroupHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e GroupHistoryOrderField) String() string {
	return string(e)
}

func (e *GroupHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupHistoryOrderField", str)
	}
	return nil
}

func (e GroupHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Group connections can be ordered.
type GroupOrderField string

const (
	GroupOrderFieldName        GroupOrderField = "name"
	GroupOrderFieldDisplayName GroupOrderField = "display_name"
)

var AllGroupOrderField = []GroupOrderField{
	GroupOrderFieldName,
	GroupOrderFieldDisplayName,
}

func (e GroupOrderField) IsValid() bool {
	switch e {
	case GroupOrderFieldName, GroupOrderFieldDisplayName:
		return true
	}
	return false
}

func (e GroupOrderField) String() string {
	return string(e)
}

func (e *GroupOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroupOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroupOrderField", str)
	}
	return nil
}

func (e GroupOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which HushHistory connections can be ordered.
type HushHistoryOrderField string

const (
	HushHistoryOrderFieldName HushHistoryOrderField = "name"
	HushHistoryOrderFieldKind HushHistoryOrderField = "kind"
)

var AllHushHistoryOrderField = []HushHistoryOrderField{
	HushHistoryOrderFieldName,
	HushHistoryOrderFieldKind,
}

func (e HushHistoryOrderField) IsValid() bool {
	switch e {
	case HushHistoryOrderFieldName, HushHistoryOrderFieldKind:
		return true
	}
	return false
}

func (e HushHistoryOrderField) String() string {
	return string(e)
}

func (e *HushHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HushHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HushHistoryOrderField", str)
	}
	return nil
}

func (e HushHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Hush connections can be ordered.
type HushOrderField string

const (
	HushOrderFieldName HushOrderField = "name"
	HushOrderFieldKind HushOrderField = "kind"
)

var AllHushOrderField = []HushOrderField{
	HushOrderFieldName,
	HushOrderFieldKind,
}

func (e HushOrderField) IsValid() bool {
	switch e {
	case HushOrderFieldName, HushOrderFieldKind:
		return true
	}
	return false
}

func (e HushOrderField) String() string {
	return string(e)
}

func (e *HushOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HushOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HushOrderField", str)
	}
	return nil
}

func (e HushOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which IntegrationHistory connections can be ordered.
type IntegrationHistoryOrderField string

const (
	IntegrationHistoryOrderFieldName IntegrationHistoryOrderField = "name"
	IntegrationHistoryOrderFieldKind IntegrationHistoryOrderField = "kind"
)

var AllIntegrationHistoryOrderField = []IntegrationHistoryOrderField{
	IntegrationHistoryOrderFieldName,
	IntegrationHistoryOrderFieldKind,
}

func (e IntegrationHistoryOrderField) IsValid() bool {
	switch e {
	case IntegrationHistoryOrderFieldName, IntegrationHistoryOrderFieldKind:
		return true
	}
	return false
}

func (e IntegrationHistoryOrderField) String() string {
	return string(e)
}

func (e *IntegrationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationHistoryOrderField", str)
	}
	return nil
}

func (e IntegrationHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Integration connections can be ordered.
type IntegrationOrderField string

const (
	IntegrationOrderFieldName IntegrationOrderField = "name"
	IntegrationOrderFieldKind IntegrationOrderField = "kind"
)

var AllIntegrationOrderField = []IntegrationOrderField{
	IntegrationOrderFieldName,
	IntegrationOrderFieldKind,
}

func (e IntegrationOrderField) IsValid() bool {
	switch e {
	case IntegrationOrderFieldName, IntegrationOrderFieldKind:
		return true
	}
	return false
}

func (e IntegrationOrderField) String() string {
	return string(e)
}

func (e *IntegrationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = IntegrationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid IntegrationOrderField", str)
	}
	return nil
}

func (e IntegrationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Possible directions in which to order a list of items when provided an `orderBy` argument.
type OrderDirection string

const (
	// Specifies an ascending order for a given `orderBy` argument.
	OrderDirectionAsc OrderDirection = "ASC"
	// Specifies a descending order for a given `orderBy` argument.
	OrderDirectionDesc OrderDirection = "DESC"
)

var AllOrderDirection = []OrderDirection{
	OrderDirectionAsc,
	OrderDirectionDesc,
}

func (e OrderDirection) IsValid() bool {
	switch e {
	case OrderDirectionAsc, OrderDirectionDesc:
		return true
	}
	return false
}

func (e OrderDirection) String() string {
	return string(e)
}

func (e *OrderDirection) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrderDirection", str)
	}
	return nil
}

func (e OrderDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which OrganizationHistory connections can be ordered.
type OrganizationHistoryOrderField string

const (
	OrganizationHistoryOrderFieldName        OrganizationHistoryOrderField = "name"
	OrganizationHistoryOrderFieldDisplayName OrganizationHistoryOrderField = "display_name"
)

var AllOrganizationHistoryOrderField = []OrganizationHistoryOrderField{
	OrganizationHistoryOrderFieldName,
	OrganizationHistoryOrderFieldDisplayName,
}

func (e OrganizationHistoryOrderField) IsValid() bool {
	switch e {
	case OrganizationHistoryOrderFieldName, OrganizationHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e OrganizationHistoryOrderField) String() string {
	return string(e)
}

func (e *OrganizationHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationHistoryOrderField", str)
	}
	return nil
}

func (e OrganizationHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Organization connections can be ordered.
type OrganizationOrderField string

const (
	OrganizationOrderFieldName        OrganizationOrderField = "name"
	OrganizationOrderFieldDisplayName OrganizationOrderField = "display_name"
)

var AllOrganizationOrderField = []OrganizationOrderField{
	OrganizationOrderFieldName,
	OrganizationOrderFieldDisplayName,
}

func (e OrganizationOrderField) IsValid() bool {
	switch e {
	case OrganizationOrderFieldName, OrganizationOrderFieldDisplayName:
		return true
	}
	return false
}

func (e OrganizationOrderField) String() string {
	return string(e)
}

func (e *OrganizationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OrganizationOrderField", str)
	}
	return nil
}

func (e OrganizationOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which TemplateHistory connections can be ordered.
type TemplateHistoryOrderField string

const (
	TemplateHistoryOrderFieldName TemplateHistoryOrderField = "name"
)

var AllTemplateHistoryOrderField = []TemplateHistoryOrderField{
	TemplateHistoryOrderFieldName,
}

func (e TemplateHistoryOrderField) IsValid() bool {
	switch e {
	case TemplateHistoryOrderFieldName:
		return true
	}
	return false
}

func (e TemplateHistoryOrderField) String() string {
	return string(e)
}

func (e *TemplateHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateHistoryOrderField", str)
	}
	return nil
}

func (e TemplateHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Template connections can be ordered.
type TemplateOrderField string

const (
	TemplateOrderFieldName TemplateOrderField = "name"
)

var AllTemplateOrderField = []TemplateOrderField{
	TemplateOrderFieldName,
}

func (e TemplateOrderField) IsValid() bool {
	switch e {
	case TemplateOrderFieldName:
		return true
	}
	return false
}

func (e TemplateOrderField) String() string {
	return string(e)
}

func (e *TemplateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TemplateOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TemplateOrderField", str)
	}
	return nil
}

func (e TemplateOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which UserHistory connections can be ordered.
type UserHistoryOrderField string

const (
	UserHistoryOrderFieldFirstName   UserHistoryOrderField = "first_name"
	UserHistoryOrderFieldLastName    UserHistoryOrderField = "last_name"
	UserHistoryOrderFieldDisplayName UserHistoryOrderField = "display_name"
)

var AllUserHistoryOrderField = []UserHistoryOrderField{
	UserHistoryOrderFieldFirstName,
	UserHistoryOrderFieldLastName,
	UserHistoryOrderFieldDisplayName,
}

func (e UserHistoryOrderField) IsValid() bool {
	switch e {
	case UserHistoryOrderFieldFirstName, UserHistoryOrderFieldLastName, UserHistoryOrderFieldDisplayName:
		return true
	}
	return false
}

func (e UserHistoryOrderField) String() string {
	return string(e)
}

func (e *UserHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserHistoryOrderField", str)
	}
	return nil
}

func (e UserHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which User connections can be ordered.
type UserOrderField string

const (
	UserOrderFieldFirstName   UserOrderField = "first_name"
	UserOrderFieldLastName    UserOrderField = "last_name"
	UserOrderFieldDisplayName UserOrderField = "display_name"
)

var AllUserOrderField = []UserOrderField{
	UserOrderFieldFirstName,
	UserOrderFieldLastName,
	UserOrderFieldDisplayName,
}

func (e UserOrderField) IsValid() bool {
	switch e {
	case UserOrderFieldFirstName, UserOrderFieldLastName, UserOrderFieldDisplayName:
		return true
	}
	return false
}

func (e UserOrderField) String() string {
	return string(e)
}

func (e *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

func (e UserOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which WebhookHistory connections can be ordered.
type WebhookHistoryOrderField string

const (
	WebhookHistoryOrderFieldName WebhookHistoryOrderField = "name"
	WebhookHistoryOrderFieldURL  WebhookHistoryOrderField = "url"
)

var AllWebhookHistoryOrderField = []WebhookHistoryOrderField{
	WebhookHistoryOrderFieldName,
	WebhookHistoryOrderFieldURL,
}

func (e WebhookHistoryOrderField) IsValid() bool {
	switch e {
	case WebhookHistoryOrderFieldName, WebhookHistoryOrderFieldURL:
		return true
	}
	return false
}

func (e WebhookHistoryOrderField) String() string {
	return string(e)
}

func (e *WebhookHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookHistoryOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookHistoryOrderField", str)
	}
	return nil
}

func (e WebhookHistoryOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Properties by which Webhook connections can be ordered.
type WebhookOrderField string

const (
	WebhookOrderFieldName WebhookOrderField = "name"
	WebhookOrderFieldURL  WebhookOrderField = "url"
)

var AllWebhookOrderField = []WebhookOrderField{
	WebhookOrderFieldName,
	WebhookOrderFieldURL,
}

func (e WebhookOrderField) IsValid() bool {
	switch e {
	case WebhookOrderFieldName, WebhookOrderFieldURL:
		return true
	}
	return false
}

func (e WebhookOrderField) String() string {
	return string(e)
}

func (e *WebhookOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookOrderField", str)
	}
	return nil
}

func (e WebhookOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
