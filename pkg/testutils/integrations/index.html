<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Integration Test Console</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM"
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@json-editor/json-editor@2.12.3/dist/css/bootstrap5.min.css"
    />
    <style>
      .providers-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 1.5rem;
        width: 100%;
      }
      body {
        background: #f4f5f7;
      }
      .integration-card {
        border: 1px solid #dee2e6;
        border-radius: 10px;
        background: #fff;
        padding: 24px;
        box-shadow: 0 2px 6px rgba(15, 23, 42, 0.08);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        height: 100%;
      }
      .provider-header {
        display: flex;
        gap: 1rem;
        align-items: center;
      }
      .provider-info {
        flex: 1;
        min-width: 0;
      }
      .provider-meta {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        align-items: flex-end;
        justify-content: center;
      }
      .provider-logo {
        width: 52px;
        height: 52px;
        border-radius: 12px;
        background: #f1f5f9;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 6px;
        flex-shrink: 0;
      }
      .provider-logo img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
      }
      .provider-info h3 {
        margin-bottom: 0.15rem;
      }
      .provider-actions {
        margin-top: auto;
      }
      .provider-actions .btn {
        width: 100%;
      }
      .provider-body {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .status-badge {
        display: inline-block;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 0.85rem;
        font-weight: 600;
      }
      .docs-link {
        white-space: nowrap;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 4px 10px;
      }
      .config-modal {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.4);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1050;
        padding: 1rem;
      }
      .config-modal.show {
        display: flex;
      }
      .config-modal__dialog {
        background: #fff;
        border-radius: 12px;
        max-width: 640px;
        width: 100%;
        display: flex;
        flex-direction: column;
        max-height: 90vh;
        box-shadow: 0 20px 40px rgba(15, 23, 42, 0.2);
      }
      .config-modal__header,
      .config-modal__footer {
        padding: 1rem 1.5rem;
        border-bottom: 1px solid #e2e8f0;
      }
      .config-modal__footer {
        border-top: 1px solid #e2e8f0;
        border-bottom: none;
        display: flex;
        justify-content: flex-end;
        gap: 0.75rem;
      }
      .config-modal__body {
        padding: 1.5rem;
        overflow-y: auto;
      }
      .config-modal__close {
        border: none;
        background: none;
        font-size: 1.25rem;
      }
      .status-connected {
        background: #d1f1e0;
        color: #0f5132;
      }
      .status-configured {
        background: #d7e8ff;
        color: #0b3d91;
      }
      .status-expired {
        background: #fff3cd;
        color: #664d03;
      }
      .status-invalid {
        background: #f8d7da;
        color: #842029;
      }
      .status-disconnected {
        background: #e2e3e5;
        color: #495057;
      }
      .log-entry {
        padding: 8px 12px;
        margin: 4px 0;
        border-radius: 8px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
        font-size: 0.85rem;
      }
      .log-success {
        background: #d1f1e0;
        color: #0f5132;
      }
      .log-error {
        background: #f8d7da;
        color: #842029;
      }
      .log-info {
        background: #d7e8ff;
        color: #0b3d91;
      }
    </style>
  </head>
  <body>
    <div class="container my-4">
      <div class="row">
        <div class="col-12">
          <h1 class="text-center mb-3">Integration Test Console</h1>
          <p class="text-center text-muted mb-4">
            Drive the declarative integration pipeline end-to-end against a running Openlane instance.
          </p>
          <div class="alert alert-info d-flex justify-content-between align-items-center" id="authStatus">
            <div>
              <strong>Authentication Status:</strong>
              <span id="authStatusText">Checking...</span>
            </div>
            <button class="btn btn-sm btn-outline-light d-none" id="loginButton">Login with Seeded User</button>
          </div>

          <div id="callbackNotice"></div>

          <section class="mt-4">
            <div class="d-flex justify-content-between align-items-center">
              <h2 class="mb-3">Available Providers</h2>
              <button class="btn btn-outline-primary btn-sm" id="refreshProviders">Refresh Providers</button>
            </div>
            <div id="providersContainer" class="providers-grid">
              <div class="text-center text-muted" id="providersPlaceholder">Loading provider metadata...</div>
            </div>
          </section>

          <section class="mt-5">
            <div class="d-flex justify-content-between align-items-center">
              <h2 class="mb-3">Configured Integrations</h2>
              <button class="btn btn-outline-secondary btn-sm" id="refreshIntegrations">Refresh List</button>
            </div>
            <div id="integrationsList" class="mb-4">
              <div class="text-center text-muted">No data loaded yet</div>
            </div>
          </section>

          <section class="mt-4">
            <div class="d-flex justify-content-between align-items-center">
              <h2 class="mb-3">Activity Log</h2>
              <button class="btn btn-outline-secondary btn-sm" id="clearLog">Clear Log</button>
            </div>
            <div
              id="activityLog"
              style="max-height: 320px; overflow-y: auto; background: #fff; border-radius: 8px; border: 1px solid #e2e8f0; padding: 12px;"
            ></div>
          </section>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@json-editor/json-editor@2.12.3/dist/jsoneditor.min.js"></script>
    <div class="config-modal" id="configModal" aria-hidden="true">
      <div class="config-modal__dialog">
        <div class="config-modal__header d-flex justify-content-between align-items-center">
          <div>
            <h5 class="mb-0" id="configModalTitle">Configure Provider</h5>
            <small class="text-muted" id="configModalSubtitle"></small>
          </div>
          <button class="config-modal__close" id="configModalClose" aria-label="Close">&times;</button>
        </div>
        <div class="config-modal__body">
          <div id="configEditorContainer"></div>
        </div>
        <div class="config-modal__footer">
          <button class="btn btn-outline-secondary" id="configModalCancel">Cancel</button>
          <button class="btn btn-primary" id="configModalSubmit">Submit Configuration</button>
        </div>
      </div>
    </div>
    <script>
      const apiBase = "http://localhost:17608";
      let authToken = null;
      let userInfo = null;
      const providerMetadata = new Map();
      let activeConfigProvider = null;
      let configModalEditor = null;
      const integrationSecretsQuery = `
        query ($kind: String!) {
          integrations(where: { kind: $kind }) {
            edges {
              node {
                id
                secrets {
                  edges {
                    node {
                      id
                      secretName
                      description
                      kind
                      expiresAt
                      lastUsedAt
                      credentialSet
                      metadata
                    }
                  }
                }
              }
            }
          }
        }
      `;

      const providerDomId = (name) => name.toLowerCase().replace(/[^a-z0-9_-]/g, "_");
      function renderSchemaSummary(schema) {
        if (!schema?.properties) {
          return '<p class="text-muted small mb-0">Credential schema not available.</p>';
        }
        const required = new Set(schema.required || []);
        const items = Object.entries(schema.properties).map(([key, prop]) => {
          const title = prop.title || key;
          const desc = prop.description || "Required by the integration";
          const requiredMark = required.has(key) ? '<span class="text-danger ms-1">*</span>' : "";
          return `<li><strong>${title}</strong>${requiredMark}<div class="text-muted">${desc}</div></li>`;
        });
        return `<ul class="list-unstyled small mb-0">${items.join("")}</ul>`;
      }

      function openConfigModal(providerName) {
        const provider = providerMetadata.get(providerName);
        if (!provider?.credentialsSchema) {
          log(`Provider ${providerName} does not expose a credential schema`, "error");
          return;
        }
        activeConfigProvider = providerName;
        const modal = document.getElementById("configModal");
        document.getElementById("configModalTitle").textContent = `Configure ${provider.displayName || provider.name}`;
        document.getElementById("configModalSubtitle").textContent =
          provider.labels?.vendor ? `Vendor: ${provider.labels.vendor}` : "";
        const container = document.getElementById("configEditorContainer");
        container.innerHTML = "";
        if (configModalEditor) {
          configModalEditor.destroy();
          configModalEditor = null;
        }
        configModalEditor = new JSONEditor(container, {
          schema: provider.credentialsSchema,
          theme: "bootstrap5",
          disable_collapse: true,
          disable_properties: true,
          prompt_before_delete: false,
        });
        modal.classList.add("show");
      }

      function closeConfigModal() {
        const modal = document.getElementById("configModal");
        modal.classList.remove("show");
        if (configModalEditor) {
          configModalEditor.destroy();
          configModalEditor = null;
        }
        activeConfigProvider = null;
      }

      async function submitConfiguration() {
        if (!activeConfigProvider || !configModalEditor) {
          log("No provider selected for configuration", "error");
          return;
        }
        try {
          const payload = { payload: configModalEditor.getValue() };
          log(`Submitting configuration for ${activeConfigProvider}`, "info");
          const response = await makeRequest(`/v1/integrations/${activeConfigProvider}/config`, {
            method: "POST",
            body: JSON.stringify(payload),
          });
          if (!response.ok) throw new Error(await response.text());
          log(`Configuration saved for ${activeConfigProvider}`, "success");
          closeConfigModal();
          await handleStatus(activeConfigProvider);
          await loadIntegrations();
        } catch (err) {
          log(`Failed to save configuration: ${err.message}`, "error");
        }
      }

      function log(message, type = "info") {
        const container = document.getElementById("activityLog");
        const entry = document.createElement("div");
        entry.className = `log-entry log-${type}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        container.appendChild(entry);
        container.scrollTop = container.scrollHeight;
      }

      function getCSRFToken() {
        const cookieName = "ol.csrf-token";
        return document.cookie
          .split(";")
          .map((c) => c.trim().split("="))
          .find(([name]) => name === cookieName)?.[1] || null;
      }

      async function makeRequest(path, options = {}) {
        const headers = { "Content-Type": "application/json", ...(options.headers || {}) };
        const method = (options.method || "GET").toUpperCase();
        if (authToken) {
          headers["Authorization"] = `Bearer ${authToken}`;
        }
        if (method !== "GET" && !path.includes("/login")) {
          const csrf = getCSRFToken();
          if (csrf) {
            headers["X-CSRF-Token"] = csrf;
          }
        }
        return fetch(`${apiBase}${path}`, {
          ...options,
          method,
          headers,
          credentials: "include",
        });
      }

      async function loginWithSeedUser() {
        try {
          log("Attempting login with seeded user", "info");
          const response = await fetch(`${apiBase}/v1/login`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            credentials: "include",
            body: JSON.stringify({
              username: "mitb@theopenlane.io",
              password: "mattisthebest1234",
            }),
          });
          if (!response.ok) {
            log(`Login failed: ${await response.text()}`, "error");
            return false;
          }
          const data = await response.json();
          if (data.success && data.access_token) {
            authToken = data.access_token;
            log("Login successful", "success");
            return true;
          }
          log("Unexpected login response format", "error");
          return false;
        } catch (err) {
          log(`Login error: ${err.message}`, "error");
          return false;
        }
      }

      async function ensureAuthenticated() {
        try {
          const params = new URLSearchParams(window.location.search);
          const sessionToken = params.get("session");
          if (sessionToken) {
            authToken = sessionToken;
            log("Adopted session token from query param", "info");
          }

          if (!authToken) {
            const loggedIn = await loginWithSeedUser();
            if (!loggedIn) {
              document.getElementById("authStatus").className =
                "alert alert-warning d-flex justify-content-between align-items-center";
              document.getElementById("authStatusText").innerHTML =
                'Authentication required. <button class="btn btn-sm btn-primary ms-2" onclick="loginWithSeedUser().then(ok => ok && initialize())">Login</button>';
              document.getElementById("loginButton").classList.remove("d-none");
              return false;
            }
          }

          const response = await makeRequest("/query", {
            method: "POST",
            body: JSON.stringify({ query: "{ self { id displayName email } }" }),
          });
          if (!response.ok) {
            log(`Auth check failed: HTTP ${response.status}`, "error");
            return false;
          }
          const data = await response.json();
          if (!data?.data?.self) {
            log("Auth check failed: no self payload", "error");
            return false;
          }
          userInfo = data.data.self;
          document.getElementById("authStatus").className =
            "alert alert-success d-flex justify-content-between align-items-center";
          document.getElementById("authStatusText").innerHTML =
            `Authenticated as <strong>${userInfo.displayName}</strong> (${userInfo.email})`;
          document.getElementById("loginButton").classList.add("d-none");
          log(`Authenticated as ${userInfo.displayName}`, "success");
          return true;
        } catch (err) {
          log(`Auth check error: ${err.message}`, "error");
          return false;
        }
      }

      function updateProviderStatus(provider, status, tokenValid = false, tokenExpired = false) {
        const badge = document.getElementById(`${providerDomId(provider)}-status`);
        if (!badge) return;
        badge.className = "status-badge";
        switch (status) {
          case "connected":
            badge.classList.add(tokenExpired ? "status-expired" : "status-connected");
            badge.textContent = tokenExpired ? "Token Expired" : "Connected";
            break;
          case "configured":
            badge.classList.add("status-configured");
            badge.textContent = "Configured";
            break;
          case "invalid":
            badge.classList.add("status-invalid");
            badge.textContent = "Invalid";
            break;
          default:
            badge.classList.add("status-disconnected");
            badge.textContent = "Disconnected";
        }
      }

      async function fetchProviders() {
        try {
          log("Fetching provider library", "info");
          const response = await makeRequest("/v1/integrations/providers");
          if (!response.ok) throw new Error(await response.text());
          const data = await response.json();
          log(`Loaded ${data.providers?.length || 0} providers`, "success");
          return data.providers || [];
        } catch (err) {
          log(`Failed to load providers: ${err.message}`, "error");
          return [];
        }
      }

      function renderProviders(providers) {
        const container = document.getElementById("providersContainer");
        container.innerHTML = "";
        if (providers.length === 0) {
          container.innerHTML = '<div class="text-center text-muted">No providers registered</div>';
          return;
        }

        providerMetadata.clear();
        providerMetadata.clear();
        providers
          .slice()
          .sort((a, b) => (a.displayName || a.name).localeCompare(b.displayName || b.name))
          .forEach((provider) => {
            if (provider?.active === false) {
              return;
            }
            providerMetadata.set(provider.name, provider);
            const name = provider.name || provider.displayName;
            const id = providerDomId(name);
            const card = document.createElement("div");
            card.className = "integration-card";
            const initials = (provider.displayName || provider.name || "??").slice(0, 2).toUpperCase();
            const logo = provider.logoUrl
              ? `<div class="provider-logo"><img src="${provider.logoUrl}" alt="${provider.displayName || provider.name} logo" loading="lazy" onerror="this.onerror=null;this.remove();this.parentElement.textContent='${initials}';" /></div>`
              : `<div class="provider-logo text-uppercase fw-bold">${initials}</div>`;
            const vendorLabel = provider.labels?.vendor || provider.category || "Integration";
            const docsLink = provider.docsUrl
              ? `<a class="btn btn-sm btn-outline-secondary docs-link" href="${provider.docsUrl}" target="_blank" rel="noopener noreferrer">Docs â†—</a>`
              : "";
            card.innerHTML = `
              <div class="provider-header">
                ${logo}
                <div class="provider-info">
                  <h3 class="mb-1">${provider.displayName || provider.name}</h3>
                  <small class="text-muted text-uppercase">${vendorLabel}</small>
                </div>
                <div class="provider-meta text-end">
                  ${docsLink || ""}
                  <span class="status-badge status-disconnected" id="${id}-status">Disconnected</span>
                </div>
              </div>
              <div class="provider-body">
                <small class="text-muted mb-0">Authentication: ${(provider.authType || "unknown").toUpperCase()}</small>
              </div>
              <div class="provider-actions d-grid gap-2" id="${id}-actions"></div>
            `;

            container.appendChild(card);

            const actions = card.querySelector(`#${id}-actions`);
            const addButton = (label, style, handler) => {
              const btn = document.createElement("button");
              btn.type = "button";
              btn.className = `btn btn-${style}`;
              btn.textContent = label;
              btn.addEventListener("click", handler);
              actions.appendChild(btn);
              return btn;
            };

            if (provider.credentialsSchema) {
              addButton("Submit Configuration", "primary", () => openConfigModal(provider.name));
            }

            if (provider.authType === "oauth2" || provider.authType === "oidc") {
              addButton("Start OAuth Flow", "dark", () => handleOAuth(provider.name));
              addButton("Refresh Token", "outline-warning", () => handleRefresh(provider.name));
            }

            addButton("Check Status", "outline-secondary", () => handleStatus(provider.name));
            addButton("Disconnect Integration", "outline-danger", () => handleDisconnect(provider.name));
          });
      }

      async function handleOAuth(provider) {
        const meta = providerMetadata.get(provider);
        if (meta?.oauth?.authUrl && meta?.oauth?.clientId && meta?.oauth?.redirectUri) {
          const params = new URLSearchParams({
            client_id: meta.oauth.clientId,
            response_type: "code",
            redirect_uri: meta.oauth.redirectUri,
            scope: (meta.oauth.scopes || []).join(" "),
            state: btoa(JSON.stringify({ provider, ts: Date.now() })),
          });
          if (meta.oauth.authParams) {
            Object.entries(meta.oauth.authParams).forEach(([key, value]) => params.set(key, value));
          }
          const authorizeUrl = `${meta.oauth.authUrl}?${params.toString()}`;
          log(`Redirecting to ${meta.displayName || provider} OAuth flow`, "info");
          window.location.href = authorizeUrl;
          return;
        }
        try {
          const payload = { provider };
          log(`Starting OAuth flow for ${provider}`, "info");
          const response = await makeRequest("/v1/integrations/oauth/start", {
            method: "POST",
            body: JSON.stringify(payload),
          });
          if (!response.ok) throw new Error(await response.text());
          const data = await response.json();
          if (!data.authUrl) throw new Error("Provider did not return an authUrl");
          window.location.href = data.authUrl;
        } catch (err) {
          log(`OAuth start failed: ${err.message}`, "error");
        }
      }

      async function handleStatus(provider) {
        try {
          log(`Checking status for ${provider}`, "info");
          const response = await makeRequest("/query", {
            method: "POST",
            body: JSON.stringify({ query: integrationSecretsQuery, variables: { kind: provider } }),
          });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const payload = await response.json();
          const integration = payload?.data?.integrations?.edges?.[0]?.node;
          if (!integration) {
            updateProviderStatus(provider, "disconnected");
            return;
          }
          const secrets = integration.secrets?.edges?.map((edge) => edge.node) || [];
          const tokenMatchers = [/access_token/i, /api_token/i, /token/i];
          const primarySecret =
            tokenMatchers
              .map((regex) => secrets.find((secret) => regex.test(secret?.secretName || "")))
              .find(Boolean) || null;
          const expirationSource =
            primarySecret?.expiresAt ||
            primarySecret?.metadata?.expiresAt ||
            secrets.find((secret) => (secret?.secretName || "").includes("_expires_at"))?.metadata?.expiresAt ||
            null;
          const expired = expirationSource ? new Date(expirationSource) < new Date() : false;
          const status = primarySecret ? (expired ? "expired" : "connected") : secrets.length ? "configured" : "disconnected";
          updateProviderStatus(provider, status, Boolean(primarySecret), expired);
        } catch (err) {
          log(`Status check failed: ${err.message}`, "error");
          updateProviderStatus(provider, "disconnected");
        }
      }

      async function handleRefresh(provider) {
        try {
          const response = await makeRequest(`/v1/integrations/${provider}/refresh`, {
            method: "POST",
          });
          if (!response.ok) throw new Error(await response.text());
          log(`Trigger refresh succeeded for ${provider}`, "success");
          await handleStatus(provider);
        } catch (err) {
          log(`Refresh failed: ${err.message}`, "error");
        }
      }

      async function handleDisconnect(provider) {
        try {
          const lookup = await makeRequest("/query", {
            method: "POST",
            body: JSON.stringify({
              query: "query ($kind: String!) { integrations(where: { kind: $kind }) { edges { node { id } } } }",
              variables: { kind: provider },
            }),
          });
          if (!lookup.ok) throw new Error(`lookup failed: HTTP ${lookup.status}`);
          const data = await lookup.json();
          const id = data?.data?.integrations?.edges?.[0]?.node?.id;
          if (!id) {
            log(`No integration to delete for ${provider}`, "info");
            updateProviderStatus(provider, "disconnected");
            return;
          }
          const response = await makeRequest("/query", {
            method: "POST",
            body: JSON.stringify({
              query: "mutation ($id: ID!) { deleteIntegration(id: $id) { deletedID } }",
              variables: { id },
            }),
          });
          if (!response.ok) throw new Error(`delete failed: HTTP ${response.status}`);
          log(`Integration deleted for ${provider}`, "success");
          updateProviderStatus(provider, "disconnected");
          await loadIntegrations();
        } catch (err) {
          log(`Disconnect failed: ${err.message}`, "error");
        }
      }

      async function loadIntegrations() {
        log("Loading configured integrations", "info");
        try {
          const container = document.getElementById("integrationsList");
          const response = await makeRequest("/query", {
            method: "POST",
            body: JSON.stringify({ query: "{ integrations { edges { node { id name kind description updatedAt } } } }" }),
          });
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const data = await response.json();
          const items = data?.data?.integrations?.edges || [];
          if (items.length === 0) {
            container.innerHTML = '<div class="text-center text-muted">No integrations configured</div>';
            return;
          }
          container.innerHTML = items
            .map(({ node }) => `
              <div class="card mb-2">
                <div class="card-body">
                  <div class="d-flex justify-content-between align-items-center">
                    <div>
                      <h6 class="card-title mb-1">${node.name}</h6>
                      <small class="text-muted">Provider: ${node.kind}</small>
                    </div>
                    <small class="text-muted">ID: ${node.id}</small>
                  </div>
                  <p class="card-text mt-2 mb-1">${node.description || "No description"}</p>
                  <small class="text-muted">Updated ${new Date(node.updatedAt).toLocaleString()}</small>
                </div>
              </div>
            `)
            .join("");
        } catch (err) {
          log(`Failed to load integrations: ${err.message}`, "error");
        }
      }

      function handleOAuthCallback() {
        const params = new URLSearchParams(window.location.search);
        const provider = params.get("provider");
        const status = params.get("status");
        const message = params.get("message");
        if (!provider || !status) return;
        const container = document.getElementById("callbackNotice");
        container.innerHTML = `
          <div class="alert ${status === "success" ? "alert-success" : "alert-danger"} alert-dismissible fade show">
            <strong>${status === "success" ? "Integration Connected" : "Integration Error"}:</strong>
            ${decodeURIComponent(message || provider)}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
          </div>
        `;
      }

      async function loadProvidersAndStatus() {
        const providers = await fetchProviders();
        renderProviders(providers);
        for (const provider of providers) {
          await handleStatus(provider.name);
        }
      }

      async function initialize() {
        log("Initializing integration console", "info");
        handleOAuthCallback();
        const authed = await ensureAuthenticated();
        if (!authed) {
          log("Authentication required before continuing", "error");
          return;
        }
        await loadProvidersAndStatus();
        await loadIntegrations();
        log("Initialization complete", "success");
      }

      document.addEventListener("DOMContentLoaded", () => {
        initialize();
        document.getElementById("loginButton").addEventListener("click", () => {
          loginWithSeedUser().then((ok) => ok && initialize());
        });
        document.getElementById("refreshProviders").addEventListener("click", loadProvidersAndStatus);
        document.getElementById("refreshIntegrations").addEventListener("click", loadIntegrations);
        document.getElementById("clearLog").addEventListener("click", () => {
          document.getElementById("activityLog").innerHTML = "";
        });
        document.getElementById("configModalClose").addEventListener("click", closeConfigModal);
        document.getElementById("configModalCancel").addEventListener("click", closeConfigModal);
        document.getElementById("configModalSubmit").addEventListener("click", submitConfiguration);
        document.getElementById("configModal").addEventListener("click", (event) => {
          if (event.target.id === "configModal") {
            closeConfigModal();
          }
        });
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            closeConfigModal();
          }
        });
      });

      window.loginWithSeedUser = loginWithSeedUser;
    </script>
  </body>
</html>
