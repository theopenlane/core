// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"reflect"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/theopenlane/ent/generated/actionplan"
	"github.com/theopenlane/ent/generated/actionplanhistory"
	"github.com/theopenlane/ent/generated/apitoken"
	"github.com/theopenlane/ent/generated/assessment"
	"github.com/theopenlane/ent/generated/assessmenthistory"
	"github.com/theopenlane/ent/generated/assessmentresponse"
	"github.com/theopenlane/ent/generated/assessmentresponsehistory"
	"github.com/theopenlane/ent/generated/asset"
	"github.com/theopenlane/ent/generated/assethistory"
	"github.com/theopenlane/ent/generated/contact"
	"github.com/theopenlane/ent/generated/contacthistory"
	"github.com/theopenlane/ent/generated/control"
	"github.com/theopenlane/ent/generated/controlhistory"
	"github.com/theopenlane/ent/generated/controlimplementation"
	"github.com/theopenlane/ent/generated/controlimplementationhistory"
	"github.com/theopenlane/ent/generated/controlobjective"
	"github.com/theopenlane/ent/generated/controlobjectivehistory"
	"github.com/theopenlane/ent/generated/customdomain"
	"github.com/theopenlane/ent/generated/customdomainhistory"
	"github.com/theopenlane/ent/generated/customtypeenum"
	"github.com/theopenlane/ent/generated/directoryaccount"
	"github.com/theopenlane/ent/generated/directoryaccounthistory"
	"github.com/theopenlane/ent/generated/directorygroup"
	"github.com/theopenlane/ent/generated/directorygrouphistory"
	"github.com/theopenlane/ent/generated/directorymembership"
	"github.com/theopenlane/ent/generated/directorymembershiphistory"
	"github.com/theopenlane/ent/generated/directorysyncrun"
	"github.com/theopenlane/ent/generated/dnsverification"
	"github.com/theopenlane/ent/generated/dnsverificationhistory"
	"github.com/theopenlane/ent/generated/documentdata"
	"github.com/theopenlane/ent/generated/documentdatahistory"
	"github.com/theopenlane/ent/generated/emailverificationtoken"
	"github.com/theopenlane/ent/generated/entity"
	"github.com/theopenlane/ent/generated/entityhistory"
	"github.com/theopenlane/ent/generated/entitytype"
	"github.com/theopenlane/ent/generated/entitytypehistory"
	"github.com/theopenlane/ent/generated/event"
	"github.com/theopenlane/ent/generated/evidence"
	"github.com/theopenlane/ent/generated/evidencehistory"
	"github.com/theopenlane/ent/generated/export"
	"github.com/theopenlane/ent/generated/file"
	"github.com/theopenlane/ent/generated/filedownloadtoken"
	"github.com/theopenlane/ent/generated/filehistory"
	"github.com/theopenlane/ent/generated/finding"
	"github.com/theopenlane/ent/generated/findingcontrol"
	"github.com/theopenlane/ent/generated/findingcontrolhistory"
	"github.com/theopenlane/ent/generated/findinghistory"
	"github.com/theopenlane/ent/generated/group"
	"github.com/theopenlane/ent/generated/grouphistory"
	"github.com/theopenlane/ent/generated/groupmembership"
	"github.com/theopenlane/ent/generated/groupmembershiphistory"
	"github.com/theopenlane/ent/generated/groupsetting"
	"github.com/theopenlane/ent/generated/groupsettinghistory"
	"github.com/theopenlane/ent/generated/hush"
	"github.com/theopenlane/ent/generated/hushhistory"
	"github.com/theopenlane/ent/generated/impersonationevent"
	"github.com/theopenlane/ent/generated/integration"
	"github.com/theopenlane/ent/generated/integrationhistory"
	"github.com/theopenlane/ent/generated/internalpolicy"
	"github.com/theopenlane/ent/generated/internalpolicyhistory"
	"github.com/theopenlane/ent/generated/invite"
	"github.com/theopenlane/ent/generated/jobresult"
	"github.com/theopenlane/ent/generated/jobrunner"
	"github.com/theopenlane/ent/generated/jobrunnerregistrationtoken"
	"github.com/theopenlane/ent/generated/jobrunnertoken"
	"github.com/theopenlane/ent/generated/jobtemplate"
	"github.com/theopenlane/ent/generated/jobtemplatehistory"
	"github.com/theopenlane/ent/generated/mappabledomain"
	"github.com/theopenlane/ent/generated/mappabledomainhistory"
	"github.com/theopenlane/ent/generated/mappedcontrol"
	"github.com/theopenlane/ent/generated/mappedcontrolhistory"
	"github.com/theopenlane/ent/generated/narrative"
	"github.com/theopenlane/ent/generated/narrativehistory"
	"github.com/theopenlane/ent/generated/note"
	"github.com/theopenlane/ent/generated/notehistory"
	"github.com/theopenlane/ent/generated/notification"
	"github.com/theopenlane/ent/generated/onboarding"
	"github.com/theopenlane/ent/generated/organization"
	"github.com/theopenlane/ent/generated/organizationhistory"
	"github.com/theopenlane/ent/generated/organizationsetting"
	"github.com/theopenlane/ent/generated/organizationsettinghistory"
	"github.com/theopenlane/ent/generated/orgmembership"
	"github.com/theopenlane/ent/generated/orgmembershiphistory"
	"github.com/theopenlane/ent/generated/orgmodule"
	"github.com/theopenlane/ent/generated/orgprice"
	"github.com/theopenlane/ent/generated/orgproduct"
	"github.com/theopenlane/ent/generated/orgsubscription"
	"github.com/theopenlane/ent/generated/orgsubscriptionhistory"
	"github.com/theopenlane/ent/generated/passwordresettoken"
	"github.com/theopenlane/ent/generated/personalaccesstoken"
	"github.com/theopenlane/ent/generated/procedure"
	"github.com/theopenlane/ent/generated/procedurehistory"
	"github.com/theopenlane/ent/generated/program"
	"github.com/theopenlane/ent/generated/programhistory"
	"github.com/theopenlane/ent/generated/programmembership"
	"github.com/theopenlane/ent/generated/programmembershiphistory"
	"github.com/theopenlane/ent/generated/remediation"
	"github.com/theopenlane/ent/generated/remediationhistory"
	"github.com/theopenlane/ent/generated/review"
	"github.com/theopenlane/ent/generated/reviewhistory"
	"github.com/theopenlane/ent/generated/risk"
	"github.com/theopenlane/ent/generated/riskhistory"
	"github.com/theopenlane/ent/generated/scan"
	"github.com/theopenlane/ent/generated/scanhistory"
	"github.com/theopenlane/ent/generated/scheduledjob"
	"github.com/theopenlane/ent/generated/scheduledjobhistory"
	"github.com/theopenlane/ent/generated/scheduledjobrun"
	"github.com/theopenlane/ent/generated/standard"
	"github.com/theopenlane/ent/generated/standardhistory"
	"github.com/theopenlane/ent/generated/subcontrol"
	"github.com/theopenlane/ent/generated/subcontrolhistory"
	"github.com/theopenlane/ent/generated/subprocessor"
	"github.com/theopenlane/ent/generated/subprocessorhistory"
	"github.com/theopenlane/ent/generated/subscriber"
	"github.com/theopenlane/ent/generated/tagdefinition"
	"github.com/theopenlane/ent/generated/task"
	"github.com/theopenlane/ent/generated/taskhistory"
	"github.com/theopenlane/ent/generated/template"
	"github.com/theopenlane/ent/generated/templatehistory"
	"github.com/theopenlane/ent/generated/tfasetting"
	"github.com/theopenlane/ent/generated/trustcenter"
	"github.com/theopenlane/ent/generated/trustcentercompliance"
	"github.com/theopenlane/ent/generated/trustcentercompliancehistory"
	"github.com/theopenlane/ent/generated/trustcenterdoc"
	"github.com/theopenlane/ent/generated/trustcenterdochistory"
	"github.com/theopenlane/ent/generated/trustcenterentity"
	"github.com/theopenlane/ent/generated/trustcenterentityhistory"
	"github.com/theopenlane/ent/generated/trustcenterhistory"
	"github.com/theopenlane/ent/generated/trustcentersetting"
	"github.com/theopenlane/ent/generated/trustcentersettinghistory"
	"github.com/theopenlane/ent/generated/trustcentersubprocessor"
	"github.com/theopenlane/ent/generated/trustcentersubprocessorhistory"
	"github.com/theopenlane/ent/generated/trustcenterwatermarkconfig"
	"github.com/theopenlane/ent/generated/trustcenterwatermarkconfighistory"
	"github.com/theopenlane/ent/generated/user"
	"github.com/theopenlane/ent/generated/userhistory"
	"github.com/theopenlane/ent/generated/usersetting"
	"github.com/theopenlane/ent/generated/usersettinghistory"
	"github.com/theopenlane/ent/generated/vulnerability"
	"github.com/theopenlane/ent/generated/vulnerabilityhistory"
	"github.com/theopenlane/ent/generated/webauthn"
	"github.com/theopenlane/ent/generated/workflowassignment"
	"github.com/theopenlane/ent/generated/workflowassignmenthistory"
	"github.com/theopenlane/ent/generated/workflowassignmenttarget"
	"github.com/theopenlane/ent/generated/workflowassignmenttargethistory"
	"github.com/theopenlane/ent/generated/workflowdefinition"
	"github.com/theopenlane/ent/generated/workflowdefinitionhistory"
	"github.com/theopenlane/ent/generated/workflowevent"
	"github.com/theopenlane/ent/generated/workfloweventhistory"
	"github.com/theopenlane/ent/generated/workflowinstance"
	"github.com/theopenlane/ent/generated/workflowinstancehistory"
	"github.com/theopenlane/ent/generated/workflowobjectref"
	"github.com/theopenlane/ent/generated/workflowobjectrefhistory"
)

// ent aliases to avoid import conflicts in user's code.
type (
	Op            = ent.Op
	Hook          = ent.Hook
	Value         = ent.Value
	Query         = ent.Query
	QueryContext  = ent.QueryContext
	Querier       = ent.Querier
	QuerierFunc   = ent.QuerierFunc
	Interceptor   = ent.Interceptor
	InterceptFunc = ent.InterceptFunc
	Traverser     = ent.Traverser
	TraverseFunc  = ent.TraverseFunc
	Policy        = ent.Policy
	Mutator       = ent.Mutator
	Mutation      = ent.Mutation
	MutateFunc    = ent.MutateFunc
)

type clientCtxKey struct{}

// FromContext returns a Client stored inside a context, or nil if there isn't one.
func FromContext(ctx context.Context) *Client {
	c, _ := ctx.Value(clientCtxKey{}).(*Client)
	return c
}

// NewContext returns a new context with the given Client attached.
func NewContext(parent context.Context, c *Client) context.Context {
	return context.WithValue(parent, clientCtxKey{}, c)
}

type txCtxKey struct{}

// TxFromContext returns a Tx stored inside a context, or nil if there isn't one.
func TxFromContext(ctx context.Context) *Tx {
	tx, _ := ctx.Value(txCtxKey{}).(*Tx)
	return tx
}

// NewTxContext returns a new context with the given Tx attached.
func NewTxContext(parent context.Context, tx *Tx) context.Context {
	return context.WithValue(parent, txCtxKey{}, tx)
}

// OrderFunc applies an ordering on the sql selector.
// Deprecated: Use Asc/Desc functions or the package builders instead.
type OrderFunc func(*sql.Selector)

var (
	initCheck   sync.Once
	columnCheck sql.ColumnCheck
)

// checkColumn checks if the column exists in the given table.
func checkColumn(t, c string) error {
	initCheck.Do(func() {
		columnCheck = sql.NewColumnCheck(map[string]func(string) bool{
			apitoken.Table:                          apitoken.ValidColumn,
			actionplan.Table:                        actionplan.ValidColumn,
			actionplanhistory.Table:                 actionplanhistory.ValidColumn,
			assessment.Table:                        assessment.ValidColumn,
			assessmenthistory.Table:                 assessmenthistory.ValidColumn,
			assessmentresponse.Table:                assessmentresponse.ValidColumn,
			assessmentresponsehistory.Table:         assessmentresponsehistory.ValidColumn,
			asset.Table:                             asset.ValidColumn,
			assethistory.Table:                      assethistory.ValidColumn,
			contact.Table:                           contact.ValidColumn,
			contacthistory.Table:                    contacthistory.ValidColumn,
			control.Table:                           control.ValidColumn,
			controlhistory.Table:                    controlhistory.ValidColumn,
			controlimplementation.Table:             controlimplementation.ValidColumn,
			controlimplementationhistory.Table:      controlimplementationhistory.ValidColumn,
			controlobjective.Table:                  controlobjective.ValidColumn,
			controlobjectivehistory.Table:           controlobjectivehistory.ValidColumn,
			customdomain.Table:                      customdomain.ValidColumn,
			customdomainhistory.Table:               customdomainhistory.ValidColumn,
			customtypeenum.Table:                    customtypeenum.ValidColumn,
			dnsverification.Table:                   dnsverification.ValidColumn,
			dnsverificationhistory.Table:            dnsverificationhistory.ValidColumn,
			directoryaccount.Table:                  directoryaccount.ValidColumn,
			directoryaccounthistory.Table:           directoryaccounthistory.ValidColumn,
			directorygroup.Table:                    directorygroup.ValidColumn,
			directorygrouphistory.Table:             directorygrouphistory.ValidColumn,
			directorymembership.Table:               directorymembership.ValidColumn,
			directorymembershiphistory.Table:        directorymembershiphistory.ValidColumn,
			directorysyncrun.Table:                  directorysyncrun.ValidColumn,
			documentdata.Table:                      documentdata.ValidColumn,
			documentdatahistory.Table:               documentdatahistory.ValidColumn,
			emailverificationtoken.Table:            emailverificationtoken.ValidColumn,
			entity.Table:                            entity.ValidColumn,
			entityhistory.Table:                     entityhistory.ValidColumn,
			entitytype.Table:                        entitytype.ValidColumn,
			entitytypehistory.Table:                 entitytypehistory.ValidColumn,
			event.Table:                             event.ValidColumn,
			evidence.Table:                          evidence.ValidColumn,
			evidencehistory.Table:                   evidencehistory.ValidColumn,
			export.Table:                            export.ValidColumn,
			file.Table:                              file.ValidColumn,
			filedownloadtoken.Table:                 filedownloadtoken.ValidColumn,
			filehistory.Table:                       filehistory.ValidColumn,
			finding.Table:                           finding.ValidColumn,
			findingcontrol.Table:                    findingcontrol.ValidColumn,
			findingcontrolhistory.Table:             findingcontrolhistory.ValidColumn,
			findinghistory.Table:                    findinghistory.ValidColumn,
			group.Table:                             group.ValidColumn,
			grouphistory.Table:                      grouphistory.ValidColumn,
			groupmembership.Table:                   groupmembership.ValidColumn,
			groupmembershiphistory.Table:            groupmembershiphistory.ValidColumn,
			groupsetting.Table:                      groupsetting.ValidColumn,
			groupsettinghistory.Table:               groupsettinghistory.ValidColumn,
			hush.Table:                              hush.ValidColumn,
			hushhistory.Table:                       hushhistory.ValidColumn,
			impersonationevent.Table:                impersonationevent.ValidColumn,
			integration.Table:                       integration.ValidColumn,
			integrationhistory.Table:                integrationhistory.ValidColumn,
			internalpolicy.Table:                    internalpolicy.ValidColumn,
			internalpolicyhistory.Table:             internalpolicyhistory.ValidColumn,
			invite.Table:                            invite.ValidColumn,
			jobresult.Table:                         jobresult.ValidColumn,
			jobrunner.Table:                         jobrunner.ValidColumn,
			jobrunnerregistrationtoken.Table:        jobrunnerregistrationtoken.ValidColumn,
			jobrunnertoken.Table:                    jobrunnertoken.ValidColumn,
			jobtemplate.Table:                       jobtemplate.ValidColumn,
			jobtemplatehistory.Table:                jobtemplatehistory.ValidColumn,
			mappabledomain.Table:                    mappabledomain.ValidColumn,
			mappabledomainhistory.Table:             mappabledomainhistory.ValidColumn,
			mappedcontrol.Table:                     mappedcontrol.ValidColumn,
			mappedcontrolhistory.Table:              mappedcontrolhistory.ValidColumn,
			narrative.Table:                         narrative.ValidColumn,
			narrativehistory.Table:                  narrativehistory.ValidColumn,
			note.Table:                              note.ValidColumn,
			notehistory.Table:                       notehistory.ValidColumn,
			notification.Table:                      notification.ValidColumn,
			onboarding.Table:                        onboarding.ValidColumn,
			orgmembership.Table:                     orgmembership.ValidColumn,
			orgmembershiphistory.Table:              orgmembershiphistory.ValidColumn,
			orgmodule.Table:                         orgmodule.ValidColumn,
			orgprice.Table:                          orgprice.ValidColumn,
			orgproduct.Table:                        orgproduct.ValidColumn,
			orgsubscription.Table:                   orgsubscription.ValidColumn,
			orgsubscriptionhistory.Table:            orgsubscriptionhistory.ValidColumn,
			organization.Table:                      organization.ValidColumn,
			organizationhistory.Table:               organizationhistory.ValidColumn,
			organizationsetting.Table:               organizationsetting.ValidColumn,
			organizationsettinghistory.Table:        organizationsettinghistory.ValidColumn,
			passwordresettoken.Table:                passwordresettoken.ValidColumn,
			personalaccesstoken.Table:               personalaccesstoken.ValidColumn,
			procedure.Table:                         procedure.ValidColumn,
			procedurehistory.Table:                  procedurehistory.ValidColumn,
			program.Table:                           program.ValidColumn,
			programhistory.Table:                    programhistory.ValidColumn,
			programmembership.Table:                 programmembership.ValidColumn,
			programmembershiphistory.Table:          programmembershiphistory.ValidColumn,
			remediation.Table:                       remediation.ValidColumn,
			remediationhistory.Table:                remediationhistory.ValidColumn,
			review.Table:                            review.ValidColumn,
			reviewhistory.Table:                     reviewhistory.ValidColumn,
			risk.Table:                              risk.ValidColumn,
			riskhistory.Table:                       riskhistory.ValidColumn,
			scan.Table:                              scan.ValidColumn,
			scanhistory.Table:                       scanhistory.ValidColumn,
			scheduledjob.Table:                      scheduledjob.ValidColumn,
			scheduledjobhistory.Table:               scheduledjobhistory.ValidColumn,
			scheduledjobrun.Table:                   scheduledjobrun.ValidColumn,
			standard.Table:                          standard.ValidColumn,
			standardhistory.Table:                   standardhistory.ValidColumn,
			subcontrol.Table:                        subcontrol.ValidColumn,
			subcontrolhistory.Table:                 subcontrolhistory.ValidColumn,
			subprocessor.Table:                      subprocessor.ValidColumn,
			subprocessorhistory.Table:               subprocessorhistory.ValidColumn,
			subscriber.Table:                        subscriber.ValidColumn,
			tfasetting.Table:                        tfasetting.ValidColumn,
			tagdefinition.Table:                     tagdefinition.ValidColumn,
			task.Table:                              task.ValidColumn,
			taskhistory.Table:                       taskhistory.ValidColumn,
			template.Table:                          template.ValidColumn,
			templatehistory.Table:                   templatehistory.ValidColumn,
			trustcenter.Table:                       trustcenter.ValidColumn,
			trustcentercompliance.Table:             trustcentercompliance.ValidColumn,
			trustcentercompliancehistory.Table:      trustcentercompliancehistory.ValidColumn,
			trustcenterdoc.Table:                    trustcenterdoc.ValidColumn,
			trustcenterdochistory.Table:             trustcenterdochistory.ValidColumn,
			trustcenterhistory.Table:                trustcenterhistory.ValidColumn,
			trustcentersetting.Table:                trustcentersetting.ValidColumn,
			trustcentersettinghistory.Table:         trustcentersettinghistory.ValidColumn,
			trustcentersubprocessor.Table:           trustcentersubprocessor.ValidColumn,
			trustcentersubprocessorhistory.Table:    trustcentersubprocessorhistory.ValidColumn,
			trustcenterwatermarkconfig.Table:        trustcenterwatermarkconfig.ValidColumn,
			trustcenterwatermarkconfighistory.Table: trustcenterwatermarkconfighistory.ValidColumn,
			trustcenterentity.Table:                 trustcenterentity.ValidColumn,
			trustcenterentityhistory.Table:          trustcenterentityhistory.ValidColumn,
			user.Table:                              user.ValidColumn,
			userhistory.Table:                       userhistory.ValidColumn,
			usersetting.Table:                       usersetting.ValidColumn,
			usersettinghistory.Table:                usersettinghistory.ValidColumn,
			vulnerability.Table:                     vulnerability.ValidColumn,
			vulnerabilityhistory.Table:              vulnerabilityhistory.ValidColumn,
			webauthn.Table:                          webauthn.ValidColumn,
			workflowassignment.Table:                workflowassignment.ValidColumn,
			workflowassignmenthistory.Table:         workflowassignmenthistory.ValidColumn,
			workflowassignmenttarget.Table:          workflowassignmenttarget.ValidColumn,
			workflowassignmenttargethistory.Table:   workflowassignmenttargethistory.ValidColumn,
			workflowdefinition.Table:                workflowdefinition.ValidColumn,
			workflowdefinitionhistory.Table:         workflowdefinitionhistory.ValidColumn,
			workflowevent.Table:                     workflowevent.ValidColumn,
			workfloweventhistory.Table:              workfloweventhistory.ValidColumn,
			workflowinstance.Table:                  workflowinstance.ValidColumn,
			workflowinstancehistory.Table:           workflowinstancehistory.ValidColumn,
			workflowobjectref.Table:                 workflowobjectref.ValidColumn,
			workflowobjectrefhistory.Table:          workflowobjectrefhistory.ValidColumn,
		})
	})
	return columnCheck(t, c)
}

// Asc applies the given fields in ASC order.
func Asc(fields ...string) func(*sql.Selector) {
	return func(s *sql.Selector) {
		for _, f := range fields {
			if err := checkColumn(s.TableName(), f); err != nil {
				s.AddError(&ValidationError{Name: f, err: fmt.Errorf("generated: %w", err)})
			}
			s.OrderBy(sql.Asc(s.C(f)))
		}
	}
}

// Desc applies the given fields in DESC order.
func Desc(fields ...string) func(*sql.Selector) {
	return func(s *sql.Selector) {
		for _, f := range fields {
			if err := checkColumn(s.TableName(), f); err != nil {
				s.AddError(&ValidationError{Name: f, err: fmt.Errorf("generated: %w", err)})
			}
			s.OrderBy(sql.Desc(s.C(f)))
		}
	}
}

// AggregateFunc applies an aggregation step on the group-by traversal/selector.
type AggregateFunc func(*sql.Selector) string

// As is a pseudo aggregation function for renaming another other functions with custom names. For example:
//
//	GroupBy(field1, field2).
//	Aggregate(generated.As(generated.Sum(field1), "sum_field1"), (generated.As(generated.Sum(field2), "sum_field2")).
//	Scan(ctx, &v)
func As(fn AggregateFunc, end string) AggregateFunc {
	return func(s *sql.Selector) string {
		return sql.As(fn(s), end)
	}
}

// Count applies the "count" aggregation function on each group.
func Count() AggregateFunc {
	return func(s *sql.Selector) string {
		return sql.Count("*")
	}
}

// Max applies the "max" aggregation function on the given field of each group.
func Max(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		if err := checkColumn(s.TableName(), field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("generated: %w", err)})
			return ""
		}
		return sql.Max(s.C(field))
	}
}

// Mean applies the "mean" aggregation function on the given field of each group.
func Mean(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		if err := checkColumn(s.TableName(), field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("generated: %w", err)})
			return ""
		}
		return sql.Avg(s.C(field))
	}
}

// Min applies the "min" aggregation function on the given field of each group.
func Min(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		if err := checkColumn(s.TableName(), field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("generated: %w", err)})
			return ""
		}
		return sql.Min(s.C(field))
	}
}

// Sum applies the "sum" aggregation function on the given field of each group.
func Sum(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		if err := checkColumn(s.TableName(), field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("generated: %w", err)})
			return ""
		}
		return sql.Sum(s.C(field))
	}
}

// ValidationError returns when validating a field or edge fails.
type ValidationError struct {
	Name string // Field or edge name.
	err  error
}

// Error implements the error interface.
func (e *ValidationError) Error() string {
	return e.err.Error()
}

// Unwrap implements the errors.Wrapper interface.
func (e *ValidationError) Unwrap() error {
	return e.err
}

// IsValidationError returns a boolean indicating whether the error is a validation error.
func IsValidationError(err error) bool {
	if err == nil {
		return false
	}
	var e *ValidationError
	return errors.As(err, &e)
}

// NotFoundError returns when trying to fetch a specific entity and it was not found in the database.
type NotFoundError struct {
	label string
}

// Error implements the error interface.
func (e *NotFoundError) Error() string {
	return "generated: " + e.label + " not found"
}

// IsNotFound returns a boolean indicating whether the error is a not found error.
func IsNotFound(err error) bool {
	if err == nil {
		return false
	}
	var e *NotFoundError
	return errors.As(err, &e)
}

// MaskNotFound masks not found error.
func MaskNotFound(err error) error {
	if IsNotFound(err) {
		return nil
	}
	return err
}

// NotSingularError returns when trying to fetch a singular entity and more then one was found in the database.
type NotSingularError struct {
	label string
}

// Error implements the error interface.
func (e *NotSingularError) Error() string {
	return "generated: " + e.label + " not singular"
}

// IsNotSingular returns a boolean indicating whether the error is a not singular error.
func IsNotSingular(err error) bool {
	if err == nil {
		return false
	}
	var e *NotSingularError
	return errors.As(err, &e)
}

// NotLoadedError returns when trying to get a node that was not loaded by the query.
type NotLoadedError struct {
	edge string
}

// Error implements the error interface.
func (e *NotLoadedError) Error() string {
	return "generated: " + e.edge + " edge was not loaded"
}

// IsNotLoaded returns a boolean indicating whether the error is a not loaded error.
func IsNotLoaded(err error) bool {
	if err == nil {
		return false
	}
	var e *NotLoadedError
	return errors.As(err, &e)
}

// ConstraintError returns when trying to create/update one or more entities and
// one or more of their constraints failed. For example, violation of edge or
// field uniqueness.
type ConstraintError struct {
	msg  string
	wrap error
}

// Error implements the error interface.
func (e ConstraintError) Error() string {
	return "generated: constraint failed: " + e.msg
}

// Unwrap implements the errors.Wrapper interface.
func (e *ConstraintError) Unwrap() error {
	return e.wrap
}

// IsConstraintError returns a boolean indicating whether the error is a constraint failure.
func IsConstraintError(err error) bool {
	if err == nil {
		return false
	}
	var e *ConstraintError
	return errors.As(err, &e)
}

// selector embedded by the different Select/GroupBy builders.
type selector struct {
	label string
	flds  *[]string
	fns   []AggregateFunc
	scan  func(context.Context, any) error
}

// ScanX is like Scan, but panics if an error occurs.
func (s *selector) ScanX(ctx context.Context, v any) {
	if err := s.scan(ctx, v); err != nil {
		panic(err)
	}
}

// Strings returns list of strings from a selector. It is only allowed when selecting one field.
func (s *selector) Strings(ctx context.Context) ([]string, error) {
	if len(*s.flds) > 1 {
		return nil, errors.New("generated: Strings is not achievable when selecting more than 1 field")
	}
	var v []string
	if err := s.scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// StringsX is like Strings, but panics if an error occurs.
func (s *selector) StringsX(ctx context.Context) []string {
	v, err := s.Strings(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// String returns a single string from a selector. It is only allowed when selecting one field.
func (s *selector) String(ctx context.Context) (_ string, err error) {
	var v []string
	if v, err = s.Strings(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{s.label}
	default:
		err = fmt.Errorf("generated: Strings returned %d results when one was expected", len(v))
	}
	return
}

// StringX is like String, but panics if an error occurs.
func (s *selector) StringX(ctx context.Context) string {
	v, err := s.String(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Ints returns list of ints from a selector. It is only allowed when selecting one field.
func (s *selector) Ints(ctx context.Context) ([]int, error) {
	if len(*s.flds) > 1 {
		return nil, errors.New("generated: Ints is not achievable when selecting more than 1 field")
	}
	var v []int
	if err := s.scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// IntsX is like Ints, but panics if an error occurs.
func (s *selector) IntsX(ctx context.Context) []int {
	v, err := s.Ints(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Int returns a single int from a selector. It is only allowed when selecting one field.
func (s *selector) Int(ctx context.Context) (_ int, err error) {
	var v []int
	if v, err = s.Ints(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{s.label}
	default:
		err = fmt.Errorf("generated: Ints returned %d results when one was expected", len(v))
	}
	return
}

// IntX is like Int, but panics if an error occurs.
func (s *selector) IntX(ctx context.Context) int {
	v, err := s.Int(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64s returns list of float64s from a selector. It is only allowed when selecting one field.
func (s *selector) Float64s(ctx context.Context) ([]float64, error) {
	if len(*s.flds) > 1 {
		return nil, errors.New("generated: Float64s is not achievable when selecting more than 1 field")
	}
	var v []float64
	if err := s.scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// Float64sX is like Float64s, but panics if an error occurs.
func (s *selector) Float64sX(ctx context.Context) []float64 {
	v, err := s.Float64s(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64 returns a single float64 from a selector. It is only allowed when selecting one field.
func (s *selector) Float64(ctx context.Context) (_ float64, err error) {
	var v []float64
	if v, err = s.Float64s(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{s.label}
	default:
		err = fmt.Errorf("generated: Float64s returned %d results when one was expected", len(v))
	}
	return
}

// Float64X is like Float64, but panics if an error occurs.
func (s *selector) Float64X(ctx context.Context) float64 {
	v, err := s.Float64(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bools returns list of bools from a selector. It is only allowed when selecting one field.
func (s *selector) Bools(ctx context.Context) ([]bool, error) {
	if len(*s.flds) > 1 {
		return nil, errors.New("generated: Bools is not achievable when selecting more than 1 field")
	}
	var v []bool
	if err := s.scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// BoolsX is like Bools, but panics if an error occurs.
func (s *selector) BoolsX(ctx context.Context) []bool {
	v, err := s.Bools(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bool returns a single bool from a selector. It is only allowed when selecting one field.
func (s *selector) Bool(ctx context.Context) (_ bool, err error) {
	var v []bool
	if v, err = s.Bools(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{s.label}
	default:
		err = fmt.Errorf("generated: Bools returned %d results when one was expected", len(v))
	}
	return
}

// BoolX is like Bool, but panics if an error occurs.
func (s *selector) BoolX(ctx context.Context) bool {
	v, err := s.Bool(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// withHooks invokes the builder operation with the given hooks, if any.
func withHooks[V Value, M any, PM interface {
	*M
	Mutation
}](ctx context.Context, exec func(context.Context) (V, error), mutation PM, hooks []Hook) (value V, err error) {
	if len(hooks) == 0 {
		return exec(ctx)
	}
	var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
		mutationT, ok := any(m).(PM)
		if !ok {
			return nil, fmt.Errorf("unexpected mutation type %T", m)
		}
		// Set the mutation to the builder.
		*mutation = *mutationT
		return exec(ctx)
	})
	for i := len(hooks) - 1; i >= 0; i-- {
		if hooks[i] == nil {
			return value, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
		}
		mut = hooks[i](mut)
	}
	v, err := mut.Mutate(ctx, mutation)
	if err != nil {
		return value, err
	}
	nv, ok := v.(V)
	if !ok {
		return value, fmt.Errorf("unexpected node type %T returned from %T", v, mutation)
	}
	return nv, nil
}

// setContextOp returns a new context with the given QueryContext attached (including its op) in case it does not exist.
func setContextOp(ctx context.Context, qc *QueryContext, op string) context.Context {
	if ent.QueryFromContext(ctx) == nil {
		qc.Op = op
		ctx = ent.NewQueryContext(ctx, qc)
	}
	return ctx
}

func querierAll[V Value, Q interface {
	sqlAll(context.Context, ...queryHook) (V, error)
}]() Querier {
	return QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		query, ok := q.(Q)
		if !ok {
			return nil, fmt.Errorf("unexpected query type %T", q)
		}
		return query.sqlAll(ctx)
	})
}

func querierCount[Q interface {
	sqlCount(context.Context) (int, error)
}]() Querier {
	return QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		query, ok := q.(Q)
		if !ok {
			return nil, fmt.Errorf("unexpected query type %T", q)
		}
		return query.sqlCount(ctx)
	})
}

func withInterceptors[V Value](ctx context.Context, q Query, qr Querier, inters []Interceptor) (v V, err error) {
	for i := len(inters) - 1; i >= 0; i-- {
		qr = inters[i].Intercept(qr)
	}
	rv, err := qr.Query(ctx, q)
	if err != nil {
		return v, err
	}
	vt, ok := rv.(V)
	if !ok {
		return v, fmt.Errorf("unexpected type %T returned from %T. expected type: %T", vt, q, v)
	}
	return vt, nil
}

func scanWithInterceptors[Q1 ent.Query, Q2 interface {
	sqlScan(context.Context, Q1, any) error
}](ctx context.Context, rootQuery Q1, selectOrGroup Q2, inters []Interceptor, v any) error {
	rv := reflect.ValueOf(v)
	var qr Querier = QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		query, ok := q.(Q1)
		if !ok {
			return nil, fmt.Errorf("unexpected query type %T", q)
		}
		if err := selectOrGroup.sqlScan(ctx, query, v); err != nil {
			return nil, err
		}
		if k := rv.Kind(); k == reflect.Pointer && rv.Elem().CanInterface() {
			return rv.Elem().Interface(), nil
		}
		return v, nil
	})
	for i := len(inters) - 1; i >= 0; i-- {
		qr = inters[i].Intercept(qr)
	}
	vv, err := qr.Query(ctx, rootQuery)
	if err != nil {
		return err
	}
	switch rv2 := reflect.ValueOf(vv); {
	case rv.IsNil(), rv2.IsNil(), rv.Kind() != reflect.Pointer:
	case rv.Type() == rv2.Type():
		rv.Elem().Set(rv2.Elem())
	case rv.Elem().Type() == rv2.Type():
		rv.Elem().Set(rv2)
	}
	return nil
}

// queryHook describes an internal hook for the different sqlAll methods.
type queryHook func(context.Context, *sqlgraph.QuerySpec)
