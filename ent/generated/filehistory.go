// Code generated by ent, DO NOT EDIT.

package generated

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/theopenlane/ent/generated/filehistory"
	"github.com/theopenlane/entx/history"
)

// FileHistory is the model entity for the FileHistory schema.
type FileHistory struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// HistoryTime holds the value of the "history_time" field.
	HistoryTime time.Time `json:"history_time,omitempty"`
	// Ref holds the value of the "ref" field.
	Ref string `json:"ref,omitempty"`
	// Operation holds the value of the "operation" field.
	Operation history.OpType `json:"operation,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// CreatedBy holds the value of the "created_by" field.
	CreatedBy string `json:"created_by,omitempty"`
	// UpdatedBy holds the value of the "updated_by" field.
	UpdatedBy string `json:"updated_by,omitempty"`
	// DeletedAt holds the value of the "deleted_at" field.
	DeletedAt time.Time `json:"deleted_at,omitempty"`
	// DeletedBy holds the value of the "deleted_by" field.
	DeletedBy string `json:"deleted_by,omitempty"`
	// tags associated with the object
	Tags []string `json:"tags,omitempty"`
	// indicates if the record is owned by the the openlane system and not by an organization
	SystemOwned bool `json:"system_owned,omitempty"`
	// internal notes about the object creation, this field is only available to system admins
	InternalNotes *string `json:"internal_notes,omitempty"`
	// an internal identifier for the mapping, this field is only available to system admins
	SystemInternalID *string `json:"system_internal_id,omitempty"`
	// the name of the file provided in the payload key without the extension
	ProvidedFileName string `json:"provided_file_name,omitempty"`
	// the extension of the file provided
	ProvidedFileExtension string `json:"provided_file_extension,omitempty"`
	// the computed size of the file in the original http request
	ProvidedFileSize int64 `json:"provided_file_size,omitempty"`
	// PersistedFileSize holds the value of the "persisted_file_size" field.
	PersistedFileSize int64 `json:"persisted_file_size,omitempty"`
	// the mime type detected by the system
	DetectedMimeType string `json:"detected_mime_type,omitempty"`
	// the computed md5 hash of the file calculated after we received the contents of the file, but before the file was written to permanent storage
	Md5Hash string `json:"md5_hash,omitempty"`
	// the content type of the HTTP request - may be different than MIME type as multipart-form can transmit multiple files and different types
	DetectedContentType string `json:"detected_content_type,omitempty"`
	// the key parsed out of a multipart-form request; if we allow multiple files to be uploaded we may want our API specifications to require the use of different keys allowing us to perform easier conditional evaluation on the key and what to do with the file based on key
	StoreKey string `json:"store_key,omitempty"`
	// the category type of the file, if any (e.g. evidence, invoice, etc.)
	CategoryType string `json:"category_type,omitempty"`
	// the full URI of the file
	URI string `json:"uri,omitempty"`
	// the storage scheme of the file, e.g. file://, s3://, etc.
	StorageScheme string `json:"storage_scheme,omitempty"`
	// the storage volume of the file which typically will be the organization ID the file belongs to - this is not a literal volume but the overlay file system mapping
	StorageVolume string `json:"storage_volume,omitempty"`
	// the storage path is the second-level directory of the file path, typically the correlating logical object ID the file is associated with; files can be stand alone objects and not always correlated to a logical one, so this path of the tree may be empty
	StoragePath string `json:"storage_path,omitempty"`
	// the contents of the file
	FileContents []byte `json:"file_contents,omitempty"`
	// additional metadata about the file
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	// the region the file is stored in, if applicable
	StorageRegion string `json:"storage_region,omitempty"`
	// the storage provider the file is stored in, if applicable
	StorageProvider string `json:"storage_provider,omitempty"`
	// LastAccessedAt holds the value of the "last_accessed_at" field.
	LastAccessedAt *time.Time `json:"last_accessed_at,omitempty"`
	selectValues   sql.SelectValues
}

// scanValues returns the types for scanning values from sql.Rows.
func (*FileHistory) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case filehistory.FieldTags, filehistory.FieldFileContents, filehistory.FieldMetadata:
			values[i] = new([]byte)
		case filehistory.FieldOperation:
			values[i] = new(history.OpType)
		case filehistory.FieldSystemOwned:
			values[i] = new(sql.NullBool)
		case filehistory.FieldProvidedFileSize, filehistory.FieldPersistedFileSize:
			values[i] = new(sql.NullInt64)
		case filehistory.FieldID, filehistory.FieldRef, filehistory.FieldCreatedBy, filehistory.FieldUpdatedBy, filehistory.FieldDeletedBy, filehistory.FieldInternalNotes, filehistory.FieldSystemInternalID, filehistory.FieldProvidedFileName, filehistory.FieldProvidedFileExtension, filehistory.FieldDetectedMimeType, filehistory.FieldMd5Hash, filehistory.FieldDetectedContentType, filehistory.FieldStoreKey, filehistory.FieldCategoryType, filehistory.FieldURI, filehistory.FieldStorageScheme, filehistory.FieldStorageVolume, filehistory.FieldStoragePath, filehistory.FieldStorageRegion, filehistory.FieldStorageProvider:
			values[i] = new(sql.NullString)
		case filehistory.FieldHistoryTime, filehistory.FieldCreatedAt, filehistory.FieldUpdatedAt, filehistory.FieldDeletedAt, filehistory.FieldLastAccessedAt:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the FileHistory fields.
func (_m *FileHistory) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case filehistory.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				_m.ID = value.String
			}
		case filehistory.FieldHistoryTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field history_time", values[i])
			} else if value.Valid {
				_m.HistoryTime = value.Time
			}
		case filehistory.FieldRef:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field ref", values[i])
			} else if value.Valid {
				_m.Ref = value.String
			}
		case filehistory.FieldOperation:
			if value, ok := values[i].(*history.OpType); !ok {
				return fmt.Errorf("unexpected type %T for field operation", values[i])
			} else if value != nil {
				_m.Operation = *value
			}
		case filehistory.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				_m.CreatedAt = value.Time
			}
		case filehistory.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				_m.UpdatedAt = value.Time
			}
		case filehistory.FieldCreatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field created_by", values[i])
			} else if value.Valid {
				_m.CreatedBy = value.String
			}
		case filehistory.FieldUpdatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field updated_by", values[i])
			} else if value.Valid {
				_m.UpdatedBy = value.String
			}
		case filehistory.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				_m.DeletedAt = value.Time
			}
		case filehistory.FieldDeletedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_by", values[i])
			} else if value.Valid {
				_m.DeletedBy = value.String
			}
		case filehistory.FieldTags:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field tags", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.Tags); err != nil {
					return fmt.Errorf("unmarshal field tags: %w", err)
				}
			}
		case filehistory.FieldSystemOwned:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field system_owned", values[i])
			} else if value.Valid {
				_m.SystemOwned = value.Bool
			}
		case filehistory.FieldInternalNotes:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field internal_notes", values[i])
			} else if value.Valid {
				_m.InternalNotes = new(string)
				*_m.InternalNotes = value.String
			}
		case filehistory.FieldSystemInternalID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field system_internal_id", values[i])
			} else if value.Valid {
				_m.SystemInternalID = new(string)
				*_m.SystemInternalID = value.String
			}
		case filehistory.FieldProvidedFileName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field provided_file_name", values[i])
			} else if value.Valid {
				_m.ProvidedFileName = value.String
			}
		case filehistory.FieldProvidedFileExtension:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field provided_file_extension", values[i])
			} else if value.Valid {
				_m.ProvidedFileExtension = value.String
			}
		case filehistory.FieldProvidedFileSize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field provided_file_size", values[i])
			} else if value.Valid {
				_m.ProvidedFileSize = value.Int64
			}
		case filehistory.FieldPersistedFileSize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field persisted_file_size", values[i])
			} else if value.Valid {
				_m.PersistedFileSize = value.Int64
			}
		case filehistory.FieldDetectedMimeType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field detected_mime_type", values[i])
			} else if value.Valid {
				_m.DetectedMimeType = value.String
			}
		case filehistory.FieldMd5Hash:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field md5_hash", values[i])
			} else if value.Valid {
				_m.Md5Hash = value.String
			}
		case filehistory.FieldDetectedContentType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field detected_content_type", values[i])
			} else if value.Valid {
				_m.DetectedContentType = value.String
			}
		case filehistory.FieldStoreKey:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field store_key", values[i])
			} else if value.Valid {
				_m.StoreKey = value.String
			}
		case filehistory.FieldCategoryType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field category_type", values[i])
			} else if value.Valid {
				_m.CategoryType = value.String
			}
		case filehistory.FieldURI:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field uri", values[i])
			} else if value.Valid {
				_m.URI = value.String
			}
		case filehistory.FieldStorageScheme:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field storage_scheme", values[i])
			} else if value.Valid {
				_m.StorageScheme = value.String
			}
		case filehistory.FieldStorageVolume:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field storage_volume", values[i])
			} else if value.Valid {
				_m.StorageVolume = value.String
			}
		case filehistory.FieldStoragePath:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field storage_path", values[i])
			} else if value.Valid {
				_m.StoragePath = value.String
			}
		case filehistory.FieldFileContents:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field file_contents", values[i])
			} else if value != nil {
				_m.FileContents = *value
			}
		case filehistory.FieldMetadata:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field metadata", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &_m.Metadata); err != nil {
					return fmt.Errorf("unmarshal field metadata: %w", err)
				}
			}
		case filehistory.FieldStorageRegion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field storage_region", values[i])
			} else if value.Valid {
				_m.StorageRegion = value.String
			}
		case filehistory.FieldStorageProvider:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field storage_provider", values[i])
			} else if value.Valid {
				_m.StorageProvider = value.String
			}
		case filehistory.FieldLastAccessedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field last_accessed_at", values[i])
			} else if value.Valid {
				_m.LastAccessedAt = new(time.Time)
				*_m.LastAccessedAt = value.Time
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the FileHistory.
// This includes values selected through modifiers, order, etc.
func (_m *FileHistory) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// Update returns a builder for updating this FileHistory.
// Note that you need to call FileHistory.Unwrap() before calling this method if this FileHistory
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *FileHistory) Update() *FileHistoryUpdateOne {
	return NewFileHistoryClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the FileHistory entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *FileHistory) Unwrap() *FileHistory {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("generated: FileHistory is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *FileHistory) String() string {
	var builder strings.Builder
	builder.WriteString("FileHistory(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("history_time=")
	builder.WriteString(_m.HistoryTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("ref=")
	builder.WriteString(_m.Ref)
	builder.WriteString(", ")
	builder.WriteString("operation=")
	builder.WriteString(fmt.Sprintf("%v", _m.Operation))
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(_m.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("created_by=")
	builder.WriteString(_m.CreatedBy)
	builder.WriteString(", ")
	builder.WriteString("updated_by=")
	builder.WriteString(_m.UpdatedBy)
	builder.WriteString(", ")
	builder.WriteString("deleted_at=")
	builder.WriteString(_m.DeletedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("deleted_by=")
	builder.WriteString(_m.DeletedBy)
	builder.WriteString(", ")
	builder.WriteString("tags=")
	builder.WriteString(fmt.Sprintf("%v", _m.Tags))
	builder.WriteString(", ")
	builder.WriteString("system_owned=")
	builder.WriteString(fmt.Sprintf("%v", _m.SystemOwned))
	builder.WriteString(", ")
	if v := _m.InternalNotes; v != nil {
		builder.WriteString("internal_notes=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.SystemInternalID; v != nil {
		builder.WriteString("system_internal_id=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("provided_file_name=")
	builder.WriteString(_m.ProvidedFileName)
	builder.WriteString(", ")
	builder.WriteString("provided_file_extension=")
	builder.WriteString(_m.ProvidedFileExtension)
	builder.WriteString(", ")
	builder.WriteString("provided_file_size=")
	builder.WriteString(fmt.Sprintf("%v", _m.ProvidedFileSize))
	builder.WriteString(", ")
	builder.WriteString("persisted_file_size=")
	builder.WriteString(fmt.Sprintf("%v", _m.PersistedFileSize))
	builder.WriteString(", ")
	builder.WriteString("detected_mime_type=")
	builder.WriteString(_m.DetectedMimeType)
	builder.WriteString(", ")
	builder.WriteString("md5_hash=")
	builder.WriteString(_m.Md5Hash)
	builder.WriteString(", ")
	builder.WriteString("detected_content_type=")
	builder.WriteString(_m.DetectedContentType)
	builder.WriteString(", ")
	builder.WriteString("store_key=")
	builder.WriteString(_m.StoreKey)
	builder.WriteString(", ")
	builder.WriteString("category_type=")
	builder.WriteString(_m.CategoryType)
	builder.WriteString(", ")
	builder.WriteString("uri=")
	builder.WriteString(_m.URI)
	builder.WriteString(", ")
	builder.WriteString("storage_scheme=")
	builder.WriteString(_m.StorageScheme)
	builder.WriteString(", ")
	builder.WriteString("storage_volume=")
	builder.WriteString(_m.StorageVolume)
	builder.WriteString(", ")
	builder.WriteString("storage_path=")
	builder.WriteString(_m.StoragePath)
	builder.WriteString(", ")
	builder.WriteString("file_contents=")
	builder.WriteString(fmt.Sprintf("%v", _m.FileContents))
	builder.WriteString(", ")
	builder.WriteString("metadata=")
	builder.WriteString(fmt.Sprintf("%v", _m.Metadata))
	builder.WriteString(", ")
	builder.WriteString("storage_region=")
	builder.WriteString(_m.StorageRegion)
	builder.WriteString(", ")
	builder.WriteString("storage_provider=")
	builder.WriteString(_m.StorageProvider)
	builder.WriteString(", ")
	if v := _m.LastAccessedAt; v != nil {
		builder.WriteString("last_accessed_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteByte(')')
	return builder.String()
}

// FileHistories is a parsable slice of FileHistory.
type FileHistories []*FileHistory
