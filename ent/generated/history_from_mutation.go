// Code generated by entc, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent"
	"github.com/theopenlane/entx"
	"github.com/theopenlane/entx/history"
)

var (
	idNotFoundError = errors.New("could not get id from mutation")
)

func EntOpToHistoryOp(op ent.Op) history.OpType {
	switch op {
	case ent.OpDelete, ent.OpDeleteOne:
		return history.OpTypeDelete
	case ent.OpUpdate, ent.OpUpdateOne:
		return history.OpTypeUpdate
	default:
		return history.OpTypeInsert
	}
}

func (m *ActionPlanMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ActionPlanHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if revision, exists := m.Revision(); exists {
		create = create.SetRevision(revision)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if actionPlanType, exists := m.ActionPlanType(); exists {
		create = create.SetActionPlanType(actionPlanType)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	if approvalRequired, exists := m.ApprovalRequired(); exists {
		create = create.SetApprovalRequired(approvalRequired)
	}

	if reviewDue, exists := m.ReviewDue(); exists {
		create = create.SetReviewDue(reviewDue)
	}

	if reviewFrequency, exists := m.ReviewFrequency(); exists {
		create = create.SetReviewFrequency(reviewFrequency)
	}

	if approverID, exists := m.ApproverID(); exists {
		create = create.SetApproverID(approverID)
	}

	if delegateID, exists := m.DelegateID(); exists {
		create = create.SetDelegateID(delegateID)
	}

	if summary, exists := m.Summary(); exists {
		create = create.SetSummary(summary)
	}

	if tagSuggestions, exists := m.TagSuggestions(); exists {
		create = create.SetTagSuggestions(tagSuggestions)
	}

	if dismissedTagSuggestions, exists := m.DismissedTagSuggestions(); exists {
		create = create.SetDismissedTagSuggestions(dismissedTagSuggestions)
	}

	if controlSuggestions, exists := m.ControlSuggestions(); exists {
		create = create.SetControlSuggestions(controlSuggestions)
	}

	if dismissedControlSuggestions, exists := m.DismissedControlSuggestions(); exists {
		create = create.SetDismissedControlSuggestions(dismissedControlSuggestions)
	}

	if improvementSuggestions, exists := m.ImprovementSuggestions(); exists {
		create = create.SetImprovementSuggestions(improvementSuggestions)
	}

	if dismissedImprovementSuggestions, exists := m.DismissedImprovementSuggestions(); exists {
		create = create.SetDismissedImprovementSuggestions(dismissedImprovementSuggestions)
	}

	if url, exists := m.URL(); exists {
		create = create.SetNillableURL(&url)
	}

	if fileID, exists := m.FileID(); exists {
		create = create.SetNillableFileID(&fileID)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if actionPlanKindName, exists := m.ActionPlanKindName(); exists {
		create = create.SetActionPlanKindName(actionPlanKindName)
	}

	if actionPlanKindID, exists := m.ActionPlanKindID(); exists {
		create = create.SetActionPlanKindID(actionPlanKindID)
	}

	if title, exists := m.Title(); exists {
		create = create.SetTitle(title)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if dueDate, exists := m.DueDate(); exists {
		create = create.SetDueDate(dueDate)
	}

	if completedAt, exists := m.CompletedAt(); exists {
		create = create.SetNillableCompletedAt(&completedAt)
	}

	if priority, exists := m.Priority(); exists {
		create = create.SetPriority(priority)
	}

	if requiresApproval, exists := m.RequiresApproval(); exists {
		create = create.SetRequiresApproval(requiresApproval)
	}

	if blocked, exists := m.Blocked(); exists {
		create = create.SetBlocked(blocked)
	}

	if blockerReason, exists := m.BlockerReason(); exists {
		create = create.SetBlockerReason(blockerReason)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	if rawPayload, exists := m.RawPayload(); exists {
		create = create.SetRawPayload(rawPayload)
	}

	if source, exists := m.Source(); exists {
		create = create.SetSource(source)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ActionPlanMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		actionplan, err := client.ActionPlan.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ActionPlanHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(actionplan.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(actionplan.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(actionplan.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(actionplan.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(actionplan.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(actionplan.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(actionplan.Tags)
		}

		if revision, exists := m.Revision(); exists {
			create = create.SetRevision(revision)
		} else {
			create = create.SetRevision(actionplan.Revision)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(actionplan.Name)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(actionplan.Status)
		}

		if actionPlanType, exists := m.ActionPlanType(); exists {
			create = create.SetActionPlanType(actionPlanType)
		} else {
			create = create.SetActionPlanType(actionplan.ActionPlanType)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(actionplan.Details)
		}

		if approvalRequired, exists := m.ApprovalRequired(); exists {
			create = create.SetApprovalRequired(approvalRequired)
		} else {
			create = create.SetApprovalRequired(actionplan.ApprovalRequired)
		}

		if reviewDue, exists := m.ReviewDue(); exists {
			create = create.SetReviewDue(reviewDue)
		} else {
			create = create.SetReviewDue(actionplan.ReviewDue)
		}

		if reviewFrequency, exists := m.ReviewFrequency(); exists {
			create = create.SetReviewFrequency(reviewFrequency)
		} else {
			create = create.SetReviewFrequency(actionplan.ReviewFrequency)
		}

		if approverID, exists := m.ApproverID(); exists {
			create = create.SetApproverID(approverID)
		} else {
			create = create.SetApproverID(actionplan.ApproverID)
		}

		if delegateID, exists := m.DelegateID(); exists {
			create = create.SetDelegateID(delegateID)
		} else {
			create = create.SetDelegateID(actionplan.DelegateID)
		}

		if summary, exists := m.Summary(); exists {
			create = create.SetSummary(summary)
		} else {
			create = create.SetSummary(actionplan.Summary)
		}

		if tagSuggestions, exists := m.TagSuggestions(); exists {
			create = create.SetTagSuggestions(tagSuggestions)
		} else {
			create = create.SetTagSuggestions(actionplan.TagSuggestions)
		}

		if dismissedTagSuggestions, exists := m.DismissedTagSuggestions(); exists {
			create = create.SetDismissedTagSuggestions(dismissedTagSuggestions)
		} else {
			create = create.SetDismissedTagSuggestions(actionplan.DismissedTagSuggestions)
		}

		if controlSuggestions, exists := m.ControlSuggestions(); exists {
			create = create.SetControlSuggestions(controlSuggestions)
		} else {
			create = create.SetControlSuggestions(actionplan.ControlSuggestions)
		}

		if dismissedControlSuggestions, exists := m.DismissedControlSuggestions(); exists {
			create = create.SetDismissedControlSuggestions(dismissedControlSuggestions)
		} else {
			create = create.SetDismissedControlSuggestions(actionplan.DismissedControlSuggestions)
		}

		if improvementSuggestions, exists := m.ImprovementSuggestions(); exists {
			create = create.SetImprovementSuggestions(improvementSuggestions)
		} else {
			create = create.SetImprovementSuggestions(actionplan.ImprovementSuggestions)
		}

		if dismissedImprovementSuggestions, exists := m.DismissedImprovementSuggestions(); exists {
			create = create.SetDismissedImprovementSuggestions(dismissedImprovementSuggestions)
		} else {
			create = create.SetDismissedImprovementSuggestions(actionplan.DismissedImprovementSuggestions)
		}

		if url, exists := m.URL(); exists {
			create = create.SetNillableURL(&url)
		} else {
			create = create.SetNillableURL(actionplan.URL)
		}

		if fileID, exists := m.FileID(); exists {
			create = create.SetNillableFileID(&fileID)
		} else {
			create = create.SetNillableFileID(actionplan.FileID)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(actionplan.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(actionplan.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(actionplan.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(actionplan.SystemInternalID)
		}

		if actionPlanKindName, exists := m.ActionPlanKindName(); exists {
			create = create.SetActionPlanKindName(actionPlanKindName)
		} else {
			create = create.SetActionPlanKindName(actionplan.ActionPlanKindName)
		}

		if actionPlanKindID, exists := m.ActionPlanKindID(); exists {
			create = create.SetActionPlanKindID(actionPlanKindID)
		} else {
			create = create.SetActionPlanKindID(actionplan.ActionPlanKindID)
		}

		if title, exists := m.Title(); exists {
			create = create.SetTitle(title)
		} else {
			create = create.SetTitle(actionplan.Title)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(actionplan.Description)
		}

		if dueDate, exists := m.DueDate(); exists {
			create = create.SetDueDate(dueDate)
		} else {
			create = create.SetDueDate(actionplan.DueDate)
		}

		if completedAt, exists := m.CompletedAt(); exists {
			create = create.SetNillableCompletedAt(&completedAt)
		} else {
			create = create.SetNillableCompletedAt(actionplan.CompletedAt)
		}

		if priority, exists := m.Priority(); exists {
			create = create.SetPriority(priority)
		} else {
			create = create.SetPriority(actionplan.Priority)
		}

		if requiresApproval, exists := m.RequiresApproval(); exists {
			create = create.SetRequiresApproval(requiresApproval)
		} else {
			create = create.SetRequiresApproval(actionplan.RequiresApproval)
		}

		if blocked, exists := m.Blocked(); exists {
			create = create.SetBlocked(blocked)
		} else {
			create = create.SetBlocked(actionplan.Blocked)
		}

		if blockerReason, exists := m.BlockerReason(); exists {
			create = create.SetBlockerReason(blockerReason)
		} else {
			create = create.SetBlockerReason(actionplan.BlockerReason)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(actionplan.Metadata)
		}

		if rawPayload, exists := m.RawPayload(); exists {
			create = create.SetRawPayload(rawPayload)
		} else {
			create = create.SetRawPayload(actionplan.RawPayload)
		}

		if source, exists := m.Source(); exists {
			create = create.SetSource(source)
		} else {
			create = create.SetSource(actionplan.Source)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ActionPlanMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		actionplan, err := client.ActionPlan.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ActionPlanHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(actionplan.CreatedAt).
			SetUpdatedAt(actionplan.UpdatedAt).
			SetCreatedBy(actionplan.CreatedBy).
			SetUpdatedBy(actionplan.UpdatedBy).
			SetDeletedAt(actionplan.DeletedAt).
			SetDeletedBy(actionplan.DeletedBy).
			SetTags(actionplan.Tags).
			SetRevision(actionplan.Revision).
			SetName(actionplan.Name).
			SetStatus(actionplan.Status).
			SetActionPlanType(actionplan.ActionPlanType).
			SetDetails(actionplan.Details).
			SetApprovalRequired(actionplan.ApprovalRequired).
			SetReviewDue(actionplan.ReviewDue).
			SetReviewFrequency(actionplan.ReviewFrequency).
			SetApproverID(actionplan.ApproverID).
			SetDelegateID(actionplan.DelegateID).
			SetSummary(actionplan.Summary).
			SetTagSuggestions(actionplan.TagSuggestions).
			SetDismissedTagSuggestions(actionplan.DismissedTagSuggestions).
			SetControlSuggestions(actionplan.ControlSuggestions).
			SetDismissedControlSuggestions(actionplan.DismissedControlSuggestions).
			SetImprovementSuggestions(actionplan.ImprovementSuggestions).
			SetDismissedImprovementSuggestions(actionplan.DismissedImprovementSuggestions).
			SetNillableURL(actionplan.URL).
			SetNillableFileID(actionplan.FileID).
			SetOwnerID(actionplan.OwnerID).
			SetSystemOwned(actionplan.SystemOwned).
			SetNillableInternalNotes(actionplan.InternalNotes).
			SetNillableSystemInternalID(actionplan.SystemInternalID).
			SetActionPlanKindName(actionplan.ActionPlanKindName).
			SetActionPlanKindID(actionplan.ActionPlanKindID).
			SetTitle(actionplan.Title).
			SetDescription(actionplan.Description).
			SetDueDate(actionplan.DueDate).
			SetNillableCompletedAt(actionplan.CompletedAt).
			SetPriority(actionplan.Priority).
			SetRequiresApproval(actionplan.RequiresApproval).
			SetBlocked(actionplan.Blocked).
			SetBlockerReason(actionplan.BlockerReason).
			SetMetadata(actionplan.Metadata).
			SetRawPayload(actionplan.RawPayload).
			SetSource(actionplan.Source).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *AssessmentMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.AssessmentHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if assessmentType, exists := m.AssessmentType(); exists {
		create = create.SetAssessmentType(assessmentType)
	}

	if templateID, exists := m.TemplateID(); exists {
		create = create.SetTemplateID(templateID)
	}

	if jsonconfig, exists := m.Jsonconfig(); exists {
		create = create.SetJsonconfig(jsonconfig)
	}

	if uischema, exists := m.Uischema(); exists {
		create = create.SetUischema(uischema)
	}

	if responseDueDuration, exists := m.ResponseDueDuration(); exists {
		create = create.SetResponseDueDuration(responseDueDuration)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *AssessmentMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		assessment, err := client.Assessment.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.AssessmentHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(assessment.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(assessment.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(assessment.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(assessment.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(assessment.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(assessment.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(assessment.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(assessment.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(assessment.Name)
		}

		if assessmentType, exists := m.AssessmentType(); exists {
			create = create.SetAssessmentType(assessmentType)
		} else {
			create = create.SetAssessmentType(assessment.AssessmentType)
		}

		if templateID, exists := m.TemplateID(); exists {
			create = create.SetTemplateID(templateID)
		} else {
			create = create.SetTemplateID(assessment.TemplateID)
		}

		if jsonconfig, exists := m.Jsonconfig(); exists {
			create = create.SetJsonconfig(jsonconfig)
		} else {
			create = create.SetJsonconfig(assessment.Jsonconfig)
		}

		if uischema, exists := m.Uischema(); exists {
			create = create.SetUischema(uischema)
		} else {
			create = create.SetUischema(assessment.Uischema)
		}

		if responseDueDuration, exists := m.ResponseDueDuration(); exists {
			create = create.SetResponseDueDuration(responseDueDuration)
		} else {
			create = create.SetResponseDueDuration(assessment.ResponseDueDuration)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *AssessmentMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		assessment, err := client.Assessment.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.AssessmentHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(assessment.CreatedAt).
			SetUpdatedAt(assessment.UpdatedAt).
			SetCreatedBy(assessment.CreatedBy).
			SetUpdatedBy(assessment.UpdatedBy).
			SetDeletedAt(assessment.DeletedAt).
			SetDeletedBy(assessment.DeletedBy).
			SetTags(assessment.Tags).
			SetOwnerID(assessment.OwnerID).
			SetName(assessment.Name).
			SetAssessmentType(assessment.AssessmentType).
			SetTemplateID(assessment.TemplateID).
			SetJsonconfig(assessment.Jsonconfig).
			SetUischema(assessment.Uischema).
			SetResponseDueDuration(assessment.ResponseDueDuration).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *AssessmentResponseMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.AssessmentResponseHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if assessmentID, exists := m.AssessmentID(); exists {
		create = create.SetAssessmentID(assessmentID)
	}

	if email, exists := m.Email(); exists {
		create = create.SetEmail(email)
	}

	if sendAttempts, exists := m.SendAttempts(); exists {
		create = create.SetSendAttempts(sendAttempts)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if assignedAt, exists := m.AssignedAt(); exists {
		create = create.SetAssignedAt(assignedAt)
	}

	if startedAt, exists := m.StartedAt(); exists {
		create = create.SetStartedAt(startedAt)
	}

	if completedAt, exists := m.CompletedAt(); exists {
		create = create.SetCompletedAt(completedAt)
	}

	if dueDate, exists := m.DueDate(); exists {
		create = create.SetDueDate(dueDate)
	}

	if documentDataID, exists := m.DocumentDataID(); exists {
		create = create.SetDocumentDataID(documentDataID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *AssessmentResponseMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		assessmentresponse, err := client.AssessmentResponse.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.AssessmentResponseHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(assessmentresponse.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(assessmentresponse.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(assessmentresponse.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(assessmentresponse.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(assessmentresponse.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(assessmentresponse.DeletedBy)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(assessmentresponse.OwnerID)
		}

		if assessmentID, exists := m.AssessmentID(); exists {
			create = create.SetAssessmentID(assessmentID)
		} else {
			create = create.SetAssessmentID(assessmentresponse.AssessmentID)
		}

		if email, exists := m.Email(); exists {
			create = create.SetEmail(email)
		} else {
			create = create.SetEmail(assessmentresponse.Email)
		}

		if sendAttempts, exists := m.SendAttempts(); exists {
			create = create.SetSendAttempts(sendAttempts)
		} else {
			create = create.SetSendAttempts(assessmentresponse.SendAttempts)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(assessmentresponse.Status)
		}

		if assignedAt, exists := m.AssignedAt(); exists {
			create = create.SetAssignedAt(assignedAt)
		} else {
			create = create.SetAssignedAt(assessmentresponse.AssignedAt)
		}

		if startedAt, exists := m.StartedAt(); exists {
			create = create.SetStartedAt(startedAt)
		} else {
			create = create.SetStartedAt(assessmentresponse.StartedAt)
		}

		if completedAt, exists := m.CompletedAt(); exists {
			create = create.SetCompletedAt(completedAt)
		} else {
			create = create.SetCompletedAt(assessmentresponse.CompletedAt)
		}

		if dueDate, exists := m.DueDate(); exists {
			create = create.SetDueDate(dueDate)
		} else {
			create = create.SetDueDate(assessmentresponse.DueDate)
		}

		if documentDataID, exists := m.DocumentDataID(); exists {
			create = create.SetDocumentDataID(documentDataID)
		} else {
			create = create.SetDocumentDataID(assessmentresponse.DocumentDataID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *AssessmentResponseMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		assessmentresponse, err := client.AssessmentResponse.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.AssessmentResponseHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(assessmentresponse.CreatedAt).
			SetUpdatedAt(assessmentresponse.UpdatedAt).
			SetCreatedBy(assessmentresponse.CreatedBy).
			SetUpdatedBy(assessmentresponse.UpdatedBy).
			SetDeletedAt(assessmentresponse.DeletedAt).
			SetDeletedBy(assessmentresponse.DeletedBy).
			SetOwnerID(assessmentresponse.OwnerID).
			SetAssessmentID(assessmentresponse.AssessmentID).
			SetEmail(assessmentresponse.Email).
			SetSendAttempts(assessmentresponse.SendAttempts).
			SetStatus(assessmentresponse.Status).
			SetAssignedAt(assessmentresponse.AssignedAt).
			SetStartedAt(assessmentresponse.StartedAt).
			SetCompletedAt(assessmentresponse.CompletedAt).
			SetDueDate(assessmentresponse.DueDate).
			SetDocumentDataID(assessmentresponse.DocumentDataID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *AssetMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.AssetHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if assetType, exists := m.AssetType(); exists {
		create = create.SetAssetType(assetType)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if identifier, exists := m.Identifier(); exists {
		create = create.SetIdentifier(identifier)
	}

	if website, exists := m.Website(); exists {
		create = create.SetWebsite(website)
	}

	if cpe, exists := m.Cpe(); exists {
		create = create.SetCpe(cpe)
	}

	if categories, exists := m.Categories(); exists {
		create = create.SetCategories(categories)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *AssetMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		asset, err := client.Asset.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.AssetHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(asset.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(asset.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(asset.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(asset.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(asset.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(asset.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(asset.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(asset.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(asset.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(asset.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(asset.SystemInternalID)
		}

		if assetType, exists := m.AssetType(); exists {
			create = create.SetAssetType(assetType)
		} else {
			create = create.SetAssetType(asset.AssetType)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(asset.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(asset.Description)
		}

		if identifier, exists := m.Identifier(); exists {
			create = create.SetIdentifier(identifier)
		} else {
			create = create.SetIdentifier(asset.Identifier)
		}

		if website, exists := m.Website(); exists {
			create = create.SetWebsite(website)
		} else {
			create = create.SetWebsite(asset.Website)
		}

		if cpe, exists := m.Cpe(); exists {
			create = create.SetCpe(cpe)
		} else {
			create = create.SetCpe(asset.Cpe)
		}

		if categories, exists := m.Categories(); exists {
			create = create.SetCategories(categories)
		} else {
			create = create.SetCategories(asset.Categories)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *AssetMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		asset, err := client.Asset.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.AssetHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(asset.CreatedAt).
			SetUpdatedAt(asset.UpdatedAt).
			SetCreatedBy(asset.CreatedBy).
			SetUpdatedBy(asset.UpdatedBy).
			SetDeletedAt(asset.DeletedAt).
			SetDeletedBy(asset.DeletedBy).
			SetTags(asset.Tags).
			SetOwnerID(asset.OwnerID).
			SetSystemOwned(asset.SystemOwned).
			SetNillableInternalNotes(asset.InternalNotes).
			SetNillableSystemInternalID(asset.SystemInternalID).
			SetAssetType(asset.AssetType).
			SetName(asset.Name).
			SetDescription(asset.Description).
			SetIdentifier(asset.Identifier).
			SetWebsite(asset.Website).
			SetCpe(asset.Cpe).
			SetCategories(asset.Categories).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ContactMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ContactHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if fullName, exists := m.FullName(); exists {
		create = create.SetFullName(fullName)
	}

	if title, exists := m.Title(); exists {
		create = create.SetTitle(title)
	}

	if company, exists := m.Company(); exists {
		create = create.SetCompany(company)
	}

	if email, exists := m.Email(); exists {
		create = create.SetEmail(email)
	}

	if phoneNumber, exists := m.PhoneNumber(); exists {
		create = create.SetPhoneNumber(phoneNumber)
	}

	if address, exists := m.Address(); exists {
		create = create.SetAddress(address)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ContactMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		contact, err := client.Contact.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ContactHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(contact.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(contact.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(contact.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(contact.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(contact.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(contact.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(contact.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(contact.OwnerID)
		}

		if fullName, exists := m.FullName(); exists {
			create = create.SetFullName(fullName)
		} else {
			create = create.SetFullName(contact.FullName)
		}

		if title, exists := m.Title(); exists {
			create = create.SetTitle(title)
		} else {
			create = create.SetTitle(contact.Title)
		}

		if company, exists := m.Company(); exists {
			create = create.SetCompany(company)
		} else {
			create = create.SetCompany(contact.Company)
		}

		if email, exists := m.Email(); exists {
			create = create.SetEmail(email)
		} else {
			create = create.SetEmail(contact.Email)
		}

		if phoneNumber, exists := m.PhoneNumber(); exists {
			create = create.SetPhoneNumber(phoneNumber)
		} else {
			create = create.SetPhoneNumber(contact.PhoneNumber)
		}

		if address, exists := m.Address(); exists {
			create = create.SetAddress(address)
		} else {
			create = create.SetAddress(contact.Address)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(contact.Status)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ContactMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		contact, err := client.Contact.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ContactHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(contact.CreatedAt).
			SetUpdatedAt(contact.UpdatedAt).
			SetCreatedBy(contact.CreatedBy).
			SetUpdatedBy(contact.UpdatedBy).
			SetDeletedAt(contact.DeletedAt).
			SetDeletedBy(contact.DeletedBy).
			SetTags(contact.Tags).
			SetOwnerID(contact.OwnerID).
			SetFullName(contact.FullName).
			SetTitle(contact.Title).
			SetCompany(contact.Company).
			SetEmail(contact.Email).
			SetPhoneNumber(contact.PhoneNumber).
			SetAddress(contact.Address).
			SetStatus(contact.Status).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ControlMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ControlHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if title, exists := m.Title(); exists {
		create = create.SetTitle(title)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if aliases, exists := m.Aliases(); exists {
		create = create.SetAliases(aliases)
	}

	if referenceID, exists := m.ReferenceID(); exists {
		create = create.SetReferenceID(referenceID)
	}

	if auditorReferenceID, exists := m.AuditorReferenceID(); exists {
		create = create.SetAuditorReferenceID(auditorReferenceID)
	}

	if responsiblePartyID, exists := m.ResponsiblePartyID(); exists {
		create = create.SetResponsiblePartyID(responsiblePartyID)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if source, exists := m.Source(); exists {
		create = create.SetSource(source)
	}

	if referenceFramework, exists := m.ReferenceFramework(); exists {
		create = create.SetNillableReferenceFramework(&referenceFramework)
	}

	if referenceFrameworkRevision, exists := m.ReferenceFrameworkRevision(); exists {
		create = create.SetNillableReferenceFrameworkRevision(&referenceFrameworkRevision)
	}

	if controlType, exists := m.ControlType(); exists {
		create = create.SetControlType(controlType)
	}

	if category, exists := m.Category(); exists {
		create = create.SetCategory(category)
	}

	if categoryID, exists := m.CategoryID(); exists {
		create = create.SetCategoryID(categoryID)
	}

	if subcategory, exists := m.Subcategory(); exists {
		create = create.SetSubcategory(subcategory)
	}

	if mappedCategories, exists := m.MappedCategories(); exists {
		create = create.SetMappedCategories(mappedCategories)
	}

	if assessmentObjectives, exists := m.AssessmentObjectives(); exists {
		create = create.SetAssessmentObjectives(assessmentObjectives)
	}

	if assessmentMethods, exists := m.AssessmentMethods(); exists {
		create = create.SetAssessmentMethods(assessmentMethods)
	}

	if controlQuestions, exists := m.ControlQuestions(); exists {
		create = create.SetControlQuestions(controlQuestions)
	}

	if implementationGuidance, exists := m.ImplementationGuidance(); exists {
		create = create.SetImplementationGuidance(implementationGuidance)
	}

	if exampleEvidence, exists := m.ExampleEvidence(); exists {
		create = create.SetExampleEvidence(exampleEvidence)
	}

	if references, exists := m.References(); exists {
		create = create.SetReferences(references)
	}

	if controlOwnerID, exists := m.ControlOwnerID(); exists {
		create = create.SetNillableControlOwnerID(&controlOwnerID)
	}

	if delegateID, exists := m.DelegateID(); exists {
		create = create.SetDelegateID(delegateID)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if controlKindName, exists := m.ControlKindName(); exists {
		create = create.SetControlKindName(controlKindName)
	}

	if controlKindID, exists := m.ControlKindID(); exists {
		create = create.SetControlKindID(controlKindID)
	}

	if refCode, exists := m.RefCode(); exists {
		create = create.SetRefCode(refCode)
	}

	if standardID, exists := m.StandardID(); exists {
		create = create.SetStandardID(standardID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ControlMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		control, err := client.Control.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ControlHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(control.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(control.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(control.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(control.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(control.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(control.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(control.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(control.Tags)
		}

		if title, exists := m.Title(); exists {
			create = create.SetTitle(title)
		} else {
			create = create.SetTitle(control.Title)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(control.Description)
		}

		if aliases, exists := m.Aliases(); exists {
			create = create.SetAliases(aliases)
		} else {
			create = create.SetAliases(control.Aliases)
		}

		if referenceID, exists := m.ReferenceID(); exists {
			create = create.SetReferenceID(referenceID)
		} else {
			create = create.SetReferenceID(control.ReferenceID)
		}

		if auditorReferenceID, exists := m.AuditorReferenceID(); exists {
			create = create.SetAuditorReferenceID(auditorReferenceID)
		} else {
			create = create.SetAuditorReferenceID(control.AuditorReferenceID)
		}

		if responsiblePartyID, exists := m.ResponsiblePartyID(); exists {
			create = create.SetResponsiblePartyID(responsiblePartyID)
		} else {
			create = create.SetResponsiblePartyID(control.ResponsiblePartyID)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(control.Status)
		}

		if source, exists := m.Source(); exists {
			create = create.SetSource(source)
		} else {
			create = create.SetSource(control.Source)
		}

		if referenceFramework, exists := m.ReferenceFramework(); exists {
			create = create.SetNillableReferenceFramework(&referenceFramework)
		} else {
			create = create.SetNillableReferenceFramework(control.ReferenceFramework)
		}

		if referenceFrameworkRevision, exists := m.ReferenceFrameworkRevision(); exists {
			create = create.SetNillableReferenceFrameworkRevision(&referenceFrameworkRevision)
		} else {
			create = create.SetNillableReferenceFrameworkRevision(control.ReferenceFrameworkRevision)
		}

		if controlType, exists := m.ControlType(); exists {
			create = create.SetControlType(controlType)
		} else {
			create = create.SetControlType(control.ControlType)
		}

		if category, exists := m.Category(); exists {
			create = create.SetCategory(category)
		} else {
			create = create.SetCategory(control.Category)
		}

		if categoryID, exists := m.CategoryID(); exists {
			create = create.SetCategoryID(categoryID)
		} else {
			create = create.SetCategoryID(control.CategoryID)
		}

		if subcategory, exists := m.Subcategory(); exists {
			create = create.SetSubcategory(subcategory)
		} else {
			create = create.SetSubcategory(control.Subcategory)
		}

		if mappedCategories, exists := m.MappedCategories(); exists {
			create = create.SetMappedCategories(mappedCategories)
		} else {
			create = create.SetMappedCategories(control.MappedCategories)
		}

		if assessmentObjectives, exists := m.AssessmentObjectives(); exists {
			create = create.SetAssessmentObjectives(assessmentObjectives)
		} else {
			create = create.SetAssessmentObjectives(control.AssessmentObjectives)
		}

		if assessmentMethods, exists := m.AssessmentMethods(); exists {
			create = create.SetAssessmentMethods(assessmentMethods)
		} else {
			create = create.SetAssessmentMethods(control.AssessmentMethods)
		}

		if controlQuestions, exists := m.ControlQuestions(); exists {
			create = create.SetControlQuestions(controlQuestions)
		} else {
			create = create.SetControlQuestions(control.ControlQuestions)
		}

		if implementationGuidance, exists := m.ImplementationGuidance(); exists {
			create = create.SetImplementationGuidance(implementationGuidance)
		} else {
			create = create.SetImplementationGuidance(control.ImplementationGuidance)
		}

		if exampleEvidence, exists := m.ExampleEvidence(); exists {
			create = create.SetExampleEvidence(exampleEvidence)
		} else {
			create = create.SetExampleEvidence(control.ExampleEvidence)
		}

		if references, exists := m.References(); exists {
			create = create.SetReferences(references)
		} else {
			create = create.SetReferences(control.References)
		}

		if controlOwnerID, exists := m.ControlOwnerID(); exists {
			create = create.SetNillableControlOwnerID(&controlOwnerID)
		} else {
			create = create.SetNillableControlOwnerID(control.ControlOwnerID)
		}

		if delegateID, exists := m.DelegateID(); exists {
			create = create.SetDelegateID(delegateID)
		} else {
			create = create.SetDelegateID(control.DelegateID)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(control.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(control.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(control.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(control.SystemInternalID)
		}

		if controlKindName, exists := m.ControlKindName(); exists {
			create = create.SetControlKindName(controlKindName)
		} else {
			create = create.SetControlKindName(control.ControlKindName)
		}

		if controlKindID, exists := m.ControlKindID(); exists {
			create = create.SetControlKindID(controlKindID)
		} else {
			create = create.SetControlKindID(control.ControlKindID)
		}

		if refCode, exists := m.RefCode(); exists {
			create = create.SetRefCode(refCode)
		} else {
			create = create.SetRefCode(control.RefCode)
		}

		if standardID, exists := m.StandardID(); exists {
			create = create.SetStandardID(standardID)
		} else {
			create = create.SetStandardID(control.StandardID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ControlMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		control, err := client.Control.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ControlHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(control.CreatedAt).
			SetUpdatedAt(control.UpdatedAt).
			SetCreatedBy(control.CreatedBy).
			SetUpdatedBy(control.UpdatedBy).
			SetDeletedAt(control.DeletedAt).
			SetDeletedBy(control.DeletedBy).
			SetDisplayID(control.DisplayID).
			SetTags(control.Tags).
			SetTitle(control.Title).
			SetDescription(control.Description).
			SetAliases(control.Aliases).
			SetReferenceID(control.ReferenceID).
			SetAuditorReferenceID(control.AuditorReferenceID).
			SetResponsiblePartyID(control.ResponsiblePartyID).
			SetStatus(control.Status).
			SetSource(control.Source).
			SetNillableReferenceFramework(control.ReferenceFramework).
			SetNillableReferenceFrameworkRevision(control.ReferenceFrameworkRevision).
			SetControlType(control.ControlType).
			SetCategory(control.Category).
			SetCategoryID(control.CategoryID).
			SetSubcategory(control.Subcategory).
			SetMappedCategories(control.MappedCategories).
			SetAssessmentObjectives(control.AssessmentObjectives).
			SetAssessmentMethods(control.AssessmentMethods).
			SetControlQuestions(control.ControlQuestions).
			SetImplementationGuidance(control.ImplementationGuidance).
			SetExampleEvidence(control.ExampleEvidence).
			SetReferences(control.References).
			SetNillableControlOwnerID(control.ControlOwnerID).
			SetDelegateID(control.DelegateID).
			SetOwnerID(control.OwnerID).
			SetSystemOwned(control.SystemOwned).
			SetNillableInternalNotes(control.InternalNotes).
			SetNillableSystemInternalID(control.SystemInternalID).
			SetControlKindName(control.ControlKindName).
			SetControlKindID(control.ControlKindID).
			SetRefCode(control.RefCode).
			SetStandardID(control.StandardID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ControlImplementationMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ControlImplementationHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if implementationDate, exists := m.ImplementationDate(); exists {
		create = create.SetImplementationDate(implementationDate)
	}

	if verified, exists := m.Verified(); exists {
		create = create.SetVerified(verified)
	}

	if verificationDate, exists := m.VerificationDate(); exists {
		create = create.SetVerificationDate(verificationDate)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ControlImplementationMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		controlimplementation, err := client.ControlImplementation.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ControlImplementationHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(controlimplementation.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(controlimplementation.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(controlimplementation.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(controlimplementation.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(controlimplementation.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(controlimplementation.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(controlimplementation.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(controlimplementation.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(controlimplementation.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(controlimplementation.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(controlimplementation.SystemInternalID)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(controlimplementation.Status)
		}

		if implementationDate, exists := m.ImplementationDate(); exists {
			create = create.SetImplementationDate(implementationDate)
		} else {
			create = create.SetImplementationDate(controlimplementation.ImplementationDate)
		}

		if verified, exists := m.Verified(); exists {
			create = create.SetVerified(verified)
		} else {
			create = create.SetVerified(controlimplementation.Verified)
		}

		if verificationDate, exists := m.VerificationDate(); exists {
			create = create.SetVerificationDate(verificationDate)
		} else {
			create = create.SetVerificationDate(controlimplementation.VerificationDate)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(controlimplementation.Details)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ControlImplementationMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		controlimplementation, err := client.ControlImplementation.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ControlImplementationHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(controlimplementation.CreatedAt).
			SetUpdatedAt(controlimplementation.UpdatedAt).
			SetCreatedBy(controlimplementation.CreatedBy).
			SetUpdatedBy(controlimplementation.UpdatedBy).
			SetDeletedAt(controlimplementation.DeletedAt).
			SetDeletedBy(controlimplementation.DeletedBy).
			SetTags(controlimplementation.Tags).
			SetOwnerID(controlimplementation.OwnerID).
			SetSystemOwned(controlimplementation.SystemOwned).
			SetNillableInternalNotes(controlimplementation.InternalNotes).
			SetNillableSystemInternalID(controlimplementation.SystemInternalID).
			SetStatus(controlimplementation.Status).
			SetImplementationDate(controlimplementation.ImplementationDate).
			SetVerified(controlimplementation.Verified).
			SetVerificationDate(controlimplementation.VerificationDate).
			SetDetails(controlimplementation.Details).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ControlObjectiveMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ControlObjectiveHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if revision, exists := m.Revision(); exists {
		create = create.SetRevision(revision)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if desiredOutcome, exists := m.DesiredOutcome(); exists {
		create = create.SetDesiredOutcome(desiredOutcome)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if source, exists := m.Source(); exists {
		create = create.SetSource(source)
	}

	if controlObjectiveType, exists := m.ControlObjectiveType(); exists {
		create = create.SetControlObjectiveType(controlObjectiveType)
	}

	if category, exists := m.Category(); exists {
		create = create.SetCategory(category)
	}

	if subcategory, exists := m.Subcategory(); exists {
		create = create.SetSubcategory(subcategory)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ControlObjectiveMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		controlobjective, err := client.ControlObjective.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ControlObjectiveHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(controlobjective.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(controlobjective.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(controlobjective.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(controlobjective.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(controlobjective.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(controlobjective.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(controlobjective.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(controlobjective.Tags)
		}

		if revision, exists := m.Revision(); exists {
			create = create.SetRevision(revision)
		} else {
			create = create.SetRevision(controlobjective.Revision)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(controlobjective.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(controlobjective.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(controlobjective.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(controlobjective.SystemInternalID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(controlobjective.Name)
		}

		if desiredOutcome, exists := m.DesiredOutcome(); exists {
			create = create.SetDesiredOutcome(desiredOutcome)
		} else {
			create = create.SetDesiredOutcome(controlobjective.DesiredOutcome)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(controlobjective.Status)
		}

		if source, exists := m.Source(); exists {
			create = create.SetSource(source)
		} else {
			create = create.SetSource(controlobjective.Source)
		}

		if controlObjectiveType, exists := m.ControlObjectiveType(); exists {
			create = create.SetControlObjectiveType(controlObjectiveType)
		} else {
			create = create.SetControlObjectiveType(controlobjective.ControlObjectiveType)
		}

		if category, exists := m.Category(); exists {
			create = create.SetCategory(category)
		} else {
			create = create.SetCategory(controlobjective.Category)
		}

		if subcategory, exists := m.Subcategory(); exists {
			create = create.SetSubcategory(subcategory)
		} else {
			create = create.SetSubcategory(controlobjective.Subcategory)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ControlObjectiveMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		controlobjective, err := client.ControlObjective.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ControlObjectiveHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(controlobjective.CreatedAt).
			SetUpdatedAt(controlobjective.UpdatedAt).
			SetCreatedBy(controlobjective.CreatedBy).
			SetUpdatedBy(controlobjective.UpdatedBy).
			SetDeletedAt(controlobjective.DeletedAt).
			SetDeletedBy(controlobjective.DeletedBy).
			SetDisplayID(controlobjective.DisplayID).
			SetTags(controlobjective.Tags).
			SetRevision(controlobjective.Revision).
			SetOwnerID(controlobjective.OwnerID).
			SetSystemOwned(controlobjective.SystemOwned).
			SetNillableInternalNotes(controlobjective.InternalNotes).
			SetNillableSystemInternalID(controlobjective.SystemInternalID).
			SetName(controlobjective.Name).
			SetDesiredOutcome(controlobjective.DesiredOutcome).
			SetStatus(controlobjective.Status).
			SetSource(controlobjective.Source).
			SetControlObjectiveType(controlobjective.ControlObjectiveType).
			SetCategory(controlobjective.Category).
			SetSubcategory(controlobjective.Subcategory).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *CustomDomainMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.CustomDomainHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if cnameRecord, exists := m.CnameRecord(); exists {
		create = create.SetCnameRecord(cnameRecord)
	}

	if mappableDomainID, exists := m.MappableDomainID(); exists {
		create = create.SetMappableDomainID(mappableDomainID)
	}

	if dnsVerificationID, exists := m.DNSVerificationID(); exists {
		create = create.SetDNSVerificationID(dnsVerificationID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *CustomDomainMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		customdomain, err := client.CustomDomain.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.CustomDomainHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(customdomain.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(customdomain.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(customdomain.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(customdomain.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(customdomain.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(customdomain.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(customdomain.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(customdomain.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(customdomain.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(customdomain.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(customdomain.SystemInternalID)
		}

		if cnameRecord, exists := m.CnameRecord(); exists {
			create = create.SetCnameRecord(cnameRecord)
		} else {
			create = create.SetCnameRecord(customdomain.CnameRecord)
		}

		if mappableDomainID, exists := m.MappableDomainID(); exists {
			create = create.SetMappableDomainID(mappableDomainID)
		} else {
			create = create.SetMappableDomainID(customdomain.MappableDomainID)
		}

		if dnsVerificationID, exists := m.DNSVerificationID(); exists {
			create = create.SetDNSVerificationID(dnsVerificationID)
		} else {
			create = create.SetDNSVerificationID(customdomain.DNSVerificationID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *CustomDomainMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		customdomain, err := client.CustomDomain.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.CustomDomainHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(customdomain.CreatedAt).
			SetUpdatedAt(customdomain.UpdatedAt).
			SetCreatedBy(customdomain.CreatedBy).
			SetUpdatedBy(customdomain.UpdatedBy).
			SetDeletedAt(customdomain.DeletedAt).
			SetDeletedBy(customdomain.DeletedBy).
			SetTags(customdomain.Tags).
			SetOwnerID(customdomain.OwnerID).
			SetSystemOwned(customdomain.SystemOwned).
			SetNillableInternalNotes(customdomain.InternalNotes).
			SetNillableSystemInternalID(customdomain.SystemInternalID).
			SetCnameRecord(customdomain.CnameRecord).
			SetMappableDomainID(customdomain.MappableDomainID).
			SetDNSVerificationID(customdomain.DNSVerificationID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *DNSVerificationMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.DNSVerificationHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if cloudflareHostnameID, exists := m.CloudflareHostnameID(); exists {
		create = create.SetCloudflareHostnameID(cloudflareHostnameID)
	}

	if dnsTxtRecord, exists := m.DNSTxtRecord(); exists {
		create = create.SetDNSTxtRecord(dnsTxtRecord)
	}

	if dnsTxtValue, exists := m.DNSTxtValue(); exists {
		create = create.SetDNSTxtValue(dnsTxtValue)
	}

	if dnsVerificationStatus, exists := m.DNSVerificationStatus(); exists {
		create = create.SetDNSVerificationStatus(dnsVerificationStatus)
	}

	if dnsVerificationStatusReason, exists := m.DNSVerificationStatusReason(); exists {
		create = create.SetDNSVerificationStatusReason(dnsVerificationStatusReason)
	}

	if acmeChallengePath, exists := m.AcmeChallengePath(); exists {
		create = create.SetAcmeChallengePath(acmeChallengePath)
	}

	if expectedAcmeChallengeValue, exists := m.ExpectedAcmeChallengeValue(); exists {
		create = create.SetExpectedAcmeChallengeValue(expectedAcmeChallengeValue)
	}

	if acmeChallengeStatus, exists := m.AcmeChallengeStatus(); exists {
		create = create.SetAcmeChallengeStatus(acmeChallengeStatus)
	}

	if acmeChallengeStatusReason, exists := m.AcmeChallengeStatusReason(); exists {
		create = create.SetAcmeChallengeStatusReason(acmeChallengeStatusReason)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *DNSVerificationMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		dnsverification, err := client.DNSVerification.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.DNSVerificationHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(dnsverification.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(dnsverification.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(dnsverification.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(dnsverification.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(dnsverification.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(dnsverification.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(dnsverification.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(dnsverification.OwnerID)
		}

		if cloudflareHostnameID, exists := m.CloudflareHostnameID(); exists {
			create = create.SetCloudflareHostnameID(cloudflareHostnameID)
		} else {
			create = create.SetCloudflareHostnameID(dnsverification.CloudflareHostnameID)
		}

		if dnsTxtRecord, exists := m.DNSTxtRecord(); exists {
			create = create.SetDNSTxtRecord(dnsTxtRecord)
		} else {
			create = create.SetDNSTxtRecord(dnsverification.DNSTxtRecord)
		}

		if dnsTxtValue, exists := m.DNSTxtValue(); exists {
			create = create.SetDNSTxtValue(dnsTxtValue)
		} else {
			create = create.SetDNSTxtValue(dnsverification.DNSTxtValue)
		}

		if dnsVerificationStatus, exists := m.DNSVerificationStatus(); exists {
			create = create.SetDNSVerificationStatus(dnsVerificationStatus)
		} else {
			create = create.SetDNSVerificationStatus(dnsverification.DNSVerificationStatus)
		}

		if dnsVerificationStatusReason, exists := m.DNSVerificationStatusReason(); exists {
			create = create.SetDNSVerificationStatusReason(dnsVerificationStatusReason)
		} else {
			create = create.SetDNSVerificationStatusReason(dnsverification.DNSVerificationStatusReason)
		}

		if acmeChallengePath, exists := m.AcmeChallengePath(); exists {
			create = create.SetAcmeChallengePath(acmeChallengePath)
		} else {
			create = create.SetAcmeChallengePath(dnsverification.AcmeChallengePath)
		}

		if expectedAcmeChallengeValue, exists := m.ExpectedAcmeChallengeValue(); exists {
			create = create.SetExpectedAcmeChallengeValue(expectedAcmeChallengeValue)
		} else {
			create = create.SetExpectedAcmeChallengeValue(dnsverification.ExpectedAcmeChallengeValue)
		}

		if acmeChallengeStatus, exists := m.AcmeChallengeStatus(); exists {
			create = create.SetAcmeChallengeStatus(acmeChallengeStatus)
		} else {
			create = create.SetAcmeChallengeStatus(dnsverification.AcmeChallengeStatus)
		}

		if acmeChallengeStatusReason, exists := m.AcmeChallengeStatusReason(); exists {
			create = create.SetAcmeChallengeStatusReason(acmeChallengeStatusReason)
		} else {
			create = create.SetAcmeChallengeStatusReason(dnsverification.AcmeChallengeStatusReason)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *DNSVerificationMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		dnsverification, err := client.DNSVerification.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.DNSVerificationHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(dnsverification.CreatedAt).
			SetUpdatedAt(dnsverification.UpdatedAt).
			SetCreatedBy(dnsverification.CreatedBy).
			SetUpdatedBy(dnsverification.UpdatedBy).
			SetDeletedAt(dnsverification.DeletedAt).
			SetDeletedBy(dnsverification.DeletedBy).
			SetTags(dnsverification.Tags).
			SetOwnerID(dnsverification.OwnerID).
			SetCloudflareHostnameID(dnsverification.CloudflareHostnameID).
			SetDNSTxtRecord(dnsverification.DNSTxtRecord).
			SetDNSTxtValue(dnsverification.DNSTxtValue).
			SetDNSVerificationStatus(dnsverification.DNSVerificationStatus).
			SetDNSVerificationStatusReason(dnsverification.DNSVerificationStatusReason).
			SetAcmeChallengePath(dnsverification.AcmeChallengePath).
			SetExpectedAcmeChallengeValue(dnsverification.ExpectedAcmeChallengeValue).
			SetAcmeChallengeStatus(dnsverification.AcmeChallengeStatus).
			SetAcmeChallengeStatusReason(dnsverification.AcmeChallengeStatusReason).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *DirectoryAccountMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.DirectoryAccountHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if integrationID, exists := m.IntegrationID(); exists {
		create = create.SetIntegrationID(integrationID)
	}

	if directorySyncRunID, exists := m.DirectorySyncRunID(); exists {
		create = create.SetDirectorySyncRunID(directorySyncRunID)
	}

	if externalID, exists := m.ExternalID(); exists {
		create = create.SetExternalID(externalID)
	}

	if secondaryKey, exists := m.SecondaryKey(); exists {
		create = create.SetNillableSecondaryKey(&secondaryKey)
	}

	if canonicalEmail, exists := m.CanonicalEmail(); exists {
		create = create.SetNillableCanonicalEmail(&canonicalEmail)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if givenName, exists := m.GivenName(); exists {
		create = create.SetNillableGivenName(&givenName)
	}

	if familyName, exists := m.FamilyName(); exists {
		create = create.SetNillableFamilyName(&familyName)
	}

	if jobTitle, exists := m.JobTitle(); exists {
		create = create.SetNillableJobTitle(&jobTitle)
	}

	if department, exists := m.Department(); exists {
		create = create.SetNillableDepartment(&department)
	}

	if organizationUnit, exists := m.OrganizationUnit(); exists {
		create = create.SetNillableOrganizationUnit(&organizationUnit)
	}

	if accountType, exists := m.AccountType(); exists {
		create = create.SetAccountType(accountType)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if mfaState, exists := m.MfaState(); exists {
		create = create.SetMfaState(mfaState)
	}

	if lastSeenIP, exists := m.LastSeenIP(); exists {
		create = create.SetNillableLastSeenIP(&lastSeenIP)
	}

	if lastLoginAt, exists := m.LastLoginAt(); exists {
		create = create.SetNillableLastLoginAt(&lastLoginAt)
	}

	if observedAt, exists := m.ObservedAt(); exists {
		create = create.SetObservedAt(observedAt)
	}

	if profileHash, exists := m.ProfileHash(); exists {
		create = create.SetProfileHash(profileHash)
	}

	if profile, exists := m.Profile(); exists {
		create = create.SetProfile(profile)
	}

	if rawProfileFileID, exists := m.RawProfileFileID(); exists {
		create = create.SetNillableRawProfileFileID(&rawProfileFileID)
	}

	if sourceVersion, exists := m.SourceVersion(); exists {
		create = create.SetNillableSourceVersion(&sourceVersion)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *DirectoryAccountMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		directoryaccount, err := client.DirectoryAccount.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.DirectoryAccountHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(directoryaccount.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(directoryaccount.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(directoryaccount.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(directoryaccount.UpdatedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(directoryaccount.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(directoryaccount.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(directoryaccount.OwnerID)
		}

		if integrationID, exists := m.IntegrationID(); exists {
			create = create.SetIntegrationID(integrationID)
		} else {
			create = create.SetIntegrationID(directoryaccount.IntegrationID)
		}

		if directorySyncRunID, exists := m.DirectorySyncRunID(); exists {
			create = create.SetDirectorySyncRunID(directorySyncRunID)
		} else {
			create = create.SetDirectorySyncRunID(directoryaccount.DirectorySyncRunID)
		}

		if externalID, exists := m.ExternalID(); exists {
			create = create.SetExternalID(externalID)
		} else {
			create = create.SetExternalID(directoryaccount.ExternalID)
		}

		if secondaryKey, exists := m.SecondaryKey(); exists {
			create = create.SetNillableSecondaryKey(&secondaryKey)
		} else {
			create = create.SetNillableSecondaryKey(directoryaccount.SecondaryKey)
		}

		if canonicalEmail, exists := m.CanonicalEmail(); exists {
			create = create.SetNillableCanonicalEmail(&canonicalEmail)
		} else {
			create = create.SetNillableCanonicalEmail(directoryaccount.CanonicalEmail)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(directoryaccount.DisplayName)
		}

		if givenName, exists := m.GivenName(); exists {
			create = create.SetNillableGivenName(&givenName)
		} else {
			create = create.SetNillableGivenName(directoryaccount.GivenName)
		}

		if familyName, exists := m.FamilyName(); exists {
			create = create.SetNillableFamilyName(&familyName)
		} else {
			create = create.SetNillableFamilyName(directoryaccount.FamilyName)
		}

		if jobTitle, exists := m.JobTitle(); exists {
			create = create.SetNillableJobTitle(&jobTitle)
		} else {
			create = create.SetNillableJobTitle(directoryaccount.JobTitle)
		}

		if department, exists := m.Department(); exists {
			create = create.SetNillableDepartment(&department)
		} else {
			create = create.SetNillableDepartment(directoryaccount.Department)
		}

		if organizationUnit, exists := m.OrganizationUnit(); exists {
			create = create.SetNillableOrganizationUnit(&organizationUnit)
		} else {
			create = create.SetNillableOrganizationUnit(directoryaccount.OrganizationUnit)
		}

		if accountType, exists := m.AccountType(); exists {
			create = create.SetAccountType(accountType)
		} else {
			create = create.SetAccountType(directoryaccount.AccountType)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(directoryaccount.Status)
		}

		if mfaState, exists := m.MfaState(); exists {
			create = create.SetMfaState(mfaState)
		} else {
			create = create.SetMfaState(directoryaccount.MfaState)
		}

		if lastSeenIP, exists := m.LastSeenIP(); exists {
			create = create.SetNillableLastSeenIP(&lastSeenIP)
		} else {
			create = create.SetNillableLastSeenIP(directoryaccount.LastSeenIP)
		}

		if lastLoginAt, exists := m.LastLoginAt(); exists {
			create = create.SetNillableLastLoginAt(&lastLoginAt)
		} else {
			create = create.SetNillableLastLoginAt(directoryaccount.LastLoginAt)
		}

		if observedAt, exists := m.ObservedAt(); exists {
			create = create.SetObservedAt(observedAt)
		} else {
			create = create.SetObservedAt(directoryaccount.ObservedAt)
		}

		if profileHash, exists := m.ProfileHash(); exists {
			create = create.SetProfileHash(profileHash)
		} else {
			create = create.SetProfileHash(directoryaccount.ProfileHash)
		}

		if profile, exists := m.Profile(); exists {
			create = create.SetProfile(profile)
		} else {
			create = create.SetProfile(directoryaccount.Profile)
		}

		if rawProfileFileID, exists := m.RawProfileFileID(); exists {
			create = create.SetNillableRawProfileFileID(&rawProfileFileID)
		} else {
			create = create.SetNillableRawProfileFileID(directoryaccount.RawProfileFileID)
		}

		if sourceVersion, exists := m.SourceVersion(); exists {
			create = create.SetNillableSourceVersion(&sourceVersion)
		} else {
			create = create.SetNillableSourceVersion(directoryaccount.SourceVersion)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *DirectoryAccountMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		directoryaccount, err := client.DirectoryAccount.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.DirectoryAccountHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(directoryaccount.CreatedAt).
			SetUpdatedAt(directoryaccount.UpdatedAt).
			SetCreatedBy(directoryaccount.CreatedBy).
			SetUpdatedBy(directoryaccount.UpdatedBy).
			SetDisplayID(directoryaccount.DisplayID).
			SetTags(directoryaccount.Tags).
			SetOwnerID(directoryaccount.OwnerID).
			SetIntegrationID(directoryaccount.IntegrationID).
			SetDirectorySyncRunID(directoryaccount.DirectorySyncRunID).
			SetExternalID(directoryaccount.ExternalID).
			SetNillableSecondaryKey(directoryaccount.SecondaryKey).
			SetNillableCanonicalEmail(directoryaccount.CanonicalEmail).
			SetDisplayName(directoryaccount.DisplayName).
			SetNillableGivenName(directoryaccount.GivenName).
			SetNillableFamilyName(directoryaccount.FamilyName).
			SetNillableJobTitle(directoryaccount.JobTitle).
			SetNillableDepartment(directoryaccount.Department).
			SetNillableOrganizationUnit(directoryaccount.OrganizationUnit).
			SetAccountType(directoryaccount.AccountType).
			SetStatus(directoryaccount.Status).
			SetMfaState(directoryaccount.MfaState).
			SetNillableLastSeenIP(directoryaccount.LastSeenIP).
			SetNillableLastLoginAt(directoryaccount.LastLoginAt).
			SetObservedAt(directoryaccount.ObservedAt).
			SetProfileHash(directoryaccount.ProfileHash).
			SetProfile(directoryaccount.Profile).
			SetNillableRawProfileFileID(directoryaccount.RawProfileFileID).
			SetNillableSourceVersion(directoryaccount.SourceVersion).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *DirectoryGroupMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.DirectoryGroupHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if integrationID, exists := m.IntegrationID(); exists {
		create = create.SetIntegrationID(integrationID)
	}

	if directorySyncRunID, exists := m.DirectorySyncRunID(); exists {
		create = create.SetDirectorySyncRunID(directorySyncRunID)
	}

	if externalID, exists := m.ExternalID(); exists {
		create = create.SetExternalID(externalID)
	}

	if email, exists := m.Email(); exists {
		create = create.SetNillableEmail(&email)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if description, exists := m.Description(); exists {
		create = create.SetNillableDescription(&description)
	}

	if classification, exists := m.Classification(); exists {
		create = create.SetClassification(classification)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if externalSharingAllowed, exists := m.ExternalSharingAllowed(); exists {
		create = create.SetExternalSharingAllowed(externalSharingAllowed)
	}

	if memberCount, exists := m.MemberCount(); exists {
		create = create.SetMemberCount(memberCount)
	}

	if observedAt, exists := m.ObservedAt(); exists {
		create = create.SetObservedAt(observedAt)
	}

	if profileHash, exists := m.ProfileHash(); exists {
		create = create.SetProfileHash(profileHash)
	}

	if profile, exists := m.Profile(); exists {
		create = create.SetProfile(profile)
	}

	if rawProfileFileID, exists := m.RawProfileFileID(); exists {
		create = create.SetNillableRawProfileFileID(&rawProfileFileID)
	}

	if sourceVersion, exists := m.SourceVersion(); exists {
		create = create.SetNillableSourceVersion(&sourceVersion)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *DirectoryGroupMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		directorygroup, err := client.DirectoryGroup.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.DirectoryGroupHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(directorygroup.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(directorygroup.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(directorygroup.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(directorygroup.UpdatedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(directorygroup.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(directorygroup.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(directorygroup.OwnerID)
		}

		if integrationID, exists := m.IntegrationID(); exists {
			create = create.SetIntegrationID(integrationID)
		} else {
			create = create.SetIntegrationID(directorygroup.IntegrationID)
		}

		if directorySyncRunID, exists := m.DirectorySyncRunID(); exists {
			create = create.SetDirectorySyncRunID(directorySyncRunID)
		} else {
			create = create.SetDirectorySyncRunID(directorygroup.DirectorySyncRunID)
		}

		if externalID, exists := m.ExternalID(); exists {
			create = create.SetExternalID(externalID)
		} else {
			create = create.SetExternalID(directorygroup.ExternalID)
		}

		if email, exists := m.Email(); exists {
			create = create.SetNillableEmail(&email)
		} else {
			create = create.SetNillableEmail(directorygroup.Email)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(directorygroup.DisplayName)
		}

		if description, exists := m.Description(); exists {
			create = create.SetNillableDescription(&description)
		} else {
			create = create.SetNillableDescription(directorygroup.Description)
		}

		if classification, exists := m.Classification(); exists {
			create = create.SetClassification(classification)
		} else {
			create = create.SetClassification(directorygroup.Classification)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(directorygroup.Status)
		}

		if externalSharingAllowed, exists := m.ExternalSharingAllowed(); exists {
			create = create.SetExternalSharingAllowed(externalSharingAllowed)
		} else {
			create = create.SetExternalSharingAllowed(directorygroup.ExternalSharingAllowed)
		}

		if memberCount, exists := m.MemberCount(); exists {
			create = create.SetMemberCount(memberCount)
		} else {
			create = create.SetMemberCount(directorygroup.MemberCount)
		}

		if observedAt, exists := m.ObservedAt(); exists {
			create = create.SetObservedAt(observedAt)
		} else {
			create = create.SetObservedAt(directorygroup.ObservedAt)
		}

		if profileHash, exists := m.ProfileHash(); exists {
			create = create.SetProfileHash(profileHash)
		} else {
			create = create.SetProfileHash(directorygroup.ProfileHash)
		}

		if profile, exists := m.Profile(); exists {
			create = create.SetProfile(profile)
		} else {
			create = create.SetProfile(directorygroup.Profile)
		}

		if rawProfileFileID, exists := m.RawProfileFileID(); exists {
			create = create.SetNillableRawProfileFileID(&rawProfileFileID)
		} else {
			create = create.SetNillableRawProfileFileID(directorygroup.RawProfileFileID)
		}

		if sourceVersion, exists := m.SourceVersion(); exists {
			create = create.SetNillableSourceVersion(&sourceVersion)
		} else {
			create = create.SetNillableSourceVersion(directorygroup.SourceVersion)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *DirectoryGroupMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		directorygroup, err := client.DirectoryGroup.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.DirectoryGroupHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(directorygroup.CreatedAt).
			SetUpdatedAt(directorygroup.UpdatedAt).
			SetCreatedBy(directorygroup.CreatedBy).
			SetUpdatedBy(directorygroup.UpdatedBy).
			SetDisplayID(directorygroup.DisplayID).
			SetTags(directorygroup.Tags).
			SetOwnerID(directorygroup.OwnerID).
			SetIntegrationID(directorygroup.IntegrationID).
			SetDirectorySyncRunID(directorygroup.DirectorySyncRunID).
			SetExternalID(directorygroup.ExternalID).
			SetNillableEmail(directorygroup.Email).
			SetDisplayName(directorygroup.DisplayName).
			SetNillableDescription(directorygroup.Description).
			SetClassification(directorygroup.Classification).
			SetStatus(directorygroup.Status).
			SetExternalSharingAllowed(directorygroup.ExternalSharingAllowed).
			SetMemberCount(directorygroup.MemberCount).
			SetObservedAt(directorygroup.ObservedAt).
			SetProfileHash(directorygroup.ProfileHash).
			SetProfile(directorygroup.Profile).
			SetNillableRawProfileFileID(directorygroup.RawProfileFileID).
			SetNillableSourceVersion(directorygroup.SourceVersion).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *DirectoryMembershipMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.DirectoryMembershipHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if integrationID, exists := m.IntegrationID(); exists {
		create = create.SetIntegrationID(integrationID)
	}

	if directorySyncRunID, exists := m.DirectorySyncRunID(); exists {
		create = create.SetDirectorySyncRunID(directorySyncRunID)
	}

	if directoryAccountID, exists := m.DirectoryAccountID(); exists {
		create = create.SetDirectoryAccountID(directoryAccountID)
	}

	if directoryGroupID, exists := m.DirectoryGroupID(); exists {
		create = create.SetDirectoryGroupID(directoryGroupID)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	}

	if source, exists := m.Source(); exists {
		create = create.SetNillableSource(&source)
	}

	if firstSeenAt, exists := m.FirstSeenAt(); exists {
		create = create.SetNillableFirstSeenAt(&firstSeenAt)
	}

	if lastSeenAt, exists := m.LastSeenAt(); exists {
		create = create.SetNillableLastSeenAt(&lastSeenAt)
	}

	if observedAt, exists := m.ObservedAt(); exists {
		create = create.SetObservedAt(observedAt)
	}

	if lastConfirmedRunID, exists := m.LastConfirmedRunID(); exists {
		create = create.SetNillableLastConfirmedRunID(&lastConfirmedRunID)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *DirectoryMembershipMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		directorymembership, err := client.DirectoryMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.DirectoryMembershipHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(directorymembership.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(directorymembership.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(directorymembership.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(directorymembership.UpdatedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(directorymembership.DisplayID)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(directorymembership.OwnerID)
		}

		if integrationID, exists := m.IntegrationID(); exists {
			create = create.SetIntegrationID(integrationID)
		} else {
			create = create.SetIntegrationID(directorymembership.IntegrationID)
		}

		if directorySyncRunID, exists := m.DirectorySyncRunID(); exists {
			create = create.SetDirectorySyncRunID(directorySyncRunID)
		} else {
			create = create.SetDirectorySyncRunID(directorymembership.DirectorySyncRunID)
		}

		if directoryAccountID, exists := m.DirectoryAccountID(); exists {
			create = create.SetDirectoryAccountID(directoryAccountID)
		} else {
			create = create.SetDirectoryAccountID(directorymembership.DirectoryAccountID)
		}

		if directoryGroupID, exists := m.DirectoryGroupID(); exists {
			create = create.SetDirectoryGroupID(directoryGroupID)
		} else {
			create = create.SetDirectoryGroupID(directorymembership.DirectoryGroupID)
		}

		if role, exists := m.Role(); exists {
			create = create.SetRole(role)
		} else {
			create = create.SetRole(directorymembership.Role)
		}

		if source, exists := m.Source(); exists {
			create = create.SetNillableSource(&source)
		} else {
			create = create.SetNillableSource(directorymembership.Source)
		}

		if firstSeenAt, exists := m.FirstSeenAt(); exists {
			create = create.SetNillableFirstSeenAt(&firstSeenAt)
		} else {
			create = create.SetNillableFirstSeenAt(directorymembership.FirstSeenAt)
		}

		if lastSeenAt, exists := m.LastSeenAt(); exists {
			create = create.SetNillableLastSeenAt(&lastSeenAt)
		} else {
			create = create.SetNillableLastSeenAt(directorymembership.LastSeenAt)
		}

		if observedAt, exists := m.ObservedAt(); exists {
			create = create.SetObservedAt(observedAt)
		} else {
			create = create.SetObservedAt(directorymembership.ObservedAt)
		}

		if lastConfirmedRunID, exists := m.LastConfirmedRunID(); exists {
			create = create.SetNillableLastConfirmedRunID(&lastConfirmedRunID)
		} else {
			create = create.SetNillableLastConfirmedRunID(directorymembership.LastConfirmedRunID)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(directorymembership.Metadata)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *DirectoryMembershipMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		directorymembership, err := client.DirectoryMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.DirectoryMembershipHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(directorymembership.CreatedAt).
			SetUpdatedAt(directorymembership.UpdatedAt).
			SetCreatedBy(directorymembership.CreatedBy).
			SetUpdatedBy(directorymembership.UpdatedBy).
			SetDisplayID(directorymembership.DisplayID).
			SetOwnerID(directorymembership.OwnerID).
			SetIntegrationID(directorymembership.IntegrationID).
			SetDirectorySyncRunID(directorymembership.DirectorySyncRunID).
			SetDirectoryAccountID(directorymembership.DirectoryAccountID).
			SetDirectoryGroupID(directorymembership.DirectoryGroupID).
			SetRole(directorymembership.Role).
			SetNillableSource(directorymembership.Source).
			SetNillableFirstSeenAt(directorymembership.FirstSeenAt).
			SetNillableLastSeenAt(directorymembership.LastSeenAt).
			SetObservedAt(directorymembership.ObservedAt).
			SetNillableLastConfirmedRunID(directorymembership.LastConfirmedRunID).
			SetMetadata(directorymembership.Metadata).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *DocumentDataMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.DocumentDataHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if templateID, exists := m.TemplateID(); exists {
		create = create.SetTemplateID(templateID)
	}

	if data, exists := m.Data(); exists {
		create = create.SetData(data)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *DocumentDataMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		documentdata, err := client.DocumentData.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.DocumentDataHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(documentdata.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(documentdata.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(documentdata.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(documentdata.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(documentdata.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(documentdata.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(documentdata.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(documentdata.OwnerID)
		}

		if templateID, exists := m.TemplateID(); exists {
			create = create.SetTemplateID(templateID)
		} else {
			create = create.SetTemplateID(documentdata.TemplateID)
		}

		if data, exists := m.Data(); exists {
			create = create.SetData(data)
		} else {
			create = create.SetData(documentdata.Data)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *DocumentDataMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		documentdata, err := client.DocumentData.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.DocumentDataHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(documentdata.CreatedAt).
			SetUpdatedAt(documentdata.UpdatedAt).
			SetCreatedBy(documentdata.CreatedBy).
			SetUpdatedBy(documentdata.UpdatedBy).
			SetDeletedAt(documentdata.DeletedAt).
			SetDeletedBy(documentdata.DeletedBy).
			SetTags(documentdata.Tags).
			SetOwnerID(documentdata.OwnerID).
			SetTemplateID(documentdata.TemplateID).
			SetData(documentdata.Data).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *EntityMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.EntityHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if domains, exists := m.Domains(); exists {
		create = create.SetDomains(domains)
	}

	if entityTypeID, exists := m.EntityTypeID(); exists {
		create = create.SetEntityTypeID(entityTypeID)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *EntityMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entity, err := client.Entity.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntityHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(entity.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(entity.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(entity.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(entity.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(entity.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(entity.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(entity.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(entity.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(entity.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(entity.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(entity.SystemInternalID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(entity.Name)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(entity.DisplayName)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(entity.Description)
		}

		if domains, exists := m.Domains(); exists {
			create = create.SetDomains(domains)
		} else {
			create = create.SetDomains(entity.Domains)
		}

		if entityTypeID, exists := m.EntityTypeID(); exists {
			create = create.SetEntityTypeID(entityTypeID)
		} else {
			create = create.SetEntityTypeID(entity.EntityTypeID)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(entity.Status)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *EntityMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entity, err := client.Entity.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntityHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(entity.CreatedAt).
			SetUpdatedAt(entity.UpdatedAt).
			SetCreatedBy(entity.CreatedBy).
			SetUpdatedBy(entity.UpdatedBy).
			SetDeletedAt(entity.DeletedAt).
			SetDeletedBy(entity.DeletedBy).
			SetTags(entity.Tags).
			SetOwnerID(entity.OwnerID).
			SetSystemOwned(entity.SystemOwned).
			SetNillableInternalNotes(entity.InternalNotes).
			SetNillableSystemInternalID(entity.SystemInternalID).
			SetName(entity.Name).
			SetDisplayName(entity.DisplayName).
			SetDescription(entity.Description).
			SetDomains(entity.Domains).
			SetEntityTypeID(entity.EntityTypeID).
			SetStatus(entity.Status).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *EntityTypeMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.EntityTypeHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *EntityTypeMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entitytype, err := client.EntityType.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntityTypeHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(entitytype.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(entitytype.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(entitytype.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(entitytype.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(entitytype.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(entitytype.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(entitytype.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(entitytype.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(entitytype.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(entitytype.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(entitytype.SystemInternalID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(entitytype.Name)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *EntityTypeMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		entitytype, err := client.EntityType.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EntityTypeHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(entitytype.CreatedAt).
			SetUpdatedAt(entitytype.UpdatedAt).
			SetCreatedBy(entitytype.CreatedBy).
			SetUpdatedBy(entitytype.UpdatedBy).
			SetDeletedAt(entitytype.DeletedAt).
			SetDeletedBy(entitytype.DeletedBy).
			SetTags(entitytype.Tags).
			SetOwnerID(entitytype.OwnerID).
			SetSystemOwned(entitytype.SystemOwned).
			SetNillableInternalNotes(entitytype.InternalNotes).
			SetNillableSystemInternalID(entitytype.SystemInternalID).
			SetName(entitytype.Name).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *EvidenceMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.EvidenceHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if collectionProcedure, exists := m.CollectionProcedure(); exists {
		create = create.SetCollectionProcedure(collectionProcedure)
	}

	if creationDate, exists := m.CreationDate(); exists {
		create = create.SetCreationDate(creationDate)
	}

	if renewalDate, exists := m.RenewalDate(); exists {
		create = create.SetRenewalDate(renewalDate)
	}

	if source, exists := m.Source(); exists {
		create = create.SetSource(source)
	}

	if isAutomated, exists := m.IsAutomated(); exists {
		create = create.SetIsAutomated(isAutomated)
	}

	if url, exists := m.URL(); exists {
		create = create.SetURL(url)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *EvidenceMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		evidence, err := client.Evidence.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EvidenceHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(evidence.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(evidence.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(evidence.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(evidence.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(evidence.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(evidence.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(evidence.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(evidence.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(evidence.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(evidence.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(evidence.Description)
		}

		if collectionProcedure, exists := m.CollectionProcedure(); exists {
			create = create.SetCollectionProcedure(collectionProcedure)
		} else {
			create = create.SetCollectionProcedure(evidence.CollectionProcedure)
		}

		if creationDate, exists := m.CreationDate(); exists {
			create = create.SetCreationDate(creationDate)
		} else {
			create = create.SetCreationDate(evidence.CreationDate)
		}

		if renewalDate, exists := m.RenewalDate(); exists {
			create = create.SetRenewalDate(renewalDate)
		} else {
			create = create.SetRenewalDate(evidence.RenewalDate)
		}

		if source, exists := m.Source(); exists {
			create = create.SetSource(source)
		} else {
			create = create.SetSource(evidence.Source)
		}

		if isAutomated, exists := m.IsAutomated(); exists {
			create = create.SetIsAutomated(isAutomated)
		} else {
			create = create.SetIsAutomated(evidence.IsAutomated)
		}

		if url, exists := m.URL(); exists {
			create = create.SetURL(url)
		} else {
			create = create.SetURL(evidence.URL)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(evidence.Status)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *EvidenceMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		evidence, err := client.Evidence.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.EvidenceHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(evidence.CreatedAt).
			SetUpdatedAt(evidence.UpdatedAt).
			SetCreatedBy(evidence.CreatedBy).
			SetUpdatedBy(evidence.UpdatedBy).
			SetDeletedAt(evidence.DeletedAt).
			SetDeletedBy(evidence.DeletedBy).
			SetDisplayID(evidence.DisplayID).
			SetTags(evidence.Tags).
			SetOwnerID(evidence.OwnerID).
			SetName(evidence.Name).
			SetDescription(evidence.Description).
			SetCollectionProcedure(evidence.CollectionProcedure).
			SetCreationDate(evidence.CreationDate).
			SetRenewalDate(evidence.RenewalDate).
			SetSource(evidence.Source).
			SetIsAutomated(evidence.IsAutomated).
			SetURL(evidence.URL).
			SetStatus(evidence.Status).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *FileMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.FileHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if providedFileName, exists := m.ProvidedFileName(); exists {
		create = create.SetProvidedFileName(providedFileName)
	}

	if providedFileExtension, exists := m.ProvidedFileExtension(); exists {
		create = create.SetProvidedFileExtension(providedFileExtension)
	}

	if providedFileSize, exists := m.ProvidedFileSize(); exists {
		create = create.SetProvidedFileSize(providedFileSize)
	}

	if persistedFileSize, exists := m.PersistedFileSize(); exists {
		create = create.SetPersistedFileSize(persistedFileSize)
	}

	if detectedMimeType, exists := m.DetectedMimeType(); exists {
		create = create.SetDetectedMimeType(detectedMimeType)
	}

	if md5Hash, exists := m.Md5Hash(); exists {
		create = create.SetMd5Hash(md5Hash)
	}

	if detectedContentType, exists := m.DetectedContentType(); exists {
		create = create.SetDetectedContentType(detectedContentType)
	}

	if storeKey, exists := m.StoreKey(); exists {
		create = create.SetStoreKey(storeKey)
	}

	if categoryType, exists := m.CategoryType(); exists {
		create = create.SetCategoryType(categoryType)
	}

	if uri, exists := m.URI(); exists {
		create = create.SetURI(uri)
	}

	if storageScheme, exists := m.StorageScheme(); exists {
		create = create.SetStorageScheme(storageScheme)
	}

	if storageVolume, exists := m.StorageVolume(); exists {
		create = create.SetStorageVolume(storageVolume)
	}

	if storagePath, exists := m.StoragePath(); exists {
		create = create.SetStoragePath(storagePath)
	}

	if fileContents, exists := m.FileContents(); exists {
		create = create.SetFileContents(fileContents)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	if storageRegion, exists := m.StorageRegion(); exists {
		create = create.SetStorageRegion(storageRegion)
	}

	if storageProvider, exists := m.StorageProvider(); exists {
		create = create.SetStorageProvider(storageProvider)
	}

	if lastAccessedAt, exists := m.LastAccessedAt(); exists {
		create = create.SetNillableLastAccessedAt(&lastAccessedAt)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *FileMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		file, err := client.File.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.FileHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(file.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(file.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(file.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(file.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(file.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(file.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(file.Tags)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(file.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(file.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(file.SystemInternalID)
		}

		if providedFileName, exists := m.ProvidedFileName(); exists {
			create = create.SetProvidedFileName(providedFileName)
		} else {
			create = create.SetProvidedFileName(file.ProvidedFileName)
		}

		if providedFileExtension, exists := m.ProvidedFileExtension(); exists {
			create = create.SetProvidedFileExtension(providedFileExtension)
		} else {
			create = create.SetProvidedFileExtension(file.ProvidedFileExtension)
		}

		if providedFileSize, exists := m.ProvidedFileSize(); exists {
			create = create.SetProvidedFileSize(providedFileSize)
		} else {
			create = create.SetProvidedFileSize(file.ProvidedFileSize)
		}

		if persistedFileSize, exists := m.PersistedFileSize(); exists {
			create = create.SetPersistedFileSize(persistedFileSize)
		} else {
			create = create.SetPersistedFileSize(file.PersistedFileSize)
		}

		if detectedMimeType, exists := m.DetectedMimeType(); exists {
			create = create.SetDetectedMimeType(detectedMimeType)
		} else {
			create = create.SetDetectedMimeType(file.DetectedMimeType)
		}

		if md5Hash, exists := m.Md5Hash(); exists {
			create = create.SetMd5Hash(md5Hash)
		} else {
			create = create.SetMd5Hash(file.Md5Hash)
		}

		if detectedContentType, exists := m.DetectedContentType(); exists {
			create = create.SetDetectedContentType(detectedContentType)
		} else {
			create = create.SetDetectedContentType(file.DetectedContentType)
		}

		if storeKey, exists := m.StoreKey(); exists {
			create = create.SetStoreKey(storeKey)
		} else {
			create = create.SetStoreKey(file.StoreKey)
		}

		if categoryType, exists := m.CategoryType(); exists {
			create = create.SetCategoryType(categoryType)
		} else {
			create = create.SetCategoryType(file.CategoryType)
		}

		if uri, exists := m.URI(); exists {
			create = create.SetURI(uri)
		} else {
			create = create.SetURI(file.URI)
		}

		if storageScheme, exists := m.StorageScheme(); exists {
			create = create.SetStorageScheme(storageScheme)
		} else {
			create = create.SetStorageScheme(file.StorageScheme)
		}

		if storageVolume, exists := m.StorageVolume(); exists {
			create = create.SetStorageVolume(storageVolume)
		} else {
			create = create.SetStorageVolume(file.StorageVolume)
		}

		if storagePath, exists := m.StoragePath(); exists {
			create = create.SetStoragePath(storagePath)
		} else {
			create = create.SetStoragePath(file.StoragePath)
		}

		if fileContents, exists := m.FileContents(); exists {
			create = create.SetFileContents(fileContents)
		} else {
			create = create.SetFileContents(file.FileContents)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(file.Metadata)
		}

		if storageRegion, exists := m.StorageRegion(); exists {
			create = create.SetStorageRegion(storageRegion)
		} else {
			create = create.SetStorageRegion(file.StorageRegion)
		}

		if storageProvider, exists := m.StorageProvider(); exists {
			create = create.SetStorageProvider(storageProvider)
		} else {
			create = create.SetStorageProvider(file.StorageProvider)
		}

		if lastAccessedAt, exists := m.LastAccessedAt(); exists {
			create = create.SetNillableLastAccessedAt(&lastAccessedAt)
		} else {
			create = create.SetNillableLastAccessedAt(file.LastAccessedAt)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *FileMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		file, err := client.File.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.FileHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(file.CreatedAt).
			SetUpdatedAt(file.UpdatedAt).
			SetCreatedBy(file.CreatedBy).
			SetUpdatedBy(file.UpdatedBy).
			SetDeletedAt(file.DeletedAt).
			SetDeletedBy(file.DeletedBy).
			SetTags(file.Tags).
			SetSystemOwned(file.SystemOwned).
			SetNillableInternalNotes(file.InternalNotes).
			SetNillableSystemInternalID(file.SystemInternalID).
			SetProvidedFileName(file.ProvidedFileName).
			SetProvidedFileExtension(file.ProvidedFileExtension).
			SetProvidedFileSize(file.ProvidedFileSize).
			SetPersistedFileSize(file.PersistedFileSize).
			SetDetectedMimeType(file.DetectedMimeType).
			SetMd5Hash(file.Md5Hash).
			SetDetectedContentType(file.DetectedContentType).
			SetStoreKey(file.StoreKey).
			SetCategoryType(file.CategoryType).
			SetURI(file.URI).
			SetStorageScheme(file.StorageScheme).
			SetStorageVolume(file.StorageVolume).
			SetStoragePath(file.StoragePath).
			SetFileContents(file.FileContents).
			SetMetadata(file.Metadata).
			SetStorageRegion(file.StorageRegion).
			SetStorageProvider(file.StorageProvider).
			SetNillableLastAccessedAt(file.LastAccessedAt).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *FindingMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.FindingHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if externalID, exists := m.ExternalID(); exists {
		create = create.SetExternalID(externalID)
	}

	if externalOwnerID, exists := m.ExternalOwnerID(); exists {
		create = create.SetExternalOwnerID(externalOwnerID)
	}

	if source, exists := m.Source(); exists {
		create = create.SetSource(source)
	}

	if resourceName, exists := m.ResourceName(); exists {
		create = create.SetResourceName(resourceName)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if state, exists := m.State(); exists {
		create = create.SetState(state)
	}

	if category, exists := m.Category(); exists {
		create = create.SetCategory(category)
	}

	if categories, exists := m.Categories(); exists {
		create = create.SetCategories(categories)
	}

	if findingClass, exists := m.FindingClass(); exists {
		create = create.SetFindingClass(findingClass)
	}

	if severity, exists := m.Severity(); exists {
		create = create.SetSeverity(severity)
	}

	if numericSeverity, exists := m.NumericSeverity(); exists {
		create = create.SetNumericSeverity(numericSeverity)
	}

	if score, exists := m.Score(); exists {
		create = create.SetScore(score)
	}

	if impact, exists := m.Impact(); exists {
		create = create.SetImpact(impact)
	}

	if exploitability, exists := m.Exploitability(); exists {
		create = create.SetExploitability(exploitability)
	}

	if priority, exists := m.Priority(); exists {
		create = create.SetPriority(priority)
	}

	if open, exists := m.Open(); exists {
		create = create.SetOpen(open)
	}

	if blocksProduction, exists := m.BlocksProduction(); exists {
		create = create.SetBlocksProduction(blocksProduction)
	}

	if production, exists := m.Production(); exists {
		create = create.SetProduction(production)
	}

	if public, exists := m.Public(); exists {
		create = create.SetPublic(public)
	}

	if validated, exists := m.Validated(); exists {
		create = create.SetValidated(validated)
	}

	if assessmentID, exists := m.AssessmentID(); exists {
		create = create.SetAssessmentID(assessmentID)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if recommendation, exists := m.Recommendation(); exists {
		create = create.SetRecommendation(recommendation)
	}

	if recommendedActions, exists := m.RecommendedActions(); exists {
		create = create.SetRecommendedActions(recommendedActions)
	}

	if references, exists := m.References(); exists {
		create = create.SetReferences(references)
	}

	if stepsToReproduce, exists := m.StepsToReproduce(); exists {
		create = create.SetStepsToReproduce(stepsToReproduce)
	}

	if targets, exists := m.Targets(); exists {
		create = create.SetTargets(targets)
	}

	if targetDetails, exists := m.TargetDetails(); exists {
		create = create.SetTargetDetails(targetDetails)
	}

	if vector, exists := m.Vector(); exists {
		create = create.SetVector(vector)
	}

	if remediationSLA, exists := m.RemediationSLA(); exists {
		create = create.SetRemediationSLA(remediationSLA)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if eventTime, exists := m.EventTime(); exists {
		create = create.SetNillableEventTime(&eventTime)
	}

	if reportedAt, exists := m.ReportedAt(); exists {
		create = create.SetNillableReportedAt(&reportedAt)
	}

	if sourceUpdatedAt, exists := m.SourceUpdatedAt(); exists {
		create = create.SetNillableSourceUpdatedAt(&sourceUpdatedAt)
	}

	if externalURI, exists := m.ExternalURI(); exists {
		create = create.SetExternalURI(externalURI)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	if rawPayload, exists := m.RawPayload(); exists {
		create = create.SetRawPayload(rawPayload)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *FindingMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		finding, err := client.Finding.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.FindingHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(finding.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(finding.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(finding.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(finding.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(finding.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(finding.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(finding.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(finding.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(finding.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(finding.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(finding.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(finding.SystemInternalID)
		}

		if externalID, exists := m.ExternalID(); exists {
			create = create.SetExternalID(externalID)
		} else {
			create = create.SetExternalID(finding.ExternalID)
		}

		if externalOwnerID, exists := m.ExternalOwnerID(); exists {
			create = create.SetExternalOwnerID(externalOwnerID)
		} else {
			create = create.SetExternalOwnerID(finding.ExternalOwnerID)
		}

		if source, exists := m.Source(); exists {
			create = create.SetSource(source)
		} else {
			create = create.SetSource(finding.Source)
		}

		if resourceName, exists := m.ResourceName(); exists {
			create = create.SetResourceName(resourceName)
		} else {
			create = create.SetResourceName(finding.ResourceName)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(finding.DisplayName)
		}

		if state, exists := m.State(); exists {
			create = create.SetState(state)
		} else {
			create = create.SetState(finding.State)
		}

		if category, exists := m.Category(); exists {
			create = create.SetCategory(category)
		} else {
			create = create.SetCategory(finding.Category)
		}

		if categories, exists := m.Categories(); exists {
			create = create.SetCategories(categories)
		} else {
			create = create.SetCategories(finding.Categories)
		}

		if findingClass, exists := m.FindingClass(); exists {
			create = create.SetFindingClass(findingClass)
		} else {
			create = create.SetFindingClass(finding.FindingClass)
		}

		if severity, exists := m.Severity(); exists {
			create = create.SetSeverity(severity)
		} else {
			create = create.SetSeverity(finding.Severity)
		}

		if numericSeverity, exists := m.NumericSeverity(); exists {
			create = create.SetNumericSeverity(numericSeverity)
		} else {
			create = create.SetNumericSeverity(finding.NumericSeverity)
		}

		if score, exists := m.Score(); exists {
			create = create.SetScore(score)
		} else {
			create = create.SetScore(finding.Score)
		}

		if impact, exists := m.Impact(); exists {
			create = create.SetImpact(impact)
		} else {
			create = create.SetImpact(finding.Impact)
		}

		if exploitability, exists := m.Exploitability(); exists {
			create = create.SetExploitability(exploitability)
		} else {
			create = create.SetExploitability(finding.Exploitability)
		}

		if priority, exists := m.Priority(); exists {
			create = create.SetPriority(priority)
		} else {
			create = create.SetPriority(finding.Priority)
		}

		if open, exists := m.Open(); exists {
			create = create.SetOpen(open)
		} else {
			create = create.SetOpen(finding.Open)
		}

		if blocksProduction, exists := m.BlocksProduction(); exists {
			create = create.SetBlocksProduction(blocksProduction)
		} else {
			create = create.SetBlocksProduction(finding.BlocksProduction)
		}

		if production, exists := m.Production(); exists {
			create = create.SetProduction(production)
		} else {
			create = create.SetProduction(finding.Production)
		}

		if public, exists := m.Public(); exists {
			create = create.SetPublic(public)
		} else {
			create = create.SetPublic(finding.Public)
		}

		if validated, exists := m.Validated(); exists {
			create = create.SetValidated(validated)
		} else {
			create = create.SetValidated(finding.Validated)
		}

		if assessmentID, exists := m.AssessmentID(); exists {
			create = create.SetAssessmentID(assessmentID)
		} else {
			create = create.SetAssessmentID(finding.AssessmentID)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(finding.Description)
		}

		if recommendation, exists := m.Recommendation(); exists {
			create = create.SetRecommendation(recommendation)
		} else {
			create = create.SetRecommendation(finding.Recommendation)
		}

		if recommendedActions, exists := m.RecommendedActions(); exists {
			create = create.SetRecommendedActions(recommendedActions)
		} else {
			create = create.SetRecommendedActions(finding.RecommendedActions)
		}

		if references, exists := m.References(); exists {
			create = create.SetReferences(references)
		} else {
			create = create.SetReferences(finding.References)
		}

		if stepsToReproduce, exists := m.StepsToReproduce(); exists {
			create = create.SetStepsToReproduce(stepsToReproduce)
		} else {
			create = create.SetStepsToReproduce(finding.StepsToReproduce)
		}

		if targets, exists := m.Targets(); exists {
			create = create.SetTargets(targets)
		} else {
			create = create.SetTargets(finding.Targets)
		}

		if targetDetails, exists := m.TargetDetails(); exists {
			create = create.SetTargetDetails(targetDetails)
		} else {
			create = create.SetTargetDetails(finding.TargetDetails)
		}

		if vector, exists := m.Vector(); exists {
			create = create.SetVector(vector)
		} else {
			create = create.SetVector(finding.Vector)
		}

		if remediationSLA, exists := m.RemediationSLA(); exists {
			create = create.SetRemediationSLA(remediationSLA)
		} else {
			create = create.SetRemediationSLA(finding.RemediationSLA)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(finding.Status)
		}

		if eventTime, exists := m.EventTime(); exists {
			create = create.SetNillableEventTime(&eventTime)
		} else {
			create = create.SetNillableEventTime(finding.EventTime)
		}

		if reportedAt, exists := m.ReportedAt(); exists {
			create = create.SetNillableReportedAt(&reportedAt)
		} else {
			create = create.SetNillableReportedAt(finding.ReportedAt)
		}

		if sourceUpdatedAt, exists := m.SourceUpdatedAt(); exists {
			create = create.SetNillableSourceUpdatedAt(&sourceUpdatedAt)
		} else {
			create = create.SetNillableSourceUpdatedAt(finding.SourceUpdatedAt)
		}

		if externalURI, exists := m.ExternalURI(); exists {
			create = create.SetExternalURI(externalURI)
		} else {
			create = create.SetExternalURI(finding.ExternalURI)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(finding.Metadata)
		}

		if rawPayload, exists := m.RawPayload(); exists {
			create = create.SetRawPayload(rawPayload)
		} else {
			create = create.SetRawPayload(finding.RawPayload)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *FindingMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		finding, err := client.Finding.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.FindingHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(finding.CreatedAt).
			SetUpdatedAt(finding.UpdatedAt).
			SetCreatedBy(finding.CreatedBy).
			SetUpdatedBy(finding.UpdatedBy).
			SetDeletedAt(finding.DeletedAt).
			SetDeletedBy(finding.DeletedBy).
			SetDisplayID(finding.DisplayID).
			SetTags(finding.Tags).
			SetOwnerID(finding.OwnerID).
			SetSystemOwned(finding.SystemOwned).
			SetNillableInternalNotes(finding.InternalNotes).
			SetNillableSystemInternalID(finding.SystemInternalID).
			SetExternalID(finding.ExternalID).
			SetExternalOwnerID(finding.ExternalOwnerID).
			SetSource(finding.Source).
			SetResourceName(finding.ResourceName).
			SetDisplayName(finding.DisplayName).
			SetState(finding.State).
			SetCategory(finding.Category).
			SetCategories(finding.Categories).
			SetFindingClass(finding.FindingClass).
			SetSeverity(finding.Severity).
			SetNumericSeverity(finding.NumericSeverity).
			SetScore(finding.Score).
			SetImpact(finding.Impact).
			SetExploitability(finding.Exploitability).
			SetPriority(finding.Priority).
			SetOpen(finding.Open).
			SetBlocksProduction(finding.BlocksProduction).
			SetProduction(finding.Production).
			SetPublic(finding.Public).
			SetValidated(finding.Validated).
			SetAssessmentID(finding.AssessmentID).
			SetDescription(finding.Description).
			SetRecommendation(finding.Recommendation).
			SetRecommendedActions(finding.RecommendedActions).
			SetReferences(finding.References).
			SetStepsToReproduce(finding.StepsToReproduce).
			SetTargets(finding.Targets).
			SetTargetDetails(finding.TargetDetails).
			SetVector(finding.Vector).
			SetRemediationSLA(finding.RemediationSLA).
			SetStatus(finding.Status).
			SetNillableEventTime(finding.EventTime).
			SetNillableReportedAt(finding.ReportedAt).
			SetNillableSourceUpdatedAt(finding.SourceUpdatedAt).
			SetExternalURI(finding.ExternalURI).
			SetMetadata(finding.Metadata).
			SetRawPayload(finding.RawPayload).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *FindingControlMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.FindingControlHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if findingID, exists := m.FindingID(); exists {
		create = create.SetFindingID(findingID)
	}

	if controlID, exists := m.ControlID(); exists {
		create = create.SetControlID(controlID)
	}

	if standardID, exists := m.StandardID(); exists {
		create = create.SetStandardID(standardID)
	}

	if externalStandard, exists := m.ExternalStandard(); exists {
		create = create.SetExternalStandard(externalStandard)
	}

	if externalStandardVersion, exists := m.ExternalStandardVersion(); exists {
		create = create.SetExternalStandardVersion(externalStandardVersion)
	}

	if externalControlID, exists := m.ExternalControlID(); exists {
		create = create.SetExternalControlID(externalControlID)
	}

	if source, exists := m.Source(); exists {
		create = create.SetSource(source)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	if discoveredAt, exists := m.DiscoveredAt(); exists {
		create = create.SetNillableDiscoveredAt(&discoveredAt)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *FindingControlMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		findingcontrol, err := client.FindingControl.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.FindingControlHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(findingcontrol.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(findingcontrol.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(findingcontrol.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(findingcontrol.UpdatedBy)
		}

		if findingID, exists := m.FindingID(); exists {
			create = create.SetFindingID(findingID)
		} else {
			create = create.SetFindingID(findingcontrol.FindingID)
		}

		if controlID, exists := m.ControlID(); exists {
			create = create.SetControlID(controlID)
		} else {
			create = create.SetControlID(findingcontrol.ControlID)
		}

		if standardID, exists := m.StandardID(); exists {
			create = create.SetStandardID(standardID)
		} else {
			create = create.SetStandardID(findingcontrol.StandardID)
		}

		if externalStandard, exists := m.ExternalStandard(); exists {
			create = create.SetExternalStandard(externalStandard)
		} else {
			create = create.SetExternalStandard(findingcontrol.ExternalStandard)
		}

		if externalStandardVersion, exists := m.ExternalStandardVersion(); exists {
			create = create.SetExternalStandardVersion(externalStandardVersion)
		} else {
			create = create.SetExternalStandardVersion(findingcontrol.ExternalStandardVersion)
		}

		if externalControlID, exists := m.ExternalControlID(); exists {
			create = create.SetExternalControlID(externalControlID)
		} else {
			create = create.SetExternalControlID(findingcontrol.ExternalControlID)
		}

		if source, exists := m.Source(); exists {
			create = create.SetSource(source)
		} else {
			create = create.SetSource(findingcontrol.Source)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(findingcontrol.Metadata)
		}

		if discoveredAt, exists := m.DiscoveredAt(); exists {
			create = create.SetNillableDiscoveredAt(&discoveredAt)
		} else {
			create = create.SetNillableDiscoveredAt(findingcontrol.DiscoveredAt)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *FindingControlMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		findingcontrol, err := client.FindingControl.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.FindingControlHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(findingcontrol.CreatedAt).
			SetUpdatedAt(findingcontrol.UpdatedAt).
			SetCreatedBy(findingcontrol.CreatedBy).
			SetUpdatedBy(findingcontrol.UpdatedBy).
			SetFindingID(findingcontrol.FindingID).
			SetControlID(findingcontrol.ControlID).
			SetStandardID(findingcontrol.StandardID).
			SetExternalStandard(findingcontrol.ExternalStandard).
			SetExternalStandardVersion(findingcontrol.ExternalStandardVersion).
			SetExternalControlID(findingcontrol.ExternalControlID).
			SetSource(findingcontrol.Source).
			SetMetadata(findingcontrol.Metadata).
			SetNillableDiscoveredAt(findingcontrol.DiscoveredAt).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.GroupHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if isManaged, exists := m.IsManaged(); exists {
		create = create.SetIsManaged(isManaged)
	}

	if gravatarLogoURL, exists := m.GravatarLogoURL(); exists {
		create = create.SetGravatarLogoURL(gravatarLogoURL)
	}

	if logoURL, exists := m.LogoURL(); exists {
		create = create.SetLogoURL(logoURL)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if scimExternalID, exists := m.ScimExternalID(); exists {
		create = create.SetNillableScimExternalID(&scimExternalID)
	}

	if scimDisplayName, exists := m.ScimDisplayName(); exists {
		create = create.SetNillableScimDisplayName(&scimDisplayName)
	}

	if scimActive, exists := m.ScimActive(); exists {
		create = create.SetScimActive(scimActive)
	}

	if scimGroupMailing, exists := m.ScimGroupMailing(); exists {
		create = create.SetNillableScimGroupMailing(&scimGroupMailing)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *GroupMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		group, err := client.Group.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(group.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(group.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(group.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(group.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(group.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(group.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(group.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(group.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(group.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(group.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(group.Description)
		}

		if isManaged, exists := m.IsManaged(); exists {
			create = create.SetIsManaged(isManaged)
		} else {
			create = create.SetIsManaged(group.IsManaged)
		}

		if gravatarLogoURL, exists := m.GravatarLogoURL(); exists {
			create = create.SetGravatarLogoURL(gravatarLogoURL)
		} else {
			create = create.SetGravatarLogoURL(group.GravatarLogoURL)
		}

		if logoURL, exists := m.LogoURL(); exists {
			create = create.SetLogoURL(logoURL)
		} else {
			create = create.SetLogoURL(group.LogoURL)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(group.DisplayName)
		}

		if scimExternalID, exists := m.ScimExternalID(); exists {
			create = create.SetNillableScimExternalID(&scimExternalID)
		} else {
			create = create.SetNillableScimExternalID(group.ScimExternalID)
		}

		if scimDisplayName, exists := m.ScimDisplayName(); exists {
			create = create.SetNillableScimDisplayName(&scimDisplayName)
		} else {
			create = create.SetNillableScimDisplayName(group.ScimDisplayName)
		}

		if scimActive, exists := m.ScimActive(); exists {
			create = create.SetScimActive(scimActive)
		} else {
			create = create.SetScimActive(group.ScimActive)
		}

		if scimGroupMailing, exists := m.ScimGroupMailing(); exists {
			create = create.SetNillableScimGroupMailing(&scimGroupMailing)
		} else {
			create = create.SetNillableScimGroupMailing(group.ScimGroupMailing)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		group, err := client.Group.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(group.CreatedAt).
			SetUpdatedAt(group.UpdatedAt).
			SetCreatedBy(group.CreatedBy).
			SetUpdatedBy(group.UpdatedBy).
			SetDeletedAt(group.DeletedAt).
			SetDeletedBy(group.DeletedBy).
			SetDisplayID(group.DisplayID).
			SetTags(group.Tags).
			SetOwnerID(group.OwnerID).
			SetName(group.Name).
			SetDescription(group.Description).
			SetIsManaged(group.IsManaged).
			SetGravatarLogoURL(group.GravatarLogoURL).
			SetLogoURL(group.LogoURL).
			SetDisplayName(group.DisplayName).
			SetNillableScimExternalID(group.ScimExternalID).
			SetNillableScimDisplayName(group.ScimDisplayName).
			SetScimActive(group.ScimActive).
			SetNillableScimGroupMailing(group.ScimGroupMailing).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupMembershipMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.GroupMembershipHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	}

	if groupID, exists := m.GroupID(); exists {
		create = create.SetGroupID(groupID)
	}

	if userID, exists := m.UserID(); exists {
		create = create.SetUserID(userID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *GroupMembershipMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		groupmembership, err := client.GroupMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupMembershipHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(groupmembership.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(groupmembership.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(groupmembership.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(groupmembership.UpdatedBy)
		}

		if role, exists := m.Role(); exists {
			create = create.SetRole(role)
		} else {
			create = create.SetRole(groupmembership.Role)
		}

		if groupID, exists := m.GroupID(); exists {
			create = create.SetGroupID(groupID)
		} else {
			create = create.SetGroupID(groupmembership.GroupID)
		}

		if userID, exists := m.UserID(); exists {
			create = create.SetUserID(userID)
		} else {
			create = create.SetUserID(groupmembership.UserID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupMembershipMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		groupmembership, err := client.GroupMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupMembershipHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(groupmembership.CreatedAt).
			SetUpdatedAt(groupmembership.UpdatedAt).
			SetCreatedBy(groupmembership.CreatedBy).
			SetUpdatedBy(groupmembership.UpdatedBy).
			SetRole(groupmembership.Role).
			SetGroupID(groupmembership.GroupID).
			SetUserID(groupmembership.UserID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupSettingMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.GroupSettingHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if visibility, exists := m.Visibility(); exists {
		create = create.SetVisibility(visibility)
	}

	if joinPolicy, exists := m.JoinPolicy(); exists {
		create = create.SetJoinPolicy(joinPolicy)
	}

	if syncToSlack, exists := m.SyncToSlack(); exists {
		create = create.SetSyncToSlack(syncToSlack)
	}

	if syncToGithub, exists := m.SyncToGithub(); exists {
		create = create.SetSyncToGithub(syncToGithub)
	}

	if groupID, exists := m.GroupID(); exists {
		create = create.SetGroupID(groupID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *GroupSettingMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		groupsetting, err := client.GroupSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupSettingHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(groupsetting.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(groupsetting.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(groupsetting.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(groupsetting.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(groupsetting.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(groupsetting.DeletedBy)
		}

		if visibility, exists := m.Visibility(); exists {
			create = create.SetVisibility(visibility)
		} else {
			create = create.SetVisibility(groupsetting.Visibility)
		}

		if joinPolicy, exists := m.JoinPolicy(); exists {
			create = create.SetJoinPolicy(joinPolicy)
		} else {
			create = create.SetJoinPolicy(groupsetting.JoinPolicy)
		}

		if syncToSlack, exists := m.SyncToSlack(); exists {
			create = create.SetSyncToSlack(syncToSlack)
		} else {
			create = create.SetSyncToSlack(groupsetting.SyncToSlack)
		}

		if syncToGithub, exists := m.SyncToGithub(); exists {
			create = create.SetSyncToGithub(syncToGithub)
		} else {
			create = create.SetSyncToGithub(groupsetting.SyncToGithub)
		}

		if groupID, exists := m.GroupID(); exists {
			create = create.SetGroupID(groupID)
		} else {
			create = create.SetGroupID(groupsetting.GroupID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *GroupSettingMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		groupsetting, err := client.GroupSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.GroupSettingHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(groupsetting.CreatedAt).
			SetUpdatedAt(groupsetting.UpdatedAt).
			SetCreatedBy(groupsetting.CreatedBy).
			SetUpdatedBy(groupsetting.UpdatedBy).
			SetDeletedAt(groupsetting.DeletedAt).
			SetDeletedBy(groupsetting.DeletedBy).
			SetVisibility(groupsetting.Visibility).
			SetJoinPolicy(groupsetting.JoinPolicy).
			SetSyncToSlack(groupsetting.SyncToSlack).
			SetSyncToGithub(groupsetting.SyncToGithub).
			SetGroupID(groupsetting.GroupID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *HushMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.HushHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if kind, exists := m.Kind(); exists {
		create = create.SetKind(kind)
	}

	if secretName, exists := m.SecretName(); exists {
		create = create.SetSecretName(secretName)
	}

	if secretValue, exists := m.SecretValue(); exists {
		create = create.SetSecretValue(secretValue)
	}

	if credentialSet, exists := m.CredentialSet(); exists {
		create = create.SetCredentialSet(credentialSet)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	if lastUsedAt, exists := m.LastUsedAt(); exists {
		create = create.SetNillableLastUsedAt(&lastUsedAt)
	}

	if expiresAt, exists := m.ExpiresAt(); exists {
		create = create.SetNillableExpiresAt(&expiresAt)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *HushMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		hush, err := client.Hush.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.HushHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(hush.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(hush.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(hush.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(hush.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(hush.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(hush.DeletedBy)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(hush.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(hush.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(hush.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(hush.SystemInternalID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(hush.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(hush.Description)
		}

		if kind, exists := m.Kind(); exists {
			create = create.SetKind(kind)
		} else {
			create = create.SetKind(hush.Kind)
		}

		if secretName, exists := m.SecretName(); exists {
			create = create.SetSecretName(secretName)
		} else {
			create = create.SetSecretName(hush.SecretName)
		}

		if secretValue, exists := m.SecretValue(); exists {
			create = create.SetSecretValue(secretValue)
		} else {
			create = create.SetSecretValue(hush.SecretValue)
		}

		if credentialSet, exists := m.CredentialSet(); exists {
			create = create.SetCredentialSet(credentialSet)
		} else {
			create = create.SetCredentialSet(hush.CredentialSet)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(hush.Metadata)
		}

		if lastUsedAt, exists := m.LastUsedAt(); exists {
			create = create.SetNillableLastUsedAt(&lastUsedAt)
		} else {
			create = create.SetNillableLastUsedAt(hush.LastUsedAt)
		}

		if expiresAt, exists := m.ExpiresAt(); exists {
			create = create.SetNillableExpiresAt(&expiresAt)
		} else {
			create = create.SetNillableExpiresAt(hush.ExpiresAt)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *HushMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		hush, err := client.Hush.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.HushHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(hush.CreatedAt).
			SetUpdatedAt(hush.UpdatedAt).
			SetCreatedBy(hush.CreatedBy).
			SetUpdatedBy(hush.UpdatedBy).
			SetDeletedAt(hush.DeletedAt).
			SetDeletedBy(hush.DeletedBy).
			SetOwnerID(hush.OwnerID).
			SetSystemOwned(hush.SystemOwned).
			SetNillableInternalNotes(hush.InternalNotes).
			SetNillableSystemInternalID(hush.SystemInternalID).
			SetName(hush.Name).
			SetDescription(hush.Description).
			SetKind(hush.Kind).
			SetSecretName(hush.SecretName).
			SetSecretValue(hush.SecretValue).
			SetCredentialSet(hush.CredentialSet).
			SetMetadata(hush.Metadata).
			SetNillableLastUsedAt(hush.LastUsedAt).
			SetNillableExpiresAt(hush.ExpiresAt).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *IntegrationMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.IntegrationHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if kind, exists := m.Kind(); exists {
		create = create.SetKind(kind)
	}

	if integrationType, exists := m.IntegrationType(); exists {
		create = create.SetIntegrationType(integrationType)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *IntegrationMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		integration, err := client.Integration.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.IntegrationHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(integration.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(integration.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(integration.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(integration.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(integration.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(integration.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(integration.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(integration.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(integration.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(integration.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(integration.SystemInternalID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(integration.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(integration.Description)
		}

		if kind, exists := m.Kind(); exists {
			create = create.SetKind(kind)
		} else {
			create = create.SetKind(integration.Kind)
		}

		if integrationType, exists := m.IntegrationType(); exists {
			create = create.SetIntegrationType(integrationType)
		} else {
			create = create.SetIntegrationType(integration.IntegrationType)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(integration.Metadata)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *IntegrationMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		integration, err := client.Integration.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.IntegrationHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(integration.CreatedAt).
			SetUpdatedAt(integration.UpdatedAt).
			SetCreatedBy(integration.CreatedBy).
			SetUpdatedBy(integration.UpdatedBy).
			SetDeletedAt(integration.DeletedAt).
			SetDeletedBy(integration.DeletedBy).
			SetTags(integration.Tags).
			SetOwnerID(integration.OwnerID).
			SetSystemOwned(integration.SystemOwned).
			SetNillableInternalNotes(integration.InternalNotes).
			SetNillableSystemInternalID(integration.SystemInternalID).
			SetName(integration.Name).
			SetDescription(integration.Description).
			SetKind(integration.Kind).
			SetIntegrationType(integration.IntegrationType).
			SetMetadata(integration.Metadata).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *InternalPolicyMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.InternalPolicyHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if revision, exists := m.Revision(); exists {
		create = create.SetRevision(revision)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if policyType, exists := m.PolicyType(); exists {
		create = create.SetPolicyType(policyType)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	if approvalRequired, exists := m.ApprovalRequired(); exists {
		create = create.SetApprovalRequired(approvalRequired)
	}

	if reviewDue, exists := m.ReviewDue(); exists {
		create = create.SetReviewDue(reviewDue)
	}

	if reviewFrequency, exists := m.ReviewFrequency(); exists {
		create = create.SetReviewFrequency(reviewFrequency)
	}

	if approverID, exists := m.ApproverID(); exists {
		create = create.SetApproverID(approverID)
	}

	if delegateID, exists := m.DelegateID(); exists {
		create = create.SetDelegateID(delegateID)
	}

	if summary, exists := m.Summary(); exists {
		create = create.SetSummary(summary)
	}

	if tagSuggestions, exists := m.TagSuggestions(); exists {
		create = create.SetTagSuggestions(tagSuggestions)
	}

	if dismissedTagSuggestions, exists := m.DismissedTagSuggestions(); exists {
		create = create.SetDismissedTagSuggestions(dismissedTagSuggestions)
	}

	if controlSuggestions, exists := m.ControlSuggestions(); exists {
		create = create.SetControlSuggestions(controlSuggestions)
	}

	if dismissedControlSuggestions, exists := m.DismissedControlSuggestions(); exists {
		create = create.SetDismissedControlSuggestions(dismissedControlSuggestions)
	}

	if improvementSuggestions, exists := m.ImprovementSuggestions(); exists {
		create = create.SetImprovementSuggestions(improvementSuggestions)
	}

	if dismissedImprovementSuggestions, exists := m.DismissedImprovementSuggestions(); exists {
		create = create.SetDismissedImprovementSuggestions(dismissedImprovementSuggestions)
	}

	if url, exists := m.URL(); exists {
		create = create.SetNillableURL(&url)
	}

	if fileID, exists := m.FileID(); exists {
		create = create.SetNillableFileID(&fileID)
	}

	if internalPolicyKindName, exists := m.InternalPolicyKindName(); exists {
		create = create.SetInternalPolicyKindName(internalPolicyKindName)
	}

	if internalPolicyKindID, exists := m.InternalPolicyKindID(); exists {
		create = create.SetInternalPolicyKindID(internalPolicyKindID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *InternalPolicyMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		internalpolicy, err := client.InternalPolicy.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.InternalPolicyHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(internalpolicy.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(internalpolicy.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(internalpolicy.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(internalpolicy.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(internalpolicy.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(internalpolicy.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(internalpolicy.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(internalpolicy.Tags)
		}

		if revision, exists := m.Revision(); exists {
			create = create.SetRevision(revision)
		} else {
			create = create.SetRevision(internalpolicy.Revision)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(internalpolicy.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(internalpolicy.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(internalpolicy.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(internalpolicy.SystemInternalID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(internalpolicy.Name)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(internalpolicy.Status)
		}

		if policyType, exists := m.PolicyType(); exists {
			create = create.SetPolicyType(policyType)
		} else {
			create = create.SetPolicyType(internalpolicy.PolicyType)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(internalpolicy.Details)
		}

		if approvalRequired, exists := m.ApprovalRequired(); exists {
			create = create.SetApprovalRequired(approvalRequired)
		} else {
			create = create.SetApprovalRequired(internalpolicy.ApprovalRequired)
		}

		if reviewDue, exists := m.ReviewDue(); exists {
			create = create.SetReviewDue(reviewDue)
		} else {
			create = create.SetReviewDue(internalpolicy.ReviewDue)
		}

		if reviewFrequency, exists := m.ReviewFrequency(); exists {
			create = create.SetReviewFrequency(reviewFrequency)
		} else {
			create = create.SetReviewFrequency(internalpolicy.ReviewFrequency)
		}

		if approverID, exists := m.ApproverID(); exists {
			create = create.SetApproverID(approverID)
		} else {
			create = create.SetApproverID(internalpolicy.ApproverID)
		}

		if delegateID, exists := m.DelegateID(); exists {
			create = create.SetDelegateID(delegateID)
		} else {
			create = create.SetDelegateID(internalpolicy.DelegateID)
		}

		if summary, exists := m.Summary(); exists {
			create = create.SetSummary(summary)
		} else {
			create = create.SetSummary(internalpolicy.Summary)
		}

		if tagSuggestions, exists := m.TagSuggestions(); exists {
			create = create.SetTagSuggestions(tagSuggestions)
		} else {
			create = create.SetTagSuggestions(internalpolicy.TagSuggestions)
		}

		if dismissedTagSuggestions, exists := m.DismissedTagSuggestions(); exists {
			create = create.SetDismissedTagSuggestions(dismissedTagSuggestions)
		} else {
			create = create.SetDismissedTagSuggestions(internalpolicy.DismissedTagSuggestions)
		}

		if controlSuggestions, exists := m.ControlSuggestions(); exists {
			create = create.SetControlSuggestions(controlSuggestions)
		} else {
			create = create.SetControlSuggestions(internalpolicy.ControlSuggestions)
		}

		if dismissedControlSuggestions, exists := m.DismissedControlSuggestions(); exists {
			create = create.SetDismissedControlSuggestions(dismissedControlSuggestions)
		} else {
			create = create.SetDismissedControlSuggestions(internalpolicy.DismissedControlSuggestions)
		}

		if improvementSuggestions, exists := m.ImprovementSuggestions(); exists {
			create = create.SetImprovementSuggestions(improvementSuggestions)
		} else {
			create = create.SetImprovementSuggestions(internalpolicy.ImprovementSuggestions)
		}

		if dismissedImprovementSuggestions, exists := m.DismissedImprovementSuggestions(); exists {
			create = create.SetDismissedImprovementSuggestions(dismissedImprovementSuggestions)
		} else {
			create = create.SetDismissedImprovementSuggestions(internalpolicy.DismissedImprovementSuggestions)
		}

		if url, exists := m.URL(); exists {
			create = create.SetNillableURL(&url)
		} else {
			create = create.SetNillableURL(internalpolicy.URL)
		}

		if fileID, exists := m.FileID(); exists {
			create = create.SetNillableFileID(&fileID)
		} else {
			create = create.SetNillableFileID(internalpolicy.FileID)
		}

		if internalPolicyKindName, exists := m.InternalPolicyKindName(); exists {
			create = create.SetInternalPolicyKindName(internalPolicyKindName)
		} else {
			create = create.SetInternalPolicyKindName(internalpolicy.InternalPolicyKindName)
		}

		if internalPolicyKindID, exists := m.InternalPolicyKindID(); exists {
			create = create.SetInternalPolicyKindID(internalPolicyKindID)
		} else {
			create = create.SetInternalPolicyKindID(internalpolicy.InternalPolicyKindID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *InternalPolicyMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		internalpolicy, err := client.InternalPolicy.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.InternalPolicyHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(internalpolicy.CreatedAt).
			SetUpdatedAt(internalpolicy.UpdatedAt).
			SetCreatedBy(internalpolicy.CreatedBy).
			SetUpdatedBy(internalpolicy.UpdatedBy).
			SetDeletedAt(internalpolicy.DeletedAt).
			SetDeletedBy(internalpolicy.DeletedBy).
			SetDisplayID(internalpolicy.DisplayID).
			SetTags(internalpolicy.Tags).
			SetRevision(internalpolicy.Revision).
			SetOwnerID(internalpolicy.OwnerID).
			SetSystemOwned(internalpolicy.SystemOwned).
			SetNillableInternalNotes(internalpolicy.InternalNotes).
			SetNillableSystemInternalID(internalpolicy.SystemInternalID).
			SetName(internalpolicy.Name).
			SetStatus(internalpolicy.Status).
			SetPolicyType(internalpolicy.PolicyType).
			SetDetails(internalpolicy.Details).
			SetApprovalRequired(internalpolicy.ApprovalRequired).
			SetReviewDue(internalpolicy.ReviewDue).
			SetReviewFrequency(internalpolicy.ReviewFrequency).
			SetApproverID(internalpolicy.ApproverID).
			SetDelegateID(internalpolicy.DelegateID).
			SetSummary(internalpolicy.Summary).
			SetTagSuggestions(internalpolicy.TagSuggestions).
			SetDismissedTagSuggestions(internalpolicy.DismissedTagSuggestions).
			SetControlSuggestions(internalpolicy.ControlSuggestions).
			SetDismissedControlSuggestions(internalpolicy.DismissedControlSuggestions).
			SetImprovementSuggestions(internalpolicy.ImprovementSuggestions).
			SetDismissedImprovementSuggestions(internalpolicy.DismissedImprovementSuggestions).
			SetNillableURL(internalpolicy.URL).
			SetNillableFileID(internalpolicy.FileID).
			SetInternalPolicyKindName(internalpolicy.InternalPolicyKindName).
			SetInternalPolicyKindID(internalpolicy.InternalPolicyKindID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *JobTemplateMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.JobTemplateHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if title, exists := m.Title(); exists {
		create = create.SetTitle(title)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if platform, exists := m.Platform(); exists {
		create = create.SetPlatform(platform)
	}

	if windmillPath, exists := m.WindmillPath(); exists {
		create = create.SetWindmillPath(windmillPath)
	}

	if downloadURL, exists := m.DownloadURL(); exists {
		create = create.SetDownloadURL(downloadURL)
	}

	if configuration, exists := m.Configuration(); exists {
		create = create.SetConfiguration(configuration)
	}

	if cron, exists := m.Cron(); exists {
		create = create.SetNillableCron(&cron)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *JobTemplateMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		jobtemplate, err := client.JobTemplate.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.JobTemplateHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(jobtemplate.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(jobtemplate.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(jobtemplate.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(jobtemplate.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(jobtemplate.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(jobtemplate.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(jobtemplate.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(jobtemplate.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(jobtemplate.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(jobtemplate.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(jobtemplate.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(jobtemplate.SystemInternalID)
		}

		if title, exists := m.Title(); exists {
			create = create.SetTitle(title)
		} else {
			create = create.SetTitle(jobtemplate.Title)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(jobtemplate.Description)
		}

		if platform, exists := m.Platform(); exists {
			create = create.SetPlatform(platform)
		} else {
			create = create.SetPlatform(jobtemplate.Platform)
		}

		if windmillPath, exists := m.WindmillPath(); exists {
			create = create.SetWindmillPath(windmillPath)
		} else {
			create = create.SetWindmillPath(jobtemplate.WindmillPath)
		}

		if downloadURL, exists := m.DownloadURL(); exists {
			create = create.SetDownloadURL(downloadURL)
		} else {
			create = create.SetDownloadURL(jobtemplate.DownloadURL)
		}

		if configuration, exists := m.Configuration(); exists {
			create = create.SetConfiguration(configuration)
		} else {
			create = create.SetConfiguration(jobtemplate.Configuration)
		}

		if cron, exists := m.Cron(); exists {
			create = create.SetNillableCron(&cron)
		} else {
			create = create.SetNillableCron(jobtemplate.Cron)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *JobTemplateMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		jobtemplate, err := client.JobTemplate.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.JobTemplateHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(jobtemplate.CreatedAt).
			SetUpdatedAt(jobtemplate.UpdatedAt).
			SetCreatedBy(jobtemplate.CreatedBy).
			SetUpdatedBy(jobtemplate.UpdatedBy).
			SetDeletedAt(jobtemplate.DeletedAt).
			SetDeletedBy(jobtemplate.DeletedBy).
			SetDisplayID(jobtemplate.DisplayID).
			SetTags(jobtemplate.Tags).
			SetOwnerID(jobtemplate.OwnerID).
			SetSystemOwned(jobtemplate.SystemOwned).
			SetNillableInternalNotes(jobtemplate.InternalNotes).
			SetNillableSystemInternalID(jobtemplate.SystemInternalID).
			SetTitle(jobtemplate.Title).
			SetDescription(jobtemplate.Description).
			SetPlatform(jobtemplate.Platform).
			SetWindmillPath(jobtemplate.WindmillPath).
			SetDownloadURL(jobtemplate.DownloadURL).
			SetConfiguration(jobtemplate.Configuration).
			SetNillableCron(jobtemplate.Cron).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *MappableDomainMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.MappableDomainHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if zoneID, exists := m.ZoneID(); exists {
		create = create.SetZoneID(zoneID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *MappableDomainMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		mappabledomain, err := client.MappableDomain.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.MappableDomainHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(mappabledomain.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(mappabledomain.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(mappabledomain.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(mappabledomain.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(mappabledomain.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(mappabledomain.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(mappabledomain.Tags)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(mappabledomain.Name)
		}

		if zoneID, exists := m.ZoneID(); exists {
			create = create.SetZoneID(zoneID)
		} else {
			create = create.SetZoneID(mappabledomain.ZoneID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *MappableDomainMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		mappabledomain, err := client.MappableDomain.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.MappableDomainHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(mappabledomain.CreatedAt).
			SetUpdatedAt(mappabledomain.UpdatedAt).
			SetCreatedBy(mappabledomain.CreatedBy).
			SetUpdatedBy(mappabledomain.UpdatedBy).
			SetDeletedAt(mappabledomain.DeletedAt).
			SetDeletedBy(mappabledomain.DeletedBy).
			SetTags(mappabledomain.Tags).
			SetName(mappabledomain.Name).
			SetZoneID(mappabledomain.ZoneID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *MappedControlMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.MappedControlHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if mappingType, exists := m.MappingType(); exists {
		create = create.SetMappingType(mappingType)
	}

	if relation, exists := m.Relation(); exists {
		create = create.SetRelation(relation)
	}

	if confidence, exists := m.Confidence(); exists {
		create = create.SetNillableConfidence(&confidence)
	}

	if source, exists := m.Source(); exists {
		create = create.SetSource(source)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *MappedControlMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		mappedcontrol, err := client.MappedControl.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.MappedControlHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(mappedcontrol.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(mappedcontrol.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(mappedcontrol.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(mappedcontrol.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(mappedcontrol.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(mappedcontrol.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(mappedcontrol.Tags)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(mappedcontrol.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(mappedcontrol.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(mappedcontrol.SystemInternalID)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(mappedcontrol.OwnerID)
		}

		if mappingType, exists := m.MappingType(); exists {
			create = create.SetMappingType(mappingType)
		} else {
			create = create.SetMappingType(mappedcontrol.MappingType)
		}

		if relation, exists := m.Relation(); exists {
			create = create.SetRelation(relation)
		} else {
			create = create.SetRelation(mappedcontrol.Relation)
		}

		if confidence, exists := m.Confidence(); exists {
			create = create.SetNillableConfidence(&confidence)
		} else {
			create = create.SetNillableConfidence(mappedcontrol.Confidence)
		}

		if source, exists := m.Source(); exists {
			create = create.SetSource(source)
		} else {
			create = create.SetSource(mappedcontrol.Source)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *MappedControlMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		mappedcontrol, err := client.MappedControl.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.MappedControlHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(mappedcontrol.CreatedAt).
			SetUpdatedAt(mappedcontrol.UpdatedAt).
			SetCreatedBy(mappedcontrol.CreatedBy).
			SetUpdatedBy(mappedcontrol.UpdatedBy).
			SetDeletedAt(mappedcontrol.DeletedAt).
			SetDeletedBy(mappedcontrol.DeletedBy).
			SetTags(mappedcontrol.Tags).
			SetSystemOwned(mappedcontrol.SystemOwned).
			SetNillableInternalNotes(mappedcontrol.InternalNotes).
			SetNillableSystemInternalID(mappedcontrol.SystemInternalID).
			SetOwnerID(mappedcontrol.OwnerID).
			SetMappingType(mappedcontrol.MappingType).
			SetRelation(mappedcontrol.Relation).
			SetNillableConfidence(mappedcontrol.Confidence).
			SetSource(mappedcontrol.Source).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *NarrativeMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.NarrativeHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *NarrativeMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		narrative, err := client.Narrative.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.NarrativeHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(narrative.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(narrative.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(narrative.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(narrative.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(narrative.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(narrative.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(narrative.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(narrative.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(narrative.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(narrative.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(narrative.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(narrative.SystemInternalID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(narrative.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(narrative.Description)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(narrative.Details)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *NarrativeMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		narrative, err := client.Narrative.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.NarrativeHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(narrative.CreatedAt).
			SetUpdatedAt(narrative.UpdatedAt).
			SetCreatedBy(narrative.CreatedBy).
			SetUpdatedBy(narrative.UpdatedBy).
			SetDeletedAt(narrative.DeletedAt).
			SetDeletedBy(narrative.DeletedBy).
			SetDisplayID(narrative.DisplayID).
			SetTags(narrative.Tags).
			SetOwnerID(narrative.OwnerID).
			SetSystemOwned(narrative.SystemOwned).
			SetNillableInternalNotes(narrative.InternalNotes).
			SetNillableSystemInternalID(narrative.SystemInternalID).
			SetName(narrative.Name).
			SetDescription(narrative.Description).
			SetDetails(narrative.Details).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *NoteMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.NoteHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if text, exists := m.Text(); exists {
		create = create.SetText(text)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *NoteMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		note, err := client.Note.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.NoteHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(note.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(note.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(note.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(note.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(note.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(note.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(note.DisplayID)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(note.OwnerID)
		}

		if text, exists := m.Text(); exists {
			create = create.SetText(text)
		} else {
			create = create.SetText(note.Text)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *NoteMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		note, err := client.Note.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.NoteHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(note.CreatedAt).
			SetUpdatedAt(note.UpdatedAt).
			SetCreatedBy(note.CreatedBy).
			SetUpdatedBy(note.UpdatedBy).
			SetDeletedAt(note.DeletedAt).
			SetDeletedBy(note.DeletedBy).
			SetDisplayID(note.DisplayID).
			SetOwnerID(note.OwnerID).
			SetText(note.Text).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *OrgMembershipMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.OrgMembershipHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	}

	if organizationID, exists := m.OrganizationID(); exists {
		create = create.SetOrganizationID(organizationID)
	}

	if userID, exists := m.UserID(); exists {
		create = create.SetUserID(userID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *OrgMembershipMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		orgmembership, err := client.OrgMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrgMembershipHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(orgmembership.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(orgmembership.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(orgmembership.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(orgmembership.UpdatedBy)
		}

		if role, exists := m.Role(); exists {
			create = create.SetRole(role)
		} else {
			create = create.SetRole(orgmembership.Role)
		}

		if organizationID, exists := m.OrganizationID(); exists {
			create = create.SetOrganizationID(organizationID)
		} else {
			create = create.SetOrganizationID(orgmembership.OrganizationID)
		}

		if userID, exists := m.UserID(); exists {
			create = create.SetUserID(userID)
		} else {
			create = create.SetUserID(orgmembership.UserID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *OrgMembershipMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		orgmembership, err := client.OrgMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrgMembershipHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(orgmembership.CreatedAt).
			SetUpdatedAt(orgmembership.UpdatedAt).
			SetCreatedBy(orgmembership.CreatedBy).
			SetUpdatedBy(orgmembership.UpdatedBy).
			SetRole(orgmembership.Role).
			SetOrganizationID(orgmembership.OrganizationID).
			SetUserID(orgmembership.UserID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *OrgSubscriptionMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.OrgSubscriptionHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if stripeSubscriptionID, exists := m.StripeSubscriptionID(); exists {
		create = create.SetStripeSubscriptionID(stripeSubscriptionID)
	}

	if stripeSubscriptionStatus, exists := m.StripeSubscriptionStatus(); exists {
		create = create.SetStripeSubscriptionStatus(stripeSubscriptionStatus)
	}

	if active, exists := m.Active(); exists {
		create = create.SetActive(active)
	}

	if expiresAt, exists := m.ExpiresAt(); exists {
		create = create.SetNillableExpiresAt(&expiresAt)
	}

	if trialExpiresAt, exists := m.TrialExpiresAt(); exists {
		create = create.SetNillableTrialExpiresAt(&trialExpiresAt)
	}

	if daysUntilDue, exists := m.DaysUntilDue(); exists {
		create = create.SetNillableDaysUntilDue(&daysUntilDue)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *OrgSubscriptionMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		orgsubscription, err := client.OrgSubscription.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrgSubscriptionHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(orgsubscription.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(orgsubscription.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(orgsubscription.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(orgsubscription.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(orgsubscription.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(orgsubscription.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(orgsubscription.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(orgsubscription.OwnerID)
		}

		if stripeSubscriptionID, exists := m.StripeSubscriptionID(); exists {
			create = create.SetStripeSubscriptionID(stripeSubscriptionID)
		} else {
			create = create.SetStripeSubscriptionID(orgsubscription.StripeSubscriptionID)
		}

		if stripeSubscriptionStatus, exists := m.StripeSubscriptionStatus(); exists {
			create = create.SetStripeSubscriptionStatus(stripeSubscriptionStatus)
		} else {
			create = create.SetStripeSubscriptionStatus(orgsubscription.StripeSubscriptionStatus)
		}

		if active, exists := m.Active(); exists {
			create = create.SetActive(active)
		} else {
			create = create.SetActive(orgsubscription.Active)
		}

		if expiresAt, exists := m.ExpiresAt(); exists {
			create = create.SetNillableExpiresAt(&expiresAt)
		} else {
			create = create.SetNillableExpiresAt(orgsubscription.ExpiresAt)
		}

		if trialExpiresAt, exists := m.TrialExpiresAt(); exists {
			create = create.SetNillableTrialExpiresAt(&trialExpiresAt)
		} else {
			create = create.SetNillableTrialExpiresAt(orgsubscription.TrialExpiresAt)
		}

		if daysUntilDue, exists := m.DaysUntilDue(); exists {
			create = create.SetNillableDaysUntilDue(&daysUntilDue)
		} else {
			create = create.SetNillableDaysUntilDue(orgsubscription.DaysUntilDue)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *OrgSubscriptionMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		orgsubscription, err := client.OrgSubscription.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrgSubscriptionHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(orgsubscription.CreatedAt).
			SetUpdatedAt(orgsubscription.UpdatedAt).
			SetCreatedBy(orgsubscription.CreatedBy).
			SetUpdatedBy(orgsubscription.UpdatedBy).
			SetDeletedAt(orgsubscription.DeletedAt).
			SetDeletedBy(orgsubscription.DeletedBy).
			SetTags(orgsubscription.Tags).
			SetOwnerID(orgsubscription.OwnerID).
			SetStripeSubscriptionID(orgsubscription.StripeSubscriptionID).
			SetStripeSubscriptionStatus(orgsubscription.StripeSubscriptionStatus).
			SetActive(orgsubscription.Active).
			SetNillableExpiresAt(orgsubscription.ExpiresAt).
			SetNillableTrialExpiresAt(orgsubscription.TrialExpiresAt).
			SetNillableDaysUntilDue(orgsubscription.DaysUntilDue).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *OrganizationMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.OrganizationHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if parentOrganizationID, exists := m.ParentOrganizationID(); exists {
		create = create.SetParentOrganizationID(parentOrganizationID)
	}

	if personalOrg, exists := m.PersonalOrg(); exists {
		create = create.SetPersonalOrg(personalOrg)
	}

	if avatarRemoteURL, exists := m.AvatarRemoteURL(); exists {
		create = create.SetNillableAvatarRemoteURL(&avatarRemoteURL)
	}

	if avatarLocalFileID, exists := m.AvatarLocalFileID(); exists {
		create = create.SetNillableAvatarLocalFileID(&avatarLocalFileID)
	}

	if avatarUpdatedAt, exists := m.AvatarUpdatedAt(); exists {
		create = create.SetNillableAvatarUpdatedAt(&avatarUpdatedAt)
	}

	if dedicatedDb, exists := m.DedicatedDb(); exists {
		create = create.SetDedicatedDb(dedicatedDb)
	}

	if stripeCustomerID, exists := m.StripeCustomerID(); exists {
		create = create.SetNillableStripeCustomerID(&stripeCustomerID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *OrganizationMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		organization, err := client.Organization.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrganizationHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(organization.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(organization.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(organization.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(organization.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(organization.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(organization.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(organization.Tags)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(organization.Name)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(organization.DisplayName)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(organization.Description)
		}

		if parentOrganizationID, exists := m.ParentOrganizationID(); exists {
			create = create.SetParentOrganizationID(parentOrganizationID)
		} else {
			create = create.SetParentOrganizationID(organization.ParentOrganizationID)
		}

		if personalOrg, exists := m.PersonalOrg(); exists {
			create = create.SetPersonalOrg(personalOrg)
		} else {
			create = create.SetPersonalOrg(organization.PersonalOrg)
		}

		if avatarRemoteURL, exists := m.AvatarRemoteURL(); exists {
			create = create.SetNillableAvatarRemoteURL(&avatarRemoteURL)
		} else {
			create = create.SetNillableAvatarRemoteURL(organization.AvatarRemoteURL)
		}

		if avatarLocalFileID, exists := m.AvatarLocalFileID(); exists {
			create = create.SetNillableAvatarLocalFileID(&avatarLocalFileID)
		} else {
			create = create.SetNillableAvatarLocalFileID(organization.AvatarLocalFileID)
		}

		if avatarUpdatedAt, exists := m.AvatarUpdatedAt(); exists {
			create = create.SetNillableAvatarUpdatedAt(&avatarUpdatedAt)
		} else {
			create = create.SetNillableAvatarUpdatedAt(organization.AvatarUpdatedAt)
		}

		if dedicatedDb, exists := m.DedicatedDb(); exists {
			create = create.SetDedicatedDb(dedicatedDb)
		} else {
			create = create.SetDedicatedDb(organization.DedicatedDb)
		}

		if stripeCustomerID, exists := m.StripeCustomerID(); exists {
			create = create.SetNillableStripeCustomerID(&stripeCustomerID)
		} else {
			create = create.SetNillableStripeCustomerID(organization.StripeCustomerID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *OrganizationMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		organization, err := client.Organization.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrganizationHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(organization.CreatedAt).
			SetUpdatedAt(organization.UpdatedAt).
			SetCreatedBy(organization.CreatedBy).
			SetUpdatedBy(organization.UpdatedBy).
			SetDeletedAt(organization.DeletedAt).
			SetDeletedBy(organization.DeletedBy).
			SetTags(organization.Tags).
			SetName(organization.Name).
			SetDisplayName(organization.DisplayName).
			SetDescription(organization.Description).
			SetParentOrganizationID(organization.ParentOrganizationID).
			SetPersonalOrg(organization.PersonalOrg).
			SetNillableAvatarRemoteURL(organization.AvatarRemoteURL).
			SetNillableAvatarLocalFileID(organization.AvatarLocalFileID).
			SetNillableAvatarUpdatedAt(organization.AvatarUpdatedAt).
			SetDedicatedDb(organization.DedicatedDb).
			SetNillableStripeCustomerID(organization.StripeCustomerID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *OrganizationSettingMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.OrganizationSettingHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if domains, exists := m.Domains(); exists {
		create = create.SetDomains(domains)
	}

	if billingContact, exists := m.BillingContact(); exists {
		create = create.SetBillingContact(billingContact)
	}

	if billingEmail, exists := m.BillingEmail(); exists {
		create = create.SetBillingEmail(billingEmail)
	}

	if billingPhone, exists := m.BillingPhone(); exists {
		create = create.SetBillingPhone(billingPhone)
	}

	if billingAddress, exists := m.BillingAddress(); exists {
		create = create.SetBillingAddress(billingAddress)
	}

	if taxIdentifier, exists := m.TaxIdentifier(); exists {
		create = create.SetTaxIdentifier(taxIdentifier)
	}

	if geoLocation, exists := m.GeoLocation(); exists {
		create = create.SetGeoLocation(geoLocation)
	}

	if organizationID, exists := m.OrganizationID(); exists {
		create = create.SetOrganizationID(organizationID)
	}

	if billingNotificationsEnabled, exists := m.BillingNotificationsEnabled(); exists {
		create = create.SetBillingNotificationsEnabled(billingNotificationsEnabled)
	}

	if allowedEmailDomains, exists := m.AllowedEmailDomains(); exists {
		create = create.SetAllowedEmailDomains(allowedEmailDomains)
	}

	if allowMatchingDomainsAutojoin, exists := m.AllowMatchingDomainsAutojoin(); exists {
		create = create.SetAllowMatchingDomainsAutojoin(allowMatchingDomainsAutojoin)
	}

	if identityProvider, exists := m.IdentityProvider(); exists {
		create = create.SetIdentityProvider(identityProvider)
	}

	if identityProviderClientID, exists := m.IdentityProviderClientID(); exists {
		create = create.SetNillableIdentityProviderClientID(&identityProviderClientID)
	}

	if identityProviderClientSecret, exists := m.IdentityProviderClientSecret(); exists {
		create = create.SetNillableIdentityProviderClientSecret(&identityProviderClientSecret)
	}

	if identityProviderMetadataEndpoint, exists := m.IdentityProviderMetadataEndpoint(); exists {
		create = create.SetIdentityProviderMetadataEndpoint(identityProviderMetadataEndpoint)
	}

	if identityProviderAuthTested, exists := m.IdentityProviderAuthTested(); exists {
		create = create.SetIdentityProviderAuthTested(identityProviderAuthTested)
	}

	if identityProviderEntityID, exists := m.IdentityProviderEntityID(); exists {
		create = create.SetIdentityProviderEntityID(identityProviderEntityID)
	}

	if oidcDiscoveryEndpoint, exists := m.OidcDiscoveryEndpoint(); exists {
		create = create.SetOidcDiscoveryEndpoint(oidcDiscoveryEndpoint)
	}

	if samlSigninURL, exists := m.SamlSigninURL(); exists {
		create = create.SetSamlSigninURL(samlSigninURL)
	}

	if samlIssuer, exists := m.SamlIssuer(); exists {
		create = create.SetSamlIssuer(samlIssuer)
	}

	if samlCert, exists := m.SamlCert(); exists {
		create = create.SetSamlCert(samlCert)
	}

	if identityProviderLoginEnforced, exists := m.IdentityProviderLoginEnforced(); exists {
		create = create.SetIdentityProviderLoginEnforced(identityProviderLoginEnforced)
	}

	if multifactorAuthEnforced, exists := m.MultifactorAuthEnforced(); exists {
		create = create.SetMultifactorAuthEnforced(multifactorAuthEnforced)
	}

	if complianceWebhookToken, exists := m.ComplianceWebhookToken(); exists {
		create = create.SetComplianceWebhookToken(complianceWebhookToken)
	}

	if paymentMethodAdded, exists := m.PaymentMethodAdded(); exists {
		create = create.SetPaymentMethodAdded(paymentMethodAdded)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *OrganizationSettingMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		organizationsetting, err := client.OrganizationSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrganizationSettingHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(organizationsetting.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(organizationsetting.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(organizationsetting.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(organizationsetting.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(organizationsetting.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(organizationsetting.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(organizationsetting.Tags)
		}

		if domains, exists := m.Domains(); exists {
			create = create.SetDomains(domains)
		} else {
			create = create.SetDomains(organizationsetting.Domains)
		}

		if billingContact, exists := m.BillingContact(); exists {
			create = create.SetBillingContact(billingContact)
		} else {
			create = create.SetBillingContact(organizationsetting.BillingContact)
		}

		if billingEmail, exists := m.BillingEmail(); exists {
			create = create.SetBillingEmail(billingEmail)
		} else {
			create = create.SetBillingEmail(organizationsetting.BillingEmail)
		}

		if billingPhone, exists := m.BillingPhone(); exists {
			create = create.SetBillingPhone(billingPhone)
		} else {
			create = create.SetBillingPhone(organizationsetting.BillingPhone)
		}

		if billingAddress, exists := m.BillingAddress(); exists {
			create = create.SetBillingAddress(billingAddress)
		} else {
			create = create.SetBillingAddress(organizationsetting.BillingAddress)
		}

		if taxIdentifier, exists := m.TaxIdentifier(); exists {
			create = create.SetTaxIdentifier(taxIdentifier)
		} else {
			create = create.SetTaxIdentifier(organizationsetting.TaxIdentifier)
		}

		if geoLocation, exists := m.GeoLocation(); exists {
			create = create.SetGeoLocation(geoLocation)
		} else {
			create = create.SetGeoLocation(organizationsetting.GeoLocation)
		}

		if organizationID, exists := m.OrganizationID(); exists {
			create = create.SetOrganizationID(organizationID)
		} else {
			create = create.SetOrganizationID(organizationsetting.OrganizationID)
		}

		if billingNotificationsEnabled, exists := m.BillingNotificationsEnabled(); exists {
			create = create.SetBillingNotificationsEnabled(billingNotificationsEnabled)
		} else {
			create = create.SetBillingNotificationsEnabled(organizationsetting.BillingNotificationsEnabled)
		}

		if allowedEmailDomains, exists := m.AllowedEmailDomains(); exists {
			create = create.SetAllowedEmailDomains(allowedEmailDomains)
		} else {
			create = create.SetAllowedEmailDomains(organizationsetting.AllowedEmailDomains)
		}

		if allowMatchingDomainsAutojoin, exists := m.AllowMatchingDomainsAutojoin(); exists {
			create = create.SetAllowMatchingDomainsAutojoin(allowMatchingDomainsAutojoin)
		} else {
			create = create.SetAllowMatchingDomainsAutojoin(organizationsetting.AllowMatchingDomainsAutojoin)
		}

		if identityProvider, exists := m.IdentityProvider(); exists {
			create = create.SetIdentityProvider(identityProvider)
		} else {
			create = create.SetIdentityProvider(organizationsetting.IdentityProvider)
		}

		if identityProviderClientID, exists := m.IdentityProviderClientID(); exists {
			create = create.SetNillableIdentityProviderClientID(&identityProviderClientID)
		} else {
			create = create.SetNillableIdentityProviderClientID(organizationsetting.IdentityProviderClientID)
		}

		if identityProviderClientSecret, exists := m.IdentityProviderClientSecret(); exists {
			create = create.SetNillableIdentityProviderClientSecret(&identityProviderClientSecret)
		} else {
			create = create.SetNillableIdentityProviderClientSecret(organizationsetting.IdentityProviderClientSecret)
		}

		if identityProviderMetadataEndpoint, exists := m.IdentityProviderMetadataEndpoint(); exists {
			create = create.SetIdentityProviderMetadataEndpoint(identityProviderMetadataEndpoint)
		} else {
			create = create.SetIdentityProviderMetadataEndpoint(organizationsetting.IdentityProviderMetadataEndpoint)
		}

		if identityProviderAuthTested, exists := m.IdentityProviderAuthTested(); exists {
			create = create.SetIdentityProviderAuthTested(identityProviderAuthTested)
		} else {
			create = create.SetIdentityProviderAuthTested(organizationsetting.IdentityProviderAuthTested)
		}

		if identityProviderEntityID, exists := m.IdentityProviderEntityID(); exists {
			create = create.SetIdentityProviderEntityID(identityProviderEntityID)
		} else {
			create = create.SetIdentityProviderEntityID(organizationsetting.IdentityProviderEntityID)
		}

		if oidcDiscoveryEndpoint, exists := m.OidcDiscoveryEndpoint(); exists {
			create = create.SetOidcDiscoveryEndpoint(oidcDiscoveryEndpoint)
		} else {
			create = create.SetOidcDiscoveryEndpoint(organizationsetting.OidcDiscoveryEndpoint)
		}

		if samlSigninURL, exists := m.SamlSigninURL(); exists {
			create = create.SetSamlSigninURL(samlSigninURL)
		} else {
			create = create.SetSamlSigninURL(organizationsetting.SamlSigninURL)
		}

		if samlIssuer, exists := m.SamlIssuer(); exists {
			create = create.SetSamlIssuer(samlIssuer)
		} else {
			create = create.SetSamlIssuer(organizationsetting.SamlIssuer)
		}

		if samlCert, exists := m.SamlCert(); exists {
			create = create.SetSamlCert(samlCert)
		} else {
			create = create.SetSamlCert(organizationsetting.SamlCert)
		}

		if identityProviderLoginEnforced, exists := m.IdentityProviderLoginEnforced(); exists {
			create = create.SetIdentityProviderLoginEnforced(identityProviderLoginEnforced)
		} else {
			create = create.SetIdentityProviderLoginEnforced(organizationsetting.IdentityProviderLoginEnforced)
		}

		if multifactorAuthEnforced, exists := m.MultifactorAuthEnforced(); exists {
			create = create.SetMultifactorAuthEnforced(multifactorAuthEnforced)
		} else {
			create = create.SetMultifactorAuthEnforced(organizationsetting.MultifactorAuthEnforced)
		}

		if complianceWebhookToken, exists := m.ComplianceWebhookToken(); exists {
			create = create.SetComplianceWebhookToken(complianceWebhookToken)
		} else {
			create = create.SetComplianceWebhookToken(organizationsetting.ComplianceWebhookToken)
		}

		if paymentMethodAdded, exists := m.PaymentMethodAdded(); exists {
			create = create.SetPaymentMethodAdded(paymentMethodAdded)
		} else {
			create = create.SetPaymentMethodAdded(organizationsetting.PaymentMethodAdded)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *OrganizationSettingMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		organizationsetting, err := client.OrganizationSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.OrganizationSettingHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(organizationsetting.CreatedAt).
			SetUpdatedAt(organizationsetting.UpdatedAt).
			SetCreatedBy(organizationsetting.CreatedBy).
			SetUpdatedBy(organizationsetting.UpdatedBy).
			SetDeletedAt(organizationsetting.DeletedAt).
			SetDeletedBy(organizationsetting.DeletedBy).
			SetTags(organizationsetting.Tags).
			SetDomains(organizationsetting.Domains).
			SetBillingContact(organizationsetting.BillingContact).
			SetBillingEmail(organizationsetting.BillingEmail).
			SetBillingPhone(organizationsetting.BillingPhone).
			SetBillingAddress(organizationsetting.BillingAddress).
			SetTaxIdentifier(organizationsetting.TaxIdentifier).
			SetGeoLocation(organizationsetting.GeoLocation).
			SetOrganizationID(organizationsetting.OrganizationID).
			SetBillingNotificationsEnabled(organizationsetting.BillingNotificationsEnabled).
			SetAllowedEmailDomains(organizationsetting.AllowedEmailDomains).
			SetAllowMatchingDomainsAutojoin(organizationsetting.AllowMatchingDomainsAutojoin).
			SetIdentityProvider(organizationsetting.IdentityProvider).
			SetNillableIdentityProviderClientID(organizationsetting.IdentityProviderClientID).
			SetNillableIdentityProviderClientSecret(organizationsetting.IdentityProviderClientSecret).
			SetIdentityProviderMetadataEndpoint(organizationsetting.IdentityProviderMetadataEndpoint).
			SetIdentityProviderAuthTested(organizationsetting.IdentityProviderAuthTested).
			SetIdentityProviderEntityID(organizationsetting.IdentityProviderEntityID).
			SetOidcDiscoveryEndpoint(organizationsetting.OidcDiscoveryEndpoint).
			SetSamlSigninURL(organizationsetting.SamlSigninURL).
			SetSamlIssuer(organizationsetting.SamlIssuer).
			SetSamlCert(organizationsetting.SamlCert).
			SetIdentityProviderLoginEnforced(organizationsetting.IdentityProviderLoginEnforced).
			SetMultifactorAuthEnforced(organizationsetting.MultifactorAuthEnforced).
			SetComplianceWebhookToken(organizationsetting.ComplianceWebhookToken).
			SetPaymentMethodAdded(organizationsetting.PaymentMethodAdded).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ProcedureMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ProcedureHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if revision, exists := m.Revision(); exists {
		create = create.SetRevision(revision)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if procedureType, exists := m.ProcedureType(); exists {
		create = create.SetProcedureType(procedureType)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	if approvalRequired, exists := m.ApprovalRequired(); exists {
		create = create.SetApprovalRequired(approvalRequired)
	}

	if reviewDue, exists := m.ReviewDue(); exists {
		create = create.SetReviewDue(reviewDue)
	}

	if reviewFrequency, exists := m.ReviewFrequency(); exists {
		create = create.SetReviewFrequency(reviewFrequency)
	}

	if approverID, exists := m.ApproverID(); exists {
		create = create.SetApproverID(approverID)
	}

	if delegateID, exists := m.DelegateID(); exists {
		create = create.SetDelegateID(delegateID)
	}

	if summary, exists := m.Summary(); exists {
		create = create.SetSummary(summary)
	}

	if tagSuggestions, exists := m.TagSuggestions(); exists {
		create = create.SetTagSuggestions(tagSuggestions)
	}

	if dismissedTagSuggestions, exists := m.DismissedTagSuggestions(); exists {
		create = create.SetDismissedTagSuggestions(dismissedTagSuggestions)
	}

	if controlSuggestions, exists := m.ControlSuggestions(); exists {
		create = create.SetControlSuggestions(controlSuggestions)
	}

	if dismissedControlSuggestions, exists := m.DismissedControlSuggestions(); exists {
		create = create.SetDismissedControlSuggestions(dismissedControlSuggestions)
	}

	if improvementSuggestions, exists := m.ImprovementSuggestions(); exists {
		create = create.SetImprovementSuggestions(improvementSuggestions)
	}

	if dismissedImprovementSuggestions, exists := m.DismissedImprovementSuggestions(); exists {
		create = create.SetDismissedImprovementSuggestions(dismissedImprovementSuggestions)
	}

	if url, exists := m.URL(); exists {
		create = create.SetNillableURL(&url)
	}

	if fileID, exists := m.FileID(); exists {
		create = create.SetNillableFileID(&fileID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if procedureKindName, exists := m.ProcedureKindName(); exists {
		create = create.SetProcedureKindName(procedureKindName)
	}

	if procedureKindID, exists := m.ProcedureKindID(); exists {
		create = create.SetProcedureKindID(procedureKindID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ProcedureMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		procedure, err := client.Procedure.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ProcedureHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(procedure.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(procedure.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(procedure.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(procedure.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(procedure.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(procedure.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(procedure.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(procedure.Tags)
		}

		if revision, exists := m.Revision(); exists {
			create = create.SetRevision(revision)
		} else {
			create = create.SetRevision(procedure.Revision)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(procedure.OwnerID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(procedure.Name)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(procedure.Status)
		}

		if procedureType, exists := m.ProcedureType(); exists {
			create = create.SetProcedureType(procedureType)
		} else {
			create = create.SetProcedureType(procedure.ProcedureType)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(procedure.Details)
		}

		if approvalRequired, exists := m.ApprovalRequired(); exists {
			create = create.SetApprovalRequired(approvalRequired)
		} else {
			create = create.SetApprovalRequired(procedure.ApprovalRequired)
		}

		if reviewDue, exists := m.ReviewDue(); exists {
			create = create.SetReviewDue(reviewDue)
		} else {
			create = create.SetReviewDue(procedure.ReviewDue)
		}

		if reviewFrequency, exists := m.ReviewFrequency(); exists {
			create = create.SetReviewFrequency(reviewFrequency)
		} else {
			create = create.SetReviewFrequency(procedure.ReviewFrequency)
		}

		if approverID, exists := m.ApproverID(); exists {
			create = create.SetApproverID(approverID)
		} else {
			create = create.SetApproverID(procedure.ApproverID)
		}

		if delegateID, exists := m.DelegateID(); exists {
			create = create.SetDelegateID(delegateID)
		} else {
			create = create.SetDelegateID(procedure.DelegateID)
		}

		if summary, exists := m.Summary(); exists {
			create = create.SetSummary(summary)
		} else {
			create = create.SetSummary(procedure.Summary)
		}

		if tagSuggestions, exists := m.TagSuggestions(); exists {
			create = create.SetTagSuggestions(tagSuggestions)
		} else {
			create = create.SetTagSuggestions(procedure.TagSuggestions)
		}

		if dismissedTagSuggestions, exists := m.DismissedTagSuggestions(); exists {
			create = create.SetDismissedTagSuggestions(dismissedTagSuggestions)
		} else {
			create = create.SetDismissedTagSuggestions(procedure.DismissedTagSuggestions)
		}

		if controlSuggestions, exists := m.ControlSuggestions(); exists {
			create = create.SetControlSuggestions(controlSuggestions)
		} else {
			create = create.SetControlSuggestions(procedure.ControlSuggestions)
		}

		if dismissedControlSuggestions, exists := m.DismissedControlSuggestions(); exists {
			create = create.SetDismissedControlSuggestions(dismissedControlSuggestions)
		} else {
			create = create.SetDismissedControlSuggestions(procedure.DismissedControlSuggestions)
		}

		if improvementSuggestions, exists := m.ImprovementSuggestions(); exists {
			create = create.SetImprovementSuggestions(improvementSuggestions)
		} else {
			create = create.SetImprovementSuggestions(procedure.ImprovementSuggestions)
		}

		if dismissedImprovementSuggestions, exists := m.DismissedImprovementSuggestions(); exists {
			create = create.SetDismissedImprovementSuggestions(dismissedImprovementSuggestions)
		} else {
			create = create.SetDismissedImprovementSuggestions(procedure.DismissedImprovementSuggestions)
		}

		if url, exists := m.URL(); exists {
			create = create.SetNillableURL(&url)
		} else {
			create = create.SetNillableURL(procedure.URL)
		}

		if fileID, exists := m.FileID(); exists {
			create = create.SetNillableFileID(&fileID)
		} else {
			create = create.SetNillableFileID(procedure.FileID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(procedure.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(procedure.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(procedure.SystemInternalID)
		}

		if procedureKindName, exists := m.ProcedureKindName(); exists {
			create = create.SetProcedureKindName(procedureKindName)
		} else {
			create = create.SetProcedureKindName(procedure.ProcedureKindName)
		}

		if procedureKindID, exists := m.ProcedureKindID(); exists {
			create = create.SetProcedureKindID(procedureKindID)
		} else {
			create = create.SetProcedureKindID(procedure.ProcedureKindID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ProcedureMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		procedure, err := client.Procedure.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ProcedureHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(procedure.CreatedAt).
			SetUpdatedAt(procedure.UpdatedAt).
			SetCreatedBy(procedure.CreatedBy).
			SetUpdatedBy(procedure.UpdatedBy).
			SetDeletedAt(procedure.DeletedAt).
			SetDeletedBy(procedure.DeletedBy).
			SetDisplayID(procedure.DisplayID).
			SetTags(procedure.Tags).
			SetRevision(procedure.Revision).
			SetOwnerID(procedure.OwnerID).
			SetName(procedure.Name).
			SetStatus(procedure.Status).
			SetProcedureType(procedure.ProcedureType).
			SetDetails(procedure.Details).
			SetApprovalRequired(procedure.ApprovalRequired).
			SetReviewDue(procedure.ReviewDue).
			SetReviewFrequency(procedure.ReviewFrequency).
			SetApproverID(procedure.ApproverID).
			SetDelegateID(procedure.DelegateID).
			SetSummary(procedure.Summary).
			SetTagSuggestions(procedure.TagSuggestions).
			SetDismissedTagSuggestions(procedure.DismissedTagSuggestions).
			SetControlSuggestions(procedure.ControlSuggestions).
			SetDismissedControlSuggestions(procedure.DismissedControlSuggestions).
			SetImprovementSuggestions(procedure.ImprovementSuggestions).
			SetDismissedImprovementSuggestions(procedure.DismissedImprovementSuggestions).
			SetNillableURL(procedure.URL).
			SetNillableFileID(procedure.FileID).
			SetSystemOwned(procedure.SystemOwned).
			SetNillableInternalNotes(procedure.InternalNotes).
			SetNillableSystemInternalID(procedure.SystemInternalID).
			SetProcedureKindName(procedure.ProcedureKindName).
			SetProcedureKindID(procedure.ProcedureKindID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ProgramMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ProgramHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if programKindName, exists := m.ProgramKindName(); exists {
		create = create.SetProgramKindName(programKindName)
	}

	if programKindID, exists := m.ProgramKindID(); exists {
		create = create.SetProgramKindID(programKindID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if programType, exists := m.ProgramType(); exists {
		create = create.SetProgramType(programType)
	}

	if frameworkName, exists := m.FrameworkName(); exists {
		create = create.SetFrameworkName(frameworkName)
	}

	if startDate, exists := m.StartDate(); exists {
		create = create.SetStartDate(startDate)
	}

	if endDate, exists := m.EndDate(); exists {
		create = create.SetEndDate(endDate)
	}

	if auditorReady, exists := m.AuditorReady(); exists {
		create = create.SetAuditorReady(auditorReady)
	}

	if auditorWriteComments, exists := m.AuditorWriteComments(); exists {
		create = create.SetAuditorWriteComments(auditorWriteComments)
	}

	if auditorReadComments, exists := m.AuditorReadComments(); exists {
		create = create.SetAuditorReadComments(auditorReadComments)
	}

	if auditFirm, exists := m.AuditFirm(); exists {
		create = create.SetAuditFirm(auditFirm)
	}

	if auditor, exists := m.Auditor(); exists {
		create = create.SetAuditor(auditor)
	}

	if auditorEmail, exists := m.AuditorEmail(); exists {
		create = create.SetAuditorEmail(auditorEmail)
	}

	if programOwnerID, exists := m.ProgramOwnerID(); exists {
		create = create.SetProgramOwnerID(programOwnerID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ProgramMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		program, err := client.Program.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ProgramHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(program.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(program.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(program.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(program.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(program.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(program.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(program.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(program.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(program.OwnerID)
		}

		if programKindName, exists := m.ProgramKindName(); exists {
			create = create.SetProgramKindName(programKindName)
		} else {
			create = create.SetProgramKindName(program.ProgramKindName)
		}

		if programKindID, exists := m.ProgramKindID(); exists {
			create = create.SetProgramKindID(programKindID)
		} else {
			create = create.SetProgramKindID(program.ProgramKindID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(program.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(program.Description)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(program.Status)
		}

		if programType, exists := m.ProgramType(); exists {
			create = create.SetProgramType(programType)
		} else {
			create = create.SetProgramType(program.ProgramType)
		}

		if frameworkName, exists := m.FrameworkName(); exists {
			create = create.SetFrameworkName(frameworkName)
		} else {
			create = create.SetFrameworkName(program.FrameworkName)
		}

		if startDate, exists := m.StartDate(); exists {
			create = create.SetStartDate(startDate)
		} else {
			create = create.SetStartDate(program.StartDate)
		}

		if endDate, exists := m.EndDate(); exists {
			create = create.SetEndDate(endDate)
		} else {
			create = create.SetEndDate(program.EndDate)
		}

		if auditorReady, exists := m.AuditorReady(); exists {
			create = create.SetAuditorReady(auditorReady)
		} else {
			create = create.SetAuditorReady(program.AuditorReady)
		}

		if auditorWriteComments, exists := m.AuditorWriteComments(); exists {
			create = create.SetAuditorWriteComments(auditorWriteComments)
		} else {
			create = create.SetAuditorWriteComments(program.AuditorWriteComments)
		}

		if auditorReadComments, exists := m.AuditorReadComments(); exists {
			create = create.SetAuditorReadComments(auditorReadComments)
		} else {
			create = create.SetAuditorReadComments(program.AuditorReadComments)
		}

		if auditFirm, exists := m.AuditFirm(); exists {
			create = create.SetAuditFirm(auditFirm)
		} else {
			create = create.SetAuditFirm(program.AuditFirm)
		}

		if auditor, exists := m.Auditor(); exists {
			create = create.SetAuditor(auditor)
		} else {
			create = create.SetAuditor(program.Auditor)
		}

		if auditorEmail, exists := m.AuditorEmail(); exists {
			create = create.SetAuditorEmail(auditorEmail)
		} else {
			create = create.SetAuditorEmail(program.AuditorEmail)
		}

		if programOwnerID, exists := m.ProgramOwnerID(); exists {
			create = create.SetProgramOwnerID(programOwnerID)
		} else {
			create = create.SetProgramOwnerID(program.ProgramOwnerID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ProgramMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		program, err := client.Program.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ProgramHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(program.CreatedAt).
			SetUpdatedAt(program.UpdatedAt).
			SetCreatedBy(program.CreatedBy).
			SetUpdatedBy(program.UpdatedBy).
			SetDeletedAt(program.DeletedAt).
			SetDeletedBy(program.DeletedBy).
			SetDisplayID(program.DisplayID).
			SetTags(program.Tags).
			SetOwnerID(program.OwnerID).
			SetProgramKindName(program.ProgramKindName).
			SetProgramKindID(program.ProgramKindID).
			SetName(program.Name).
			SetDescription(program.Description).
			SetStatus(program.Status).
			SetProgramType(program.ProgramType).
			SetFrameworkName(program.FrameworkName).
			SetStartDate(program.StartDate).
			SetEndDate(program.EndDate).
			SetAuditorReady(program.AuditorReady).
			SetAuditorWriteComments(program.AuditorWriteComments).
			SetAuditorReadComments(program.AuditorReadComments).
			SetAuditFirm(program.AuditFirm).
			SetAuditor(program.Auditor).
			SetAuditorEmail(program.AuditorEmail).
			SetProgramOwnerID(program.ProgramOwnerID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ProgramMembershipMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ProgramMembershipHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	}

	if programID, exists := m.ProgramID(); exists {
		create = create.SetProgramID(programID)
	}

	if userID, exists := m.UserID(); exists {
		create = create.SetUserID(userID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ProgramMembershipMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		programmembership, err := client.ProgramMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ProgramMembershipHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(programmembership.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(programmembership.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(programmembership.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(programmembership.UpdatedBy)
		}

		if role, exists := m.Role(); exists {
			create = create.SetRole(role)
		} else {
			create = create.SetRole(programmembership.Role)
		}

		if programID, exists := m.ProgramID(); exists {
			create = create.SetProgramID(programID)
		} else {
			create = create.SetProgramID(programmembership.ProgramID)
		}

		if userID, exists := m.UserID(); exists {
			create = create.SetUserID(userID)
		} else {
			create = create.SetUserID(programmembership.UserID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ProgramMembershipMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		programmembership, err := client.ProgramMembership.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ProgramMembershipHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(programmembership.CreatedAt).
			SetUpdatedAt(programmembership.UpdatedAt).
			SetCreatedBy(programmembership.CreatedBy).
			SetUpdatedBy(programmembership.UpdatedBy).
			SetRole(programmembership.Role).
			SetProgramID(programmembership.ProgramID).
			SetUserID(programmembership.UserID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *RemediationMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.RemediationHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if externalID, exists := m.ExternalID(); exists {
		create = create.SetExternalID(externalID)
	}

	if externalOwnerID, exists := m.ExternalOwnerID(); exists {
		create = create.SetExternalOwnerID(externalOwnerID)
	}

	if title, exists := m.Title(); exists {
		create = create.SetTitle(title)
	}

	if state, exists := m.State(); exists {
		create = create.SetState(state)
	}

	if intent, exists := m.Intent(); exists {
		create = create.SetIntent(intent)
	}

	if summary, exists := m.Summary(); exists {
		create = create.SetSummary(summary)
	}

	if explanation, exists := m.Explanation(); exists {
		create = create.SetExplanation(explanation)
	}

	if instructions, exists := m.Instructions(); exists {
		create = create.SetInstructions(instructions)
	}

	if ownerReference, exists := m.OwnerReference(); exists {
		create = create.SetOwnerReference(ownerReference)
	}

	if repositoryURI, exists := m.RepositoryURI(); exists {
		create = create.SetRepositoryURI(repositoryURI)
	}

	if pullRequestURI, exists := m.PullRequestURI(); exists {
		create = create.SetPullRequestURI(pullRequestURI)
	}

	if ticketReference, exists := m.TicketReference(); exists {
		create = create.SetTicketReference(ticketReference)
	}

	if dueAt, exists := m.DueAt(); exists {
		create = create.SetNillableDueAt(&dueAt)
	}

	if completedAt, exists := m.CompletedAt(); exists {
		create = create.SetNillableCompletedAt(&completedAt)
	}

	if prGeneratedAt, exists := m.PrGeneratedAt(); exists {
		create = create.SetNillablePrGeneratedAt(&prGeneratedAt)
	}

	if error, exists := m.Error(); exists {
		create = create.SetError(error)
	}

	if source, exists := m.Source(); exists {
		create = create.SetSource(source)
	}

	if externalURI, exists := m.ExternalURI(); exists {
		create = create.SetExternalURI(externalURI)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *RemediationMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		remediation, err := client.Remediation.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.RemediationHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(remediation.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(remediation.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(remediation.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(remediation.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(remediation.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(remediation.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(remediation.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(remediation.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(remediation.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(remediation.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(remediation.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(remediation.SystemInternalID)
		}

		if externalID, exists := m.ExternalID(); exists {
			create = create.SetExternalID(externalID)
		} else {
			create = create.SetExternalID(remediation.ExternalID)
		}

		if externalOwnerID, exists := m.ExternalOwnerID(); exists {
			create = create.SetExternalOwnerID(externalOwnerID)
		} else {
			create = create.SetExternalOwnerID(remediation.ExternalOwnerID)
		}

		if title, exists := m.Title(); exists {
			create = create.SetTitle(title)
		} else {
			create = create.SetTitle(remediation.Title)
		}

		if state, exists := m.State(); exists {
			create = create.SetState(state)
		} else {
			create = create.SetState(remediation.State)
		}

		if intent, exists := m.Intent(); exists {
			create = create.SetIntent(intent)
		} else {
			create = create.SetIntent(remediation.Intent)
		}

		if summary, exists := m.Summary(); exists {
			create = create.SetSummary(summary)
		} else {
			create = create.SetSummary(remediation.Summary)
		}

		if explanation, exists := m.Explanation(); exists {
			create = create.SetExplanation(explanation)
		} else {
			create = create.SetExplanation(remediation.Explanation)
		}

		if instructions, exists := m.Instructions(); exists {
			create = create.SetInstructions(instructions)
		} else {
			create = create.SetInstructions(remediation.Instructions)
		}

		if ownerReference, exists := m.OwnerReference(); exists {
			create = create.SetOwnerReference(ownerReference)
		} else {
			create = create.SetOwnerReference(remediation.OwnerReference)
		}

		if repositoryURI, exists := m.RepositoryURI(); exists {
			create = create.SetRepositoryURI(repositoryURI)
		} else {
			create = create.SetRepositoryURI(remediation.RepositoryURI)
		}

		if pullRequestURI, exists := m.PullRequestURI(); exists {
			create = create.SetPullRequestURI(pullRequestURI)
		} else {
			create = create.SetPullRequestURI(remediation.PullRequestURI)
		}

		if ticketReference, exists := m.TicketReference(); exists {
			create = create.SetTicketReference(ticketReference)
		} else {
			create = create.SetTicketReference(remediation.TicketReference)
		}

		if dueAt, exists := m.DueAt(); exists {
			create = create.SetNillableDueAt(&dueAt)
		} else {
			create = create.SetNillableDueAt(remediation.DueAt)
		}

		if completedAt, exists := m.CompletedAt(); exists {
			create = create.SetNillableCompletedAt(&completedAt)
		} else {
			create = create.SetNillableCompletedAt(remediation.CompletedAt)
		}

		if prGeneratedAt, exists := m.PrGeneratedAt(); exists {
			create = create.SetNillablePrGeneratedAt(&prGeneratedAt)
		} else {
			create = create.SetNillablePrGeneratedAt(remediation.PrGeneratedAt)
		}

		if error, exists := m.Error(); exists {
			create = create.SetError(error)
		} else {
			create = create.SetError(remediation.Error)
		}

		if source, exists := m.Source(); exists {
			create = create.SetSource(source)
		} else {
			create = create.SetSource(remediation.Source)
		}

		if externalURI, exists := m.ExternalURI(); exists {
			create = create.SetExternalURI(externalURI)
		} else {
			create = create.SetExternalURI(remediation.ExternalURI)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(remediation.Metadata)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *RemediationMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		remediation, err := client.Remediation.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.RemediationHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(remediation.CreatedAt).
			SetUpdatedAt(remediation.UpdatedAt).
			SetCreatedBy(remediation.CreatedBy).
			SetUpdatedBy(remediation.UpdatedBy).
			SetDeletedAt(remediation.DeletedAt).
			SetDeletedBy(remediation.DeletedBy).
			SetDisplayID(remediation.DisplayID).
			SetTags(remediation.Tags).
			SetOwnerID(remediation.OwnerID).
			SetSystemOwned(remediation.SystemOwned).
			SetNillableInternalNotes(remediation.InternalNotes).
			SetNillableSystemInternalID(remediation.SystemInternalID).
			SetExternalID(remediation.ExternalID).
			SetExternalOwnerID(remediation.ExternalOwnerID).
			SetTitle(remediation.Title).
			SetState(remediation.State).
			SetIntent(remediation.Intent).
			SetSummary(remediation.Summary).
			SetExplanation(remediation.Explanation).
			SetInstructions(remediation.Instructions).
			SetOwnerReference(remediation.OwnerReference).
			SetRepositoryURI(remediation.RepositoryURI).
			SetPullRequestURI(remediation.PullRequestURI).
			SetTicketReference(remediation.TicketReference).
			SetNillableDueAt(remediation.DueAt).
			SetNillableCompletedAt(remediation.CompletedAt).
			SetNillablePrGeneratedAt(remediation.PrGeneratedAt).
			SetError(remediation.Error).
			SetSource(remediation.Source).
			SetExternalURI(remediation.ExternalURI).
			SetMetadata(remediation.Metadata).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ReviewMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ReviewHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if externalID, exists := m.ExternalID(); exists {
		create = create.SetExternalID(externalID)
	}

	if externalOwnerID, exists := m.ExternalOwnerID(); exists {
		create = create.SetExternalOwnerID(externalOwnerID)
	}

	if title, exists := m.Title(); exists {
		create = create.SetTitle(title)
	}

	if state, exists := m.State(); exists {
		create = create.SetState(state)
	}

	if category, exists := m.Category(); exists {
		create = create.SetCategory(category)
	}

	if classification, exists := m.Classification(); exists {
		create = create.SetClassification(classification)
	}

	if summary, exists := m.Summary(); exists {
		create = create.SetSummary(summary)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	if reporter, exists := m.Reporter(); exists {
		create = create.SetReporter(reporter)
	}

	if approved, exists := m.Approved(); exists {
		create = create.SetApproved(approved)
	}

	if reviewedAt, exists := m.ReviewedAt(); exists {
		create = create.SetNillableReviewedAt(&reviewedAt)
	}

	if reportedAt, exists := m.ReportedAt(); exists {
		create = create.SetNillableReportedAt(&reportedAt)
	}

	if approvedAt, exists := m.ApprovedAt(); exists {
		create = create.SetNillableApprovedAt(&approvedAt)
	}

	if reviewerID, exists := m.ReviewerID(); exists {
		create = create.SetReviewerID(reviewerID)
	}

	if source, exists := m.Source(); exists {
		create = create.SetSource(source)
	}

	if externalURI, exists := m.ExternalURI(); exists {
		create = create.SetExternalURI(externalURI)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	if rawPayload, exists := m.RawPayload(); exists {
		create = create.SetRawPayload(rawPayload)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ReviewMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		review, err := client.Review.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ReviewHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(review.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(review.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(review.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(review.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(review.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(review.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(review.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(review.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(review.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(review.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(review.SystemInternalID)
		}

		if externalID, exists := m.ExternalID(); exists {
			create = create.SetExternalID(externalID)
		} else {
			create = create.SetExternalID(review.ExternalID)
		}

		if externalOwnerID, exists := m.ExternalOwnerID(); exists {
			create = create.SetExternalOwnerID(externalOwnerID)
		} else {
			create = create.SetExternalOwnerID(review.ExternalOwnerID)
		}

		if title, exists := m.Title(); exists {
			create = create.SetTitle(title)
		} else {
			create = create.SetTitle(review.Title)
		}

		if state, exists := m.State(); exists {
			create = create.SetState(state)
		} else {
			create = create.SetState(review.State)
		}

		if category, exists := m.Category(); exists {
			create = create.SetCategory(category)
		} else {
			create = create.SetCategory(review.Category)
		}

		if classification, exists := m.Classification(); exists {
			create = create.SetClassification(classification)
		} else {
			create = create.SetClassification(review.Classification)
		}

		if summary, exists := m.Summary(); exists {
			create = create.SetSummary(summary)
		} else {
			create = create.SetSummary(review.Summary)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(review.Details)
		}

		if reporter, exists := m.Reporter(); exists {
			create = create.SetReporter(reporter)
		} else {
			create = create.SetReporter(review.Reporter)
		}

		if approved, exists := m.Approved(); exists {
			create = create.SetApproved(approved)
		} else {
			create = create.SetApproved(review.Approved)
		}

		if reviewedAt, exists := m.ReviewedAt(); exists {
			create = create.SetNillableReviewedAt(&reviewedAt)
		} else {
			create = create.SetNillableReviewedAt(review.ReviewedAt)
		}

		if reportedAt, exists := m.ReportedAt(); exists {
			create = create.SetNillableReportedAt(&reportedAt)
		} else {
			create = create.SetNillableReportedAt(review.ReportedAt)
		}

		if approvedAt, exists := m.ApprovedAt(); exists {
			create = create.SetNillableApprovedAt(&approvedAt)
		} else {
			create = create.SetNillableApprovedAt(review.ApprovedAt)
		}

		if reviewerID, exists := m.ReviewerID(); exists {
			create = create.SetReviewerID(reviewerID)
		} else {
			create = create.SetReviewerID(review.ReviewerID)
		}

		if source, exists := m.Source(); exists {
			create = create.SetSource(source)
		} else {
			create = create.SetSource(review.Source)
		}

		if externalURI, exists := m.ExternalURI(); exists {
			create = create.SetExternalURI(externalURI)
		} else {
			create = create.SetExternalURI(review.ExternalURI)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(review.Metadata)
		}

		if rawPayload, exists := m.RawPayload(); exists {
			create = create.SetRawPayload(rawPayload)
		} else {
			create = create.SetRawPayload(review.RawPayload)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ReviewMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		review, err := client.Review.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ReviewHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(review.CreatedAt).
			SetUpdatedAt(review.UpdatedAt).
			SetCreatedBy(review.CreatedBy).
			SetUpdatedBy(review.UpdatedBy).
			SetDeletedAt(review.DeletedAt).
			SetDeletedBy(review.DeletedBy).
			SetTags(review.Tags).
			SetOwnerID(review.OwnerID).
			SetSystemOwned(review.SystemOwned).
			SetNillableInternalNotes(review.InternalNotes).
			SetNillableSystemInternalID(review.SystemInternalID).
			SetExternalID(review.ExternalID).
			SetExternalOwnerID(review.ExternalOwnerID).
			SetTitle(review.Title).
			SetState(review.State).
			SetCategory(review.Category).
			SetClassification(review.Classification).
			SetSummary(review.Summary).
			SetDetails(review.Details).
			SetReporter(review.Reporter).
			SetApproved(review.Approved).
			SetNillableReviewedAt(review.ReviewedAt).
			SetNillableReportedAt(review.ReportedAt).
			SetNillableApprovedAt(review.ApprovedAt).
			SetReviewerID(review.ReviewerID).
			SetSource(review.Source).
			SetExternalURI(review.ExternalURI).
			SetMetadata(review.Metadata).
			SetRawPayload(review.RawPayload).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *RiskMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.RiskHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if riskKindName, exists := m.RiskKindName(); exists {
		create = create.SetRiskKindName(riskKindName)
	}

	if riskKindID, exists := m.RiskKindID(); exists {
		create = create.SetRiskKindID(riskKindID)
	}

	if riskCategoryName, exists := m.RiskCategoryName(); exists {
		create = create.SetRiskCategoryName(riskCategoryName)
	}

	if riskCategoryID, exists := m.RiskCategoryID(); exists {
		create = create.SetRiskCategoryID(riskCategoryID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if riskType, exists := m.RiskType(); exists {
		create = create.SetRiskType(riskType)
	}

	if category, exists := m.Category(); exists {
		create = create.SetCategory(category)
	}

	if impact, exists := m.Impact(); exists {
		create = create.SetImpact(impact)
	}

	if likelihood, exists := m.Likelihood(); exists {
		create = create.SetLikelihood(likelihood)
	}

	if score, exists := m.Score(); exists {
		create = create.SetScore(score)
	}

	if mitigation, exists := m.Mitigation(); exists {
		create = create.SetMitigation(mitigation)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	if businessCosts, exists := m.BusinessCosts(); exists {
		create = create.SetBusinessCosts(businessCosts)
	}

	if stakeholderID, exists := m.StakeholderID(); exists {
		create = create.SetStakeholderID(stakeholderID)
	}

	if delegateID, exists := m.DelegateID(); exists {
		create = create.SetDelegateID(delegateID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *RiskMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		risk, err := client.Risk.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.RiskHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(risk.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(risk.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(risk.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(risk.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(risk.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(risk.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(risk.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(risk.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(risk.OwnerID)
		}

		if riskKindName, exists := m.RiskKindName(); exists {
			create = create.SetRiskKindName(riskKindName)
		} else {
			create = create.SetRiskKindName(risk.RiskKindName)
		}

		if riskKindID, exists := m.RiskKindID(); exists {
			create = create.SetRiskKindID(riskKindID)
		} else {
			create = create.SetRiskKindID(risk.RiskKindID)
		}

		if riskCategoryName, exists := m.RiskCategoryName(); exists {
			create = create.SetRiskCategoryName(riskCategoryName)
		} else {
			create = create.SetRiskCategoryName(risk.RiskCategoryName)
		}

		if riskCategoryID, exists := m.RiskCategoryID(); exists {
			create = create.SetRiskCategoryID(riskCategoryID)
		} else {
			create = create.SetRiskCategoryID(risk.RiskCategoryID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(risk.Name)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(risk.Status)
		}

		if riskType, exists := m.RiskType(); exists {
			create = create.SetRiskType(riskType)
		} else {
			create = create.SetRiskType(risk.RiskType)
		}

		if category, exists := m.Category(); exists {
			create = create.SetCategory(category)
		} else {
			create = create.SetCategory(risk.Category)
		}

		if impact, exists := m.Impact(); exists {
			create = create.SetImpact(impact)
		} else {
			create = create.SetImpact(risk.Impact)
		}

		if likelihood, exists := m.Likelihood(); exists {
			create = create.SetLikelihood(likelihood)
		} else {
			create = create.SetLikelihood(risk.Likelihood)
		}

		if score, exists := m.Score(); exists {
			create = create.SetScore(score)
		} else {
			create = create.SetScore(risk.Score)
		}

		if mitigation, exists := m.Mitigation(); exists {
			create = create.SetMitigation(mitigation)
		} else {
			create = create.SetMitigation(risk.Mitigation)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(risk.Details)
		}

		if businessCosts, exists := m.BusinessCosts(); exists {
			create = create.SetBusinessCosts(businessCosts)
		} else {
			create = create.SetBusinessCosts(risk.BusinessCosts)
		}

		if stakeholderID, exists := m.StakeholderID(); exists {
			create = create.SetStakeholderID(stakeholderID)
		} else {
			create = create.SetStakeholderID(risk.StakeholderID)
		}

		if delegateID, exists := m.DelegateID(); exists {
			create = create.SetDelegateID(delegateID)
		} else {
			create = create.SetDelegateID(risk.DelegateID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *RiskMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		risk, err := client.Risk.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.RiskHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(risk.CreatedAt).
			SetUpdatedAt(risk.UpdatedAt).
			SetCreatedBy(risk.CreatedBy).
			SetUpdatedBy(risk.UpdatedBy).
			SetDeletedAt(risk.DeletedAt).
			SetDeletedBy(risk.DeletedBy).
			SetDisplayID(risk.DisplayID).
			SetTags(risk.Tags).
			SetOwnerID(risk.OwnerID).
			SetRiskKindName(risk.RiskKindName).
			SetRiskKindID(risk.RiskKindID).
			SetRiskCategoryName(risk.RiskCategoryName).
			SetRiskCategoryID(risk.RiskCategoryID).
			SetName(risk.Name).
			SetStatus(risk.Status).
			SetRiskType(risk.RiskType).
			SetCategory(risk.Category).
			SetImpact(risk.Impact).
			SetLikelihood(risk.Likelihood).
			SetScore(risk.Score).
			SetMitigation(risk.Mitigation).
			SetDetails(risk.Details).
			SetBusinessCosts(risk.BusinessCosts).
			SetStakeholderID(risk.StakeholderID).
			SetDelegateID(risk.DelegateID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ScanMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ScanHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if target, exists := m.Target(); exists {
		create = create.SetTarget(target)
	}

	if scanType, exists := m.ScanType(); exists {
		create = create.SetScanType(scanType)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ScanMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		scan, err := client.Scan.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ScanHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(scan.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(scan.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(scan.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(scan.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(scan.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(scan.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(scan.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(scan.OwnerID)
		}

		if target, exists := m.Target(); exists {
			create = create.SetTarget(target)
		} else {
			create = create.SetTarget(scan.Target)
		}

		if scanType, exists := m.ScanType(); exists {
			create = create.SetScanType(scanType)
		} else {
			create = create.SetScanType(scan.ScanType)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(scan.Metadata)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(scan.Status)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ScanMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		scan, err := client.Scan.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ScanHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(scan.CreatedAt).
			SetUpdatedAt(scan.UpdatedAt).
			SetCreatedBy(scan.CreatedBy).
			SetUpdatedBy(scan.UpdatedBy).
			SetDeletedAt(scan.DeletedAt).
			SetDeletedBy(scan.DeletedBy).
			SetTags(scan.Tags).
			SetOwnerID(scan.OwnerID).
			SetTarget(scan.Target).
			SetScanType(scan.ScanType).
			SetMetadata(scan.Metadata).
			SetStatus(scan.Status).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *ScheduledJobMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.ScheduledJobHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if jobID, exists := m.JobID(); exists {
		create = create.SetJobID(jobID)
	}

	if active, exists := m.Active(); exists {
		create = create.SetActive(active)
	}

	if configuration, exists := m.Configuration(); exists {
		create = create.SetConfiguration(configuration)
	}

	if cron, exists := m.Cron(); exists {
		create = create.SetNillableCron(&cron)
	}

	if jobRunnerID, exists := m.JobRunnerID(); exists {
		create = create.SetJobRunnerID(jobRunnerID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *ScheduledJobMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		scheduledjob, err := client.ScheduledJob.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ScheduledJobHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(scheduledjob.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(scheduledjob.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(scheduledjob.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(scheduledjob.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(scheduledjob.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(scheduledjob.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(scheduledjob.DisplayID)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(scheduledjob.OwnerID)
		}

		if jobID, exists := m.JobID(); exists {
			create = create.SetJobID(jobID)
		} else {
			create = create.SetJobID(scheduledjob.JobID)
		}

		if active, exists := m.Active(); exists {
			create = create.SetActive(active)
		} else {
			create = create.SetActive(scheduledjob.Active)
		}

		if configuration, exists := m.Configuration(); exists {
			create = create.SetConfiguration(configuration)
		} else {
			create = create.SetConfiguration(scheduledjob.Configuration)
		}

		if cron, exists := m.Cron(); exists {
			create = create.SetNillableCron(&cron)
		} else {
			create = create.SetNillableCron(scheduledjob.Cron)
		}

		if jobRunnerID, exists := m.JobRunnerID(); exists {
			create = create.SetJobRunnerID(jobRunnerID)
		} else {
			create = create.SetJobRunnerID(scheduledjob.JobRunnerID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *ScheduledJobMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		scheduledjob, err := client.ScheduledJob.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.ScheduledJobHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(scheduledjob.CreatedAt).
			SetUpdatedAt(scheduledjob.UpdatedAt).
			SetCreatedBy(scheduledjob.CreatedBy).
			SetUpdatedBy(scheduledjob.UpdatedBy).
			SetDeletedAt(scheduledjob.DeletedAt).
			SetDeletedBy(scheduledjob.DeletedBy).
			SetDisplayID(scheduledjob.DisplayID).
			SetOwnerID(scheduledjob.OwnerID).
			SetJobID(scheduledjob.JobID).
			SetActive(scheduledjob.Active).
			SetConfiguration(scheduledjob.Configuration).
			SetNillableCron(scheduledjob.Cron).
			SetJobRunnerID(scheduledjob.JobRunnerID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *StandardMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.StandardHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if revision, exists := m.Revision(); exists {
		create = create.SetRevision(revision)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if shortName, exists := m.ShortName(); exists {
		create = create.SetShortName(shortName)
	}

	if framework, exists := m.Framework(); exists {
		create = create.SetFramework(framework)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if governingBodyLogoURL, exists := m.GoverningBodyLogoURL(); exists {
		create = create.SetGoverningBodyLogoURL(governingBodyLogoURL)
	}

	if governingBody, exists := m.GoverningBody(); exists {
		create = create.SetGoverningBody(governingBody)
	}

	if domains, exists := m.Domains(); exists {
		create = create.SetDomains(domains)
	}

	if link, exists := m.Link(); exists {
		create = create.SetLink(link)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if isPublic, exists := m.IsPublic(); exists {
		create = create.SetIsPublic(isPublic)
	}

	if freeToUse, exists := m.FreeToUse(); exists {
		create = create.SetFreeToUse(freeToUse)
	}

	if standardType, exists := m.StandardType(); exists {
		create = create.SetStandardType(standardType)
	}

	if version, exists := m.Version(); exists {
		create = create.SetVersion(version)
	}

	if logoFileID, exists := m.LogoFileID(); exists {
		create = create.SetNillableLogoFileID(&logoFileID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *StandardMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		standard, err := client.Standard.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.StandardHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(standard.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(standard.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(standard.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(standard.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(standard.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(standard.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(standard.Tags)
		}

		if revision, exists := m.Revision(); exists {
			create = create.SetRevision(revision)
		} else {
			create = create.SetRevision(standard.Revision)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(standard.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(standard.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(standard.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(standard.SystemInternalID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(standard.Name)
		}

		if shortName, exists := m.ShortName(); exists {
			create = create.SetShortName(shortName)
		} else {
			create = create.SetShortName(standard.ShortName)
		}

		if framework, exists := m.Framework(); exists {
			create = create.SetFramework(framework)
		} else {
			create = create.SetFramework(standard.Framework)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(standard.Description)
		}

		if governingBodyLogoURL, exists := m.GoverningBodyLogoURL(); exists {
			create = create.SetGoverningBodyLogoURL(governingBodyLogoURL)
		} else {
			create = create.SetGoverningBodyLogoURL(standard.GoverningBodyLogoURL)
		}

		if governingBody, exists := m.GoverningBody(); exists {
			create = create.SetGoverningBody(governingBody)
		} else {
			create = create.SetGoverningBody(standard.GoverningBody)
		}

		if domains, exists := m.Domains(); exists {
			create = create.SetDomains(domains)
		} else {
			create = create.SetDomains(standard.Domains)
		}

		if link, exists := m.Link(); exists {
			create = create.SetLink(link)
		} else {
			create = create.SetLink(standard.Link)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(standard.Status)
		}

		if isPublic, exists := m.IsPublic(); exists {
			create = create.SetIsPublic(isPublic)
		} else {
			create = create.SetIsPublic(standard.IsPublic)
		}

		if freeToUse, exists := m.FreeToUse(); exists {
			create = create.SetFreeToUse(freeToUse)
		} else {
			create = create.SetFreeToUse(standard.FreeToUse)
		}

		if standardType, exists := m.StandardType(); exists {
			create = create.SetStandardType(standardType)
		} else {
			create = create.SetStandardType(standard.StandardType)
		}

		if version, exists := m.Version(); exists {
			create = create.SetVersion(version)
		} else {
			create = create.SetVersion(standard.Version)
		}

		if logoFileID, exists := m.LogoFileID(); exists {
			create = create.SetNillableLogoFileID(&logoFileID)
		} else {
			create = create.SetNillableLogoFileID(standard.LogoFileID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *StandardMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		standard, err := client.Standard.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.StandardHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(standard.CreatedAt).
			SetUpdatedAt(standard.UpdatedAt).
			SetCreatedBy(standard.CreatedBy).
			SetUpdatedBy(standard.UpdatedBy).
			SetDeletedAt(standard.DeletedAt).
			SetDeletedBy(standard.DeletedBy).
			SetTags(standard.Tags).
			SetRevision(standard.Revision).
			SetOwnerID(standard.OwnerID).
			SetSystemOwned(standard.SystemOwned).
			SetNillableInternalNotes(standard.InternalNotes).
			SetNillableSystemInternalID(standard.SystemInternalID).
			SetName(standard.Name).
			SetShortName(standard.ShortName).
			SetFramework(standard.Framework).
			SetDescription(standard.Description).
			SetGoverningBodyLogoURL(standard.GoverningBodyLogoURL).
			SetGoverningBody(standard.GoverningBody).
			SetDomains(standard.Domains).
			SetLink(standard.Link).
			SetStatus(standard.Status).
			SetIsPublic(standard.IsPublic).
			SetFreeToUse(standard.FreeToUse).
			SetStandardType(standard.StandardType).
			SetVersion(standard.Version).
			SetNillableLogoFileID(standard.LogoFileID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *SubcontrolMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.SubcontrolHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if title, exists := m.Title(); exists {
		create = create.SetTitle(title)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if aliases, exists := m.Aliases(); exists {
		create = create.SetAliases(aliases)
	}

	if referenceID, exists := m.ReferenceID(); exists {
		create = create.SetReferenceID(referenceID)
	}

	if auditorReferenceID, exists := m.AuditorReferenceID(); exists {
		create = create.SetAuditorReferenceID(auditorReferenceID)
	}

	if responsiblePartyID, exists := m.ResponsiblePartyID(); exists {
		create = create.SetResponsiblePartyID(responsiblePartyID)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if source, exists := m.Source(); exists {
		create = create.SetSource(source)
	}

	if referenceFramework, exists := m.ReferenceFramework(); exists {
		create = create.SetNillableReferenceFramework(&referenceFramework)
	}

	if referenceFrameworkRevision, exists := m.ReferenceFrameworkRevision(); exists {
		create = create.SetNillableReferenceFrameworkRevision(&referenceFrameworkRevision)
	}

	if controlType, exists := m.ControlType(); exists {
		create = create.SetControlType(controlType)
	}

	if category, exists := m.Category(); exists {
		create = create.SetCategory(category)
	}

	if categoryID, exists := m.CategoryID(); exists {
		create = create.SetCategoryID(categoryID)
	}

	if subcategory, exists := m.Subcategory(); exists {
		create = create.SetSubcategory(subcategory)
	}

	if mappedCategories, exists := m.MappedCategories(); exists {
		create = create.SetMappedCategories(mappedCategories)
	}

	if assessmentObjectives, exists := m.AssessmentObjectives(); exists {
		create = create.SetAssessmentObjectives(assessmentObjectives)
	}

	if assessmentMethods, exists := m.AssessmentMethods(); exists {
		create = create.SetAssessmentMethods(assessmentMethods)
	}

	if controlQuestions, exists := m.ControlQuestions(); exists {
		create = create.SetControlQuestions(controlQuestions)
	}

	if implementationGuidance, exists := m.ImplementationGuidance(); exists {
		create = create.SetImplementationGuidance(implementationGuidance)
	}

	if exampleEvidence, exists := m.ExampleEvidence(); exists {
		create = create.SetExampleEvidence(exampleEvidence)
	}

	if references, exists := m.References(); exists {
		create = create.SetReferences(references)
	}

	if controlOwnerID, exists := m.ControlOwnerID(); exists {
		create = create.SetNillableControlOwnerID(&controlOwnerID)
	}

	if delegateID, exists := m.DelegateID(); exists {
		create = create.SetDelegateID(delegateID)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if subcontrolKindName, exists := m.SubcontrolKindName(); exists {
		create = create.SetSubcontrolKindName(subcontrolKindName)
	}

	if subcontrolKindID, exists := m.SubcontrolKindID(); exists {
		create = create.SetSubcontrolKindID(subcontrolKindID)
	}

	if refCode, exists := m.RefCode(); exists {
		create = create.SetRefCode(refCode)
	}

	if controlID, exists := m.ControlID(); exists {
		create = create.SetControlID(controlID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *SubcontrolMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		subcontrol, err := client.Subcontrol.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.SubcontrolHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(subcontrol.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(subcontrol.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(subcontrol.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(subcontrol.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(subcontrol.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(subcontrol.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(subcontrol.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(subcontrol.Tags)
		}

		if title, exists := m.Title(); exists {
			create = create.SetTitle(title)
		} else {
			create = create.SetTitle(subcontrol.Title)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(subcontrol.Description)
		}

		if aliases, exists := m.Aliases(); exists {
			create = create.SetAliases(aliases)
		} else {
			create = create.SetAliases(subcontrol.Aliases)
		}

		if referenceID, exists := m.ReferenceID(); exists {
			create = create.SetReferenceID(referenceID)
		} else {
			create = create.SetReferenceID(subcontrol.ReferenceID)
		}

		if auditorReferenceID, exists := m.AuditorReferenceID(); exists {
			create = create.SetAuditorReferenceID(auditorReferenceID)
		} else {
			create = create.SetAuditorReferenceID(subcontrol.AuditorReferenceID)
		}

		if responsiblePartyID, exists := m.ResponsiblePartyID(); exists {
			create = create.SetResponsiblePartyID(responsiblePartyID)
		} else {
			create = create.SetResponsiblePartyID(subcontrol.ResponsiblePartyID)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(subcontrol.Status)
		}

		if source, exists := m.Source(); exists {
			create = create.SetSource(source)
		} else {
			create = create.SetSource(subcontrol.Source)
		}

		if referenceFramework, exists := m.ReferenceFramework(); exists {
			create = create.SetNillableReferenceFramework(&referenceFramework)
		} else {
			create = create.SetNillableReferenceFramework(subcontrol.ReferenceFramework)
		}

		if referenceFrameworkRevision, exists := m.ReferenceFrameworkRevision(); exists {
			create = create.SetNillableReferenceFrameworkRevision(&referenceFrameworkRevision)
		} else {
			create = create.SetNillableReferenceFrameworkRevision(subcontrol.ReferenceFrameworkRevision)
		}

		if controlType, exists := m.ControlType(); exists {
			create = create.SetControlType(controlType)
		} else {
			create = create.SetControlType(subcontrol.ControlType)
		}

		if category, exists := m.Category(); exists {
			create = create.SetCategory(category)
		} else {
			create = create.SetCategory(subcontrol.Category)
		}

		if categoryID, exists := m.CategoryID(); exists {
			create = create.SetCategoryID(categoryID)
		} else {
			create = create.SetCategoryID(subcontrol.CategoryID)
		}

		if subcategory, exists := m.Subcategory(); exists {
			create = create.SetSubcategory(subcategory)
		} else {
			create = create.SetSubcategory(subcontrol.Subcategory)
		}

		if mappedCategories, exists := m.MappedCategories(); exists {
			create = create.SetMappedCategories(mappedCategories)
		} else {
			create = create.SetMappedCategories(subcontrol.MappedCategories)
		}

		if assessmentObjectives, exists := m.AssessmentObjectives(); exists {
			create = create.SetAssessmentObjectives(assessmentObjectives)
		} else {
			create = create.SetAssessmentObjectives(subcontrol.AssessmentObjectives)
		}

		if assessmentMethods, exists := m.AssessmentMethods(); exists {
			create = create.SetAssessmentMethods(assessmentMethods)
		} else {
			create = create.SetAssessmentMethods(subcontrol.AssessmentMethods)
		}

		if controlQuestions, exists := m.ControlQuestions(); exists {
			create = create.SetControlQuestions(controlQuestions)
		} else {
			create = create.SetControlQuestions(subcontrol.ControlQuestions)
		}

		if implementationGuidance, exists := m.ImplementationGuidance(); exists {
			create = create.SetImplementationGuidance(implementationGuidance)
		} else {
			create = create.SetImplementationGuidance(subcontrol.ImplementationGuidance)
		}

		if exampleEvidence, exists := m.ExampleEvidence(); exists {
			create = create.SetExampleEvidence(exampleEvidence)
		} else {
			create = create.SetExampleEvidence(subcontrol.ExampleEvidence)
		}

		if references, exists := m.References(); exists {
			create = create.SetReferences(references)
		} else {
			create = create.SetReferences(subcontrol.References)
		}

		if controlOwnerID, exists := m.ControlOwnerID(); exists {
			create = create.SetNillableControlOwnerID(&controlOwnerID)
		} else {
			create = create.SetNillableControlOwnerID(subcontrol.ControlOwnerID)
		}

		if delegateID, exists := m.DelegateID(); exists {
			create = create.SetDelegateID(delegateID)
		} else {
			create = create.SetDelegateID(subcontrol.DelegateID)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(subcontrol.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(subcontrol.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(subcontrol.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(subcontrol.SystemInternalID)
		}

		if subcontrolKindName, exists := m.SubcontrolKindName(); exists {
			create = create.SetSubcontrolKindName(subcontrolKindName)
		} else {
			create = create.SetSubcontrolKindName(subcontrol.SubcontrolKindName)
		}

		if subcontrolKindID, exists := m.SubcontrolKindID(); exists {
			create = create.SetSubcontrolKindID(subcontrolKindID)
		} else {
			create = create.SetSubcontrolKindID(subcontrol.SubcontrolKindID)
		}

		if refCode, exists := m.RefCode(); exists {
			create = create.SetRefCode(refCode)
		} else {
			create = create.SetRefCode(subcontrol.RefCode)
		}

		if controlID, exists := m.ControlID(); exists {
			create = create.SetControlID(controlID)
		} else {
			create = create.SetControlID(subcontrol.ControlID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *SubcontrolMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		subcontrol, err := client.Subcontrol.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.SubcontrolHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(subcontrol.CreatedAt).
			SetUpdatedAt(subcontrol.UpdatedAt).
			SetCreatedBy(subcontrol.CreatedBy).
			SetUpdatedBy(subcontrol.UpdatedBy).
			SetDeletedAt(subcontrol.DeletedAt).
			SetDeletedBy(subcontrol.DeletedBy).
			SetDisplayID(subcontrol.DisplayID).
			SetTags(subcontrol.Tags).
			SetTitle(subcontrol.Title).
			SetDescription(subcontrol.Description).
			SetAliases(subcontrol.Aliases).
			SetReferenceID(subcontrol.ReferenceID).
			SetAuditorReferenceID(subcontrol.AuditorReferenceID).
			SetResponsiblePartyID(subcontrol.ResponsiblePartyID).
			SetStatus(subcontrol.Status).
			SetSource(subcontrol.Source).
			SetNillableReferenceFramework(subcontrol.ReferenceFramework).
			SetNillableReferenceFrameworkRevision(subcontrol.ReferenceFrameworkRevision).
			SetControlType(subcontrol.ControlType).
			SetCategory(subcontrol.Category).
			SetCategoryID(subcontrol.CategoryID).
			SetSubcategory(subcontrol.Subcategory).
			SetMappedCategories(subcontrol.MappedCategories).
			SetAssessmentObjectives(subcontrol.AssessmentObjectives).
			SetAssessmentMethods(subcontrol.AssessmentMethods).
			SetControlQuestions(subcontrol.ControlQuestions).
			SetImplementationGuidance(subcontrol.ImplementationGuidance).
			SetExampleEvidence(subcontrol.ExampleEvidence).
			SetReferences(subcontrol.References).
			SetNillableControlOwnerID(subcontrol.ControlOwnerID).
			SetDelegateID(subcontrol.DelegateID).
			SetOwnerID(subcontrol.OwnerID).
			SetSystemOwned(subcontrol.SystemOwned).
			SetNillableInternalNotes(subcontrol.InternalNotes).
			SetNillableSystemInternalID(subcontrol.SystemInternalID).
			SetSubcontrolKindName(subcontrol.SubcontrolKindName).
			SetSubcontrolKindID(subcontrol.SubcontrolKindID).
			SetRefCode(subcontrol.RefCode).
			SetControlID(subcontrol.ControlID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *SubprocessorMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.SubprocessorHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if logoRemoteURL, exists := m.LogoRemoteURL(); exists {
		create = create.SetNillableLogoRemoteURL(&logoRemoteURL)
	}

	if logoFileID, exists := m.LogoFileID(); exists {
		create = create.SetNillableLogoFileID(&logoFileID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *SubprocessorMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		subprocessor, err := client.Subprocessor.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.SubprocessorHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(subprocessor.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(subprocessor.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(subprocessor.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(subprocessor.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(subprocessor.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(subprocessor.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(subprocessor.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(subprocessor.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(subprocessor.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(subprocessor.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(subprocessor.SystemInternalID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(subprocessor.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(subprocessor.Description)
		}

		if logoRemoteURL, exists := m.LogoRemoteURL(); exists {
			create = create.SetNillableLogoRemoteURL(&logoRemoteURL)
		} else {
			create = create.SetNillableLogoRemoteURL(subprocessor.LogoRemoteURL)
		}

		if logoFileID, exists := m.LogoFileID(); exists {
			create = create.SetNillableLogoFileID(&logoFileID)
		} else {
			create = create.SetNillableLogoFileID(subprocessor.LogoFileID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *SubprocessorMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		subprocessor, err := client.Subprocessor.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.SubprocessorHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(subprocessor.CreatedAt).
			SetUpdatedAt(subprocessor.UpdatedAt).
			SetCreatedBy(subprocessor.CreatedBy).
			SetUpdatedBy(subprocessor.UpdatedBy).
			SetDeletedAt(subprocessor.DeletedAt).
			SetDeletedBy(subprocessor.DeletedBy).
			SetTags(subprocessor.Tags).
			SetOwnerID(subprocessor.OwnerID).
			SetSystemOwned(subprocessor.SystemOwned).
			SetNillableInternalNotes(subprocessor.InternalNotes).
			SetNillableSystemInternalID(subprocessor.SystemInternalID).
			SetName(subprocessor.Name).
			SetDescription(subprocessor.Description).
			SetNillableLogoRemoteURL(subprocessor.LogoRemoteURL).
			SetNillableLogoFileID(subprocessor.LogoFileID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *TaskMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.TaskHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if taskKindName, exists := m.TaskKindName(); exists {
		create = create.SetTaskKindName(taskKindName)
	}

	if taskKindID, exists := m.TaskKindID(); exists {
		create = create.SetTaskKindID(taskKindID)
	}

	if title, exists := m.Title(); exists {
		create = create.SetTitle(title)
	}

	if details, exists := m.Details(); exists {
		create = create.SetDetails(details)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if category, exists := m.Category(); exists {
		create = create.SetCategory(category)
	}

	if due, exists := m.Due(); exists {
		create = create.SetNillableDue(&due)
	}

	if completed, exists := m.Completed(); exists {
		create = create.SetNillableCompleted(&completed)
	}

	if assigneeID, exists := m.AssigneeID(); exists {
		create = create.SetAssigneeID(assigneeID)
	}

	if assignerID, exists := m.AssignerID(); exists {
		create = create.SetAssignerID(assignerID)
	}

	if systemGenerated, exists := m.SystemGenerated(); exists {
		create = create.SetSystemGenerated(systemGenerated)
	}

	if idempotencyKey, exists := m.IdempotencyKey(); exists {
		create = create.SetIdempotencyKey(idempotencyKey)
	}

	if externalReferenceURL, exists := m.ExternalReferenceURL(); exists {
		create = create.SetExternalReferenceURL(externalReferenceURL)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *TaskMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		task, err := client.Task.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TaskHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(task.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(task.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(task.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(task.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(task.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(task.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(task.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(task.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(task.OwnerID)
		}

		if taskKindName, exists := m.TaskKindName(); exists {
			create = create.SetTaskKindName(taskKindName)
		} else {
			create = create.SetTaskKindName(task.TaskKindName)
		}

		if taskKindID, exists := m.TaskKindID(); exists {
			create = create.SetTaskKindID(taskKindID)
		} else {
			create = create.SetTaskKindID(task.TaskKindID)
		}

		if title, exists := m.Title(); exists {
			create = create.SetTitle(title)
		} else {
			create = create.SetTitle(task.Title)
		}

		if details, exists := m.Details(); exists {
			create = create.SetDetails(details)
		} else {
			create = create.SetDetails(task.Details)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(task.Status)
		}

		if category, exists := m.Category(); exists {
			create = create.SetCategory(category)
		} else {
			create = create.SetCategory(task.Category)
		}

		if due, exists := m.Due(); exists {
			create = create.SetNillableDue(&due)
		} else {
			create = create.SetNillableDue(task.Due)
		}

		if completed, exists := m.Completed(); exists {
			create = create.SetNillableCompleted(&completed)
		} else {
			create = create.SetNillableCompleted(task.Completed)
		}

		if assigneeID, exists := m.AssigneeID(); exists {
			create = create.SetAssigneeID(assigneeID)
		} else {
			create = create.SetAssigneeID(task.AssigneeID)
		}

		if assignerID, exists := m.AssignerID(); exists {
			create = create.SetAssignerID(assignerID)
		} else {
			create = create.SetAssignerID(task.AssignerID)
		}

		if systemGenerated, exists := m.SystemGenerated(); exists {
			create = create.SetSystemGenerated(systemGenerated)
		} else {
			create = create.SetSystemGenerated(task.SystemGenerated)
		}

		if idempotencyKey, exists := m.IdempotencyKey(); exists {
			create = create.SetIdempotencyKey(idempotencyKey)
		} else {
			create = create.SetIdempotencyKey(task.IdempotencyKey)
		}

		if externalReferenceURL, exists := m.ExternalReferenceURL(); exists {
			create = create.SetExternalReferenceURL(externalReferenceURL)
		} else {
			create = create.SetExternalReferenceURL(task.ExternalReferenceURL)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *TaskMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		task, err := client.Task.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TaskHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(task.CreatedAt).
			SetUpdatedAt(task.UpdatedAt).
			SetCreatedBy(task.CreatedBy).
			SetUpdatedBy(task.UpdatedBy).
			SetDeletedAt(task.DeletedAt).
			SetDeletedBy(task.DeletedBy).
			SetDisplayID(task.DisplayID).
			SetTags(task.Tags).
			SetOwnerID(task.OwnerID).
			SetTaskKindName(task.TaskKindName).
			SetTaskKindID(task.TaskKindID).
			SetTitle(task.Title).
			SetDetails(task.Details).
			SetStatus(task.Status).
			SetCategory(task.Category).
			SetNillableDue(task.Due).
			SetNillableCompleted(task.Completed).
			SetAssigneeID(task.AssigneeID).
			SetAssignerID(task.AssignerID).
			SetSystemGenerated(task.SystemGenerated).
			SetIdempotencyKey(task.IdempotencyKey).
			SetExternalReferenceURL(task.ExternalReferenceURL).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *TemplateMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.TemplateHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if templateType, exists := m.TemplateType(); exists {
		create = create.SetTemplateType(templateType)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if kind, exists := m.Kind(); exists {
		create = create.SetKind(kind)
	}

	if jsonconfig, exists := m.Jsonconfig(); exists {
		create = create.SetJsonconfig(jsonconfig)
	}

	if uischema, exists := m.Uischema(); exists {
		create = create.SetUischema(uischema)
	}

	if trustCenterID, exists := m.TrustCenterID(); exists {
		create = create.SetTrustCenterID(trustCenterID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *TemplateMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		template, err := client.Template.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TemplateHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(template.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(template.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(template.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(template.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(template.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(template.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(template.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(template.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(template.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(template.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(template.SystemInternalID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(template.Name)
		}

		if templateType, exists := m.TemplateType(); exists {
			create = create.SetTemplateType(templateType)
		} else {
			create = create.SetTemplateType(template.TemplateType)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(template.Description)
		}

		if kind, exists := m.Kind(); exists {
			create = create.SetKind(kind)
		} else {
			create = create.SetKind(template.Kind)
		}

		if jsonconfig, exists := m.Jsonconfig(); exists {
			create = create.SetJsonconfig(jsonconfig)
		} else {
			create = create.SetJsonconfig(template.Jsonconfig)
		}

		if uischema, exists := m.Uischema(); exists {
			create = create.SetUischema(uischema)
		} else {
			create = create.SetUischema(template.Uischema)
		}

		if trustCenterID, exists := m.TrustCenterID(); exists {
			create = create.SetTrustCenterID(trustCenterID)
		} else {
			create = create.SetTrustCenterID(template.TrustCenterID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *TemplateMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		template, err := client.Template.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TemplateHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(template.CreatedAt).
			SetUpdatedAt(template.UpdatedAt).
			SetCreatedBy(template.CreatedBy).
			SetUpdatedBy(template.UpdatedBy).
			SetDeletedAt(template.DeletedAt).
			SetDeletedBy(template.DeletedBy).
			SetTags(template.Tags).
			SetOwnerID(template.OwnerID).
			SetSystemOwned(template.SystemOwned).
			SetNillableInternalNotes(template.InternalNotes).
			SetNillableSystemInternalID(template.SystemInternalID).
			SetName(template.Name).
			SetTemplateType(template.TemplateType).
			SetDescription(template.Description).
			SetKind(template.Kind).
			SetJsonconfig(template.Jsonconfig).
			SetUischema(template.Uischema).
			SetTrustCenterID(template.TrustCenterID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *TrustCenterMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.TrustCenterHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if slug, exists := m.Slug(); exists {
		create = create.SetSlug(slug)
	}

	if customDomainID, exists := m.CustomDomainID(); exists {
		create = create.SetCustomDomainID(customDomainID)
	}

	if previewDomainID, exists := m.PreviewDomainID(); exists {
		create = create.SetPreviewDomainID(previewDomainID)
	}

	if pirschDomainID, exists := m.PirschDomainID(); exists {
		create = create.SetPirschDomainID(pirschDomainID)
	}

	if pirschIdentificationCode, exists := m.PirschIdentificationCode(); exists {
		create = create.SetPirschIdentificationCode(pirschIdentificationCode)
	}

	if previewStatus, exists := m.PreviewStatus(); exists {
		create = create.SetPreviewStatus(previewStatus)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *TrustCenterMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		trustcenter, err := client.TrustCenter.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TrustCenterHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(trustcenter.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(trustcenter.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(trustcenter.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(trustcenter.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(trustcenter.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(trustcenter.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(trustcenter.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(trustcenter.OwnerID)
		}

		if slug, exists := m.Slug(); exists {
			create = create.SetSlug(slug)
		} else {
			create = create.SetSlug(trustcenter.Slug)
		}

		if customDomainID, exists := m.CustomDomainID(); exists {
			create = create.SetCustomDomainID(customDomainID)
		} else {
			create = create.SetCustomDomainID(trustcenter.CustomDomainID)
		}

		if previewDomainID, exists := m.PreviewDomainID(); exists {
			create = create.SetPreviewDomainID(previewDomainID)
		} else {
			create = create.SetPreviewDomainID(trustcenter.PreviewDomainID)
		}

		if pirschDomainID, exists := m.PirschDomainID(); exists {
			create = create.SetPirschDomainID(pirschDomainID)
		} else {
			create = create.SetPirschDomainID(trustcenter.PirschDomainID)
		}

		if pirschIdentificationCode, exists := m.PirschIdentificationCode(); exists {
			create = create.SetPirschIdentificationCode(pirschIdentificationCode)
		} else {
			create = create.SetPirschIdentificationCode(trustcenter.PirschIdentificationCode)
		}

		if previewStatus, exists := m.PreviewStatus(); exists {
			create = create.SetPreviewStatus(previewStatus)
		} else {
			create = create.SetPreviewStatus(trustcenter.PreviewStatus)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *TrustCenterMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		trustcenter, err := client.TrustCenter.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TrustCenterHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(trustcenter.CreatedAt).
			SetUpdatedAt(trustcenter.UpdatedAt).
			SetCreatedBy(trustcenter.CreatedBy).
			SetUpdatedBy(trustcenter.UpdatedBy).
			SetDeletedAt(trustcenter.DeletedAt).
			SetDeletedBy(trustcenter.DeletedBy).
			SetTags(trustcenter.Tags).
			SetOwnerID(trustcenter.OwnerID).
			SetSlug(trustcenter.Slug).
			SetCustomDomainID(trustcenter.CustomDomainID).
			SetPreviewDomainID(trustcenter.PreviewDomainID).
			SetPirschDomainID(trustcenter.PirschDomainID).
			SetPirschIdentificationCode(trustcenter.PirschIdentificationCode).
			SetPreviewStatus(trustcenter.PreviewStatus).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *TrustCenterComplianceMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.TrustCenterComplianceHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if standardID, exists := m.StandardID(); exists {
		create = create.SetStandardID(standardID)
	}

	if trustCenterID, exists := m.TrustCenterID(); exists {
		create = create.SetTrustCenterID(trustCenterID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *TrustCenterComplianceMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		trustcentercompliance, err := client.TrustCenterCompliance.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TrustCenterComplianceHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(trustcentercompliance.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(trustcentercompliance.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(trustcentercompliance.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(trustcentercompliance.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(trustcentercompliance.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(trustcentercompliance.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(trustcentercompliance.Tags)
		}

		if standardID, exists := m.StandardID(); exists {
			create = create.SetStandardID(standardID)
		} else {
			create = create.SetStandardID(trustcentercompliance.StandardID)
		}

		if trustCenterID, exists := m.TrustCenterID(); exists {
			create = create.SetTrustCenterID(trustCenterID)
		} else {
			create = create.SetTrustCenterID(trustcentercompliance.TrustCenterID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *TrustCenterComplianceMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		trustcentercompliance, err := client.TrustCenterCompliance.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TrustCenterComplianceHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(trustcentercompliance.CreatedAt).
			SetUpdatedAt(trustcentercompliance.UpdatedAt).
			SetCreatedBy(trustcentercompliance.CreatedBy).
			SetUpdatedBy(trustcentercompliance.UpdatedBy).
			SetDeletedAt(trustcentercompliance.DeletedAt).
			SetDeletedBy(trustcentercompliance.DeletedBy).
			SetTags(trustcentercompliance.Tags).
			SetStandardID(trustcentercompliance.StandardID).
			SetTrustCenterID(trustcentercompliance.TrustCenterID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *TrustCenterDocMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.TrustCenterDocHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if trustCenterID, exists := m.TrustCenterID(); exists {
		create = create.SetTrustCenterID(trustCenterID)
	}

	if title, exists := m.Title(); exists {
		create = create.SetTitle(title)
	}

	if category, exists := m.Category(); exists {
		create = create.SetCategory(category)
	}

	if fileID, exists := m.FileID(); exists {
		create = create.SetNillableFileID(&fileID)
	}

	if originalFileID, exists := m.OriginalFileID(); exists {
		create = create.SetNillableOriginalFileID(&originalFileID)
	}

	if watermarkingEnabled, exists := m.WatermarkingEnabled(); exists {
		create = create.SetWatermarkingEnabled(watermarkingEnabled)
	}

	if watermarkStatus, exists := m.WatermarkStatus(); exists {
		create = create.SetWatermarkStatus(watermarkStatus)
	}

	if visibility, exists := m.Visibility(); exists {
		create = create.SetVisibility(visibility)
	}

	if standardID, exists := m.StandardID(); exists {
		create = create.SetStandardID(standardID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *TrustCenterDocMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		trustcenterdoc, err := client.TrustCenterDoc.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TrustCenterDocHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(trustcenterdoc.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(trustcenterdoc.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(trustcenterdoc.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(trustcenterdoc.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(trustcenterdoc.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(trustcenterdoc.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(trustcenterdoc.Tags)
		}

		if trustCenterID, exists := m.TrustCenterID(); exists {
			create = create.SetTrustCenterID(trustCenterID)
		} else {
			create = create.SetTrustCenterID(trustcenterdoc.TrustCenterID)
		}

		if title, exists := m.Title(); exists {
			create = create.SetTitle(title)
		} else {
			create = create.SetTitle(trustcenterdoc.Title)
		}

		if category, exists := m.Category(); exists {
			create = create.SetCategory(category)
		} else {
			create = create.SetCategory(trustcenterdoc.Category)
		}

		if fileID, exists := m.FileID(); exists {
			create = create.SetNillableFileID(&fileID)
		} else {
			create = create.SetNillableFileID(trustcenterdoc.FileID)
		}

		if originalFileID, exists := m.OriginalFileID(); exists {
			create = create.SetNillableOriginalFileID(&originalFileID)
		} else {
			create = create.SetNillableOriginalFileID(trustcenterdoc.OriginalFileID)
		}

		if watermarkingEnabled, exists := m.WatermarkingEnabled(); exists {
			create = create.SetWatermarkingEnabled(watermarkingEnabled)
		} else {
			create = create.SetWatermarkingEnabled(trustcenterdoc.WatermarkingEnabled)
		}

		if watermarkStatus, exists := m.WatermarkStatus(); exists {
			create = create.SetWatermarkStatus(watermarkStatus)
		} else {
			create = create.SetWatermarkStatus(trustcenterdoc.WatermarkStatus)
		}

		if visibility, exists := m.Visibility(); exists {
			create = create.SetVisibility(visibility)
		} else {
			create = create.SetVisibility(trustcenterdoc.Visibility)
		}

		if standardID, exists := m.StandardID(); exists {
			create = create.SetStandardID(standardID)
		} else {
			create = create.SetStandardID(trustcenterdoc.StandardID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *TrustCenterDocMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		trustcenterdoc, err := client.TrustCenterDoc.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TrustCenterDocHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(trustcenterdoc.CreatedAt).
			SetUpdatedAt(trustcenterdoc.UpdatedAt).
			SetCreatedBy(trustcenterdoc.CreatedBy).
			SetUpdatedBy(trustcenterdoc.UpdatedBy).
			SetDeletedAt(trustcenterdoc.DeletedAt).
			SetDeletedBy(trustcenterdoc.DeletedBy).
			SetTags(trustcenterdoc.Tags).
			SetTrustCenterID(trustcenterdoc.TrustCenterID).
			SetTitle(trustcenterdoc.Title).
			SetCategory(trustcenterdoc.Category).
			SetNillableFileID(trustcenterdoc.FileID).
			SetNillableOriginalFileID(trustcenterdoc.OriginalFileID).
			SetWatermarkingEnabled(trustcenterdoc.WatermarkingEnabled).
			SetWatermarkStatus(trustcenterdoc.WatermarkStatus).
			SetVisibility(trustcenterdoc.Visibility).
			SetStandardID(trustcenterdoc.StandardID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *TrustCenterSettingMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.TrustCenterSettingHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if trustCenterID, exists := m.TrustCenterID(); exists {
		create = create.SetTrustCenterID(trustCenterID)
	}

	if title, exists := m.Title(); exists {
		create = create.SetTitle(title)
	}

	if overview, exists := m.Overview(); exists {
		create = create.SetOverview(overview)
	}

	if logoRemoteURL, exists := m.LogoRemoteURL(); exists {
		create = create.SetNillableLogoRemoteURL(&logoRemoteURL)
	}

	if logoLocalFileID, exists := m.LogoLocalFileID(); exists {
		create = create.SetNillableLogoLocalFileID(&logoLocalFileID)
	}

	if faviconRemoteURL, exists := m.FaviconRemoteURL(); exists {
		create = create.SetNillableFaviconRemoteURL(&faviconRemoteURL)
	}

	if faviconLocalFileID, exists := m.FaviconLocalFileID(); exists {
		create = create.SetNillableFaviconLocalFileID(&faviconLocalFileID)
	}

	if themeMode, exists := m.ThemeMode(); exists {
		create = create.SetThemeMode(themeMode)
	}

	if primaryColor, exists := m.PrimaryColor(); exists {
		create = create.SetPrimaryColor(primaryColor)
	}

	if font, exists := m.Font(); exists {
		create = create.SetFont(font)
	}

	if foregroundColor, exists := m.ForegroundColor(); exists {
		create = create.SetForegroundColor(foregroundColor)
	}

	if backgroundColor, exists := m.BackgroundColor(); exists {
		create = create.SetBackgroundColor(backgroundColor)
	}

	if accentColor, exists := m.AccentColor(); exists {
		create = create.SetAccentColor(accentColor)
	}

	if secondaryBackgroundColor, exists := m.SecondaryBackgroundColor(); exists {
		create = create.SetSecondaryBackgroundColor(secondaryBackgroundColor)
	}

	if secondaryForegroundColor, exists := m.SecondaryForegroundColor(); exists {
		create = create.SetSecondaryForegroundColor(secondaryForegroundColor)
	}

	if environment, exists := m.Environment(); exists {
		create = create.SetEnvironment(environment)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *TrustCenterSettingMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		trustcentersetting, err := client.TrustCenterSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TrustCenterSettingHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(trustcentersetting.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(trustcentersetting.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(trustcentersetting.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(trustcentersetting.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(trustcentersetting.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(trustcentersetting.DeletedBy)
		}

		if trustCenterID, exists := m.TrustCenterID(); exists {
			create = create.SetTrustCenterID(trustCenterID)
		} else {
			create = create.SetTrustCenterID(trustcentersetting.TrustCenterID)
		}

		if title, exists := m.Title(); exists {
			create = create.SetTitle(title)
		} else {
			create = create.SetTitle(trustcentersetting.Title)
		}

		if overview, exists := m.Overview(); exists {
			create = create.SetOverview(overview)
		} else {
			create = create.SetOverview(trustcentersetting.Overview)
		}

		if logoRemoteURL, exists := m.LogoRemoteURL(); exists {
			create = create.SetNillableLogoRemoteURL(&logoRemoteURL)
		} else {
			create = create.SetNillableLogoRemoteURL(trustcentersetting.LogoRemoteURL)
		}

		if logoLocalFileID, exists := m.LogoLocalFileID(); exists {
			create = create.SetNillableLogoLocalFileID(&logoLocalFileID)
		} else {
			create = create.SetNillableLogoLocalFileID(trustcentersetting.LogoLocalFileID)
		}

		if faviconRemoteURL, exists := m.FaviconRemoteURL(); exists {
			create = create.SetNillableFaviconRemoteURL(&faviconRemoteURL)
		} else {
			create = create.SetNillableFaviconRemoteURL(trustcentersetting.FaviconRemoteURL)
		}

		if faviconLocalFileID, exists := m.FaviconLocalFileID(); exists {
			create = create.SetNillableFaviconLocalFileID(&faviconLocalFileID)
		} else {
			create = create.SetNillableFaviconLocalFileID(trustcentersetting.FaviconLocalFileID)
		}

		if themeMode, exists := m.ThemeMode(); exists {
			create = create.SetThemeMode(themeMode)
		} else {
			create = create.SetThemeMode(trustcentersetting.ThemeMode)
		}

		if primaryColor, exists := m.PrimaryColor(); exists {
			create = create.SetPrimaryColor(primaryColor)
		} else {
			create = create.SetPrimaryColor(trustcentersetting.PrimaryColor)
		}

		if font, exists := m.Font(); exists {
			create = create.SetFont(font)
		} else {
			create = create.SetFont(trustcentersetting.Font)
		}

		if foregroundColor, exists := m.ForegroundColor(); exists {
			create = create.SetForegroundColor(foregroundColor)
		} else {
			create = create.SetForegroundColor(trustcentersetting.ForegroundColor)
		}

		if backgroundColor, exists := m.BackgroundColor(); exists {
			create = create.SetBackgroundColor(backgroundColor)
		} else {
			create = create.SetBackgroundColor(trustcentersetting.BackgroundColor)
		}

		if accentColor, exists := m.AccentColor(); exists {
			create = create.SetAccentColor(accentColor)
		} else {
			create = create.SetAccentColor(trustcentersetting.AccentColor)
		}

		if secondaryBackgroundColor, exists := m.SecondaryBackgroundColor(); exists {
			create = create.SetSecondaryBackgroundColor(secondaryBackgroundColor)
		} else {
			create = create.SetSecondaryBackgroundColor(trustcentersetting.SecondaryBackgroundColor)
		}

		if secondaryForegroundColor, exists := m.SecondaryForegroundColor(); exists {
			create = create.SetSecondaryForegroundColor(secondaryForegroundColor)
		} else {
			create = create.SetSecondaryForegroundColor(trustcentersetting.SecondaryForegroundColor)
		}

		if environment, exists := m.Environment(); exists {
			create = create.SetEnvironment(environment)
		} else {
			create = create.SetEnvironment(trustcentersetting.Environment)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *TrustCenterSettingMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		trustcentersetting, err := client.TrustCenterSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TrustCenterSettingHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(trustcentersetting.CreatedAt).
			SetUpdatedAt(trustcentersetting.UpdatedAt).
			SetCreatedBy(trustcentersetting.CreatedBy).
			SetUpdatedBy(trustcentersetting.UpdatedBy).
			SetDeletedAt(trustcentersetting.DeletedAt).
			SetDeletedBy(trustcentersetting.DeletedBy).
			SetTrustCenterID(trustcentersetting.TrustCenterID).
			SetTitle(trustcentersetting.Title).
			SetOverview(trustcentersetting.Overview).
			SetNillableLogoRemoteURL(trustcentersetting.LogoRemoteURL).
			SetNillableLogoLocalFileID(trustcentersetting.LogoLocalFileID).
			SetNillableFaviconRemoteURL(trustcentersetting.FaviconRemoteURL).
			SetNillableFaviconLocalFileID(trustcentersetting.FaviconLocalFileID).
			SetThemeMode(trustcentersetting.ThemeMode).
			SetPrimaryColor(trustcentersetting.PrimaryColor).
			SetFont(trustcentersetting.Font).
			SetForegroundColor(trustcentersetting.ForegroundColor).
			SetBackgroundColor(trustcentersetting.BackgroundColor).
			SetAccentColor(trustcentersetting.AccentColor).
			SetSecondaryBackgroundColor(trustcentersetting.SecondaryBackgroundColor).
			SetSecondaryForegroundColor(trustcentersetting.SecondaryForegroundColor).
			SetEnvironment(trustcentersetting.Environment).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *TrustCenterSubprocessorMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.TrustCenterSubprocessorHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if subprocessorID, exists := m.SubprocessorID(); exists {
		create = create.SetSubprocessorID(subprocessorID)
	}

	if trustCenterID, exists := m.TrustCenterID(); exists {
		create = create.SetTrustCenterID(trustCenterID)
	}

	if countries, exists := m.Countries(); exists {
		create = create.SetCountries(countries)
	}

	if category, exists := m.Category(); exists {
		create = create.SetCategory(category)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *TrustCenterSubprocessorMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		trustcentersubprocessor, err := client.TrustCenterSubprocessor.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TrustCenterSubprocessorHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(trustcentersubprocessor.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(trustcentersubprocessor.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(trustcentersubprocessor.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(trustcentersubprocessor.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(trustcentersubprocessor.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(trustcentersubprocessor.DeletedBy)
		}

		if subprocessorID, exists := m.SubprocessorID(); exists {
			create = create.SetSubprocessorID(subprocessorID)
		} else {
			create = create.SetSubprocessorID(trustcentersubprocessor.SubprocessorID)
		}

		if trustCenterID, exists := m.TrustCenterID(); exists {
			create = create.SetTrustCenterID(trustCenterID)
		} else {
			create = create.SetTrustCenterID(trustcentersubprocessor.TrustCenterID)
		}

		if countries, exists := m.Countries(); exists {
			create = create.SetCountries(countries)
		} else {
			create = create.SetCountries(trustcentersubprocessor.Countries)
		}

		if category, exists := m.Category(); exists {
			create = create.SetCategory(category)
		} else {
			create = create.SetCategory(trustcentersubprocessor.Category)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *TrustCenterSubprocessorMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		trustcentersubprocessor, err := client.TrustCenterSubprocessor.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TrustCenterSubprocessorHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(trustcentersubprocessor.CreatedAt).
			SetUpdatedAt(trustcentersubprocessor.UpdatedAt).
			SetCreatedBy(trustcentersubprocessor.CreatedBy).
			SetUpdatedBy(trustcentersubprocessor.UpdatedBy).
			SetDeletedAt(trustcentersubprocessor.DeletedAt).
			SetDeletedBy(trustcentersubprocessor.DeletedBy).
			SetSubprocessorID(trustcentersubprocessor.SubprocessorID).
			SetTrustCenterID(trustcentersubprocessor.TrustCenterID).
			SetCountries(trustcentersubprocessor.Countries).
			SetCategory(trustcentersubprocessor.Category).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *TrustCenterWatermarkConfigMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.TrustCenterWatermarkConfigHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if trustCenterID, exists := m.TrustCenterID(); exists {
		create = create.SetTrustCenterID(trustCenterID)
	}

	if isEnabled, exists := m.IsEnabled(); exists {
		create = create.SetIsEnabled(isEnabled)
	}

	if logoID, exists := m.LogoID(); exists {
		create = create.SetNillableLogoID(&logoID)
	}

	if text, exists := m.Text(); exists {
		create = create.SetText(text)
	}

	if fontSize, exists := m.FontSize(); exists {
		create = create.SetFontSize(fontSize)
	}

	if opacity, exists := m.Opacity(); exists {
		create = create.SetOpacity(opacity)
	}

	if rotation, exists := m.Rotation(); exists {
		create = create.SetRotation(rotation)
	}

	if color, exists := m.Color(); exists {
		create = create.SetColor(color)
	}

	if font, exists := m.Font(); exists {
		create = create.SetFont(font)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *TrustCenterWatermarkConfigMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		trustcenterwatermarkconfig, err := client.TrustCenterWatermarkConfig.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TrustCenterWatermarkConfigHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(trustcenterwatermarkconfig.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(trustcenterwatermarkconfig.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(trustcenterwatermarkconfig.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(trustcenterwatermarkconfig.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(trustcenterwatermarkconfig.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(trustcenterwatermarkconfig.DeletedBy)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(trustcenterwatermarkconfig.OwnerID)
		}

		if trustCenterID, exists := m.TrustCenterID(); exists {
			create = create.SetTrustCenterID(trustCenterID)
		} else {
			create = create.SetTrustCenterID(trustcenterwatermarkconfig.TrustCenterID)
		}

		if isEnabled, exists := m.IsEnabled(); exists {
			create = create.SetIsEnabled(isEnabled)
		} else {
			create = create.SetIsEnabled(trustcenterwatermarkconfig.IsEnabled)
		}

		if logoID, exists := m.LogoID(); exists {
			create = create.SetNillableLogoID(&logoID)
		} else {
			create = create.SetNillableLogoID(trustcenterwatermarkconfig.LogoID)
		}

		if text, exists := m.Text(); exists {
			create = create.SetText(text)
		} else {
			create = create.SetText(trustcenterwatermarkconfig.Text)
		}

		if fontSize, exists := m.FontSize(); exists {
			create = create.SetFontSize(fontSize)
		} else {
			create = create.SetFontSize(trustcenterwatermarkconfig.FontSize)
		}

		if opacity, exists := m.Opacity(); exists {
			create = create.SetOpacity(opacity)
		} else {
			create = create.SetOpacity(trustcenterwatermarkconfig.Opacity)
		}

		if rotation, exists := m.Rotation(); exists {
			create = create.SetRotation(rotation)
		} else {
			create = create.SetRotation(trustcenterwatermarkconfig.Rotation)
		}

		if color, exists := m.Color(); exists {
			create = create.SetColor(color)
		} else {
			create = create.SetColor(trustcenterwatermarkconfig.Color)
		}

		if font, exists := m.Font(); exists {
			create = create.SetFont(font)
		} else {
			create = create.SetFont(trustcenterwatermarkconfig.Font)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *TrustCenterWatermarkConfigMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		trustcenterwatermarkconfig, err := client.TrustCenterWatermarkConfig.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TrustCenterWatermarkConfigHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(trustcenterwatermarkconfig.CreatedAt).
			SetUpdatedAt(trustcenterwatermarkconfig.UpdatedAt).
			SetCreatedBy(trustcenterwatermarkconfig.CreatedBy).
			SetUpdatedBy(trustcenterwatermarkconfig.UpdatedBy).
			SetDeletedAt(trustcenterwatermarkconfig.DeletedAt).
			SetDeletedBy(trustcenterwatermarkconfig.DeletedBy).
			SetOwnerID(trustcenterwatermarkconfig.OwnerID).
			SetTrustCenterID(trustcenterwatermarkconfig.TrustCenterID).
			SetIsEnabled(trustcenterwatermarkconfig.IsEnabled).
			SetNillableLogoID(trustcenterwatermarkconfig.LogoID).
			SetText(trustcenterwatermarkconfig.Text).
			SetFontSize(trustcenterwatermarkconfig.FontSize).
			SetOpacity(trustcenterwatermarkconfig.Opacity).
			SetRotation(trustcenterwatermarkconfig.Rotation).
			SetColor(trustcenterwatermarkconfig.Color).
			SetFont(trustcenterwatermarkconfig.Font).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *TrustcenterEntityMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.TrustcenterEntityHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if logoFileID, exists := m.LogoFileID(); exists {
		create = create.SetNillableLogoFileID(&logoFileID)
	}

	if url, exists := m.URL(); exists {
		create = create.SetURL(url)
	}

	if trustCenterID, exists := m.TrustCenterID(); exists {
		create = create.SetTrustCenterID(trustCenterID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if entityTypeID, exists := m.EntityTypeID(); exists {
		create = create.SetEntityTypeID(entityTypeID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *TrustcenterEntityMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		trustcenterentity, err := client.TrustcenterEntity.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TrustcenterEntityHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(trustcenterentity.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(trustcenterentity.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(trustcenterentity.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(trustcenterentity.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(trustcenterentity.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(trustcenterentity.DeletedBy)
		}

		if logoFileID, exists := m.LogoFileID(); exists {
			create = create.SetNillableLogoFileID(&logoFileID)
		} else {
			create = create.SetNillableLogoFileID(trustcenterentity.LogoFileID)
		}

		if url, exists := m.URL(); exists {
			create = create.SetURL(url)
		} else {
			create = create.SetURL(trustcenterentity.URL)
		}

		if trustCenterID, exists := m.TrustCenterID(); exists {
			create = create.SetTrustCenterID(trustCenterID)
		} else {
			create = create.SetTrustCenterID(trustcenterentity.TrustCenterID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(trustcenterentity.Name)
		}

		if entityTypeID, exists := m.EntityTypeID(); exists {
			create = create.SetEntityTypeID(entityTypeID)
		} else {
			create = create.SetEntityTypeID(trustcenterentity.EntityTypeID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *TrustcenterEntityMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		trustcenterentity, err := client.TrustcenterEntity.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.TrustcenterEntityHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(trustcenterentity.CreatedAt).
			SetUpdatedAt(trustcenterentity.UpdatedAt).
			SetCreatedBy(trustcenterentity.CreatedBy).
			SetUpdatedBy(trustcenterentity.UpdatedBy).
			SetDeletedAt(trustcenterentity.DeletedAt).
			SetDeletedBy(trustcenterentity.DeletedBy).
			SetNillableLogoFileID(trustcenterentity.LogoFileID).
			SetURL(trustcenterentity.URL).
			SetTrustCenterID(trustcenterentity.TrustCenterID).
			SetName(trustcenterentity.Name).
			SetEntityTypeID(trustcenterentity.EntityTypeID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *UserMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.UserHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if email, exists := m.Email(); exists {
		create = create.SetEmail(email)
	}

	if firstName, exists := m.FirstName(); exists {
		create = create.SetFirstName(firstName)
	}

	if lastName, exists := m.LastName(); exists {
		create = create.SetLastName(lastName)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if avatarRemoteURL, exists := m.AvatarRemoteURL(); exists {
		create = create.SetNillableAvatarRemoteURL(&avatarRemoteURL)
	}

	if avatarLocalFileID, exists := m.AvatarLocalFileID(); exists {
		create = create.SetNillableAvatarLocalFileID(&avatarLocalFileID)
	}

	if avatarUpdatedAt, exists := m.AvatarUpdatedAt(); exists {
		create = create.SetNillableAvatarUpdatedAt(&avatarUpdatedAt)
	}

	if lastSeen, exists := m.LastSeen(); exists {
		create = create.SetNillableLastSeen(&lastSeen)
	}

	if lastLoginProvider, exists := m.LastLoginProvider(); exists {
		create = create.SetLastLoginProvider(lastLoginProvider)
	}

	if password, exists := m.Password(); exists {
		create = create.SetNillablePassword(&password)
	}

	if sub, exists := m.Sub(); exists {
		create = create.SetSub(sub)
	}

	if authProvider, exists := m.AuthProvider(); exists {
		create = create.SetAuthProvider(authProvider)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	}

	if scimExternalID, exists := m.ScimExternalID(); exists {
		create = create.SetNillableScimExternalID(&scimExternalID)
	}

	if scimUsername, exists := m.ScimUsername(); exists {
		create = create.SetNillableScimUsername(&scimUsername)
	}

	if scimActive, exists := m.ScimActive(); exists {
		create = create.SetScimActive(scimActive)
	}

	if scimPreferredLanguage, exists := m.ScimPreferredLanguage(); exists {
		create = create.SetNillableScimPreferredLanguage(&scimPreferredLanguage)
	}

	if scimLocale, exists := m.ScimLocale(); exists {
		create = create.SetNillableScimLocale(&scimLocale)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *UserMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		user, err := client.User.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.UserHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(user.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(user.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(user.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(user.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(user.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(user.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(user.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(user.Tags)
		}

		if email, exists := m.Email(); exists {
			create = create.SetEmail(email)
		} else {
			create = create.SetEmail(user.Email)
		}

		if firstName, exists := m.FirstName(); exists {
			create = create.SetFirstName(firstName)
		} else {
			create = create.SetFirstName(user.FirstName)
		}

		if lastName, exists := m.LastName(); exists {
			create = create.SetLastName(lastName)
		} else {
			create = create.SetLastName(user.LastName)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(user.DisplayName)
		}

		if avatarRemoteURL, exists := m.AvatarRemoteURL(); exists {
			create = create.SetNillableAvatarRemoteURL(&avatarRemoteURL)
		} else {
			create = create.SetNillableAvatarRemoteURL(user.AvatarRemoteURL)
		}

		if avatarLocalFileID, exists := m.AvatarLocalFileID(); exists {
			create = create.SetNillableAvatarLocalFileID(&avatarLocalFileID)
		} else {
			create = create.SetNillableAvatarLocalFileID(user.AvatarLocalFileID)
		}

		if avatarUpdatedAt, exists := m.AvatarUpdatedAt(); exists {
			create = create.SetNillableAvatarUpdatedAt(&avatarUpdatedAt)
		} else {
			create = create.SetNillableAvatarUpdatedAt(user.AvatarUpdatedAt)
		}

		if lastSeen, exists := m.LastSeen(); exists {
			create = create.SetNillableLastSeen(&lastSeen)
		} else {
			create = create.SetNillableLastSeen(user.LastSeen)
		}

		if lastLoginProvider, exists := m.LastLoginProvider(); exists {
			create = create.SetLastLoginProvider(lastLoginProvider)
		} else {
			create = create.SetLastLoginProvider(user.LastLoginProvider)
		}

		if password, exists := m.Password(); exists {
			create = create.SetNillablePassword(&password)
		} else {
			create = create.SetNillablePassword(user.Password)
		}

		if sub, exists := m.Sub(); exists {
			create = create.SetSub(sub)
		} else {
			create = create.SetSub(user.Sub)
		}

		if authProvider, exists := m.AuthProvider(); exists {
			create = create.SetAuthProvider(authProvider)
		} else {
			create = create.SetAuthProvider(user.AuthProvider)
		}

		if role, exists := m.Role(); exists {
			create = create.SetRole(role)
		} else {
			create = create.SetRole(user.Role)
		}

		if scimExternalID, exists := m.ScimExternalID(); exists {
			create = create.SetNillableScimExternalID(&scimExternalID)
		} else {
			create = create.SetNillableScimExternalID(user.ScimExternalID)
		}

		if scimUsername, exists := m.ScimUsername(); exists {
			create = create.SetNillableScimUsername(&scimUsername)
		} else {
			create = create.SetNillableScimUsername(user.ScimUsername)
		}

		if scimActive, exists := m.ScimActive(); exists {
			create = create.SetScimActive(scimActive)
		} else {
			create = create.SetScimActive(user.ScimActive)
		}

		if scimPreferredLanguage, exists := m.ScimPreferredLanguage(); exists {
			create = create.SetNillableScimPreferredLanguage(&scimPreferredLanguage)
		} else {
			create = create.SetNillableScimPreferredLanguage(user.ScimPreferredLanguage)
		}

		if scimLocale, exists := m.ScimLocale(); exists {
			create = create.SetNillableScimLocale(&scimLocale)
		} else {
			create = create.SetNillableScimLocale(user.ScimLocale)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *UserMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		user, err := client.User.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.UserHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(user.CreatedAt).
			SetUpdatedAt(user.UpdatedAt).
			SetCreatedBy(user.CreatedBy).
			SetUpdatedBy(user.UpdatedBy).
			SetDeletedAt(user.DeletedAt).
			SetDeletedBy(user.DeletedBy).
			SetDisplayID(user.DisplayID).
			SetTags(user.Tags).
			SetEmail(user.Email).
			SetFirstName(user.FirstName).
			SetLastName(user.LastName).
			SetDisplayName(user.DisplayName).
			SetNillableAvatarRemoteURL(user.AvatarRemoteURL).
			SetNillableAvatarLocalFileID(user.AvatarLocalFileID).
			SetNillableAvatarUpdatedAt(user.AvatarUpdatedAt).
			SetNillableLastSeen(user.LastSeen).
			SetLastLoginProvider(user.LastLoginProvider).
			SetNillablePassword(user.Password).
			SetSub(user.Sub).
			SetAuthProvider(user.AuthProvider).
			SetRole(user.Role).
			SetNillableScimExternalID(user.ScimExternalID).
			SetNillableScimUsername(user.ScimUsername).
			SetScimActive(user.ScimActive).
			SetNillableScimPreferredLanguage(user.ScimPreferredLanguage).
			SetNillableScimLocale(user.ScimLocale).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *UserSettingMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.UserSettingHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if userID, exists := m.UserID(); exists {
		create = create.SetUserID(userID)
	}

	if locked, exists := m.Locked(); exists {
		create = create.SetLocked(locked)
	}

	if silencedAt, exists := m.SilencedAt(); exists {
		create = create.SetNillableSilencedAt(&silencedAt)
	}

	if suspendedAt, exists := m.SuspendedAt(); exists {
		create = create.SetNillableSuspendedAt(&suspendedAt)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if emailConfirmed, exists := m.EmailConfirmed(); exists {
		create = create.SetEmailConfirmed(emailConfirmed)
	}

	if isWebauthnAllowed, exists := m.IsWebauthnAllowed(); exists {
		create = create.SetIsWebauthnAllowed(isWebauthnAllowed)
	}

	if isTfaEnabled, exists := m.IsTfaEnabled(); exists {
		create = create.SetIsTfaEnabled(isTfaEnabled)
	}

	if phoneNumber, exists := m.PhoneNumber(); exists {
		create = create.SetNillablePhoneNumber(&phoneNumber)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *UserSettingMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		usersetting, err := client.UserSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.UserSettingHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(usersetting.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(usersetting.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(usersetting.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(usersetting.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(usersetting.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(usersetting.DeletedBy)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(usersetting.Tags)
		}

		if userID, exists := m.UserID(); exists {
			create = create.SetUserID(userID)
		} else {
			create = create.SetUserID(usersetting.UserID)
		}

		if locked, exists := m.Locked(); exists {
			create = create.SetLocked(locked)
		} else {
			create = create.SetLocked(usersetting.Locked)
		}

		if silencedAt, exists := m.SilencedAt(); exists {
			create = create.SetNillableSilencedAt(&silencedAt)
		} else {
			create = create.SetNillableSilencedAt(usersetting.SilencedAt)
		}

		if suspendedAt, exists := m.SuspendedAt(); exists {
			create = create.SetNillableSuspendedAt(&suspendedAt)
		} else {
			create = create.SetNillableSuspendedAt(usersetting.SuspendedAt)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(usersetting.Status)
		}

		if emailConfirmed, exists := m.EmailConfirmed(); exists {
			create = create.SetEmailConfirmed(emailConfirmed)
		} else {
			create = create.SetEmailConfirmed(usersetting.EmailConfirmed)
		}

		if isWebauthnAllowed, exists := m.IsWebauthnAllowed(); exists {
			create = create.SetIsWebauthnAllowed(isWebauthnAllowed)
		} else {
			create = create.SetIsWebauthnAllowed(usersetting.IsWebauthnAllowed)
		}

		if isTfaEnabled, exists := m.IsTfaEnabled(); exists {
			create = create.SetIsTfaEnabled(isTfaEnabled)
		} else {
			create = create.SetIsTfaEnabled(usersetting.IsTfaEnabled)
		}

		if phoneNumber, exists := m.PhoneNumber(); exists {
			create = create.SetNillablePhoneNumber(&phoneNumber)
		} else {
			create = create.SetNillablePhoneNumber(usersetting.PhoneNumber)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *UserSettingMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		usersetting, err := client.UserSetting.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.UserSettingHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(usersetting.CreatedAt).
			SetUpdatedAt(usersetting.UpdatedAt).
			SetCreatedBy(usersetting.CreatedBy).
			SetUpdatedBy(usersetting.UpdatedBy).
			SetDeletedAt(usersetting.DeletedAt).
			SetDeletedBy(usersetting.DeletedBy).
			SetTags(usersetting.Tags).
			SetUserID(usersetting.UserID).
			SetLocked(usersetting.Locked).
			SetNillableSilencedAt(usersetting.SilencedAt).
			SetNillableSuspendedAt(usersetting.SuspendedAt).
			SetStatus(usersetting.Status).
			SetEmailConfirmed(usersetting.EmailConfirmed).
			SetIsWebauthnAllowed(usersetting.IsWebauthnAllowed).
			SetIsTfaEnabled(usersetting.IsTfaEnabled).
			SetNillablePhoneNumber(usersetting.PhoneNumber).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *VulnerabilityMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.VulnerabilityHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if externalOwnerID, exists := m.ExternalOwnerID(); exists {
		create = create.SetExternalOwnerID(externalOwnerID)
	}

	if externalID, exists := m.ExternalID(); exists {
		create = create.SetExternalID(externalID)
	}

	if cveID, exists := m.CveID(); exists {
		create = create.SetCveID(cveID)
	}

	if source, exists := m.Source(); exists {
		create = create.SetSource(source)
	}

	if displayName, exists := m.DisplayName(); exists {
		create = create.SetDisplayName(displayName)
	}

	if category, exists := m.Category(); exists {
		create = create.SetCategory(category)
	}

	if severity, exists := m.Severity(); exists {
		create = create.SetSeverity(severity)
	}

	if score, exists := m.Score(); exists {
		create = create.SetScore(score)
	}

	if impact, exists := m.Impact(); exists {
		create = create.SetImpact(impact)
	}

	if exploitability, exists := m.Exploitability(); exists {
		create = create.SetExploitability(exploitability)
	}

	if priority, exists := m.Priority(); exists {
		create = create.SetPriority(priority)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if summary, exists := m.Summary(); exists {
		create = create.SetSummary(summary)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if vector, exists := m.Vector(); exists {
		create = create.SetVector(vector)
	}

	if remediationSLA, exists := m.RemediationSLA(); exists {
		create = create.SetRemediationSLA(remediationSLA)
	}

	if open, exists := m.Open(); exists {
		create = create.SetOpen(open)
	}

	if blocking, exists := m.Blocking(); exists {
		create = create.SetBlocking(blocking)
	}

	if production, exists := m.Production(); exists {
		create = create.SetProduction(production)
	}

	if public, exists := m.Public(); exists {
		create = create.SetPublic(public)
	}

	if validated, exists := m.Validated(); exists {
		create = create.SetValidated(validated)
	}

	if references, exists := m.References(); exists {
		create = create.SetReferences(references)
	}

	if impacts, exists := m.Impacts(); exists {
		create = create.SetImpacts(impacts)
	}

	if publishedAt, exists := m.PublishedAt(); exists {
		create = create.SetNillablePublishedAt(&publishedAt)
	}

	if discoveredAt, exists := m.DiscoveredAt(); exists {
		create = create.SetNillableDiscoveredAt(&discoveredAt)
	}

	if sourceUpdatedAt, exists := m.SourceUpdatedAt(); exists {
		create = create.SetNillableSourceUpdatedAt(&sourceUpdatedAt)
	}

	if externalURI, exists := m.ExternalURI(); exists {
		create = create.SetExternalURI(externalURI)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	if rawPayload, exists := m.RawPayload(); exists {
		create = create.SetRawPayload(rawPayload)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *VulnerabilityMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		vulnerability, err := client.Vulnerability.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.VulnerabilityHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(vulnerability.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(vulnerability.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(vulnerability.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(vulnerability.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(vulnerability.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(vulnerability.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(vulnerability.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(vulnerability.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(vulnerability.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(vulnerability.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(vulnerability.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(vulnerability.SystemInternalID)
		}

		if externalOwnerID, exists := m.ExternalOwnerID(); exists {
			create = create.SetExternalOwnerID(externalOwnerID)
		} else {
			create = create.SetExternalOwnerID(vulnerability.ExternalOwnerID)
		}

		if externalID, exists := m.ExternalID(); exists {
			create = create.SetExternalID(externalID)
		} else {
			create = create.SetExternalID(vulnerability.ExternalID)
		}

		if cveID, exists := m.CveID(); exists {
			create = create.SetCveID(cveID)
		} else {
			create = create.SetCveID(vulnerability.CveID)
		}

		if source, exists := m.Source(); exists {
			create = create.SetSource(source)
		} else {
			create = create.SetSource(vulnerability.Source)
		}

		if displayName, exists := m.DisplayName(); exists {
			create = create.SetDisplayName(displayName)
		} else {
			create = create.SetDisplayName(vulnerability.DisplayName)
		}

		if category, exists := m.Category(); exists {
			create = create.SetCategory(category)
		} else {
			create = create.SetCategory(vulnerability.Category)
		}

		if severity, exists := m.Severity(); exists {
			create = create.SetSeverity(severity)
		} else {
			create = create.SetSeverity(vulnerability.Severity)
		}

		if score, exists := m.Score(); exists {
			create = create.SetScore(score)
		} else {
			create = create.SetScore(vulnerability.Score)
		}

		if impact, exists := m.Impact(); exists {
			create = create.SetImpact(impact)
		} else {
			create = create.SetImpact(vulnerability.Impact)
		}

		if exploitability, exists := m.Exploitability(); exists {
			create = create.SetExploitability(exploitability)
		} else {
			create = create.SetExploitability(vulnerability.Exploitability)
		}

		if priority, exists := m.Priority(); exists {
			create = create.SetPriority(priority)
		} else {
			create = create.SetPriority(vulnerability.Priority)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(vulnerability.Status)
		}

		if summary, exists := m.Summary(); exists {
			create = create.SetSummary(summary)
		} else {
			create = create.SetSummary(vulnerability.Summary)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(vulnerability.Description)
		}

		if vector, exists := m.Vector(); exists {
			create = create.SetVector(vector)
		} else {
			create = create.SetVector(vulnerability.Vector)
		}

		if remediationSLA, exists := m.RemediationSLA(); exists {
			create = create.SetRemediationSLA(remediationSLA)
		} else {
			create = create.SetRemediationSLA(vulnerability.RemediationSLA)
		}

		if open, exists := m.Open(); exists {
			create = create.SetOpen(open)
		} else {
			create = create.SetOpen(vulnerability.Open)
		}

		if blocking, exists := m.Blocking(); exists {
			create = create.SetBlocking(blocking)
		} else {
			create = create.SetBlocking(vulnerability.Blocking)
		}

		if production, exists := m.Production(); exists {
			create = create.SetProduction(production)
		} else {
			create = create.SetProduction(vulnerability.Production)
		}

		if public, exists := m.Public(); exists {
			create = create.SetPublic(public)
		} else {
			create = create.SetPublic(vulnerability.Public)
		}

		if validated, exists := m.Validated(); exists {
			create = create.SetValidated(validated)
		} else {
			create = create.SetValidated(vulnerability.Validated)
		}

		if references, exists := m.References(); exists {
			create = create.SetReferences(references)
		} else {
			create = create.SetReferences(vulnerability.References)
		}

		if impacts, exists := m.Impacts(); exists {
			create = create.SetImpacts(impacts)
		} else {
			create = create.SetImpacts(vulnerability.Impacts)
		}

		if publishedAt, exists := m.PublishedAt(); exists {
			create = create.SetNillablePublishedAt(&publishedAt)
		} else {
			create = create.SetNillablePublishedAt(vulnerability.PublishedAt)
		}

		if discoveredAt, exists := m.DiscoveredAt(); exists {
			create = create.SetNillableDiscoveredAt(&discoveredAt)
		} else {
			create = create.SetNillableDiscoveredAt(vulnerability.DiscoveredAt)
		}

		if sourceUpdatedAt, exists := m.SourceUpdatedAt(); exists {
			create = create.SetNillableSourceUpdatedAt(&sourceUpdatedAt)
		} else {
			create = create.SetNillableSourceUpdatedAt(vulnerability.SourceUpdatedAt)
		}

		if externalURI, exists := m.ExternalURI(); exists {
			create = create.SetExternalURI(externalURI)
		} else {
			create = create.SetExternalURI(vulnerability.ExternalURI)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(vulnerability.Metadata)
		}

		if rawPayload, exists := m.RawPayload(); exists {
			create = create.SetRawPayload(rawPayload)
		} else {
			create = create.SetRawPayload(vulnerability.RawPayload)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *VulnerabilityMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		vulnerability, err := client.Vulnerability.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.VulnerabilityHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(vulnerability.CreatedAt).
			SetUpdatedAt(vulnerability.UpdatedAt).
			SetCreatedBy(vulnerability.CreatedBy).
			SetUpdatedBy(vulnerability.UpdatedBy).
			SetDeletedAt(vulnerability.DeletedAt).
			SetDeletedBy(vulnerability.DeletedBy).
			SetDisplayID(vulnerability.DisplayID).
			SetTags(vulnerability.Tags).
			SetOwnerID(vulnerability.OwnerID).
			SetSystemOwned(vulnerability.SystemOwned).
			SetNillableInternalNotes(vulnerability.InternalNotes).
			SetNillableSystemInternalID(vulnerability.SystemInternalID).
			SetExternalOwnerID(vulnerability.ExternalOwnerID).
			SetExternalID(vulnerability.ExternalID).
			SetCveID(vulnerability.CveID).
			SetSource(vulnerability.Source).
			SetDisplayName(vulnerability.DisplayName).
			SetCategory(vulnerability.Category).
			SetSeverity(vulnerability.Severity).
			SetScore(vulnerability.Score).
			SetImpact(vulnerability.Impact).
			SetExploitability(vulnerability.Exploitability).
			SetPriority(vulnerability.Priority).
			SetStatus(vulnerability.Status).
			SetSummary(vulnerability.Summary).
			SetDescription(vulnerability.Description).
			SetVector(vulnerability.Vector).
			SetRemediationSLA(vulnerability.RemediationSLA).
			SetOpen(vulnerability.Open).
			SetBlocking(vulnerability.Blocking).
			SetProduction(vulnerability.Production).
			SetPublic(vulnerability.Public).
			SetValidated(vulnerability.Validated).
			SetReferences(vulnerability.References).
			SetImpacts(vulnerability.Impacts).
			SetNillablePublishedAt(vulnerability.PublishedAt).
			SetNillableDiscoveredAt(vulnerability.DiscoveredAt).
			SetNillableSourceUpdatedAt(vulnerability.SourceUpdatedAt).
			SetExternalURI(vulnerability.ExternalURI).
			SetMetadata(vulnerability.Metadata).
			SetRawPayload(vulnerability.RawPayload).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *WorkflowAssignmentMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.WorkflowAssignmentHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if workflowInstanceID, exists := m.WorkflowInstanceID(); exists {
		create = create.SetWorkflowInstanceID(workflowInstanceID)
	}

	if assignmentKey, exists := m.AssignmentKey(); exists {
		create = create.SetAssignmentKey(assignmentKey)
	}

	if role, exists := m.Role(); exists {
		create = create.SetRole(role)
	}

	if label, exists := m.Label(); exists {
		create = create.SetLabel(label)
	}

	if required, exists := m.Required(); exists {
		create = create.SetRequired(required)
	}

	if status, exists := m.Status(); exists {
		create = create.SetStatus(status)
	}

	if metadata, exists := m.Metadata(); exists {
		create = create.SetMetadata(metadata)
	}

	if decidedAt, exists := m.DecidedAt(); exists {
		create = create.SetNillableDecidedAt(&decidedAt)
	}

	if actorUserID, exists := m.ActorUserID(); exists {
		create = create.SetActorUserID(actorUserID)
	}

	if actorGroupID, exists := m.ActorGroupID(); exists {
		create = create.SetActorGroupID(actorGroupID)
	}

	if notes, exists := m.Notes(); exists {
		create = create.SetNotes(notes)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *WorkflowAssignmentMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		workflowassignment, err := client.WorkflowAssignment.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.WorkflowAssignmentHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(workflowassignment.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(workflowassignment.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(workflowassignment.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(workflowassignment.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(workflowassignment.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(workflowassignment.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(workflowassignment.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(workflowassignment.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(workflowassignment.OwnerID)
		}

		if workflowInstanceID, exists := m.WorkflowInstanceID(); exists {
			create = create.SetWorkflowInstanceID(workflowInstanceID)
		} else {
			create = create.SetWorkflowInstanceID(workflowassignment.WorkflowInstanceID)
		}

		if assignmentKey, exists := m.AssignmentKey(); exists {
			create = create.SetAssignmentKey(assignmentKey)
		} else {
			create = create.SetAssignmentKey(workflowassignment.AssignmentKey)
		}

		if role, exists := m.Role(); exists {
			create = create.SetRole(role)
		} else {
			create = create.SetRole(workflowassignment.Role)
		}

		if label, exists := m.Label(); exists {
			create = create.SetLabel(label)
		} else {
			create = create.SetLabel(workflowassignment.Label)
		}

		if required, exists := m.Required(); exists {
			create = create.SetRequired(required)
		} else {
			create = create.SetRequired(workflowassignment.Required)
		}

		if status, exists := m.Status(); exists {
			create = create.SetStatus(status)
		} else {
			create = create.SetStatus(workflowassignment.Status)
		}

		if metadata, exists := m.Metadata(); exists {
			create = create.SetMetadata(metadata)
		} else {
			create = create.SetMetadata(workflowassignment.Metadata)
		}

		if decidedAt, exists := m.DecidedAt(); exists {
			create = create.SetNillableDecidedAt(&decidedAt)
		} else {
			create = create.SetNillableDecidedAt(workflowassignment.DecidedAt)
		}

		if actorUserID, exists := m.ActorUserID(); exists {
			create = create.SetActorUserID(actorUserID)
		} else {
			create = create.SetActorUserID(workflowassignment.ActorUserID)
		}

		if actorGroupID, exists := m.ActorGroupID(); exists {
			create = create.SetActorGroupID(actorGroupID)
		} else {
			create = create.SetActorGroupID(workflowassignment.ActorGroupID)
		}

		if notes, exists := m.Notes(); exists {
			create = create.SetNotes(notes)
		} else {
			create = create.SetNotes(workflowassignment.Notes)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *WorkflowAssignmentMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		workflowassignment, err := client.WorkflowAssignment.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.WorkflowAssignmentHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(workflowassignment.CreatedAt).
			SetUpdatedAt(workflowassignment.UpdatedAt).
			SetCreatedBy(workflowassignment.CreatedBy).
			SetUpdatedBy(workflowassignment.UpdatedBy).
			SetDeletedAt(workflowassignment.DeletedAt).
			SetDeletedBy(workflowassignment.DeletedBy).
			SetDisplayID(workflowassignment.DisplayID).
			SetTags(workflowassignment.Tags).
			SetOwnerID(workflowassignment.OwnerID).
			SetWorkflowInstanceID(workflowassignment.WorkflowInstanceID).
			SetAssignmentKey(workflowassignment.AssignmentKey).
			SetRole(workflowassignment.Role).
			SetLabel(workflowassignment.Label).
			SetRequired(workflowassignment.Required).
			SetStatus(workflowassignment.Status).
			SetMetadata(workflowassignment.Metadata).
			SetNillableDecidedAt(workflowassignment.DecidedAt).
			SetActorUserID(workflowassignment.ActorUserID).
			SetActorGroupID(workflowassignment.ActorGroupID).
			SetNotes(workflowassignment.Notes).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *WorkflowAssignmentTargetMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.WorkflowAssignmentTargetHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if workflowAssignmentID, exists := m.WorkflowAssignmentID(); exists {
		create = create.SetWorkflowAssignmentID(workflowAssignmentID)
	}

	if targetType, exists := m.TargetType(); exists {
		create = create.SetTargetType(targetType)
	}

	if targetUserID, exists := m.TargetUserID(); exists {
		create = create.SetTargetUserID(targetUserID)
	}

	if targetGroupID, exists := m.TargetGroupID(); exists {
		create = create.SetTargetGroupID(targetGroupID)
	}

	if resolverKey, exists := m.ResolverKey(); exists {
		create = create.SetResolverKey(resolverKey)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *WorkflowAssignmentTargetMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		workflowassignmenttarget, err := client.WorkflowAssignmentTarget.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.WorkflowAssignmentTargetHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(workflowassignmenttarget.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(workflowassignmenttarget.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(workflowassignmenttarget.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(workflowassignmenttarget.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(workflowassignmenttarget.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(workflowassignmenttarget.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(workflowassignmenttarget.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(workflowassignmenttarget.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(workflowassignmenttarget.OwnerID)
		}

		if workflowAssignmentID, exists := m.WorkflowAssignmentID(); exists {
			create = create.SetWorkflowAssignmentID(workflowAssignmentID)
		} else {
			create = create.SetWorkflowAssignmentID(workflowassignmenttarget.WorkflowAssignmentID)
		}

		if targetType, exists := m.TargetType(); exists {
			create = create.SetTargetType(targetType)
		} else {
			create = create.SetTargetType(workflowassignmenttarget.TargetType)
		}

		if targetUserID, exists := m.TargetUserID(); exists {
			create = create.SetTargetUserID(targetUserID)
		} else {
			create = create.SetTargetUserID(workflowassignmenttarget.TargetUserID)
		}

		if targetGroupID, exists := m.TargetGroupID(); exists {
			create = create.SetTargetGroupID(targetGroupID)
		} else {
			create = create.SetTargetGroupID(workflowassignmenttarget.TargetGroupID)
		}

		if resolverKey, exists := m.ResolverKey(); exists {
			create = create.SetResolverKey(resolverKey)
		} else {
			create = create.SetResolverKey(workflowassignmenttarget.ResolverKey)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *WorkflowAssignmentTargetMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		workflowassignmenttarget, err := client.WorkflowAssignmentTarget.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.WorkflowAssignmentTargetHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(workflowassignmenttarget.CreatedAt).
			SetUpdatedAt(workflowassignmenttarget.UpdatedAt).
			SetCreatedBy(workflowassignmenttarget.CreatedBy).
			SetUpdatedBy(workflowassignmenttarget.UpdatedBy).
			SetDeletedAt(workflowassignmenttarget.DeletedAt).
			SetDeletedBy(workflowassignmenttarget.DeletedBy).
			SetDisplayID(workflowassignmenttarget.DisplayID).
			SetTags(workflowassignmenttarget.Tags).
			SetOwnerID(workflowassignmenttarget.OwnerID).
			SetWorkflowAssignmentID(workflowassignmenttarget.WorkflowAssignmentID).
			SetTargetType(workflowassignmenttarget.TargetType).
			SetTargetUserID(workflowassignmenttarget.TargetUserID).
			SetTargetGroupID(workflowassignmenttarget.TargetGroupID).
			SetResolverKey(workflowassignmenttarget.ResolverKey).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *WorkflowDefinitionMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.WorkflowDefinitionHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if systemOwned, exists := m.SystemOwned(); exists {
		create = create.SetSystemOwned(systemOwned)
	}

	if internalNotes, exists := m.InternalNotes(); exists {
		create = create.SetNillableInternalNotes(&internalNotes)
	}

	if systemInternalID, exists := m.SystemInternalID(); exists {
		create = create.SetNillableSystemInternalID(&systemInternalID)
	}

	if name, exists := m.Name(); exists {
		create = create.SetName(name)
	}

	if description, exists := m.Description(); exists {
		create = create.SetDescription(description)
	}

	if workflowKind, exists := m.WorkflowKind(); exists {
		create = create.SetWorkflowKind(workflowKind)
	}

	if schemaType, exists := m.SchemaType(); exists {
		create = create.SetSchemaType(schemaType)
	}

	if revision, exists := m.Revision(); exists {
		create = create.SetRevision(revision)
	}

	if draft, exists := m.Draft(); exists {
		create = create.SetDraft(draft)
	}

	if publishedAt, exists := m.PublishedAt(); exists {
		create = create.SetNillablePublishedAt(&publishedAt)
	}

	if cooldownSeconds, exists := m.CooldownSeconds(); exists {
		create = create.SetCooldownSeconds(cooldownSeconds)
	}

	if isDefault, exists := m.IsDefault(); exists {
		create = create.SetIsDefault(isDefault)
	}

	if active, exists := m.Active(); exists {
		create = create.SetActive(active)
	}

	if triggerOperations, exists := m.TriggerOperations(); exists {
		create = create.SetTriggerOperations(triggerOperations)
	}

	if triggerFields, exists := m.TriggerFields(); exists {
		create = create.SetTriggerFields(triggerFields)
	}

	if definitionJSON, exists := m.DefinitionJSON(); exists {
		create = create.SetDefinitionJSON(definitionJSON)
	}

	if trackedFields, exists := m.TrackedFields(); exists {
		create = create.SetTrackedFields(trackedFields)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *WorkflowDefinitionMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		workflowdefinition, err := client.WorkflowDefinition.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.WorkflowDefinitionHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(workflowdefinition.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(workflowdefinition.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(workflowdefinition.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(workflowdefinition.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(workflowdefinition.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(workflowdefinition.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(workflowdefinition.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(workflowdefinition.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(workflowdefinition.OwnerID)
		}

		if systemOwned, exists := m.SystemOwned(); exists {
			create = create.SetSystemOwned(systemOwned)
		} else {
			create = create.SetSystemOwned(workflowdefinition.SystemOwned)
		}

		if internalNotes, exists := m.InternalNotes(); exists {
			create = create.SetNillableInternalNotes(&internalNotes)
		} else {
			create = create.SetNillableInternalNotes(workflowdefinition.InternalNotes)
		}

		if systemInternalID, exists := m.SystemInternalID(); exists {
			create = create.SetNillableSystemInternalID(&systemInternalID)
		} else {
			create = create.SetNillableSystemInternalID(workflowdefinition.SystemInternalID)
		}

		if name, exists := m.Name(); exists {
			create = create.SetName(name)
		} else {
			create = create.SetName(workflowdefinition.Name)
		}

		if description, exists := m.Description(); exists {
			create = create.SetDescription(description)
		} else {
			create = create.SetDescription(workflowdefinition.Description)
		}

		if workflowKind, exists := m.WorkflowKind(); exists {
			create = create.SetWorkflowKind(workflowKind)
		} else {
			create = create.SetWorkflowKind(workflowdefinition.WorkflowKind)
		}

		if schemaType, exists := m.SchemaType(); exists {
			create = create.SetSchemaType(schemaType)
		} else {
			create = create.SetSchemaType(workflowdefinition.SchemaType)
		}

		if revision, exists := m.Revision(); exists {
			create = create.SetRevision(revision)
		} else {
			create = create.SetRevision(workflowdefinition.Revision)
		}

		if draft, exists := m.Draft(); exists {
			create = create.SetDraft(draft)
		} else {
			create = create.SetDraft(workflowdefinition.Draft)
		}

		if publishedAt, exists := m.PublishedAt(); exists {
			create = create.SetNillablePublishedAt(&publishedAt)
		} else {
			create = create.SetNillablePublishedAt(workflowdefinition.PublishedAt)
		}

		if cooldownSeconds, exists := m.CooldownSeconds(); exists {
			create = create.SetCooldownSeconds(cooldownSeconds)
		} else {
			create = create.SetCooldownSeconds(workflowdefinition.CooldownSeconds)
		}

		if isDefault, exists := m.IsDefault(); exists {
			create = create.SetIsDefault(isDefault)
		} else {
			create = create.SetIsDefault(workflowdefinition.IsDefault)
		}

		if active, exists := m.Active(); exists {
			create = create.SetActive(active)
		} else {
			create = create.SetActive(workflowdefinition.Active)
		}

		if triggerOperations, exists := m.TriggerOperations(); exists {
			create = create.SetTriggerOperations(triggerOperations)
		} else {
			create = create.SetTriggerOperations(workflowdefinition.TriggerOperations)
		}

		if triggerFields, exists := m.TriggerFields(); exists {
			create = create.SetTriggerFields(triggerFields)
		} else {
			create = create.SetTriggerFields(workflowdefinition.TriggerFields)
		}

		if definitionJSON, exists := m.DefinitionJSON(); exists {
			create = create.SetDefinitionJSON(definitionJSON)
		} else {
			create = create.SetDefinitionJSON(workflowdefinition.DefinitionJSON)
		}

		if trackedFields, exists := m.TrackedFields(); exists {
			create = create.SetTrackedFields(trackedFields)
		} else {
			create = create.SetTrackedFields(workflowdefinition.TrackedFields)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *WorkflowDefinitionMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		workflowdefinition, err := client.WorkflowDefinition.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.WorkflowDefinitionHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(workflowdefinition.CreatedAt).
			SetUpdatedAt(workflowdefinition.UpdatedAt).
			SetCreatedBy(workflowdefinition.CreatedBy).
			SetUpdatedBy(workflowdefinition.UpdatedBy).
			SetDeletedAt(workflowdefinition.DeletedAt).
			SetDeletedBy(workflowdefinition.DeletedBy).
			SetDisplayID(workflowdefinition.DisplayID).
			SetTags(workflowdefinition.Tags).
			SetOwnerID(workflowdefinition.OwnerID).
			SetSystemOwned(workflowdefinition.SystemOwned).
			SetNillableInternalNotes(workflowdefinition.InternalNotes).
			SetNillableSystemInternalID(workflowdefinition.SystemInternalID).
			SetName(workflowdefinition.Name).
			SetDescription(workflowdefinition.Description).
			SetWorkflowKind(workflowdefinition.WorkflowKind).
			SetSchemaType(workflowdefinition.SchemaType).
			SetRevision(workflowdefinition.Revision).
			SetDraft(workflowdefinition.Draft).
			SetNillablePublishedAt(workflowdefinition.PublishedAt).
			SetCooldownSeconds(workflowdefinition.CooldownSeconds).
			SetIsDefault(workflowdefinition.IsDefault).
			SetActive(workflowdefinition.Active).
			SetTriggerOperations(workflowdefinition.TriggerOperations).
			SetTriggerFields(workflowdefinition.TriggerFields).
			SetDefinitionJSON(workflowdefinition.DefinitionJSON).
			SetTrackedFields(workflowdefinition.TrackedFields).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *WorkflowEventMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.WorkflowEventHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if workflowInstanceID, exists := m.WorkflowInstanceID(); exists {
		create = create.SetWorkflowInstanceID(workflowInstanceID)
	}

	if eventType, exists := m.EventType(); exists {
		create = create.SetEventType(eventType)
	}

	if payload, exists := m.Payload(); exists {
		create = create.SetPayload(payload)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *WorkflowEventMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		workflowevent, err := client.WorkflowEvent.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.WorkflowEventHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(workflowevent.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(workflowevent.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(workflowevent.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(workflowevent.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(workflowevent.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(workflowevent.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(workflowevent.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(workflowevent.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(workflowevent.OwnerID)
		}

		if workflowInstanceID, exists := m.WorkflowInstanceID(); exists {
			create = create.SetWorkflowInstanceID(workflowInstanceID)
		} else {
			create = create.SetWorkflowInstanceID(workflowevent.WorkflowInstanceID)
		}

		if eventType, exists := m.EventType(); exists {
			create = create.SetEventType(eventType)
		} else {
			create = create.SetEventType(workflowevent.EventType)
		}

		if payload, exists := m.Payload(); exists {
			create = create.SetPayload(payload)
		} else {
			create = create.SetPayload(workflowevent.Payload)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *WorkflowEventMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		workflowevent, err := client.WorkflowEvent.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.WorkflowEventHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(workflowevent.CreatedAt).
			SetUpdatedAt(workflowevent.UpdatedAt).
			SetCreatedBy(workflowevent.CreatedBy).
			SetUpdatedBy(workflowevent.UpdatedBy).
			SetDeletedAt(workflowevent.DeletedAt).
			SetDeletedBy(workflowevent.DeletedBy).
			SetDisplayID(workflowevent.DisplayID).
			SetTags(workflowevent.Tags).
			SetOwnerID(workflowevent.OwnerID).
			SetWorkflowInstanceID(workflowevent.WorkflowInstanceID).
			SetEventType(workflowevent.EventType).
			SetPayload(workflowevent.Payload).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *WorkflowInstanceMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.WorkflowInstanceHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if deletedAt, exists := m.DeletedAt(); exists {
		create = create.SetDeletedAt(deletedAt)
	}

	if deletedBy, exists := m.DeletedBy(); exists {
		create = create.SetDeletedBy(deletedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if tags, exists := m.Tags(); exists {
		create = create.SetTags(tags)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if workflowDefinitionID, exists := m.WorkflowDefinitionID(); exists {
		create = create.SetWorkflowDefinitionID(workflowDefinitionID)
	}

	if state, exists := m.State(); exists {
		create = create.SetState(state)
	}

	if context, exists := m.Context(); exists {
		create = create.SetContext(context)
	}

	if lastEvaluatedAt, exists := m.LastEvaluatedAt(); exists {
		create = create.SetNillableLastEvaluatedAt(&lastEvaluatedAt)
	}

	if definitionSnapshot, exists := m.DefinitionSnapshot(); exists {
		create = create.SetDefinitionSnapshot(definitionSnapshot)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *WorkflowInstanceMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		workflowinstance, err := client.WorkflowInstance.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.WorkflowInstanceHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(workflowinstance.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(workflowinstance.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(workflowinstance.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(workflowinstance.UpdatedBy)
		}

		if deletedAt, exists := m.DeletedAt(); exists {
			create = create.SetDeletedAt(deletedAt)
		} else {
			create = create.SetDeletedAt(workflowinstance.DeletedAt)
		}

		if deletedBy, exists := m.DeletedBy(); exists {
			create = create.SetDeletedBy(deletedBy)
		} else {
			create = create.SetDeletedBy(workflowinstance.DeletedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(workflowinstance.DisplayID)
		}

		if tags, exists := m.Tags(); exists {
			create = create.SetTags(tags)
		} else {
			create = create.SetTags(workflowinstance.Tags)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(workflowinstance.OwnerID)
		}

		if workflowDefinitionID, exists := m.WorkflowDefinitionID(); exists {
			create = create.SetWorkflowDefinitionID(workflowDefinitionID)
		} else {
			create = create.SetWorkflowDefinitionID(workflowinstance.WorkflowDefinitionID)
		}

		if state, exists := m.State(); exists {
			create = create.SetState(state)
		} else {
			create = create.SetState(workflowinstance.State)
		}

		if context, exists := m.Context(); exists {
			create = create.SetContext(context)
		} else {
			create = create.SetContext(workflowinstance.Context)
		}

		if lastEvaluatedAt, exists := m.LastEvaluatedAt(); exists {
			create = create.SetNillableLastEvaluatedAt(&lastEvaluatedAt)
		} else {
			create = create.SetNillableLastEvaluatedAt(workflowinstance.LastEvaluatedAt)
		}

		if definitionSnapshot, exists := m.DefinitionSnapshot(); exists {
			create = create.SetDefinitionSnapshot(definitionSnapshot)
		} else {
			create = create.SetDefinitionSnapshot(workflowinstance.DefinitionSnapshot)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *WorkflowInstanceMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		workflowinstance, err := client.WorkflowInstance.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.WorkflowInstanceHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(workflowinstance.CreatedAt).
			SetUpdatedAt(workflowinstance.UpdatedAt).
			SetCreatedBy(workflowinstance.CreatedBy).
			SetUpdatedBy(workflowinstance.UpdatedBy).
			SetDeletedAt(workflowinstance.DeletedAt).
			SetDeletedBy(workflowinstance.DeletedBy).
			SetDisplayID(workflowinstance.DisplayID).
			SetTags(workflowinstance.Tags).
			SetOwnerID(workflowinstance.OwnerID).
			SetWorkflowDefinitionID(workflowinstance.WorkflowDefinitionID).
			SetState(workflowinstance.State).
			SetContext(workflowinstance.Context).
			SetNillableLastEvaluatedAt(workflowinstance.LastEvaluatedAt).
			SetDefinitionSnapshot(workflowinstance.DefinitionSnapshot).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *WorkflowObjectRefMutation) CreateHistoryFromCreate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	client := m.Client()

	id, ok := m.ID()
	if !ok {
		return idNotFoundError
	}

	create := client.WorkflowObjectRefHistory.Create()

	create = create.
		SetOperation(EntOpToHistoryOp(m.Op())).
		SetHistoryTime(time.Now()).
		SetRef(id)

	if createdAt, exists := m.CreatedAt(); exists {
		create = create.SetCreatedAt(createdAt)
	}

	if updatedAt, exists := m.UpdatedAt(); exists {
		create = create.SetUpdatedAt(updatedAt)
	}

	if createdBy, exists := m.CreatedBy(); exists {
		create = create.SetCreatedBy(createdBy)
	}

	if updatedBy, exists := m.UpdatedBy(); exists {
		create = create.SetUpdatedBy(updatedBy)
	}

	if displayID, exists := m.DisplayID(); exists {
		create = create.SetDisplayID(displayID)
	}

	if ownerID, exists := m.OwnerID(); exists {
		create = create.SetOwnerID(ownerID)
	}

	if workflowInstanceID, exists := m.WorkflowInstanceID(); exists {
		create = create.SetWorkflowInstanceID(workflowInstanceID)
	}

	if controlID, exists := m.ControlID(); exists {
		create = create.SetControlID(controlID)
	}

	if taskID, exists := m.TaskID(); exists {
		create = create.SetTaskID(taskID)
	}

	if internalPolicyID, exists := m.InternalPolicyID(); exists {
		create = create.SetInternalPolicyID(internalPolicyID)
	}

	if findingID, exists := m.FindingID(); exists {
		create = create.SetFindingID(findingID)
	}

	if directoryAccountID, exists := m.DirectoryAccountID(); exists {
		create = create.SetDirectoryAccountID(directoryAccountID)
	}

	if directoryGroupID, exists := m.DirectoryGroupID(); exists {
		create = create.SetDirectoryGroupID(directoryGroupID)
	}

	if directoryMembershipID, exists := m.DirectoryMembershipID(); exists {
		create = create.SetDirectoryMembershipID(directoryMembershipID)
	}

	_, err := create.Save(ctx)

	return err
}

func (m *WorkflowObjectRefMutation) CreateHistoryFromUpdate(ctx context.Context) error {
	ctx = history.WithContext(ctx)
	// check for soft delete operation and delete instead
	if entx.CheckIsSoftDelete(ctx) {
		return m.CreateHistoryFromDelete(ctx)
	}
	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		workflowobjectref, err := client.WorkflowObjectRef.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.WorkflowObjectRefHistory.Create()

		create = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id)

		if createdAt, exists := m.CreatedAt(); exists {
			create = create.SetCreatedAt(createdAt)
		} else {
			create = create.SetCreatedAt(workflowobjectref.CreatedAt)
		}

		if updatedAt, exists := m.UpdatedAt(); exists {
			create = create.SetUpdatedAt(updatedAt)
		} else {
			create = create.SetUpdatedAt(workflowobjectref.UpdatedAt)
		}

		if createdBy, exists := m.CreatedBy(); exists {
			create = create.SetCreatedBy(createdBy)
		} else {
			create = create.SetCreatedBy(workflowobjectref.CreatedBy)
		}

		if updatedBy, exists := m.UpdatedBy(); exists {
			create = create.SetUpdatedBy(updatedBy)
		} else {
			create = create.SetUpdatedBy(workflowobjectref.UpdatedBy)
		}

		if displayID, exists := m.DisplayID(); exists {
			create = create.SetDisplayID(displayID)
		} else {
			create = create.SetDisplayID(workflowobjectref.DisplayID)
		}

		if ownerID, exists := m.OwnerID(); exists {
			create = create.SetOwnerID(ownerID)
		} else {
			create = create.SetOwnerID(workflowobjectref.OwnerID)
		}

		if workflowInstanceID, exists := m.WorkflowInstanceID(); exists {
			create = create.SetWorkflowInstanceID(workflowInstanceID)
		} else {
			create = create.SetWorkflowInstanceID(workflowobjectref.WorkflowInstanceID)
		}

		if controlID, exists := m.ControlID(); exists {
			create = create.SetControlID(controlID)
		} else {
			create = create.SetControlID(workflowobjectref.ControlID)
		}

		if taskID, exists := m.TaskID(); exists {
			create = create.SetTaskID(taskID)
		} else {
			create = create.SetTaskID(workflowobjectref.TaskID)
		}

		if internalPolicyID, exists := m.InternalPolicyID(); exists {
			create = create.SetInternalPolicyID(internalPolicyID)
		} else {
			create = create.SetInternalPolicyID(workflowobjectref.InternalPolicyID)
		}

		if findingID, exists := m.FindingID(); exists {
			create = create.SetFindingID(findingID)
		} else {
			create = create.SetFindingID(workflowobjectref.FindingID)
		}

		if directoryAccountID, exists := m.DirectoryAccountID(); exists {
			create = create.SetDirectoryAccountID(directoryAccountID)
		} else {
			create = create.SetDirectoryAccountID(workflowobjectref.DirectoryAccountID)
		}

		if directoryGroupID, exists := m.DirectoryGroupID(); exists {
			create = create.SetDirectoryGroupID(directoryGroupID)
		} else {
			create = create.SetDirectoryGroupID(workflowobjectref.DirectoryGroupID)
		}

		if directoryMembershipID, exists := m.DirectoryMembershipID(); exists {
			create = create.SetDirectoryMembershipID(directoryMembershipID)
		} else {
			create = create.SetDirectoryMembershipID(workflowobjectref.DirectoryMembershipID)
		}

		if _, err := create.Save(ctx); err != nil {
			return err
		}
	}

	return nil
}

func (m *WorkflowObjectRefMutation) CreateHistoryFromDelete(ctx context.Context) error {
	ctx = history.WithContext(ctx)

	// check for soft delete operation and skip so it happens on update
	if entx.CheckIsSoftDelete(ctx) {
		return nil
	}

	client := m.Client()

	ids, err := m.IDs(ctx)
	if err != nil {
		return fmt.Errorf("getting ids: %w", err)
	}

	for _, id := range ids {
		workflowobjectref, err := client.WorkflowObjectRef.Get(ctx, id)
		if err != nil {
			return err
		}

		create := client.WorkflowObjectRefHistory.Create()

		_, err = create.
			SetOperation(EntOpToHistoryOp(m.Op())).
			SetHistoryTime(time.Now()).
			SetRef(id).
			SetCreatedAt(workflowobjectref.CreatedAt).
			SetUpdatedAt(workflowobjectref.UpdatedAt).
			SetCreatedBy(workflowobjectref.CreatedBy).
			SetUpdatedBy(workflowobjectref.UpdatedBy).
			SetDisplayID(workflowobjectref.DisplayID).
			SetOwnerID(workflowobjectref.OwnerID).
			SetWorkflowInstanceID(workflowobjectref.WorkflowInstanceID).
			SetControlID(workflowobjectref.ControlID).
			SetTaskID(workflowobjectref.TaskID).
			SetInternalPolicyID(workflowobjectref.InternalPolicyID).
			SetFindingID(workflowobjectref.FindingID).
			SetDirectoryAccountID(workflowobjectref.DirectoryAccountID).
			SetDirectoryGroupID(workflowobjectref.DirectoryGroupID).
			SetDirectoryMembershipID(workflowobjectref.DirectoryMembershipID).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}
