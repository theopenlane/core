package schema

import (
	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/field"
	"entgo.io/ent/schema/index"
	"github.com/theopenlane/entx"
	"github.com/theopenlane/entx/accessmap"
	"github.com/theopenlane/iam/entfga"

	"github.com/theopenlane/ent/generated"
	"github.com/theopenlane/ent/mixin"
	"github.com/theopenlane/ent/privacy/policy"
	"github.com/theopenlane/shared/models"
)

// Vulnerability defines the vulnerability schema.
type Vulnerability struct {
	SchemaFuncs

	ent.Schema
}

// SchemaVulnerability is the name of the vulnerability schema.
const SchemaVulnerability = "vulnerability"

// Name returns the name of the vulnerability schema.
func (Vulnerability) Name() string {
	return SchemaVulnerability
}

// GetType returns the type of the vulnerability schema.
func (Vulnerability) GetType() any {
	return Vulnerability.Type
}

// PluralName returns the plural name of the vulnerability schema.
func (Vulnerability) PluralName() string {
	// pluralize does not handle the word "vulnerability" correctly
	return "vulnerabilities"
}

// Fields returns vulnerability fields.
func (Vulnerability) Fields() []ent.Field {
	return []ent.Field{
		field.String("external_owner_id").
			Comment("owner of the vulnerability").
			Optional().
			Annotations(
				entx.FieldSearchable(),
				entgql.OrderField("external_owner_id"),
			),
		field.String("external_id").
			Comment("external identifier from the integration source for the vulnerability").
			NotEmpty().
			Annotations(
				entx.FieldSearchable(),
				entgql.OrderField("external_id"),
			),
		field.String("cve_id").
			Comment("CVE identifier for the vulnerability when applicable").
			Optional().
			Annotations(
				entx.FieldSearchable(),
				entgql.OrderField("cve_id"),
			),
		field.String("source").
			Comment("system that produced the vulnerability record").
			Optional(),
		field.String("display_name").
			Comment("display name for the vulnerability when provided").
			Optional(),
		field.String("category").
			Comment("category of the vulnerability such as application or infrastructure").
			Optional().
			Annotations(
				entgql.OrderField("category"),
			),
		field.String("severity").
			Comment("severity label for the vulnerability").
			Optional().
			Annotations(
				entgql.OrderField("severity"),
				entx.FieldSearchable(),
			),
		field.Float("score").
			Comment("overall score such as CVSS for the vulnerability").
			Optional(),
		field.Float("impact").
			Comment("impact score or rating for the vulnerability").
			Optional(),
		field.Float("exploitability").
			Comment("exploitability score or rating for the vulnerability").
			Optional(),
		field.String("priority").
			Comment("priority assigned to the vulnerability").
			Optional(),
		field.String("status").
			Comment("lifecycle status of the vulnerability").
			Optional(),
		field.Text("summary").
			Comment("short summary of the vulnerability details").
			Optional(),
		field.Text("description").
			Comment("long form description of the vulnerability").
			Optional(),
		field.String("vector").
			Comment("attack vector string such as a CVSS vector").
			Optional(),
		field.Int("remediation_sla").
			Comment("remediation service level agreement in days").
			Optional(),
		field.Bool("open").
			Comment("indicates if the vulnerability is still open").
			Default(true).
			Optional(),
		field.Bool("blocking").
			Comment("true when the vulnerability blocks production changes").
			Default(false).
			Optional(),
		field.Bool("production").
			Comment("true when the vulnerability affects production systems").
			Optional(),
		field.Bool("public").
			Comment("true when the vulnerability is publicly disclosed").
			Optional(),
		field.Bool("validated").
			Comment("true when the vulnerability has been validated by the security team").
			Optional(),
		field.Strings("references").
			Comment("reference links for the vulnerability").
			Optional().
			Default([]string{}),
		field.Strings("impacts").
			Comment("targets or assets impacted by the vulnerability").
			Optional().
			Default([]string{}),
		field.Time("published_at").
			Comment("timestamp when the vulnerability was published").
			GoType(models.DateTime{}).
			Optional().
			Nillable(),
		field.Time("discovered_at").
			Comment("timestamp when the vulnerability was discovered in the environment").
			GoType(models.DateTime{}).
			Optional().
			Nillable(),
		field.Time("source_updated_at").
			Comment("timestamp when the source last updated the vulnerability").
			GoType(models.DateTime{}).
			Optional().
			Nillable(),
		field.String("external_uri").
			Comment("link to the vulnerability in the source system").
			Optional(),
		field.JSON("metadata", map[string]any{}).
			Comment("raw metadata payload for the vulnerability from the source system").
			Optional(),
		field.JSON("raw_payload", map[string]any{}).
			Comment("raw payload received from the integration for auditing and troubleshooting").
			Optional(),
	}
}

// Edges of the Vulnerability
func (v Vulnerability) Edges() []ent.Edge {
	return []ent.Edge{
		edgeFromWithPagination(&edgeDefinition{
			fromSchema: v,
			edgeSchema: Integration{},
			comment:    "integration that produced the vulnerability",
		}),
		defaultEdgeToWithPagination(v, Finding{}),
		defaultEdgeToWithPagination(v, ActionPlan{}),
		defaultEdgeToWithPagination(v, Control{}),
		defaultEdgeToWithPagination(v, Subcontrol{}),
		defaultEdgeToWithPagination(v, Risk{}),
		defaultEdgeToWithPagination(v, Program{}),
		defaultEdgeToWithPagination(v, Asset{}),
		defaultEdgeToWithPagination(v, Entity{}),
		defaultEdgeToWithPagination(v, Scan{}),
		defaultEdgeToWithPagination(v, Task{}),
		edgeToWithPagination(&edgeDefinition{
			fromSchema: v,
			edgeSchema: Remediation{},
			comment:    "remediation efforts tracked against the vulnerability",
		}),
		edgeToWithPagination(&edgeDefinition{
			fromSchema: v,
			edgeSchema: Review{},
			comment:    "reviews performed for this vulnerability",
		}),
		edgeToWithPagination(&edgeDefinition{
			fromSchema: v,
			name:       "comments",
			t:          Note.Type,
			comment:    "discussion threads associated with the vulnerability",
			annotations: []schema.Annotation{
				accessmap.EdgeAuthCheck(Note{}.Name()),
			},
		}),
		edgeToWithPagination(&edgeDefinition{
			fromSchema: v,
			edgeSchema: File{},
			comment:    "supporting files or evidence for the vulnerability",
		}),
	}
}

// Mixin of the Vulnerability
func (v Vulnerability) Mixin() []ent.Mixin {
	return mixinConfig{
		prefix: "VUL",
		additionalMixins: []ent.Mixin{
			newObjectOwnedMixin[generated.Vulnerability](v,
				withParents(
					Program{},
					Control{},
					Subcontrol{},
					Risk{},
					Asset{},
					Entity{},
					Scan{},
				),
				withOrganizationOwner(true),
			),
			newGroupPermissionsMixin(),
			mixin.NewSystemOwnedMixin(),
		},
	}.getMixins(v)
}

// Indexes of the Vulnerability
func (Vulnerability) Indexes() []ent.Index {
	return []ent.Index{
		index.Fields("external_id", ownerFieldName).
			Unique().
			Annotations(
				entsql.IndexWhere("deleted_at is NULL"),
			),
		index.Fields("cve_id", ownerFieldName).
			Unique().
			Annotations(
				entsql.IndexWhere("deleted_at is NULL"),
			),
	}
}

// Annotations of the Vulnerability
func (Vulnerability) Annotations() []schema.Annotation {
	return []schema.Annotation{
		entfga.SelfAccessChecks(),
		entx.Exportable{},
	}
}

// Policy of the Vulnerability
func (v Vulnerability) Policy() ent.Policy {
	return policy.NewPolicy(
		policy.WithMutationRules(
			policy.CheckOrgWriteAccess(),
			policy.CheckCreateAccess(),
			entfga.CheckEditAccess[*generated.VulnerabilityMutation](),
		),
	)
}

func (Vulnerability) Modules() []models.OrgModule {
	return []models.OrgModule{
		models.CatalogVulnerabilityManagementModule,
	}
}
