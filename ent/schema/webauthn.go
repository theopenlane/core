package schema

import (
	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/privacy"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/field"

	"github.com/gertd/go-pluralize"

	"github.com/theopenlane/entx/history"
	emixin "github.com/theopenlane/entx/mixin"

	"github.com/theopenlane/core/pkg/models"
	"github.com/theopenlane/ent/hooks"
	"github.com/theopenlane/ent/mixin"
	"github.com/theopenlane/ent/privacy/policy"
)

// Webauthn holds the schema definition for the Webauthn entity
type Webauthn struct {
	SchemaFuncs

	ent.Schema
}

// SchemaWebauthn is the name of the Webauthn schema.
const SchemaWebauthn = "webauthn"

// Name returns the name of the Webauthn schema.
func (Webauthn) Name() string {
	return SchemaWebauthn
}

// GetType returns the type of the Webauthn schema.
func (Webauthn) GetType() any {
	return Webauthn.Type
}

// PluralName returns the plural name of the Webauthn schema.
func (Webauthn) PluralName() string {
	return pluralize.NewClient().Plural(SchemaWebauthn)
}

// Fields of the Webauthn
func (Webauthn) Fields() []ent.Field {
	return []ent.Field{
		field.Bytes("credential_id").
			Annotations(
				entgql.Skip(entgql.SkipAll),
			).
			Comment("A probabilistically-unique byte sequence identifying a public key credential source and its authentication assertions").
			Unique().
			Optional(),
		field.Bytes("public_key").
			Annotations(
				entgql.Skip(entgql.SkipAll),
			).
			Comment("The public key portion of a Relying Party-specific credential key pair, generated by an authenticator and returned to a Relying Party at registration time").
			Optional(),
		field.String("attestation_type").
			Annotations(
				entgql.Skip(entgql.SkipAll),
			).
			Comment("The attestation format used (if any) by the authenticator when creating the credential").
			Optional(),
		field.Other("aaguid", &models.AAGUID{}).
			Annotations(
				entgql.Skip(^entgql.SkipType),
			).
			Comment("The AAGUID of the authenticator; AAGUID is defined as an array containing the globally unique identifier of the authenticator model being sought").
			SchemaType(map[string]string{
				// keep existing data safe and intact else uuid might have been the best option here
				dialect.Postgres: "bytea",
			}).
			Immutable(),
		field.Int32("sign_count").
			Annotations(
				entgql.Skip(entgql.SkipAll),
			).
			Comment("SignCount -Upon a new login operation, the Relying Party compares the stored signature counter value with the new signCount value returned in the assertions authenticator data. If this new signCount value is less than or equal to the stored value, a cloned authenticator may exist, or the authenticator may be malfunctioning"),
		field.Strings("transports").
			Annotations(
				entgql.Skip(entgql.SkipAll),
			).
			Comment("transport"),
		field.Bool("backup_eligible").
			Comment("Flag backup eligible indicates the credential is able to be backed up and/or sync'd between devices. This should NEVER change").
			Annotations(
				entgql.Skip(^entgql.SkipType),
			).
			Default(false).
			Immutable(),
		field.Bool("backup_state").
			Annotations(
				entgql.Skip(^entgql.SkipType),
			).
			Comment("Flag backup state indicates the credential has been backed up and/or sync'd").
			Default(false),
		field.Bool("user_present").
			Annotations(
				entgql.Skip(entgql.SkipAll),
			).
			Comment("Flag user present indicates the users presence").
			Default(false),
		field.Bool("user_verified").
			Annotations(
				entgql.Skip(entgql.SkipAll),
			).
			Comment("Flag user verified indicates the user performed verification").
			Default(false),
	}
}

// Mixin of the Webauthn
func (w Webauthn) Mixin() []ent.Mixin {
	return []ent.Mixin{
		emixin.AuditMixin{},
		emixin.IDMixin{},
		mixin.TagMixin{},
		newUserOwnedMixin(w),
	}
}

func (Webauthn) Modules() []models.OrgModule {
	return []models.OrgModule{
		models.CatalogBaseModule,
	}
}

// Annotations of the Webauthn
func (w Webauthn) Annotations() []schema.Annotation {
	return []schema.Annotation{
		entgql.RelayConnection(),

		entgql.QueryField(),

		entgql.Skip(entgql.SkipMutationCreateInput |
			entgql.SkipMutationUpdateInput),

		history.Annotations{
			Exclude: true,
		},
	}
}

// Policy of the Webauthn
func (w Webauthn) Policy() ent.Policy {
	return policy.NewPolicy(
		policy.WithMutationRules(
			privacy.AlwaysAllowRule(),
		),
	)
}

func (Webauthn) Hooks() []ent.Hook {
	return []ent.Hook{
		hooks.HookWebauthnDelete(),
	}
}
